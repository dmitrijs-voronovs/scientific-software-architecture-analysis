quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Security," ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CompositeJK; docstring. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ExternalPotential; Stores external potential field, computes external potential matrix. FCHKWriter; Extracts information from a wavefunction object, and writes it to an FCHK file. FDDS_Dispersion; docstring. FISAPT; A Fragment-SAPT Wavefunction. FittedSlaterCorrelationFactor; docstring. FittingMetric; docstring. FragmentType; Fragment activation status. Functional; docstring. GaussianShell; Class containing information about basis functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:11695,access,access,11695,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,1,['access'],['access']
Security," ccgradient, etc. CIVector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. DIISManager; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ExternalPotential; Stores external potential field, computes external potential matrix. FCHKWriter; Extracts information from a wavefunction object, and writes it to an FCHK file. FDDS_Dispersion; docstring. FISAPT; A Fragment-SAPT Wavefunction. FittedSlaterCorrelationFactor; docstring. FittingMetric; docstring. FragmentType; Fragment activation status. Functional; docstring. GaussianShell; Class containing information about basis functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:12499,access,access,12499,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['access'],['access']
Security," choices. ‘d2p4’ calls the -D2 correction; within psi4 (hence, faked for mode=’dftd3’). The other three, ‘d2gr’, ‘d3zero’,; and ‘d3bj’ call the three dftd3 modes of operation (corresponding to -old, -zero, -bj).; Additionally, there are three aliased dashlvl choices since the aliases in dash_alias; above are imposed. driver¶. gradient(name, **kwargs)[source]¶; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. hessian(name, **kwargs)[source]¶; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. molden(filename)[source]¶; Function to write wavefunction information in molden; format to filename. parse_arbitrary_order(name)[source]¶; Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. parse_cotton_irreps(irrep)[source]¶; Function to return validated Cotton ordering index from string or integer; irreducible representation irrep. gaussian_n¶. run_gaussian_2(name, **kwargs)[source]¶. pcmgetkw¶. class Getkw(top)[source]¶; Unified interface to sections and keywords.; Implements a path stack. find_sect(path)[source]¶. get_active_section()[source]¶. get_keyword(path)[source]¶. get_topsect()[source]¶. getkw(path)[source]¶. pop_sect()[source]¶. push_sect(path)[source]¶. run_callbacks(templ)[source]¶. sanitize(templ)[source]¶. setkw(path)[source]¶. class GetkwParser(templ=None)[source]¶; Implements a class to do the actual parsing of input files and store; the results in Sections and Keywords. The parseFile() method returns a; Getkw object. add_sect(s, l, t)[source]¶. bnf = None¶. caseless = False¶. check_type(arg, argt)[source]¶. conv_dval(s, loc, toks)[source]¶. conv_ival(s, loc, toks)[source]¶. conv_lval(s, loc, toks)[source]¶. fixate_type(arg)[source]¶. getkw_bnf()[source]¶. no = <_sre.SRE_Pattern object at 0x17bb7440>¶. parseFile(fil)[source",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:14398,validat,validated,14398,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['validat'],['validated']
Security," cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequencies(cls, val):; warnings.warn(; ""Using `psi4.core.Wavefunction.set_frequencies` (accessing c-side member data) instead of `psi4.core.Wavefunction.frequency_analysis` (py-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_legacy_frequencies(val). core.Wavefunction.frequencies = _core_wavefunction_frequencies; core.Wavefunction.legacy_frequencies = _core_wavefunction_legacy_frequencies; core.Wavefunction.set_frequencies = _core_wavefunction_set_frequencies. ## Psi4 v1.3 Export Deprecations. def _core_get_gradient():; warnings.warn(; ""Using `psi4.core.get_gradient` (only used internally for C++ optking; deprecated silently in 1.2) is deprecated, and in 1.4 (or whenever Py optking is adopted) it will stop working\n"",; category=FutureWarning,; stac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:24604,access,accessing,24604,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['access'],['accessing']
Security," core potentials (ECPs). PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:8161,access,accessed,8161,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,8,['access'],['accessed']
Security," core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Vector.to_array = _to_array; core.Vector.shape = _np_shape; core.Vector.np = _np_view; core.Vector.nph = _nph_view; core.Vector.__array_interface__ = _array_conversion; core.Vector.np_write = _np_write; core.Vector.np_read = classmethod(_np_read); core.Vector.to_serial = _to_serial; core.Vector.from_serial = classmethod(_from_serial). ### CIVector properties. @property; def _civec_view(self):; """"""; Returns a view of the CIVector's buffer; """"""; return np.asarray(self). core.CIVector.np = _civec_view. ### Dimension properties. @classmethod; def _dimension_from_list(self, dims, name=""New Dimension""):; """"""; Builds a core.Dimension object from a python list or tuple. If a dimension; object is passed a copy will be returned.; """""". if isinstance(dims, (tuple, list, np.ndarray)):; irreps = len(dims); elif isinstance(dims, core.Dimension):; irreps = dims.n(); else:; raise ValidationError(""Dimension from list: Type '%s' not understood"" % type(dims)). ret = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(dim):; """"""; Converts a core.Dimension object to a tuple.; """""". if isinstance(dim, (tuple, list)):; return tuple(dim). irreps = dim.n(); ret = []; for i in range(irreps):; ret.append(dim[i]); return tuple(ret). def _dimension_iter(dim):; """"""; Provides an iterator class for the Dimension object. Allows:; dim = psi4.core.Dimension(...); list(dim); """""". for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.2.1;  · . PSI4. Module code. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:13846,Validat,ValidationError,13846,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security," core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). return core.adc(ref_wfn). def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.backends import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:110990,Validat,ValidationError,110990,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security," core.set_local_option('OCC', 'DO_SCS', 'TRUE'); core.set_local_option('OCC', 'SCS_TYPE', 'SCSVDW'); elif name == 'sos-omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'DO_SOS', 'TRUE'); core.set_local_option('OCC', 'SOS_TYPE', 'SOS'); elif name == 'sos-pi-omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'DO_SOS', 'TRUE'); core.set_local_option('OCC', 'SOS_TYPE', 'SOSPI'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'DO_SCS', 'FALSE'); core.set_local_option('OCC', 'DO_SOS', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'DO_SCS', 'FALSE'); core.set_local_option('OCC', 'DO_SOS', 'FALSE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:57530,Validat,ValidationError,57530,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security," core.set_local_option('OCC', 'DO_SCS', 'TRUE'); core.set_local_option('OCC', 'SCS_TYPE', 'SCSVDW'); elif name == 'sos-omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'DO_SOS', 'TRUE'); core.set_local_option('OCC', 'SOS_TYPE', 'SOS'); elif name == 'sos-pi-omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'DO_SOS', 'TRUE'); core.set_local_option('OCC', 'SOS_TYPE', 'SOSPI'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'DO_SCS', 'FALSE'); core.set_local_option('OCC', 'DO_SOS', 'FALSE'); elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'DO_SCS', 'FALSE'); core.set_local_option('OCC', 'DO_SOS', 'FALSE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if name == 'mp2':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; core.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); core.set_local_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:55648,Validat,ValidationError,55648,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security," core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']). oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa', 'roa_tensor']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_globa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:72485,Validat,ValidationError,72485,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security," d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, ret):; if d1 == 0: continue. dense_ret[start1: start1 + d1, start2: start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. def _build_view(matrix):; """"""; Builds a view of the vector or matrix; """"""; views = _to_array(matrix, copy=False, dense=False); if matrix.nirrep() > 1:; return tuple(views); else:; return views. def get_view(self):; if hasattr(self, '_np_view_data'):; return self._np_view_data; else:; self._np_view_data = _build_view(self); return self._np_view_data. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object; """"""; view_data = get_view(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data.shape. @property; def _np_view(self):; """"""; View without only one irrep; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps. Please use .nph for objects with irreps.""); return get_view(self). @property; def _nph_view(self):; """"""; View with irreps.; """"""; if self.nirrep() > 1:; return get_view(self); else:; return get_view(self),. @property; def _array_conversion(self):; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(self, filename=None, prefix=""""):. ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:8836,Validat,ValidationError,8836,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security," def init_string(data):; return (""""). data = _initialize_findif(mol, freq_irrep_only, ""2_1"", findifrec['stencil_size'], findifrec['step']['size'],; init_string, findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; d_per_salc = 2 * max_disp. # Populating with positive and negative displacements for the identity point group; dipole = np.zeros(shape=(data['n_salc'], d_per_salc, 3)); for salc_index in salc_indices:; for j in range(1, max_disp + 1):; dipole[salc_index, max_disp - j] = displacements[f""{salc_index}: {-j}""][""dipole""]; dipole[salc_index, max_disp + j - 1] = displacements[f""{salc_index}: {j}""][""dipole""]. for h in range(1, data[""n_irrep""]):; # Find the group operation that converts + to - displacements.; gamma = ct.gamma(h); for group_op in range(order):; if gamma.character(group_op) == -1:; break; else:; raise ValidationError(""A symmetric dipole passed for a non-symmetric one.""). sym_op = np.array(ct.symm_operation(group_op).matrix()); salc_indices = data[""salc_indices_pi""][h]. # Creating positive displacements and populating for the other point groups; for salc_index in salc_indices:; for j in range(1, max_disp + 1):; pos_disp_dipole = np.dot(sym_op, displacements[f""{salc_index}: {-j}""][""dipole""].T); dipole[salc_index, max_disp - j] = displacements[f""{salc_index}: {-j}""][""dipole""]; dipole[salc_index, max_disp + j - 1] = pos_disp_dipole. # Computing the dipole derivative by finite differnce; if findifrec[""stencil_size""] == 3:; dipder_q = (dipole[:, 1] - dipole[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; dipder_q = (dipole[:, 0] - 8.0 * dipole[:, 1] + 8.0 * dipole[:, 2] -; dipole[:, 3]) / (12.0 * findifrec[""step""][""size""]). # Transform the dipole derivates from mass-weighted SALCs to non-mass-weighted Cartesians; B = np.asarray(data[""salc_list""].matrix()); dipder_c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:28373,Validat,ValidationError,28373,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['Validat'],['ValidationError']
Security," default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); monomerB_basis = core.BasisSet.build(monomerB, ""BASIS"", core.get_global_option(""BASIS"")); nfc_ab = monomerA_basis.n_frozen_core() + monomerB_basis.n_frozen_core(). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). do_delta_mp2 = True if name.endswith('dmp2') else False; do_empirical_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). # raise Exception(""""). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:135915,Validat,ValidationError,135915,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security," default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); monomerB_basis = core.BasisSet.build(monomerB, ""BASIS"", core.get_global_option(""BASIS"")); nfc_ab = monomerA_basis.n_frozen_core() + monomerB_basis.n_frozen_core(). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). do_delta_mp2 = True if name.endswith('dmp2') else False; do_empirical_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:146586,Validat,ValidationError,146586,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'bccdcorl': 'CCSD CORRELATION ENERGY'}; VARH['cc3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc3corl': 'CC3 CORRELATION ENERGY'}; VARH['ccsd(t)'] = { 'scftot': 'S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:59113,Validat,ValidationError,59113,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security," delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY', ; 'mp4(sdq)corl': 'MP4(SDQ) CORRELATION ENERGY'}; VARH['mp4'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60521,Validat,ValidationError,60521,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security," derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". if ptype not in ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:2798,Validat,ValidationError,2798,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security," derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". if ptype not in ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:2889,Validat,ValidationError,2889,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security," derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". if ptype not in ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:2857,Validat,ValidationError,2857,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security," dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program gcp gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; core.set_variable('GCP CORRECTION ENERGY', dashd); psi_dashdderiv = core.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; if not verbose and isP4regime:; verbose = True if core.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> GCP Output <==\n'; text += out.decode('utf-8'); if dertype != 0:; with open(derivfile, 'r') as handle:; text += handle.read().replace('D', 'E'); text += '\n'; if isP4regime:; core.print_out(text); else:; print(text). # # Clean up files and remove scratch directory; # os.unlink(paramfile1); # os.unlink(paramfile2); # os.unlink(geomfile); # if dertype != 0:; # os.unlink(derivfile); # if defmoved is True:; # os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); # try:; # shutil.rmtree(dftd3_tmpdir); # except OSError as e:; # ValidationError('Unable to remove dftd3 temporary directory %s' % e); os.chdir(current_directory). # return -D & d(-D)/dx; if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif dertype == 1:; return psi_dashdderiv. try:; # Attach method to libmints psi4.Molecule class; core.Molecule.run_gcp = run_gcp; except (NameError, AttributeError):; # But don't worry if that doesn't work b/c; # it'll get attached to qcdb.Molecule class; pass. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. Module code. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html:10193,Validat,ValidationError,10193,psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,1,['Validat'],['ValidationError']
Security," different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_tour-1.html:2650,access,accessibility,2650,psi4manual/1.4.0/prog_tour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_tour-1.html,2,['access'],['accessibility']
Security," different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/prog_tour-1.html:2650,access,accessibility,2650,psi4manual/1.5.0/prog_tour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/prog_tour-1.html,2,['access'],['accessibility']
Security," dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]; def _to_array(; matrix: Union[core.Matrix, core.Vector],; copy: bool = True,; dense: bool = False,; ) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a |PSIfour| Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irrepped Psi4 objects to diagonally blocked dense arrays if; `True`. Returns a list of arrays otherwise. Returns; -------; ~numpy.ndarray or ~typing.List[~numpy.ndarray]; Returns a single or list of NumPy arrays depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a lar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:6064,Validat,ValidationError,6064,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,3,['Validat'],['ValidationError']
Security," dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(; matrix: Union[core.Matrix, core.Vector],; copy: bool = True,; dense: bool = False,; ) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a |PSIfour| Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irrepped Psi4 objects to diagonally blocked dense arrays if; `True`. Returns a list of arrays otherwise. Returns; -------; ~numpy.ndarray or ~typing.List[~numpy.ndarray]; Returns a single or list of NumPy arrays depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:6060,Validat,ValidationError,6060,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security," don't play well together. Returns; -------; bool; Whether excited-state MOM (not just the plain stabilizing MOM) is enabled during scf. """"""; enabled = (core.get_option('SCF', ""MOM_START"") != 0 and len(core.get_option('SCF', ""MOM_OCC"")) > 0); if enabled:; start = core.get_option('SCF', ""MOM_START""); if enabled < 0:; raise ValidationError('SCF MOM_START ({}) must be at least 1'.format(start)). return enabled. def _validate_soscf():; """"""Sanity-checks SOSCF control options. Raises; ------; ValidationError; If any of |scf__soscf|, |scf__soscf_start_convergence|,; |scf__soscf_min_iter|, |scf__soscf_max_iter| don't play well together. Returns; -------; bool; Whether SOSCF is enabled during scf. """"""; enabled = core.get_option('SCF', 'SOSCF'); if enabled:; start = core.get_option('SCF', 'SOSCF_START_CONVERGENCE'); if start < 0.0:; raise ValidationError('SCF SOSCF_START_CONVERGENCE ({}) must be positive'.format(start)). miniter = core.get_option('SCF', 'SOSCF_MIN_ITER'); if miniter < 1:; raise ValidationError('SCF SOSCF_MIN_ITER ({}) must be at least 1'.format(miniter)). maxiter = core.get_option('SCF', 'SOSCF_MAX_ITER'); if maxiter < miniter:; raise ValidationError(; 'SCF SOSCF_MAX_ITER ({}) must be at least SOSCF_MIN_ITER ({})'.format(maxiter, miniter)). conv = core.get_option('SCF', 'SOSCF_CONV'); if conv < 1.e-10:; raise ValidationError('SCF SOSCF_CONV ({}) must be achievable'.format(conv)). return enabled. def field_fn(xyz):; """"""Callback function for PylibEFP to compute electric field from electrons; in ab initio part for libefp polarization calculation. Parameters; ----------; xyz : list; (3 * npt, ) flat array of points at which to compute electric field. Returns; -------; list; (3 * npt, ) flat array of electric field at points in `xyz`. Notes; -----; Function signature defined by libefp, so function uses number of; basis functions and integrals factory `mints_psi4_yo` and total density; matrix `efp_Dt_psi4_yo` from global namespace. """"""; points = np.array(xyz).reshap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:25893,Validat,ValidationError,25893,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security," elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCORRELATIONENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:3647,Validat,ValidationError,3647,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security," exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:50411,access,accesses,50411,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['access'],['accesses']
Security," file to keep from the computation"",; ""default"": true,; ""type"": ""boolean""; },; ""error_correction"": {; ""title"": ""Error Correction"",; ""description"": ""Policies for error correction"",; ""allOf"": [; {; ""$ref"": ""#/definitions/ErrorCorrectionProtocol""; }; ]; },; ""native_files"": {; ""description"": ""Policies for keeping processed files from the computation"",; ""default"": ""none"",; ""allOf"": [; {; ""$ref"": ""#/definitions/NativeFilesProtocolEnum""; }; ]; }; },; ""additionalProperties"": false; }; }; }. Fields:. basis (str); computed (bool); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); method (str); molecule (Any); owner_group (str | None); priority (str); protocols (qcelemental.models.results.AtomicResultProtocols | Dict[str, Any] | None); result (Any); result_id (str | None); tag (str). Validators:. set_basis » basis; set_keywords » keywords; set_method » method. field basis: str [Required]¶; The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, …). Validated by:. set_basis. field computed: bool = False¶; Whether quantum chemistry has been run on this task. field driver: DriverEnum [Required]¶; The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver. field keywords: Dict[str, Any] [Optional]¶; The keywords to use in the computation. Validated by:. set_keywords. field method: str [Required]¶; The quantum chemistry method to evaluate (e.g., B3LYP, MP2, …). Validated by:. set_method. field molecule: Any [Required]¶; The molecule to use in the computation. field owner_group: Optional[str] = None¶; group in the chown sense. field priority: str = 1¶; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}¶; Output modifications. field result: Any [Optional]¶; AtomicResult return. field result_id: Optional[str] = None¶; The ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:5066,Validat,Validated,5066,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,3,['Validat'],['Validated']
Security," fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" %; (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.68",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:12361,Validat,ValidationError,12361,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security," float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). elif xyzC.match(text[2 + i]):. fileAtom = int(float(xyzC.match(text[2 + i]).group(1))); fileX = float(xyzC.match(text[2 + i]).group(2)); fileY = float(xyzC.match(text[2 + i]).group(3)); fileZ = float(xyzC.match(text[2 + i]).group(4)). # Check that the atomic number is valid; if not fileAtom in z2el:; raise ValidationError('Illegal atom symbol in geometry specification: %d' % (fileAtom)). # Add it to the molecule.; instance.add_atom(fileAtom, fileX, fileY, fileZ, z2el[fileAtom], z2mass[fileAtom], fileAtom). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d.\n%s:%s"" %; (i + 3, xyzfilename, text[i + 2])); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3,; text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:8246,Validat,ValidationError,8246,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security," float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more."""""".format(; memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount); return memory_amount. [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return core.get_memory(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); core.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label, exitonfail=True):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*; (or to *digits* itself when *digits* < 1 e.g. digits=0.04). Performs; a system exit on failure unless *exitonfa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html:5641,Validat,ValidationError,5641,psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security," float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount); return memory_amount. [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return core.get_memory(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); core.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label, exitonfail=True):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*; (or to *digits* itself when *digits* < 1 e.g. digits=0.04). Performs; a system exit on failure unless *exitonfa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:5683,Validat,ValidationError,5683,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security," float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]; def get_memory() -> int:; """"""Return the total memory allocation in bytes.""""""; return core.get_memory(). [docs]; def copy_file_to_scratch(filename: str, prefix: str, namespace: str, unit: int, move: bool = False):; """"""Move a file into scratch following the naming convention. Parameters; ----------; filename; Full path to file.; prefix; Computation prefix, usually 'psi'.; namespace; Context namespace, usually molecule name.; unit; Unit number, e.g. 32.; move; Whether to copy (default) or move?. Examples; --------. >>> # Assume PID is 12345 and SCRATCH is /scratch/parrish/; >>> copy_file_to_scratch('temp', 'psi', 'h2o', 32):; Out[1]: -cp ./temp /scratch/parrish/psi.12345.h2o.32; >>> copy_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:6389,Validat,ValidationError,6389,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,3,['Validat'],['ValidationError']
Security," float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]def get_memory() -> int:; """"""Return the total memory allocation in bytes.""""""; return core.get_memory(). [docs]def copy_file_to_scratch(filename: str, prefix: str, namespace: str, unit: int, move: bool = False):; """"""Move a file into scratch following the naming convention. Parameters; ----------; filename; Full path to file.; prefix; Computation prefix, usually 'psi'.; namespace; Context namespace, usually molecule name.; unit; Unit number, e.g. 32.; move; Whether to copy (default) or move?. Examples; --------. >>> # Assume PID is 12345 and SCRATCH is /scratch/parrish/; >>> copy_file_to_scratch('temp', 'psi', 'h2o', 32):; Out[1]: -cp ./temp /scratch/parrish/psi.12345.h2o.32; >>> copy_file",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:6330,Validat,ValidationError,6330,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security," float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return core.get_memory(). [docs]def copy_file_to_scratch(filename, prefix, namespace, unit, move=False):; """"""Function to move file into scratch with correct naming; convention. Arguments:. @arg filename full path to file; @arg prefix computation prefix, usually 'psi'; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32; @arg move copy or move? (default copy). Example:. Assume PID is 12345 and SCRATCH is /scratch/parrish/. copy_file_to_scratch('temp', 'psi', 'h2o', 32):; -cp ./temp /scratch/parrish/psi.12345.h2o.32; copy_file_to_scratch('/tmp/temp', 'psi', 'h2o', 32):; -cp /tmp/te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html:6096,Validat,ValidationError,6096,psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,3,['Validat'],['ValidationError']
Security," for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the basis set name in brackets.; As the second line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; The combination of [basis name], PUREAM value, and element basis set specifications; forms a section, like the one shown below.; Multiple basis sets can be specified in the same file by adding additional sections to the file.; Specify the location of the new basis set file in a PSI4 input file with the command; basis file path/to/basis.file, where the path can be either relative or absolute.; [ sto-3g ]; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (3) Include new basis set in input file.; Construct for a basis set a section like the one above that includes; [basis name], PUREAM; value, and element basis set specifications. Hash signs denote comments.; Copy the section into a PSI4 input file and surround it with the command basis {...},; as shown below.; Multiple basis sets can be specified by adding additional sections within the surrounding brackets.; basis {; # basis set section like in snippet above goes here; # additional basis set sections follow; }. Previous topic; Customization: Adding Simple Extensions; Next topic; Defining a Method Alias; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Customization: Adding Simple Extensions ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/quickaddbasis-1.html:2632,Hash,Hash,2632,psi4manual/4.0b2/quickaddbasis-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddbasis-1.html,2,['Hash'],['Hash']
Security," for html and on bottom for mpl, so flip the numbers; posnM.sort(key=lambda tup: tup[2]); posnM.sort(key=lambda tup: tup[3]); last = (0, 0); for dbse, rxn, val, show, x, y in posnM:; if val is None or val is np.nan:; continue. now = (int(x), int(y)); if now == last:; htmlcode += """"""<!-- map overlap! %s-%s %+.2f skipped -->\n"""""" % (dbse, rxn, val); else:; htmlcode += """"""<AREA shape=""rect"" coords=""%d,%d,%d,%d"" onmouseover=""javascript:mouseshow('%s', '%s', '%+.2f', '%s');"">\n"""""" % \; (x - 2, img_height - y - 20,; x + 2, img_height - y + 20,; dbse, rxn, val, show); last = now. htmlcode += """"""</MAP>\n"""""". plt.close(); return files_saved, htmlcode. [docs]def ternary(sapt, title='', labeled=True, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Takes array of arrays *sapt* in form [elst, indc, disp] and builds formatted; two-triangle ternary diagrams. Either fully-readable or dotsonly depending; on *labeled*. Saves in formats *graphicsformat*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt; import matplotlib as mpl; from matplotlib.path import Path; import matplotlib.patches as patches. # initialize plot; fig, ax = plt.subplots(figsize=(6, 3.6)); plt.xlim([-0.75, 1.25]); plt.ylim([-0.18, 1.02]); plt.xticks([]); plt.yticks([]); ax.set_aspect('equal'). if labeled:; # form and color ternary triangles; codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]; pathPos = Path([(0., 0.), (1., 0.), (0.5, 0.866), (0., 0.)], codes); pathNeg = Path([(0., 0.), (-0.5, 0.866), (0.5, 0.866), (0., 0.)], codes); ax.add_patch(patches.PathPatch(pathPos, facecolor='white', lw=2)); ax.add_patch(patches.PathPatch(pathNeg, facecolor='#fff5ee', lw=2)). # form and color HB/MX/DD dividing lines; ax.plot([0.667, 0.5], [0., 0.866], color='#eeb4b4', lw=0.5); ax.plot([-0.333, 0.5], [0.577, 0.866], color='#eeb4b4', lw=0.5); ax.plot([0.333, 0.5], [0., 0.866], color='#7ec0ee', lw=0.5); ax.plot([-0.167, 0.5], [0.289, 0.866], color='#7ec0ee', lw=0.5). # l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:23423,hash,hashlib,23423,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security," for row in range(n)] for col in range(m)]; return new_matrix. [docs]def identity(m):; """"""Create identity matrix""""""; new_matrix = zero(m, m); for i in range(m):; new_matrix[i][i] = 1.0; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print(col). [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; try:; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; except TypeError:; new_matrix = zero(len(matrix1), 1); for i in range(len(matrix1)):; for k in range(len(matrix2)):; new_matrix[i][0] += matrix1[i][k] * matrix2[k]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. [docs]def matadd(matrix1, matrix2, fac1=1.0, fac2=1.0):; """"""Matrix addition""""""; if (len(matrix1[0]) != len(matrix2[0])) or (len(matrix1) != len(matrix2)):; raise ValidationError('Matrices must be same dimension to add.'); new_matrix = zero(len(matrix1), len(matrix1[0])); for i in range(len(matrix1)):; for j in range(len(matrix1[0])):; new_matrix[i][j] = fac1 * matrix1[i][j] + fac2 * matrix2[i][j]; return new_matrix. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html:8769,Validat,ValidationError,8769,psi4manual/1.0.0/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html,2,['Validat'],['ValidationError']
Security," for view in self.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise ValidationError(""_to_json is only used for vector and matrix objects.""). return json_data. def _from_serial(self, json_data: Dict[str, Any]) -> Union[core.Matrix, core.Vector]:; """"""; Converts serialized data to the correct Psi4 data type. Parameters; ----------; self; Pointer to which class to be constructed.; json_data; Serialization of class. See :meth:`to_serial` for data layout. """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs) -> core.Matrix:; """"""Chains dot products together from a series of Psi4 Matrix classes. Uses :func:`~psi4.core.doublet`. Parameters; ----------; args; Arbitrary number of :class:`~psi4.core.Matrix` arguments to be; multiplied.; trans; Optional iterable of booleans of length number of `args` to designate; transposes, if any. """"""; trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:13224,Validat,ValidationError,13224,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security," for view in self.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise ValidationError(""_to_json is only used for vector and matrix objects.""). return json_data. def _from_serial(self, json_data: Dict[str, Any]) -> Union[core.Matrix, core.Vector]:; """"""; Converts serialized data to the correct Psi4 data type. Parameters; ----------; self; Pointer to which class to be constructed.; json_data; Serialization of class. See :meth:`to_serial` for data layout. """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs) -> core.Matrix:; """"""Chains dot products together from a series of Psi4 Matrix classes.; Uses :func:`~psi4.core.doublet`. Parameters; ----------; args; Arbitrary number of :class:`~psi4.core.Matrix` arguments to be; multiplied.; trans; Optional iterable of booleans of length number of `args` to designate; transposes, if any. """"""; trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:13231,Validat,ValidationError,13231,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security," for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.core.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, str):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dash",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html:2717,Validat,ValidationError,2717,psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,1,['Validat'],['ValidationError']
Security," from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]; def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: str; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:2433,access,accessible,2433,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,1,['access'],['accessible']
Security," func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/proc_py-1.html:6814,access,access,6814,psi4manual/1.2.1/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/proc_py-1.html,2,['access'],['access']
Security," function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; 1energy('mp2'). runs MP2 with CONV with default implementation OCC; 1; 2set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; 1; 2set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select [1]. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DETCI; Y;  ;  ;  ;  ;  ; Y;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/notes_c-1.html:1570,access,accessible,1570,psi4manual/1.1.0/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/notes_c-1.html,6,['access'],['accessible']
Security," function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to \(10^{-6} E_h\), the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. PSI4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/notes_c-1.html:1588,access,accessible,1588,psi4manual/1.4.0/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/notes_c-1.html,4,['access'],['accessible']
Security," functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exists, must be Python 2; str = str; unicode = unicode; bytes = str; basestring = basestring. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:87312,Validat,ValidationError,87312,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security," getFromDict(dataDict, mapList):; return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; blockprefix = ['chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant']; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.iteritems():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); except KeyError:; continue; for v in qwer:; vv = v.values(); if vv[0] == prefix + lpv[1]:; enedict[pv] = float(vv[1]). return enedict. [docs]def compare_csx():; """"""Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. """"""; if 'csx4psi' in sys.modules.keys():; if psi4.get_global_option('WRITE_CSX'):; enedict = csx2endict(); compare_integers(len(enedict) >= 2, True, 'CSX harvested'); for pv, en in enedict.iteritems():; compare_values(psi4.get_variable(pv), en, 6, 'CSX ' + pv + ' ' + str(round(en, 4))). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:14261,validat,validate,14261,psi4manual/1.0.0/_modules/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html,1,['validat'],['validate']
Security," group; self.PYbits = 0. # Divert to constructor functions; # if len(args) == 0:; # self.constructor_zero_ao_basis(); if len(args) == 1 and \; isinstance(args[0], basestring):; self.constructor_schoenflies(*args); elif len(args) == 1 and \; isinstance(args[0], int):; self.constructor_bits(*args); elif len(args) == 2 and \; isinstance(args[0], basestring) and \; len(args[1]) == 3:; self.constructor_schoenflies_origin(*args); elif len(args) == 2 and \; isinstance(args[0], int) and \; len(args[1]) == 3:; self.constructor_bits_origin(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. # libmints: These 2 constructors do not work right now.; [docs] def constructor_schoenflies(self, s):; """"""This constructor takes a string containing the Schoenflies; symbol of the point group as its only argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = [0.0, 0.0, 0.0]. [docs] def constructor_schoenflies_origin(self, s, origin):; """"""Like the above, but this constructor also takes a point of; origin as an argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = origin. [docs] def constructor_bits(self, bits):; """"""Using the bitwise representation constructor the point group; object. """"""; self.PYbits = bits; self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = [0.0, 0.0, 0.0]. [docs] def constructor_bits_origin(self, bits, origin):; """"""Using the bitwise representation constructor the point group; object. """"""; self.PYbits = bits; self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = origin. # <<< Simple Methods for Basic PointGroup Information",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:39439,Validat,ValidationError,39439,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security," h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[, h]); Returns the rows in irrep h. save(self, filename[, append, ...]); Saves the matrix in ASCII format to filename, as symmetry blocks or full matrix. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args, **kwargs); Overloaded function. set_block(self, rows, cols, block); Set a matrix block. subtract(self, arg0); Substract a matrix from this matrix. sum_of_squares(self); Returns the sum of the squares of this matrix. symmetrize_gradient(self, mol); Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self); Returns the overall symmetry of the matrix. to_array([copy, dense]); Converts a Psi4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self); Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transpose(self); Creates a new matrix that is the transpose of this matrix. transpose_this(self); Transpose the matrix in-place. triplet(A, B, C, transA, transB, transC); Multiply three matrices together. vector_dot(self, rhs); Returns the vector dot product of this with rhs. zero(self); Zero all elements of the matrix. zero_diagonal(self); Zero the diagonal of the matrix. zero_lower(self); Zero the lower triangle. zero_upper(self); Zero the upper triangle. Attributes Documentation. name¶; The name of the Matrix. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix) → float¶; Returns the absolute maximum value. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; Multiplies two arguments and adds the result to this ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.matrix.html:4822,access,accessor,4822,psi4manual/1.5.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.matrix.html,1,['access'],['accessor']
Security," if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:20002,Validat,ValidationError,20002,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security," if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationErro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:21305,Validat,ValidationError,21305,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security," if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if input.yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif input.no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:34251,Validat,ValidationError,34251,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security," if self.has_zmatrix:; # moldict['zmat'] = self.zmat; # TODO zmat, geometry_variables. nat = self.natom(); geom = np.array(self.geometry()) # [a0]; if molrec['units'] == 'Angstrom':; geom *= psi_bohr2angstroms #self.input_units_to_au(); molrec['geom'] = geom.reshape((-1)). molrec['elea'] = np.array([self.mass_number(at) for at in range(nat)]); molrec['elez'] = np.array([el2z[self.symbol(at).upper()] for at in range(nat)]); molrec['elem'] = np.array([self.symbol(at).capitalize() for at in range(nat)]); molrec['mass'] = np.array([self.mass(at) for at in range(nat)]); molrec['real'] = np.array([bool(self.Z(at)) for at in range(nat)]); molrec['elbl'] = np.array([self.label(at)[len(self.symbol(at)):].lower() for at in range(nat)]). fragments = [x[:] for x in self.get_fragments()]; fragment_charges = [float(f) for f in self.get_fragment_charges()]; fragment_multiplicities = [m for m in self.get_fragment_multiplicities()]. # do trimming not performed in Molecule class b/c fragment_* member data never directly exposed; for ifr, fr in reversed(list(enumerate(self.get_fragment_types()))):; if fr == 'Ghost':; fragment_charges[ifr] = 0.; fragment_multiplicities[ifr] = 1; elif fr == 'Absent':; del fragment_charges[ifr]; del fragment_multiplicities[ifr]; # readjust atom indices for subsequent fragments; renum = fragments[ifr][0]; for iffr, ffr in enumerate(fragments):; if iffr <= ifr:; continue; lenfr = ffr[1] - ffr[0]; fragments[iffr] = [renum, renum + lenfr]; renum += lenfr; del fragments[ifr]. molrec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the diffe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:48604,expose,exposed,48604,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['expose'],['exposed']
Security," if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4.driver.AtomicComputer` but may be other when wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersystem""]`) to which the modelchem specified in **kwargs** applies.; That is, `nbodies = self.nbodies_per_mc_level[mc_level_idx]`.; Note the natural 1-indexing of ``nbodies`` _contents_, so `[1]` covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, `mc_level_lbl = mc_level_idx + 1`; Formerly nlevel as in `nbody = self.nbody_list[nbody_level=nlevel]`.; kwargs; Other arguments for initializing **mb_computer**. In particular, specifies model chemistry. Returns; -------; count : int; Number of new tasks planned by this call.; Formerly, didn't include",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:36352,access,accessed,36352,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,3,['access'],['accessed']
Security," import numpy as np. from psi4 import core; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.dft import functionals, build_superfunctional_from_dictionary. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html:2091,Validat,ValidationError,2091,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,1,['Validat'],['ValidationError']
Security," import print_function; from __future__ import absolute_import. import numpy as np. from psi4 import core; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.dft_funcs import functionals; from psi4.driver.procrouting.dft_funcs import build_superfunctional_from_dictionary. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html:2127,Validat,ValidationError,2127,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,1,['Validat'],['ValidationError']
Security," in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False, label='electronic energy'):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.strip().split(None, 10); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if label == 'electronic energy' and s[8:10] == ['electronic', 'energy']:; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:8547,Validat,ValidationError,8547,psi4manual/1.0.0/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html,1,['Validat'],['ValidationError']
Security," in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.core.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; # elif der2nd.match(str(dertype)):; # raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html:2829,Validat,ValidationError,2829,psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,2,['Validat'],['ValidationError']
Security," in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; from typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. import qcelemental as qcel; from qcelemental.models import AtomicInput, AtomicResult, DriverEnum; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core. from . import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Fie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html:1334,validat,validator,1334,psi4manual/1.9.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html,4,['validat'],['validator']
Security," irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self, h); Returns the rows in irrep h. save(self, filename, append, …); Saves the matrix in ASCII format to filename, as symmetry blocks or full matrix. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args, **kwargs); Overloaded function. set_block(self, rows, cols, block); Set a matrix block. subtract(self, arg0); Substract a matrix from this matrix. sum_of_squares(self); Returns the sum of the squares of this matrix. symmetrize_gradient(self, mol); Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self); Returns the overall symmetry of the matrix. to_array([copy, dense]); Converts a Psi4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self); Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transpose(self); Creates a new matrix that is the transpose of this matrix. transpose_this(self); Transpose the matrix in-place. triplet(A, B, C, transA, transB, transC); Multiply three matrices together. vector_dot(self, rhs); Returns the vector dot product of this with rhs. zero(self); Zero all elements of the matrix. zero_diagonal(self); Zero the diagonal of the matrix. zero_lower(self); Zero the lower triangle. zero_upper(self); Zero the upper triangle. Attributes Documentation. name¶; The name of the Matrix. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix) → float¶; Returns the absolute maximum value. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; Multiplies two arguments and adds the result to this ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html:4806,access,accessor,4806,psi4manual/1.4.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html,1,['access'],['accessor']
Security," irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self, h); Returns the rows in irrep h. save(self, filename, append, …); Saves the matrix in ASCII format to filename, as symmetry blocks or full matrix. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args, **kwargs); Overloaded function. set_block(self, rows, cols, block); Set a matrix block. subtract(self, arg0); Substract a matrix from this matrix. sum_of_squares(self); Returns the sum of the squares of this matrix. symmetrize_gradient(self, mol); Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self); Returns the overall symmetry of the matrix. to_array([copy, dense]); Converts a Psi4 Matrix or Vector to a numpy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self); Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transpose(self); Creates a new matrix that is the transpose of this matrix. transpose_this(self); Transpose the matrix in-place. triplet(A, B, C, transA, transB, transC). vector_dot(self, rhs); Returns the vector dot product of this with rhs. zero(self); Zero all elements of the matrix. zero_diagonal(self); Zero the diagonal of the matrix. zero_lower(self); Zero the lower triangle. zero_upper(self); Zero the upper triangle. Attributes Documentation. name¶; The name of the Matrix. Used in printing. np¶; View without only one irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix) → float¶; Returns the absolute maximum value. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; Multiplies two arguments and adds the result to this matrix. add(*args, **kwargs)¶; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:4778,access,accessor,4778,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,1,['access'],['accessor']
Security," irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self, h); Returns the rows in irrep h. save(self, filename, append, …); Saves the matrix in ASCII format to filename, as symmetry blocks or full matrix. scale(self, a); Scales the matrix by the floating point value a. scale_column(self, h, n, a); Scales column n of irrep h by a. scale_row(self, h, m, a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args, **kwargs); Overloaded function. set_block(self, rows, cols, block); Set a matrix block. subtract(self, arg0); Substract a matrix from this matrix. sum_of_squares(self); Returns the sum of the squares of this matrix. symmetrize_gradient(self, mol); Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self); Returns the overall symmetry of the matrix. to_array([copy, dense]); Converts a Psi4 Matrix or Vector to a numpy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self); Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transpose(self); Creates a new matrix that is the transpose of this matrix. transpose_this(self); Transpose the matrix in-place. triplet(A, B, C, transA, transB, transC); Returns the multiplication of three matrics A, B, and C, with options to transpose each beforehand. vector_dot(self, rhs); Returns the vector dot product of this with rhs. zero(self); Zero all elements of the matrix. zero_diagonal(self); Zero the diagonal of the matrix. zero_lower(self); Zero the lower triangle. zero_upper(self); Zero the upper triangle. Attributes Documentation. name¶; The name of the Matrix. Used in printing. np¶; View without only one irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix) → float¶; Returns the absolute maximum value. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:4787,access,accessor,4787,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['access'],['accessor']
Security," is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""xyzabc"", ""points"", ""rotmat""] for f in hint_types):; types = hint_types; else:; raise ValidationError(""""""hint_types not among 'xyzabc', 'points', 'rotmat': {}"""""".format(hint_types)). hints = []; hlen = {""xyzabc"": 6, ""points"": 9, ""rotmat"": 12}; for ifr, fr in enumerate(geom_hints):; try:; hint = [float(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types"": types, ""geom_hints"": hints}. def validate_and_fill_geometry(geom=None, tooclose=0.1, copy=True):; """"""Check `geom` for overlapping atoms. Return flattened"""""". npgeom = np.array(geom, copy=copy, dtype=float).reshape((-1, 3)). # Upper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:16724,Validat,ValidationError,16724,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security," is; hardwired to 5x5 since the H irrep in Ih is 5 dimensional. """""". def __init__(self, *args):; """"""Constructor"""""". # order of representation; self.n = 0; # matrix representation; self.d = zero(5, 5). # Divert to constructor functions; if len(args) == 1 and \; isinstance(args[0], int):; self.constructor_order(*args); elif len(args) == 1 and \; isinstance(args[0], SymmetryOperation):; self.constructor_symmetryoperation(*args); else:; raise ValidationError('SymRep::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_order(self, i):; """"""Initialize order only. """"""; self.n = i; self.zero(). [docs] def constructor_symmetryoperation(self, so):; """"""Initialize from 3x3 SymmetryOperation. """"""; self.n = 3; self.zero(); for i in range(3):; for j in range(3):; self.d[i][j] = so[i][j]. [docs] def SymmetryOperation(self):; """"""Cast SymRep to SymmetryOperation. """"""; if self.n != 3:; raise ValidationError(""SymRep::operator SymmetryOperation(): trying to cast to symop when n != 3""). so = SymmetryOperation(); for i in range(3):; for j in range(3):; so[i][j] = self.d[i][j]; return so. # <<< Simple Methods for Basic SymRep Information >>>. [docs] def set_dim(self, i):; """"""Set the dimension of d""""""; self.n = i. def __getitem__(self, i, j=None):; """"""Returns the (i,j)th element of the transformation matrix; or the i'th row of the transformation matrix if *j* is None. """"""; if j is None:; return self.d[i]; else:; return self.d[i][j]. [docs] def trace(self):; """"""returns the trace of the transformation matrix. """"""; r = 0.0; for i in range(self.n):; r += self.d[i][i]; return r. # <<< Methods for Symmetry Operations >>>. [docs] def zero(self):; """"""zero out the symop""""""; self.d = zero(5, 5). [docs] def unit(self):; """"""Set equal to a unit matrix""""""; self.zero(); self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[2][2] = 1.0; self.d[3][3] = 1.0; self.d[4][4] = 1.0. [docs] def E(self):; """"""Set equal to the identity""""""; self.unit(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:10932,Validat,ValidationError,10932,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security," it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequencies(cls, val):; warnings.warn(; ""Using `psi4.core.Wavefunction.set_frequencies` (accessing c-side member data) instead of `psi4.core.Wavefunction.frequency_analysis` (py-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_legacy_frequencies(val). core.Wavefunction.frequencies = _core_wavefunction_frequencies; core.Wavefunction.legacy_frequencies = _core_wavefunction_legacy_frequencies; core.Wavefunction.set_frequencies = _core_wavefunction_set_frequencies. ## Psi4 v1.3 Export Deprecations. def _core_get_gradient():; warnings.warn(; ""Using `psi4.core.get_gradient` (only used internally for C++ optking; deprecated silently in 1.2) is deprecated, and in 1.4 (or whenever Py optking is adopted) it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.get_legacy_gradient(). def _core_set_gradient(val):; warnings.warn(; ""Using `psi4.core.set_gradient` (only used internally for C++ optking; deprecated silently in 1.2) is deprecated, and in 1.4 (or whenever Py optking is adopted) it will stop wor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:24875,access,accessing,24875,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['access'],['accessing']
Security," item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({0:d}) and low ({1:d}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); # either both *_wfn and *_basis have to be specified; if ""{:s}_wfn"".format(sn) in kwargs and ""{:s}_basis"".format(sn) in kwargs:; stage = {""wfn"": kwargs[""{:s}_wfn"".format(sn)], ""basis"": kwargs[""{:s}_basis"".format(sn)]}; # or we're at a scf stage which can be implied with a provided scf_basis; elif sn == ""scf"" and ""{:s}_basis"".format(sn) in kwargs:; stage = {""wfn"": ""hf"", ""basis"": kwargs[""{:s}_basis"".format(sn)]}; # otherwise go to the next possible stage; else:; continue; # if we made it here, stage exists - parse other keywords; if ""{:s}_scheme"".format(sn) in kwargs:; st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:31901,validat,validate,31901,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,2,"['Validat', 'validat']","['ValidationError', 'validate']"
Security," keywords = {k.lower(): v for k, v in prepare_options_for_set_options().items()}; if function_kwargs is not None:; keywords[""function_kwargs""] = function_kwargs. kw_basis = keywords.pop(""basis"", None); basis = basis or kw_basis. resi = AtomicInput(; **{; ""driver"": driver,; ""extras"": {; ""wfn_qcvars_only"": True,; },; ""model"": {; ""method"": method,; ""basis"": basis,; },; ""keywords"": keywords,; ""molecule"": molecule.to_schema(dtype=2),; ""provenance"": provenance_stamp(__name__),; }). return resi. [docs]; def mat2arr(mat: core.Matrix) -> List[List[float]]:; """"""Convert Matrix to List. Parameters; ----------; mat; |PSIfour| matrix. Should be flat with respect to symmetry. Returns; -------; List[List[float]]; Pure Python representation of `mat`. """"""; warnings.warn(; ""Using `psi4.driver.p4util.mat2arr` instead of `MatrixInstance.to_array().tolist()` is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2). if mat.rowdim().n() != 1:; raise ValidationError('Cannot convert Matrix with symmetry.'); arr = []; for row in range(mat.rowdim()[0]):; temp = []; for col in range(mat.coldim()[0]):; temp.append(mat.get(row, col)); arr.append(temp); return arr. [docs]; def expand_psivars(; pvdefs: Dict[str, Dict[str, Union[List[str], Callable]]],; verbose: Optional[int] = None):; """"""From rules on building QCVariables from others, set new variables to; P::e if all the contributors are available. Parameters; ----------; pvdefs; Dictionary with keys with names of QCVariables to be created and values; with dictionary of two keys: 'args', the QCVariables that contribute to; the key and 'func', a function (or lambda) to combine them.; verbose; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:17803,Validat,ValidationError,17803,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,3,['Validat'],['ValidationError']
Security," kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.gro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:116728,Validat,ValidationError,116728,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security," len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Truhlar SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Truhlar SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Truhlar 2-point power from SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_truhlar_2: datatype is not recognized '%s'."" % type(valueLO)). def scf_xtpl_karton_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333, DOI: 10.1007/s00214-005-0028-6. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3. """""". if type(valueLO) != type(valueHI):; raise ValidationError(""scf_xtpl_karton_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 6.30. beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = '';",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:11098,Validat,ValidationError,11098,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security," len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); # either both *_wfn and *_basis have to be specified; if ""{:s}_wfn"".format(sn) in kwargs and ""{:s}_basis"".format(sn) in kwargs:; stage = {""wfn"": kwargs[""{:s}_wfn"".format(sn)], ""basis"": kwargs[""{:s}_basis"".format(sn)]}; # or we're at a scf stage which can be implied with a provided scf_basis; elif sn == ""scf"" and ""{:s}_basis"".format(sn) in kwargs:; stage = {""wfn"": ""hf"", ""basis"": kwargs[""{:s}_basis"".format(sn)]}; # otherwise go to the next possible stage; else:; continue; # if we made it here, stage exists - parse other keywords; if ""{:s}_scheme"".format(sn) in kwargs:; stage[""scheme""] = kwargs[""{:s}_scheme"".format(sn)]; if ""{:s}_wfn_lesser"".format(sn) in kwargs:; stage[""wfn_lo""] = kwargs[""{:s}_wfn_lesser"".format(sn)]; if ""cbs_{:s}_alpha"".format(sn) in kwargs:; stage[""alpha""] = kwargs[""cbs_{:s}_alpha""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:32236,Validat,ValidationError,32236,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security," list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); view = _get_raw_views(ret)[0]; view[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:5021,Validat,ValidationError,5021,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security," list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irrepped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:5008,Validat,ValidationError,5008,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],['ValidationError']
Security," lowername, **kwargs). return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(""""""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # Does an analytic procedure exist for the re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:66124,Validat,ValidationError,66124,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security," lowername, **kwargs). return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0. # Does an analytic procedure exist for the requested method?; if dertype == 2:; psi4.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:64287,Validat,ValidationError,64287,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security," m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. shape¶; Shape of the Psi4 data object. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of unit length and arg1 direction. class psi4.core.VectorMatrix¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:264491,access,accessor,264491,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['access'],['accessor']
Security," match up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). [docs]def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - hand it off for more checks; newinput += parse_multiline_array(input_list); else:; # Nothing to do - just add the line to the string; newinput += ""%s\n"" % (input_list.pop(0)); return newinput. [docs]def process_input(raw_input, print_level=1):; """"""Function to preprocess *raw input*, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; *raw_input* is printed to the output file unless *print_level* =0. Does; a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(input_re, line):; input_start = line_count + 3; break. stop_re = re.compile(r'^-{74}'); input_stop = -1; f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:19096,validat,validate,19096,psi4manual/1.0.0/_modules/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html,1,['validat'],['validate']
Security," mcset='default', failoninc=True, verbose=False):; """"""For all data or modelchem subset *mcset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if mcset == 'default':; lsslist = self.data.keys(); elif callable(mcset):; # mcset is function that will generate subset of HRXN from sset(self); lsslist = [mc for mc in self.data.keys() if mc in mcset(self)] # untested; else:; # mcset is array containing modelchemistries; lsslist = [mc for mc in self.data.keys() if mc in mcset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for mc in lsslist:; lsset[mc] = self.data[mc]. lbench = self.benchmark if benchmark == 'default' else benchmark; try:; mcGreater = self.data[lbench].value; except KeyError as e:; raise ValidationError(""""""Reaction %s missing benchmark datum %s."""""" % (self.name, str(e))). err = {}; for label, datum in lsset.iteritems():; try:; mcLesser = datum.value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (label, str(e))); else:; continue. err[label] = [mcLesser - mcGreater,; (mcLesser - mcGreater) / abs(mcGreater),; (mcLesser - mcGreater) / abs(mcGreater)] # TODO define BER; if verbose:; print(""""""p = %6.2f, pe = %6.1f%%, bpe = %6.1f%% modelchem %s."""""" %; (err[label][0], 100 * err[label][1], 100 * err[label][2], label)). return err. [docs] def plot(self, benchmark='default', mcset='default',; failoninc=True, verbose=False, color='sapt',; xlimit=4.0, labeled=True, view=True,; mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Computes individual errors over model chemistries in *mcset* (which; may be default or an array or a function generating an array)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:16717,Validat,ValidationError,16717,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security," miniconda has; already been installed (instructions at Quick Installation),; libefp can be obtained through conda install libefp -c psi4.; Then enable it as a feature with ENABLE_libefp,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect libefp and activate dependent code. To remove a conda installation, conda remove libefp. Source. If using PSI4 built from source and you want libefp built from; from source also,; enable it as a feature with ENABLE_libefp,; and let the build system fetch and build it and activate dependent code. EFP Fragments¶; LIBEFP comes with a couple dozen ready-to-use fragments (water, benzene,; common solvents, etc.) listed here; with source https://github.com/libefp2/libefp/tree/master/fraglib. Any of these may be used directly in; a PSI4 input file as described here.; Creating new efp fragments requires the GAMESS quantum chemistry package.; Instructions on building new fragments are here.; Once your new fragment is ready, make it accessible to PSI4 by; including the directory in which the .efp file is located to the colon; separated environment variable PSIPATH. Fragments are searched; for first in the current directory, next in the paths of PSIPATH, and; finally in built-in library. If PSI4 is unable to find the; fragment, an error will be reported. Note; When constructing new fragment files, the name of the name of the; file should be lowercase and have extension .efp. The molecule name; within the file, e.g., $NH3 must correspond to the name of the; fragment file. Molecule Specification¶; EFP fragment geometries are specified alongside the quantum mechanical; (QM) molecule and make use of the -- fragment separation scheme; described here. Each EFP fragment has its own; fragment section that includes the label efp, the name of the file; fragname from which EFP parameters are to be read, and the position; specification for the fragment in one of two ways, XYZABC or POINTS. For; XYZABC, the fragment specification is all",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/libefp.html:1862,access,accessible,1862,psi4manual/master/libefp.html,https://psicode.org,https://psicode.org/psi4manual/master/libefp.html,9,['access'],['accessible']
Security," minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:30592,Validat,ValidationError,30592,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['Validat'],['ValidationError']
Security," minus the value); if vstr[0] == '-':; self.all_variables.append(vstr[1:]); return VariableValue(vstr[1:], self.geometry_variables, True). # handle normal variable values; else:; self.all_variables.append(vstr); return VariableValue(vstr, self.geometry_variables). [docs] def add_atom(self, Z, x, y, z, label="""", mass=0.0, charge=0.0, lineno=-1):; """"""Add an atom to the molecule; *Z* atomic number; *x* cartesian coordinate; *y* cartesian coordinate; *z* cartesian coordinate; *symb* atomic symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('Molecule::atom_at_position: Argument vector not of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; #if self.all_variables; #print 'vstr', vstr, 'all_variables', self.all_variables, (vstr.upper() in self.all_variables), '\n'; return True if vstr.upper() in self.all_variables else",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:34563,Validat,ValidationError,34563,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security," module proc. run_mp3_gradient() in module proc. RUN_MP4 (FNOCC). run_mrcc() in module proc. run_ocepa() in module proc. run_ocepa_gradient() in module proc. run_oldmp2() in module proc. run_omp2() in module proc. run_omp2_5() in module proc. run_omp2_5_gradient() in module proc. run_omp2_gradient() in module proc. run_omp3() in module proc. run_omp3_gradient() in module proc. run_psimrcc() in module proc. run_psimrcc_scf() in module proc. run_sapt() in module proc. run_sapt_ct() in module proc. run_scf() in module proc. run_scf_gradient() in module proc. run_scf_property() in module proc. run_scs_omp2() in module proc. run_scs_omp3() in module proc. run_sos_omp2() in module proc. run_sos_omp3() in module proc. S. S (DETCI). S22 module, [1]. S22by5 module, [1]. S66 module, [1]. S_ORTHOGONALIZATION (SCF). S_SQUARED (DETCI). S_TOLERANCE (SCF). SAD_CHOL_TOLERANCE (SCF). SAD_D_CONVERGENCE (SCF). SAD_E_CONVERGENCE (SCF). SAD_F_MIX_START (SCF). SAD_MAXITER (SCF). SAD_PRINT (SCF). sanitize() Getkw method. Section method. sanitize_basisname() in module p4util.basislist. sanity_check() Keyword method. Section method. SAPT. SAPT0. charge-transfer. higher-order. output. theory. SAPT (SCF). SAPT_LEVEL (SAPT). SAPT_MEM_CHECK (SAPT). SAPT_MEM_SAFETY (SAPT). SAPT_OS_SCALE (SAPT). SAPT_SS_SCALE (SAPT). SAPTDISPENERGY. SAPTELSTENERGY. SAPTENERGY. SAPTEXCHENERGY. SAPTINDENERGY. SAPTSAPT0ENERGY. SAPTSAPT2+(3)(CCD)ENERGY. SAPTSAPT2+(3)ENERGY. SAPTSAPT2+(CCD)ENERGY. SAPTSAPT2+3(CCD)ENERGY. SAPTSAPT2+3ENERGY. SAPTSAPT2+ENERGY. SAPTSAPT2ENERGY. save() Table method. SAVE_JK (SCF). save_string_xyz() LibmintsMolecule method. Molecule method. save_to_checkpoint() LibmintsMolecule method. save_xyz() LibmintsMolecule method. SCALE (STABILITY). scale() in module qcdb.vecutil. Table method. SCF. theory. scf_helper() in module proc. SCF_MAXITER (DCFT). SCF_MEM_SAFETY_FACTOR (SCF). SCF_TYPE (CPHF). (SCF). scf_xtpl_helgaker_2() in module wrappers. scf_xtpl_helgaker_3() in module wrappers. SCFDIPOLEX.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:42659,sanitiz,sanitize,42659,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['sanitiz'],['sanitize']
Security," molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:13106,Validat,ValidationError,13106,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security," name[:-3].strip(); # work our way through the sets merging them; combined_atom_basis_shell = OrderedDict(); for at in range(len(sets)):; atom_basis_shell = sets[at].atom_basis_shell. for label, basis_map in atom_basis_shell.items():; if label not in combined_atom_basis_shell:; combined_atom_basis_shell[label] = OrderedDict(); combined_atom_basis_shell[label][name] = []; for basis, shells in basis_map.items():; combined_atom_basis_shell[label][name].extend(shells). #for label, basis_map in combined_atom_basis_shell.items():; # # sort the shells by angular momentum; # combined_atom_basis_shell[label][name] = sorted(combined_atom_basis_shell[label][name], key=lambda shell: she. # Molecule and parser prepped, call the constructor; mol.set_basis_all_atoms(name, ""CABS""). # Construct the grand BasisSet for mol; basisset = BasisSet(""CABS"", mol, combined_atom_basis_shell). # Construct all the one-atom BasisSet-s for mol's CoordEntry-s; for at in range(mol.natom()):; oneatombasis = BasisSet(basisset, at); oneatombasishash = hashlib.sha1(oneatombasis.print_detail(numbersonly=True).encode('utf-8')).hexdigest(); mol.set_shell_by_number(at, oneatombasishash, role=""CABS""); mol.update_geometry() # re-evaluate symmetry taking basissets into account. text = """""" => Creating Basis Set <=\n\n""""""; text += """""" Role: %s\n"""""" % (fitroles); text += """""" Keyword: %s\n"""""" % (keys); text += """""" Name: %s\n"""""" % (name). if returnBasisSet:; print(text); return basisset; else:; bsdict = {}; bsdict['message'] = text; bsdict['name'] = basisset.name; bsdict['puream'] = int(basisset.has_puream()); bsdict['shell_map'] = basisset.export_for_libmints(""CABS""); return bsdict. @staticmethod; [docs] def pyconstruct(mol, key, target, fitrole='BASIS', other=None):; """"""Builds a BasisSet object for *mol* (either a qcdb.Molecule or; a string that can be instantiated into one) from basis set; specifications passed in as python functions or as a string that; names a basis to be applied to all atoms. Always required i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:16771,hash,hashlib,16771,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['hash'],['hashlib']
Security," not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(self: Union[core.Matrix, core.Vector]) -> Dict[str, Any]:; """"""; Converts an object with a ``.nph`` accessor to a serialized dictionary. Parameters; ----------; self; Matrix or Vector instance. Returns; -------; ~typing.Dict[str, ~typing.Any]; Serialized dictionary with keys:. - shape; - data : List[str]; - type : {'matrix', 'vector'}. """"""; json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in self.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise ValidationError(""_to_json is only used for vector and matrix objects.""). return json_data. def _from_serial(self, json_data: Dict[str, Any]) -> Union[core.Matrix, core.Vector]:; """"""; Converts serialized data to the correct Psi4 data type. Parameters; ----------; self; Pointer to which class to be constructed.; json_data; Serialization of class. See :meth:`to_serial` for data layout. """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:11904,access,accessor,11904,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['access'],['accessor']
Security," np; View without only one irrep. classmethod np_read(filename, prefix=''); Reads the data from a NumPy compress file. np_write(filename=None, prefix=''); Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph; View with irreps. print_out(self: psi4.core.Vector) → None; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None; Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None; Set a vector block. shape; Shape of the Psi4 data object. to_array(copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vector.html:8485,access,accessor,8485,psi4manual/1.2.1/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vector.html,1,['access'],['accessor']
Security," numAtoms == 1:; os.chdir(current_directory); dashd = 0.0; dashdderiv = core.Matrix(1, 3). if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif dertype == 1:; return dashdderiv. geom = mol.save_string_xyz(); reals = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; numAtoms -= 1; else:; reals.append(line). geomtext = str(numAtoms) + '\n\n'; for line in reals:; geomtext += line.strip() + '\n'; geomfile = './dftd3_geometry.xyz'; with open(geomfile, 'w') as handle:; handle.write(geomtext); # TODO somehow the variations on save_string_xyz and; # whether natom and chgmult does or doesn't get written; # have gotten all tangled. I fear this doesn't work; # the same btwn libmints and qcdb or for ghosts. # Call dftd3 program; command = ['dftd3', geomfile]; if dertype != 0:; command.append('-grad'); try:; dashout = subprocess.Popen(command, stdout=subprocess.PIPE, env=lenv); except OSError as e:; raise ValidationError('Program dftd3 not found in path. %s' % e); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; line = line.decode('utf-8'); if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful run. Possibly -D variant not available in dftd3 version.""""""). # Parse grad output; if dertype != 0:; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != mol.natom():; raise ValidationError('Program dftd3 gradient file has %d a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:8514,Validat,ValidationError,8514,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security," numpy_holder(object):; """"""; Blank object, stupid. Apparently you cannot create a view directly from a dictionary; """"""; def __init__(self, interface):; self.__array_interface__ = translate_interface(interface). def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; ret = []; for data in self.array_interface():. # Yet another hack; if isinstance(data[""shape""], list):; data[""shape""] = tuple(data[""shape""]). if 0 in data[""shape""]:; ret.append(np.empty(shape=data[""shape""])); else:; ret.append(np.array(numpy_holder(data), copy=copy)); return ret. def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; try:; arr.shape; except:; raise ValidationError(""Expected numpy array, found object of type '%s'"", type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr : array or list of arrays; Numpy array or list of arrays to use as the data for a new core.Matrix; name : str; Name to give the new core.Matrix; dim1 : list, tuple, or core.Dimension (optional); If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 :; Same as dim1 only if using a Psi4.Dimension object. Returns; -------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Returns the given Psi4 object. Notes; -----; This is a generalized function to convert a NumPy array to a Psi4 object. Examples; --------. >>> data = np.random.rand(20)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:2612,Validat,ValidationError,2612,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security," of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', psi4.get_active_molecule()); else:; psi4.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = sapt_dimer.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). do_delta_mp2 = True if name.endswith('dmp2') else False. sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'). if sapt_basis == ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:79855,Validat,ValidationError,79855,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security," of different helpers to export various quantities from the wavefunction; to external formats such as FCHK and MOLDEN. Because the Wavefunction makes; its members available to the Python layer, any other similar export functions; should be written in python. Integral consuming technologies¶; The general philosophy in PSI4 is to try write two-electron integral; driven tasks in methods like Hartree-Fock, CIS and CPHF in terms of generalized; Fock-like matrices. From here, a single class can be used to construct these; generalized Fock matrices, which is what libFock; (psi4/psi4/src/psi4/libfock) accomplishes. A number of integral; technologies – such as integral-direct, disk-based and density fitting – are; supported in libFock, making them generally available to all elements of the; code that use the generalized Fock matrix strategy. Exposing C++ code to Python¶; The recent push to move sections of the code that are not a bottleneck into the; Python layer requires that the C++ code is callable from Python and that its; results are accessible. The result accessibility is addressed by populating; the appropriate variables in the Wavefunction object. To make the code; callable from Python, we rely on the excellent PyBind11 library; to create the bindings. Existing code to export various PSI4 classes can; be found in psi4/psi4/src in the files whose name begins with export_.; The code to export functions that run entire calculations is usually found in; psi4/psi4/src/core.cc. table of contents. General layout of the core: where new C++ code should live; New integral operators; Completely new methods; Integral consuming technologies; Exposing C++ code to Python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction to Programming in PSI4; General layout of the core: where new C++ code should live. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_tour.html:2650,access,accessibility,2650,psi4manual/1.6.x/prog_tour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_tour.html,1,['access'],['accessibility']
Security," of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys; from typing import List, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr: Union[np.ndarray, List[np.ndarray]], name: str = ""New Matrix"", dim1: Union[List, Tuple, core.Dimension] = None, dim2: core.Dimension = None) -> Union[core.Matrix, core.Vector]:; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr; Numpy array or list of arrays to use as the data for a new core.Matrix; name; Name to give the new core.Matrix; dim1; If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2; Same as dim1 only if using a psi4.core.Dimension object. Returns; -------; Matrix or Vector; Returns the given Psi4 object. Notes; -----; This is a generalized function to convert a NumPy array to a Psi4 object. Examples; --------. >>> data = np.random.r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:1921,Validat,ValidationError,1921,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,3,['Validat'],['ValidationError']
Security," of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility function for dumping the Hamiltonian to file in FCIDUMP format."""""". __all__ = [; ""compare_fcidumps"",; ""energies_from_fcidump"",; ""fcidump"",; ""fcidump_from_file"",; ]. from typing import Any, Dict, List, Optional. import numpy as np. from psi4 import core. from .. import psifiles as psif; from ..procrouting.proc_util import check_iwl_file_from_scf_type; from .exceptions import TestComparisonError, ValidationError; from .testing import compare_integers, compare_recursive, compare_values. [docs]; def fcidump(wfn: core.Wavefunction, fname: str = 'INTDUMP', oe_ints: Optional[List] = None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/fcidump.html:1536,Validat,ValidationError,1536,psi4manual/1.9.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/fcidump.html,2,['Validat'],['ValidationError']
Security," of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). psi4.hessian(name[, molecule, return_wfn, func, dertype, irrep])[source]¶; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. Returns:Matrix – Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. Returns:(Matrix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples:. 1; 2>>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). 1; 2; 3; 4; 5; 6>>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). It’s handy to collect the wavefunction after a frequency; calculation through e, wfn = psi4.frequency(...,; return_wfn=True) as the frequencies can be accessed through; psi4.core.Wavefunction.frequencies(), the Hessian through; psi4.core.Wavefunction.hessian(), and much other computation; info through psi4.core.Wavefunction.frequency_analysis; (note no parentheses). Examples of using this data; structure can be found fd-freq-gradient and; python/vibanalysis. Formatted printing of vibrational; results is available through qcdb.vib.print_vibs(). Results accessible through psi4.core.Wavefunction.frequency_analysis¶. key; description (lbl & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; nd.array(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy;  ; ndarray(ndof) int. TRV; translation/rotation/vibration;  ; ndarray(ndof) str ‘TR’ or ‘V’ or ‘-‘ for partial. gamma; irreducible rep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/freq-1.html:4901,access,accessed,4901,psi4manual/1.2.1/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/freq-1.html,2,['access'],['accessed']
Security," of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documented below. psi4.driver.procrouting.interface_cfour.run_cfour(name[, keep, path])[source]¶; Function that prepares environment and input files; for a calculation calling Stanton and Gauss’s CFOUR code.; Also processes results back into Psi4 format.; This function is not called directly but is instead called by; energy() or optimize() when a Cfour; method is requested (through name argument). In order to function; correctly, the Cfour executable xcfour must be present in; PATH or PSIPATH. Many PSI Variables extracted from the Cfour output; Python dictionary of associated file constants accessible as P4C4_INFO['zmat'], P4C4_INFO['output'], P4C4_INFO['grd'], etc. Parameters. name (str) – 'c4-scf' || 'c4-ccsd(t)' || 'cfour' || etc.; First argument, usually unlabeled. Indicates the computational; method to be applied to the system. keep (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. path (str) – Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory.; If specified, GENBAS and/or ZMAT within will be used. genbas (str) – Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {…} block and basis is set through; PSI4‘s BASIS keyword. In that case, a GENBAS is written from; LibMints and all is well. Otherwise, a GENBAS is looked for in; the usual places: PSIPATH, PATH, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:24002,access,accessible,24002,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,5,['access'],['accessible']
Security," of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documented below. psi4.driver.procrouting.interface_cfour.run_cfour(name[, keep, path])[source]¶; Function that prepares environment and input files; for a calculation calling Stanton and Gauss’s CFOUR code.; Also processes results back into Psi4 format.; This function is not called directly but is instead called by; energy() or optimize() when a Cfour; method is requested (through name argument). In order to function; correctly, the Cfour executable xcfour must be present in; PATH or PSIPATH. Many PSI Variables extracted from the Cfour output; Python dictionary of associated file constants accessible as P4C4_INFO['zmat'], P4C4_INFO['output'], P4C4_INFO['grd'], etc. Parameters:. name (str) – 'c4-scf' || 'c4-ccsd(t)' || 'cfour' || etc.; First argument, usually unlabeled. Indicates the computational; method to be applied to the system. keep (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. path (str) – Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory.; If specified, GENBAS and/or ZMAT within will be used. genbas (str) – Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {…} block and basis is set through; PSI4‘s BASIS keyword. In that case, a GENBAS is written from; LibMints and all is well. Otherwise, a GENBAS is looked for in; the usual places: PSIPATH, PATH,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:24133,access,accessible,24133,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,4,['access'],['accessible']
Security," on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'. elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Call appropriate wrappers; if gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(hessian, name.lower(), ptype='hessian', **kwargs); # Check if this is a CBS extrapolation; elif gradient_type == ""cbs_gufunc"":; return driver_cbs._cbs_gufunc(hessian, name.lower(), **kwargs, ptype=""hessian""); elif gradient_type == ""cbs_wrapper"":; return driver_cbs.cbs(hessian, ""cbs"", **kwargs, ptype=""hessian""); elif gradient_type != ""conventional"":; raise ValidationError(""Hessian: Does not yet support custom functions.""); else:; lowername = name.lower(). _filter_renamed_methods(""frequency"", lowername); ; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.get('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Set method-dependent scf convergence criteria (test on proce",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:75875,Validat,ValidationError,75875,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security," on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'. elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Call appropriate wrappers; if gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(hessian, name.lower(), ptype='hessian', **kwargs); # Check if this is a CBS extrapolation; elif gradient_type == ""cbs_gufunc"":; return driver_cbs._cbs_gufunc(hessian, name.lower(), **kwargs, ptype=""hessian""); elif gradient_type == ""cbs_wrapper"":; return driver_cbs.cbs(hessian, ""cbs"", **kwargs, ptype=""hessian""); elif gradient_type != ""conventional"":; raise ValidationError(""Hessian: Does not yet support custom functions.""); else:; lowername = name.lower(). return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:63261,Validat,ValidationError,63261,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security," only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exported via pybind11) documented thereat; are accessible through the handle option_molecule_name in; molecule optional_molecule_name {...}. The molecular geometry can be got and set and manipulated as a; Matrix object. Below shows how to access; coordinates in an input file in Python.; molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Pyt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithonmol.html:17051,access,accessible,17051,psi4manual/master/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/master/psithonmol.html,9,['access'],['accessible']
Security," option read in DFMP2; PsiMod.set_global_option('SCF_TYPE', 'DF'). if not PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 properties need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). PsiMod.dfmp2grad(); e_dfmp2 = PsiMod.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = PsiMod.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:31272,Validat,ValidationError,31272,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security," or parameter > 100.0:; raise ValidationError('SCF DAMPING_PERCENTAGE ({}) must be between 0 and 100'.format(parameter)). stop = core.get_option('SCF', 'DAMPING_CONVERGENCE'); if stop < 0.0:; raise ValidationError('SCF DAMPING_CONVERGENCE ({}) must be > 0'.format(stop)). return enabled. def _validate_diis():; """"""Sanity-checks DIIS control options. Raises; ------; ValidationError; If any of |scf__diis|, |scf__diis_start|,; |scf__diis_min_vecs|, |scf__diis_max_vecs| don't play well together. Returns; -------; bool; Whether DIIS is enabled during scf. """"""; enabled = bool(core.get_option('SCF', 'DIIS')); if enabled:; start = core.get_option('SCF', 'DIIS_START'); if start < 1:; raise ValidationError('SCF DIIS_START ({}) must be at least 1'.format(start)). minvecs = core.get_option('SCF', 'DIIS_MIN_VECS'); if minvecs < 1:; raise ValidationError('SCF DIIS_MIN_VECS ({}) must be at least 1'.format(minvecs)). maxvecs = core.get_option('SCF', 'DIIS_MAX_VECS'); if maxvecs < minvecs:; raise ValidationError(; 'SCF DIIS_MAX_VECS ({}) must be at least DIIS_MIN_VECS ({})'.format(maxvecs, minvecs)). return enabled. def _validate_frac():; """"""Sanity-checks FRAC control options. Raises; ------; ValidationError; If any of |scf__frac_start| don't play well together. Returns; -------; bool; Whether FRAC is enabled during scf. """"""; enabled = (core.get_option('SCF', 'FRAC_START') != 0); if enabled:; if enabled < 0:; raise ValidationError('SCF FRAC_START ({}) must be at least 1'.format(enabled)). return enabled. def _validate_MOM():; """"""Sanity-checks MOM control options. Raises; ------; ValidationError; If any of |scf__mom_start|, |scf__mom_occ| don't play well together. Returns; -------; bool; Whether excited-state MOM (not just the plain stabilizing MOM) is enabled during scf. """"""; enabled = (core.get_option('SCF', ""MOM_START"") != 0 and len(core.get_option('SCF', ""MOM_OCC"")) > 0); if enabled:; start = core.get_option('SCF', ""MOM_START""); if enabled < 0:; raise ValidationError('SCF MOM_START",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:24240,Validat,ValidationError,24240,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security," p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n""); core.print_out("" "" + banner.center(58)). scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(scf_wfn). # The wfn from_file routine adds the npy suffix if needed, but we add it here so that; # we can use os.path.isfile to query whether the file exists before attempting to read; read_filename = scf_wfn.get_scratch_filename(180) + '.npy'; if ((core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename)):; old_wfn = core.Wavefunction.from_file(read_filename). Ca_occ = old_wfn.Ca_subset(""SO"", ""OCC""); Cb_occ = old_wfn.Cb_subset(""SO"", ""OCC""). if old_wfn.molecule().schoenflies_symbol() != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if old_wfn.basisset().name() == scf_wfn.basisset().name():; core.print_out(f"" Reading orbitals from file {read_filename}, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out(f"" Reading orbitals from file {read_filename}, projecting to new basis.\n\n""); core.print_out("" Computing basis projection from %s to %s\n\n"" % (old_wfn.basisset().name(), scf_wfn.basisset().name())). pCa = scf_wfn.basis_projection(Ca_occ, old_wfn.nalphapi(), old_wfn.basisset(), scf_wfn.basisset()); pCb = scf_wfn.basis_projection(Cb_occ, old_wfn.nbetapi(), old_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Strip off headers to only get R, RO, U, CU; old_ref = old_wfn.name().replace(""KS"", """").replace(""HF"", """"); new_ref = scf_wfn.name().replace(""KS"", """").replace(""HF"", """"); if old_ref != new_ref:; scf_wfn.reset_occ_ = True. elif (core.get_option('SCF', 'GUESS') == 'READ') and not os.pat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:46766,Validat,ValidationError,46766,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security," pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; freq_mode = 'continuous'; if ('mode' in kwargs) and ((dertype == 0) or (dertype == 1)):; freq_mode = kwargs['mode']. if (freq_mode.lower() == 'continuous'):; pass; elif (freq_mode.lower() == 'sow'):; pass; elif (freq_mode.lower() == 'reap'):; if('linkage' in kwargs):; freq_linkage = kwargs['linkage']; else:; raise ValidationError('Frequency execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Frequency execution mode \'%s\' not valid.' % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Select certain irreps; if 'irrep' in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:60808,Validat,ValidationError,60808,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Validat'],['ValidationError']
Security," path, do nothing.; if (keep != False or ('path' in kwargs)):; psi4.print_out('\nMRCC scratch files have been kept.\n'); psi4.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; psi4.print_out('\n'); p4util.banner('Full results from MRCC'); psi4.print_out('\n'); psi4.print_out(iface_contents). return ref_wfn. [docs]def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE']). psi4.set_local_option('FNOCC', 'DFCC', True); psi4.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). def set_cholesky_from(mtd_type):; type_val = psi4.get_global_option(mtd_type); if type_val == 'CD':; psi4.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'CD'); psi4.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); elif type_val == 'DF':; if psi4.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; psi4.set_local_option('FNOCC', 'DF_BASIS_CC', ''); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:97879,Validat,ValidationError,97879,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security," path:; psi4_io.set_default_path('/scratch/user'). To set up the scratch path from a variable $MYSCRATCH:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). To set up a specific path for the internal coordinate file and instruct PSI4 not to delete it:; psi4_io.set_specific_path(12, './'); psi4_io.set_specific_retention(12, True). # equivalent to above; psi4_io.set_specific_path(PSIF_INTCO, './'); psi4_io.set_specific_retention(PSIF_INTCO, True). The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instructions in the ~/.psi4rc file. During; execution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed.; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and C++; std::thread for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external.html:11311,access,accessible,11311,psi4manual/master/external.html,https://psicode.org,https://psicode.org/psi4manual/master/external.html,9,['access'],['accessible']
Security," popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs``",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:2689,access,access,2689,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,4,['access'],['access']
Security," portions of a Psi4 output file outtext. muster_basis(bas)[source]¶; Transform input mem in MB into psi4-type options. muster_cdsgroup_options()[source]¶. muster_memory(mem)[source]¶; Transform input mem in MB into psi4-type options. muster_modelchem(name, dertype)[source]¶; Transform calculation method name and derivative level dertype; into options for cfour. While deliberately requested pieces,; generally CFOUR_DERIV_LEVEL and CFOUR_CALC_LEVEL,; are set to complain if contradicted (‘clobber’ set to True), other; ‘recommended’ settings, like CFOUR_CC_PROGRAM, can be; countermanded by keywords in input file (‘clobber’ set to False).; Occasionally, want these pieces to actually overcome keywords in; input file (‘superclobber’ set to True). psi4_list()[source]¶; Return an array of Psi4 methods with energies. class BasisSet(*args)[source]¶; Basis set container class; Reads the basis set from a checkpoint file object. Also reads the molecule; from the checkpoint file storing the information in an internal Molecule class; which can be accessed using molecule(). LIBINT_MAX_AM = 6¶. add(b)[source]¶; Adds this plus another basis set and returns the result.; Equivalent to the ‘+’ operator. Appears defunct. ao_to_shell(i)[source]¶; Given a Cartesian function (AO) number what shell does it correspond to. atomic_basis_set(center)[source]¶; Return a BasisSet object containing all shells at center i (0-index); * Used for Atomic HF computations for SAD Guesses; * @param center Atomic center to provide a basis object for.; * @returns A new basis set object for the atomic center. static build(molecule, shells)[source]¶; Builder factory method; * @param molecule the molecule to build the BasisSet around; * @param shells array of atom-numbered GaussianShells to build the BasisSet from; * @return BasisSet corresponding to this molecule and set of shells. compute_phi(phi_ao, x, y, z)[source]¶; Returns the values of the basis functions at a point. concatenate(b)[source]¶; Concatenates tw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:58236,access,accessed,58236,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['access'],['accessed']
Security," psi4.get_option('SCF', 'REFERENCE') == 'UKS':; psi4.set_local_option('SCF', 'REFERENCE', 'UHF'); else:; pass; elif lowername == 'rhf':; psi4.set_local_option('SCF', 'REFERENCE', 'RHF'); elif lowername == 'uhf':; psi4.set_local_option('SCF', 'REFERENCE', 'UHF'); elif lowername == 'rohf':; psi4.set_local_option('SCF', 'REFERENCE', 'ROHF'); elif lowername == 'rscf':; if (len(psi4.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); else:; psi4.set_local_option('SCF', 'REFERENCE', 'RHF'); elif lowername == 'uscf':; if (len(psi4.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); else:; psi4.set_local_option('SCF', 'REFERENCE', 'UHF'); elif lowername == 'roscf':; if (len(psi4.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; psi4.set_local_option('SCF', 'REFERENCE', 'ROHF'). scf_helper(name, **kwargs). optstash.restore(). [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). if (psi4.get_option('SCF', 'SCF_TYPE') == 'DF'):. # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). psi4.scfgrad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:14070,Validat,ValidationError,14070,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security," psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if psi4.has_option_changed('SCF', 'BASIS_GUESS'):; cast = psi4.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; molecule = psi4.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF','REFERENCE') != 'UHF' and psi4.get_option('SCF','REFERENCE') != 'UKS':; raise ValidationError('You must specify ""set reference uhf"" to use broken symmetry.'); do_broken = True; else:; do_broken = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that can't query PUREAM option directly, as it only; # reflects user changes to value, so load basis and; # read effective PUREAM setting off of it; psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')); psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; molecule.set_multiplicity(3); psi4.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); psi4.print_out('\n'). # cast set-up; if (cas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:17657,Validat,ValidationError,17657,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security," psi4.set_local_option('OCC', 'DO_SCS', 'TRUE'); psi4.set_local_option('OCC', 'SCS_TYPE', 'SCSVDW'); elif name == 'sos-omp3':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'); psi4.set_local_option('OCC', 'DO_SOS', 'TRUE'); psi4.set_local_option('OCC', 'SOS_TYPE', 'SOS'); elif name == 'sos-pi-omp3':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'); psi4.set_local_option('OCC', 'DO_SOS', 'TRUE'); psi4.set_local_option('OCC', 'SOS_TYPE', 'SOSPI'). elif name == 'lccd':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); psi4.set_local_option('OCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('OCC', 'DO_SOS', 'FALSE'); elif name == 'olccd':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'TRUE'); psi4.set_local_option('OCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('OCC', 'DO_SOS', 'FALSE'); else:; raise ValidationError(""""""Invalid method %s"""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = psi4.occ(ref_wfn). optstash.restore(); return occ_wfn. [docs]def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if name == 'mp2':; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'conv-omp2']:; psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2'); psi4.set_lo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:46001,Validat,ValidationError,46001,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security," psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more."""""".format(; memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount); return memory_amount. [docs]def get_memory():; """"""Function to return ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html:4934,Validat,ValidationError,4934,psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security," psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount); return memory_amount. [docs]def get_memory():; """"""Function to return ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:4976,Validat,ValidationError,4976,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security," psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]; def get_memory() -> int:; """"""Ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:5682,Validat,ValidationError,5682,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,3,['Validat'],['ValidationError']
Security," psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]def get_memory() -> int:; """"""Retur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:5623,Validat,ValidationError,5623,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security," psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]def get_memory():; """"""Function to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html:5389,Validat,ValidationError,5389,psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,3,['Validat'],['ValidationError']
Security," ptype not in derivatives:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:3166,Validat,ValidationError,3166,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security," published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. # Gn theory. import re; import os; import math; import warnings; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. [docs]def run_gaussian_2(name, **kwargs):. # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""""""g2 computations require ""reference rhf"".""""""). # stash user options:; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['SCF','SCF_TYPE']). # override default scf_type; psi4.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; psi4.clean(); psi4.set_global_option('BASIS',""6-31G(D)""); optimize('scf'); psi4.clean(). # scf frequencies for zpe; frequency('scf'). # thermodynamic properties; du = psi4.get_variable('INTERNAL ENERGY CORRECTION'); dh = psi4.get_variable('ENTHALPY CORRECTION'); dg = psi4.get_variable('GIBBS FREE ENERGY CORRECTION'). ref = psi4.wavefunction(); freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range (0,nfreq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html:1352,Validat,ValidationError,1352,psi4manual/4.0b5/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html,1,['Validat'],['ValidationError']
Security," qcdb.vecutil — Psi4 [1.0.0 6a9a71b] Docs. Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». Source code for qcdb.vecutil; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""File for accessory procedures in the chem module.; Credit for the libmints vector3 class to Justin M. Turney and; incremental improvements by other psi4 developers. """"""; from __future__ import absolute_import; from __future__ import print_function; import math; import copy; from .exceptions import *. ZERO = 1.0E-14. [docs]def norm(v):; """"""Compute the magnitude of vector *v*.""""""; return math.sqrt(sum(v[i] * v[i] for i in range(len(v)))). [docs]def add(v, u):; """"""Compute sum of vectors *v* and *u*.""""""; return [u[i] + v[i] for i in range(len(v))]. [docs]def sub(v, u):; """"""Compute difference of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def naivemult(v, u):; """"""Compute by-element multiplication of vectors *v* and *u*.""""""; if len(u) != len(v):; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html:989,access,accessory,989,psi4manual/1.0.0/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html,1,['access'],['accessory']
Security," raise ValidationError('Molecule::get_variable: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print(""""""Setting geometry variable %s to %f"""""" % (vstr.upper(), val)); try:; self.update_geometry(); except IncompleteAtomError:; # Update geometry might have added some atoms, delete them to be safe.; self.atoms = []; # TODO outfile. # def __setattr__(self, name, value):; # """"""Function to overload setting attributes to allow geometry; # variable assigment as if member data.; #; # """"""; # try:; # if name.upper() in self.__dict__['all_variables']:; # self.set_variable(name, value); # else:; # self.__dict__[name] = value; # except KeyError:; # self.__dict__[name] = value; #; # def __getattr__(self, name):; # """"""Function to overload accessing attribute contents to allow; # retrivial geometry variable values as if member data.; #; # """"""; ## #if not name in self.__dict__:; ## if not name in self.__dict__['__dict__']:; ## if object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; ## else:; ## #return self.__dict__[name]; ## return self.__dict__['__dict__'][name]; #; ## if name in self.__dict__:; ## return self.__dict__[name]; ## elif '__dict__' in self.__dict__ and name in self.__dict__['__dict__']:; ## return self.__dict__['__dict__'][name]; ## elif object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; #; # if not name in self.__dict__:; # if object.__getattribute__(self, 'is_variable')(name):; # return object.__getattribute__(self, 'get_variable')(name); # else:; # raise AttributeError; # else:; # return self.__dict__[name]. def __",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:36837,access,accessing,36837,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['access'],['accessing']
Security," raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:35938,Validat,ValidationError,35938,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security," raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='cont",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:36662,Validat,ValidationError,36662,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security," recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). psi4.hessian(name[, molecule, return_wfn, func, dertype, irrep])[source]; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. Returns; Matrix – Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. Returns; (Matrix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). It’s handy to collect the wavefunction after a frequency; calculation through e, wfn = psi4.frequency(...,; return_wfn=True) as the frequencies can be accessed through; psi4.core.Wavefunction.frequencies(), the Hessian through; psi4.core.Wavefunction.hessian(), and much other computation; info through psi4.core.Wavefunction.frequency_analysis; (note no parentheses). Examples of using this data; structure can be found fd-freq-gradient and; psi4/tests/pytests/test_vibanalysis.py. Formatted printing of vibrational; results is available through psi4.driver.qcdb.vib.print_vibs(). Results accessible through psi4.core.Wavefunction.frequency_analysis¶. key; description (lbl & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; ndarray(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy. ndarray(ndof) int. TRV; translation/rotation/vibration. ndarray(ndof) str ‘TR’ or ‘V’ or ‘-’ for partia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/freq-1.html:4448,access,accessed,4448,psi4manual/1.4.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/freq-1.html,5,['access'],['accessed']
Security," recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). psi4.hessian(name[, molecule, return_wfn, func, dertype, irrep])[source]¶; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. Returns:Matrix – Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. Returns:(Matrix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). It’s handy to collect the wavefunction after a frequency; calculation through e, wfn = psi4.frequency(...,; return_wfn=True) as the frequencies can be accessed through; psi4.core.Wavefunction.frequencies(), the Hessian through; psi4.core.Wavefunction.hessian(), and much other computation; info through psi4.core.Wavefunction.frequency_analysis; (note no parentheses). Examples of using this data; structure can be found fd-freq-gradient and; python/vibanalysis. Formatted printing of vibrational; results is available through qcdb.vib.print_vibs(). Results accessible through psi4.core.Wavefunction.frequency_analysis¶. key; description (lbl & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; nd.array(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy;  ; ndarray(ndof) int. TRV; translation/rotation/vibration;  ; ndarray(ndof) str ‘TR’ or ‘V’ or ‘-‘ for partial. gamma; irreducible rep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/freq-1.html:4355,access,accessed,4355,psi4manual/1.3.2/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/freq-1.html,2,['access'],['accessed']
Security," ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:150861,Validat,ValidationError,150861,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security," ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:156663,Validat,ValidationError,156663,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security," ret = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(self: core.Dimension) -> Tuple[int]:; """"""Serializes :class:`~psi4.core.Dimension` to a tuple."""""". if isinstance(self, (tuple, list)):; return tuple(self). irreps = self.n(); ret = []; for i in range(irreps):; ret.append(self[i]); return tuple(ret). def _dimension_iter(dim) -> Iterator[int]:; """"""; Provides an iterator class for the Dimension object. Example; -------; >>> dim = psi4.core.Dimension(...); >>> list(dim). """"""; for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. # General functions for NumPy array manipulation. [docs]; def block_diagonal_array(*args: List[np.ndarray]) -> np.ndarray:; """"""; Convert square NumPy array to a single block diagonal array. Mimic of SciPy's :func:`scipy.linalg.block_diag`. Parameters; ----------; args; Arbitrary number of square arrays. """""". # Validate the input matrices.; dim = 0; for matrix in args:; try:; shape = matrix.shape; dim += shape[0]; except (AttributeError, TypeError):; raise ValidationError(""Cannot construct block diagonal from non-arrays.""); if len(shape) != 2:; raise ValidationError(""Cannot construct block diagonal from non-2D arrays.""); if shape[0] != shape[1]:; raise ValidationError(""Cannot construct block diagonal from non-square arrays.""). # If this is too slow, try a sparse matrix?; block_diag = np.zeros((dim, dim)); start = 0; for matrix in args:; next_block = slice(start, start + matrix.shape[0]); block_diag[next_block, next_block] = matrix; start += matrix.shape[0]. return block_diag. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.p4util.numpy_helper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:17575,Validat,Validate,17575,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],"['Validate', 'ValidationError']"
Security," return self.extract_fragments(reals, ghosts=[]). [docs] def extract_fragments(self, reals, ghosts=[]):; """"""Makes a copy of the molecule, returning a new molecule with; only certain fragment atoms present as either ghost or real atoms; *reals*: The list or int of fragments (1-indexed) that should be present in the molecule as real atoms.; *ghosts*: The list or int of fragments (1-indexed) that should be present in the molecule as ghosts.; (method name in libmints is extract_subsets. This is different; in qcdb because the psi4 input parser tries to process lines with; that term, giving rise to Boost:Python type conlicts.) See usage; at :py:func:`~qcdb.molecule.extract_fragments`. """"""; lreals = []; try:; for idx in reals:; lreals.append(idx - 1); except TypeError:; lreals = [reals - 1]; lghosts = []; try:; for idx in ghosts:; lghosts.append(idx - 1); except TypeError:; lghosts = [ghosts - 1]; if len(lreals) + len(lghosts) > self.nfragments():; raise ValidationError('The sum of real- and ghost-atom subsets is greater than the number of subsets'). subset = self.clone(); subset.deactivate_all_fragments(); for fr in lreals:; subset.set_active_fragment(fr + 1) # the active fragment code subtracts 1; for fr in lghosts:; subset.set_ghost_fragment(fr + 1) # the ghost fragment code subtracts 1. subset.update_geometry(); return subset. # <<< Methods for Construction >>>. [docs] def create_molecule_from_string(self, text):; """"""Given a string *geom* of psi4-style geometry specification; (including newlines to separate lines), builds a new molecule.; Called from constructor. """"""; comment = re.compile(r'^\s*#'); blank = re.compile(r'^\s*$'); bohr = re.compile(r'^\s*units?[\s=]+(bohr|au|a.u.)\s*$', re.IGNORECASE); ang = re.compile(r'^\s*units?[\s=]+(ang|angstrom)\s*$', re.IGNORECASE); orient = re.compile(r'^\s*(no_reorient|noreorient)\s*$', re.IGNORECASE); com = re.compile(r'^\s*(no_com|nocom)\s*$', re.IGNORECASE); symmetry = re.compile(r'^\s*symmetry[\s=]+(\w+)\s*$', re.IGNORECASE)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:12597,Validat,ValidationError,12597,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['Validat'],['ValidationError']
Security," root)); root = root - 1; if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). optstash.restore(); return ciwfn. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); ref_wfn = run_ccenergy('ccsd', **kwargs); elif name == 'eom-cc2':. user_ref = psi4.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for EOM-CC2 is not available.' % user_ref). psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CC2'); ref_wfn = run_ccenergy('cc2', **kwargs); elif name == 'eom-cc3':; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CC3'); ref_wfn = run_ccenergy('cc3', **kwargs). psi4.cchbar(ref_wfn); psi4.cceom(ref_wfn). optstash.restore(); return ref_wfn; # TODO ask if all these cc modules not actually changing wfn. [docs]def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; opts",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:67283,Validat,ValidationError,67283,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security," rvals: The bond lengths (in Angstrom) for which energies are; provided, of length at least 5 and equal to the length of the energies array. :param energies: The energies (Eh) computed at the bond lengths in the rvals list. :param plot_fit: A string describing where to save a plot of the harmonic and anharmonic fits, the; inputted data points, re, r0 and the first few energy levels, if matplotlib; is available. Set to 'screen' to generate an interactive plot on the screen instead. If a filename is; provided, the image type is determined by the extension; see matplotlib for supported file types. :returns: (*dict*) Keys: ""re"", ""r0"", ""we"", ""wexe"", ""nu"", ""ZPVE(harmonic)"", ""ZPVE(anharmonic)"", ""Be"", ""B0"", ""ae"", ""De""; corresponding to the spectroscopic constants in cm-1; """""". angstrom_to_bohr = 1.0 / constants.bohr2angstroms; angstrom_to_meter = 10e-10. # Make sure the input is valid; if len(rvals) != len(energies):; raise ValidationError(""The number of energies must match the number of distances""); npoints = len(rvals); if npoints < 5:; raise ValidationError(""At least 5 data points must be provided to compute anharmonicity""); core.print_out(""\n\nPerforming a fit to %d data points\n"" % npoints). # Sort radii and values first from lowest to highest radius; indices = np.argsort(rvals); rvals = np.array(rvals)[indices]; energies = np.array(energies)[indices]. # Make sure the molecule the user provided is the active one; molecule = mol or core.get_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Find rval of the minimum of energies, check number of points left and right; min_index = np.argmin(energies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:3768,Validat,ValidationError,3768,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,14,['Validat'],['ValidationError']
Security," salc_list.nirrep(); n_salc = salc_list.ncd(). if print_lvl and verbose:; info = f"" Number of atoms is {n_atom}.\n""; if method_allowed_irreps != 0x1:; info += f"" Number of irreps is {n_irrep}.\n""; info += "" Number of {!s}SALCs is {:d}.\n"".format("""" if method_allowed_irreps != 0x1 else ""symmetric "",; n_salc); info += f"" Translations projected? {t_project:d}. Rotations projected? {r_project:d}.\n""; core.print_out(info); logger.info(info). # TODO: Replace with a generator from a stencil to a set of points.; # Diagonal displacements differ between the totally symmetric irrep, compared to all others.; # Off-diagonal displacements are the same for both.; pts_dict = {; 3: {; ""sym_irr"": ((-1, ), (1, )),; ""asym_irr"": ((-1, ), ),; ""off"": ((1, 1), (-1, -1)); },; 5: {; ""sym_irr"": ((-2, ), (-1, ), (1, ), (2, )),; ""asym_irr"": ((-2, ), (-1, )),; ""off"": ((-1, -2), (-2, -1), (-1, -1), (1, -1), (-1, 1), (1, 1), (2, 1), (1, 2)); }; }. try:; disps = pts_dict[stencil_size]; except KeyError:; raise ValidationError(f""FINDIF: Number of points ({stencil_size}) not among {pts_dict.keys()}!""). # Convention: x_pi means x_per_irrep. The ith element is x for irrep i, with Cotton ordering.; salc_indices_pi = [[] for h in range(n_irrep)]. # Validate that we have an irrep matching the user-specified irrep, if any.; try:; salc_indices_pi[freq_irrep_only]; except (TypeError, IndexError):; if freq_irrep_only != -1:; raise ValidationError(; f""FINDIF: 0-indexed Irrep value ({freq_irrep_only}) not in valid range: <{len(salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:9727,Validat,ValidationError,9727,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['Validat'],['ValidationError']
Security," sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:167491,Validat,ValidationError,167491,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security," serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]; def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix, core.Vector]:; """"""; Converts a `NumPy array; <https://numpy.org/doc/stable/reference/arrays.ndarray.html>`_ or list of; NumPy arrays into a |PSIfour| :class:`~psi4.core.Matrix` or; :class:`~psi4.core.Vector` (irrepped if list). Parameters; ----------; self; Matrix or Vector class.; arr; NumPy array or list of arrays to use as the data for a new; :class:`~psi4.core.Matrix` or :class:`~psi4.core.Vector`.; name; Name to give the new :class:`~psi4.core.Matrix`.; dim1; If a single dense NumPy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:2254,Validat,ValidationError,2254,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security," set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description=""AtomicResult return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs] @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs] @validator(""method""); def set_method(cls, method):; return method.lower(). [docs] @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs] def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": {; ""stdout"": True,; },; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs] def compute(self, client: Optional[""FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True; from qcportal.models import KeywordSet, Molecule. # Build the keywords; keyword_id = client.add_keywords([KeywordSet(values=self.keywords)])[0]. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). r = client.add_compute(; ""psi4"", self.method, self.basis, self.driver, keyword_id, [mol]; ); self.result_id = r.ids[0]; # NOTE: The foll",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html:3155,validat,validator,3155,psi4manual/1.6.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html,1,['validat'],['validator']
Security," size. extract_clusters(mol, ghost=True, cluster_size=0)[source]¶; Function to return all subclusters of the molecule mol of; real size cluster_size and all other atoms ghosted if ghost; equals true, all other atoms discarded if ghost is false. If; cluster_size = 0, returns all possible combinations of cluster size. geometry(geom, name='default')[source]¶; Function to create a molecule object of name name; from the geometry in string geom. Permitted for user use but deprecated in; driver in favor of explicit molecule-passing. new_get_attr(self, name)[source]¶; Function to redefine __getattr__ method of molecule class. new_set_attr(self, name, value)[source]¶; Function to redefine __setattr__ method of molecule class. driver_util¶. parse_arbitrary_order(name)[source]¶; Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. parse_cotton_irreps(irrep, point_group)[source]¶; Function to return validated Cotton ordering index for molecular; point_group from string or integer irreducible representation irrep. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. fake_file11(wfn, filename='fake_file11.dat', **kwargs)[source]¶; Function to print a file filename of the old file11 format; from molecule and gradient information in wfn. New in version 0.6: wfn parameter passed explicitly. Returns:None. Parameters:; filename (string) – destination file name for file11 file; wfn (Wavefunction) – set of molecule, gradient from which to generate file11. Examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). interactive¶. run()[source]¶. pubchem¶. class PubChemObj(cid, mf, iupac)[source]¶. getCartesian()[source]¶; Function to return a string of the atom symbol and XYZ; co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:2953,validat,validated,2953,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['validat'],['validated']
Security," so as to match those ; # run normally through OEProp so subject to change; if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). optstash.restore(); return returnvalue. ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+--------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:44838,Validat,ValidationError,44838,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security," special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf(name, **kwargs); returnvalue = PsiMod.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; PsiMod.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); PsiMod.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); PsiMod.dfmp2(); vdh = dfun.c_alpha() * PsiMod.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; PsiMod.dfmp2(); vdh = dfun.c_alpha() * PsiMod.get_variable('MP2 CORRELATION ENERG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:35835,Validat,ValidationError,35835,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security," stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return metadata. def _process_cbs_kwargs(kwargs: Dict) -> CBSMetadata:; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs; kwargs containing the CBS function specification. Returns; -------; cbs_metadata; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:20056,validat,validation,20056,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['validat'],['validation']
Security," str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(psi4.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). psi4.dfmp2grad(); e_dfmp2 = psi4.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if (name.lower() == 'eom-ccsd'):; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); run_ccenergy('ccsd', **k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:34028,Validat,ValidationError,34028,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security, symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = da,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:32513,Validat,ValidationError,32513,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security, symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deform,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:33187,Validat,ValidationError,33187,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security," taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; >>> dim = psi4.core.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.core.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None)[source]¶; Converts a NumPy array or list of; NumPy arrays into a PSI4 Matrix or; Vector (irrepped if list). Parameters:. self (Union[Matrix, Vector]) – Matrix or Vector class.; arr (Union[ndarray, List[ndarray]]) – NumPy array or list of arrays to use as the data for a new; Matrix or Vector.; name (str) – Name to give the new Matrix.; dim1 (Union[List, Tuple, Dimension, None]) – If a single dense NumPy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension])",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/numpy.html:2500,access,accessor,2500,psi4manual/master/numpy.html,https://psicode.org,https://psicode.org/psi4manual/master/numpy.html,4,['access'],['accessor']
Security," taken when using these; views. Views can be created in two ways:; >>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; >>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; >>> dim = psi4.core.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.core.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None)[source]¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters. arr (Union[ndarray, List[ndarray]]) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (Union[List, Tuple, Dimension, None]) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a psi4.core.Dimension object. Returns; Retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/numpy-1.html:2491,access,accessor,2491,psi4manual/1.4.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/numpy-1.html,5,['access'],['accessor']
Security," that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geomet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:70415,Validat,ValidationError,70415,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Validat'],['ValidationError']
Security," the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. opt-multi-dimer-c2h; Multi-fragment opt of C2h metha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:18200,validat,validate,18200,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['validat'],['validate']
Security," the database() function,; where case structure must match the database file. Note; Boolean options can be specified by yes, on, true, or 1; for affirmative and no, off, false, or 0 for negative,; all insensitive to case. Note; Certain convergence and tolerance keywords, of type double (real numbers),; may be specified using either a real number or an integer; and integer X is then; treated as the number of converged decimal digits required. For example, to request; as energy converged to , the user may set the e_convergence; keyword to 0.000001, 1.0e-6, or 6. Alternate Implementations¶; Depending on the reference (RHF, UHF, ROHF) and the integral treatment; (conventional CONV, density-fitted DF, and Cholesky-decomposed CD),; computational methods are sometimes implemented by multiple coders or even; multiple times. Psi4 transparently selects the most efficient; implementation, so one generally needn’t consult this table. However, to; understand the details of what combinations are accessible or what; alternate implementations are available, read on.; Below, “Y” means method available in module, “D” means module is default; for that method, and “” means method not available. HF, DFT, and MP2; default to density-fitted integrals, while all higher methods default to; conventional integrals. Therefore, for a closed-shell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of Psi4¶. name; _; type select [1]. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DETCI; Y;  ;  ;  ;  ;  ; Y;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ; D [2];  ;  ; D [2];  ;  ; D;  ;  ; D;  ;  ;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/notes_c-1.html:1607,access,accessible,1607,psi4manual/1.0.0/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/notes_c-1.html,2,['access'],['accessible']
Security," the irrep. The order of the point group; is also provided (this is equal to the number of characters in an; irrep). """""". def __init__(self, *args):; """"""Constructor"""""". # the order of the group; self.g = 0 # int really self?; # the degeneracy of the irrep; self.degen = 0 # int really self?; # the number of rotations in this irrep; self.PYnrot = 0 # int; # the number of translations in this irrep; self.PYntrans = 0 # int; # true if this irrep has a complex representation; self.PYcomplex = 0; # mulliken symbol for this irrep; self.symb = 0 # str; # mulliken symbol for this irrep w/o special characters; self.csymb = 0 # str; # representation matrices for the symops; self.rep = []. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 4 and \; isinstance(args[0], int) and \; isinstance(args[1], int) and \; isinstance(args[2], basestring) and \; isinstance(args[3], basestring):; self.constructor_order_degen_mulliken(*args); else:; raise ValidationError('IrreducibleRepresentation::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_order_degen_mulliken(self, order, d, lab, clab):; """"""This constructor takes as arguments the *order* of the point; group, the degeneracy *d* of the irrep, and the Mulliken symbol of; the irrep. The Mulliken symbol is copied internally. """"""; self.init(order, d, lab, clab). [docs] def init(self, order, d, lab, clab):; """"""Initialize the order, degeneracy, and Mulliken symbol of the; irrep. """"""; self.g = order; self.degen = d; self.PYntrans = 0; self.PYnrot = 0; self.PYcomplex = 0; self.symb = lab; self.csymb = clab. if order > 0:; for i in range(order):; self.rep.append(SymRep(d)). # IrreducibleRepresentation(const IrreducibleRepresentation&);; # IrreducibleRepresentation& operator=(const IrreducibleRepresentation&);. # <<< Simple Methods for Basic IrreducibleRepresentation Information >>>. [docs] def order(self):; """"""Returns the order of the group",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:16856,Validat,ValidationError,16856,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security," the private external_potentials list. reset_occupation(self: psi4.core.HF) → None¶; docstring. rotate_orbitals(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None¶; docstring. save_density_and_energy(self: psi4.core.HF) → None¶; docstring. scf_type(self: psi4.core.HF) → str¶; Return the value of scf_type used in the SCF computation. semicanonicalize(self: psi4.core.HF) → None¶; Semicanonicalizes the orbitals for ROHF. set_energies(self: psi4.core.HF, arg0: str, arg1: float) → None¶; docstring. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix]) → None¶; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; HF. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:11234,Validat,ValidationError,11234,psi4manual/1.7.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html,1,['Validat'],['ValidationError']
Security," the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """"""# to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """"""# has produced a number of input files (FREQ-*.in) for individual components\n""""""; instructionsO += """"""# and a single input file (FREQ-master.in) with a frequency(mode='reap') command.\n""""""; instructionsO += """"""# These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """"""# rather than normal input. Follow the instructions below (repeated in FREQ-master.in)\n""""""; instructionsO += """"""# to continue.\n#\n""""""; instructionsO += """"""# Alternatively, a single-job execution of the hessian may be accessed through\n""""""; instructionsO += """"""# the frequency wrapper option mode='continuous'.\n#\n""""""; core.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this frequency computation.\n#\n""""""; instructionsM += """"""# (1) Run all of the FREQ-*.in input files on any variety of computer architecture.\n""""""; instructionsM += """"""# The output file names must be as given below (these are the defaults when executed\n""""""; instructionsM += """"""# as `psi4 FREQ-1.in`, etc.).\n#\n""""""; for rgt in range(ndisp):; pre = 'FREQ-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# FREQ-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the frequency computation in its output file.\n#\n""""""; instructionsM += """"""# psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:76133,access,accessed,76133,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['access'],['accessed']
Security," the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """"""# to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """"""# has produced a number of input files (FREQ-*.in) for individual components\n""""""; instructionsO += """"""# and a single input file (FREQ-master.in) with a frequency(mode='reap') command.\n""""""; instructionsO += """"""# These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """"""# rather than normal input. Follow the instructions below (repeated in FREQ-master.in)\n""""""; instructionsO += """"""# to continue.\n#\n""""""; instructionsO += """"""# Alternatively, a single-job execution of the hessian may be accessed through\n""""""; instructionsO += """"""# the frequency wrapper option mode='continuous'.\n#\n""""""; psi4.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this frequency computation.\n#\n""""""; instructionsM += """"""# (1) Run all of the FREQ-*.in input files on any variety of computer architecture.\n""""""; instructionsM += """"""# The output file names must be as given below (these are the defaults when executed\n""""""; instructionsM += """"""# as `psi4 FREQ-1.in`, etc.).\n#\n""""""; for rgt in range(ndisp):; pre = 'FREQ-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# FREQ-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the frequency computation in its output file.\n#\n""""""; instructionsM += """"""# psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:74151,access,accessed,74151,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['access'],['accessed']
Security," the syntax correct? If so, process the line; if matchobj:; result += process_option(spaces, module, matchobj.group(1), matchobj.group(2), command); # Reset the string; command = """"; else:; bad_option_syntax(command); return result. def process_from_file_command(matchobj):; """"""Function that process a match of ``from_file`` in molecule block.""""""; string = matchobj.group(2); mol = core.mol_from_file(string, 1); tempmol = [line for line in mol.split('\n') if line.strip() != '']; mol2 = set(tempmol); mol = """"; for i in mol2:; mol += i; mol += ""\n""; return mol. def process_molecule_command(matchobj):; """"""Function to process match of ``molecule name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); geometry = matchobj.group(3); from_filere = re.compile(r'^(\s*from_file\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE); geometry = from_filere.sub(process_from_file_command, geometry); molecule = spaces. if name != """":; if not name.isidentifier():; raise ValidationError('Molecule name not valid Python identifier: ' + name). if name != """":; molecule += '%s = ' % (name). molecule += 'geometry(""""""%s""""""' % (geometry); if name != """":; molecule += ',""%s""' % (name). molecule += "")\n""; molecule += '%score.IO.set_default_namespace(""%s"")' % (spaces, name). return molecule. def process_literal_blocks(matchobj):; """"""Function to process match of ``literals_psi4_yo-...``.""""""; return literals[matchobj.group(1)]. def process_cfour_command(matchobj):; """"""Function to process match of ``cfour name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); cfourblock = matchobj.group(3). literalkey = str(uuid.uuid4())[:8]; literals[literalkey] = cfourblock; return ""%score.set_global_option(\""%s\"", \""\""\""%s\n\""\""\"")\n"" % \; (spaces, 'LITERAL_CFOUR', 'literals_psi4_yo-' + literalkey). def process_extract_command(matchobj):; """"""Function to process match of ``extract_subsets``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); result = matchobj.group(0); result +=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/inputparser.html:6191,Validat,ValidationError,6191,psi4manual/1.3.2/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/inputparser.html,8,['Validat'],['ValidationError']
Security," title=title, xtitle=axis,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def load_saptdata_frombfdb(self, sset='default',; pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True): # pythonpath=None; """"""This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. """"""; saptpackage = OrderedDict(); for db, odb in self.dbdict.items():; modname = 'sapt_' + odb.dbse; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). try:; saptdata = getattr(datamodule, 'DATA'); except AttributeError:; raise ValidationError(""SAPT punt module does not contain DATA"" + str(modname)); saptmc = saptdata['SAPT MODELCHEM']. dbix = self.dbdict.keys().index(db); for rxn, orxn in odb.hrxn.iteritems():; lss = self.sset[sset][dbix]; if lss is not None:; if rxn in odb.sset[lss]:; dbrxn = orxn.dbrxn; try:; elst = saptdata['SAPT ELST ENERGY'][dbrxn]; exch = saptdata['SAPT EXCH ENERGY'][dbrxn]; ind = saptdata['SAPT IND ENERGY'][dbrxn]; disp = saptdata['SAPT DISP ENERGY'][dbrxn]; except (KeyError, AttributeError):; print(""""""Warning: DATA['SAPT * ENERGY'] missing for reaction %s"""""" % (dbrxn)); if failoninc:; break; else:; if not all([elst, ind, disp]): # exch sometimes physically zero; print(""""""Warning: DATA['SAPT * ENERGY'] missing piece for reaction %s: %s"""""" % (dbrxn, [elst, exch, ind, disp])); if failoninc:; break; saptpackage[dbrxn] = {'mc': saptmc,; 'elst': elst,; 'exch': exch,; 'ind': ind,; 'disp': disp}; return saptpackage. [docs] def plot_ternary(self, sset='default', labeled=True,; pythonpath='/Users/loriab/linux/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:65456,Validat,ValidationError,65456,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security," to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI mode:; 1psi4.set_memory(int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:3818,access,access,3818,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,2,['access'],['access']
Security," to SI units (Cm) conversion factor for dipoles ; dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:3820,access,access,3820,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,2,['access'],['access']
Security," to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; """"""Function to write wavefunction information in molden; format to *filename*. """"""; m = PsiMod.MoldenWriter(PsiMod.reference_wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. point_group = PsiMod.get_active_molecule().schoenflies_symbol().lower(); irreducible_representation = str(irrep).lower(). try:; return cotton[point_group][irreducible_representation]; except KeyError:; raise ValidationError(""Irrep \'%s\' not valid for point group \'%s\'."" % (str(irrep), point_group)). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta3] » ; Module code ». © Copyright 2012, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:52997,Validat,ValidationError,52997,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Validat'],['ValidationError']
Security," to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:29745,Validat,Validated,29745,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['Validated']
Security," to compare two FCHK files. # an older format description can be found here; # http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; # It lists more fields (logical, character) that are not included in this; # test function. They should be covered by the string comparison.; # This function is only meant to work with PSI4's FCHK files.; #; # :param expected: reference FCHK file name; # :param computed: computed FCHK file name; # :param digits: tolerance for high accuracy fields -- 1.e-8 or 1.e-9 suitable; # :param label: string labelling the test; # """""". fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = digits; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and not ""N="" in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html:3397,Validat,ValidationError,3397,psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/fchk.html,2,['Validat'],['ValidationError']
Security," to stash these since only read, never reset; cast = False; if core.has_option_changed('SCF', 'BASIS_GUESS'):; cast = core.get_option('SCF', 'BASIS_GUESS'); if p4util.yes.match(str(cast)):; cast = True; elif p4util.no.match(str(cast)):; cast = False. if cast:. # A user can set ""BASIS_GUESS"" to True and we default to 3-21G; if cast is True:; guessbasis = '3-21G'; else:; guessbasis = cast; core.set_global_option('BASIS', guessbasis). castdf = 'DF' in core.get_global_option('SCF_TYPE'). if core.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, (unicode, str)):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:31609,Validat,ValidationError,31609,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security," to the gradient in GRD, the result of which; is printed below and passed on to Optking.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-scf Gradient Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ... Irrep: 1 Size: 4 x 3. 1 2 3. 1 0.0000000 -0.0122978 0.0000000; 2 -0.0051192 0.0040993 -0.0088667; 3 -0.0051192 0.0040993 0.0088667; 4 0.0102384 0.0040993 0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; Matrix object through; psi4.get_gradient().; Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the PSI4 input file.; 1; 2energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:23061,access,accessed,23061,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['access'],['accessed']
Security," under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import re; import sys; import uuid; import warnings; from collections import Counter; from itertools import product; from pathlib import Path; from tempfile import NamedTemporaryFile; from typing import Any, Dict, Union. import numpy as np. import qcelemental as qcel; from psi4 import core; from psi4.driver import qcdb. from . import optproc; from .exceptions import TestComparisonError, ValidationError, UpgradeHelper. ## Python basis helps. @staticmethod; def _pybuild_basis(mol,; key=None,; target=None,; fitrole='ORBITAL',; other=None,; puream=-1,; return_atomlist=False,; *,; quiet=False):; if key == 'ORBITAL':; key = 'BASIS'. def _resolve_target(key, target):; """"""Figure out exactly what basis set was intended by (key, target); """"""; horde = qcdb.libmintsbasisset.basishorde; if not target:; if not key:; key = 'BASIS'; target = core.get_global_option(key). if target in horde:; return horde[target]; return target. # Figure out what exactly was meant by 'target'.; resolved_target = _resolve_target(key, target). # resolved_target needs to be either a string or function for pyconstuct.; # if a string, they search for a gbs file with that name.; # if a function, it needs to apply a basis to each atom. bs, basisdict = qcdb.BasisSet.pyconstruct(mol.to_dict(),; key,; resolved_target,; fitrole,; other,; return_dict=True,; return_atomlist=return_atomlist). if return_atomlist:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:1535,Validat,ValidationError,1535,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security," under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import re; import sys; import uuid; import warnings; from collections import Counter; from itertools import product; from pathlib import Path; from tempfile import NamedTemporaryFile; from typing import Any, Dict, Union. import numpy as np. import qcelemental as qcel; from psi4 import core; from psi4.driver import qcdb. from . import optproc; from .exceptions import TestComparisonError, ValidationError, UpgradeHelper. ## Python basis helps. @staticmethod; def _pybuild_basis(mol,; key=None,; target=None,; fitrole='ORBITAL',; other=None,; puream=-1,; return_atomlist=False,; quiet=False):; if key == 'ORBITAL':; key = 'BASIS'. def _resolve_target(key, target):; """"""Figure out exactly what basis set was intended by (key, target); """"""; horde = qcdb.libmintsbasisset.basishorde; if not target:; if not key:; key = 'BASIS'; target = core.get_global_option(key). if target in horde:; return horde[target]; return target. # Figure out what exactly was meant by 'target'.; resolved_target = _resolve_target(key, target). # resolved_target needs to be either a string or function for pyconstuct.; # if a string, they search for a gbs file with that name.; # if a function, it needs to apply a basis to each atom. bs, basisdict = qcdb.BasisSet.pyconstruct(mol.to_dict(),; key,; resolved_target,; fitrole,; other,; return_dict=True,; return_atomlist=return_atomlist). if return_atomlist:; at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:1535,Validat,ValidationError,1535,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security," up dispersion correction parameters in whatever form needed.; When *mode* is 'dftd3', returns a string suitable for writing to ./dftd3_parameters; to calculuate the correction at *dashlvl* with the default parameters for functional; *func*. When *mode* is 'psi4', returns a tuple of arguments suitable for building; a Dispersion object with *dashlvl* parameters for functional *func*. There are four computational *dashlvl* choices. 'd2p4' calls the -D2 correction; within psi4 (hence, faked for mode='dftd3'). The other three, 'd2gr', 'd3zero',; and 'd3bj' call the three dftd3 modes of operation (corresponding to -old, -zero, -bj).; Additionally, there are three aliased *dashlvl* choices since the aliases in dash_alias; above are imposed. """"""; # Validate input arguments; dashlvl = dashlvl.lower(); dashlvleff = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl. func = func.lower(); if func not in dashcoeff[dashlvleff].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)). # Return strings for dftd3 program parameter file; # d2p4: s6 sr6=1.1 s8=0.0 a2=None alpha6=20.0 version=2; # d2gr: s6 sr6=1.1 s8=0.0 a2=None alpha6 version=2; # d3zero: s6 sr6 s8 a2=None alpha6 version=3; # d3bj: s6 a1 s8 a2 alpha6=None version=4; if mode.lower() == 'dftd3':; if dashlvleff.lower() == 'd2p4':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; 1.1, 0.0, 0.0, 20.0, 2); elif dashlvleff.lower() == 'd2gr':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; 1.1, 0.0, 0.0,; dashcoeff[dashlvleff][func]['alpha6'],; 2); elif dashlvleff.lower() == 'd3zero':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['sr6'],; dashcoeff[dashlvleff][func]['s8'],; 1.0,; dashcoeff[dashlvleff][func]['alpha6'],; 3); elif dashlvleff.lower() == 'd3bj':; return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/dashparam.html:9055,Validat,ValidationError,9055,psi4manual/4.0b3/_modules/dashparam.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/dashparam.html,3,['Validat'],['ValidationError']
Security," up dispersion correction parameters in whatever form needed.; When *mode* is 'dftd3', returns a string suitable for writing to ./dftd3_parameters; to calculuate the correction at *dashlvl* with the default parameters for functional; *func*. When *mode* is 'psi4', returns a tuple of arguments suitable for building; a Dispersion object with *dashlvl* parameters for functional *func*. There are four computational *dashlvl* choices. 'd2p4' calls the -D2 correction; within psi4 (hence, faked for mode='dftd3'). The other three, 'd2gr', 'd3zero',; and 'd3bj' call the three dftd3 modes of operation (corresponding to -old, -zero, -bj).; Additionally, there are three aliased *dashlvl* choices since the aliases in dash_alias; above are imposed. """"""; # Validate input arguments; dashlvl = dashlvl.lower(); dashlvleff = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl. func = func.lower(); if func not in dashcoeff[dashlvleff].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)). # Return strings for dftd3 program parameter file; # s6 rs6 s18 rs8 alpha6 version; # d2p4: s6 sr6=1.1 s8=0.0 a2=None alpha6=20.0 version=2; # d2gr: s6 sr6=1.1 s8=0.0 a2=None alpha6 version=2; # d3zero: s6 sr6 s8 a2=None alpha6 version=3; # d3bj: s6 a1 s8 a2 alpha6=None version=4; # d3mzero: s6 sr6 s8 beta alpha6=14.0 version=5; # d3mbj: s6 a1 s8 a2 alpha6=None version=6. if mode.lower() == 'dftd3':; if dashlvleff.lower() == 'd2p4':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; 1.1, 0.0, 0.0, 20.0, 2); elif dashlvleff.lower() == 'd2gr':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; 1.1, 0.0, 0.0,; dashcoeff[dashlvleff][func]['alpha6'],; 2); elif dashlvleff.lower() == 'd3zero':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; dashcoeff[dashlvleff][func]['sr6'],; da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html:11375,Validat,ValidationError,11375,psi4manual/1.0.0/_modules/qcdb/dashparam.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html,1,['Validat'],['ValidationError']
Security," upon activating through ``set integral_package erd``, known failures will be caught and halted, but perhaps other types not tested and identified will give *wrong* answers. Consider this your warning.""); endif(). ############################ Options: Build How? #############################; include(psi4OptionsTools); option_with_print(BUILD_SHARED_LIBS ""Build internally built Psi4 add-on libraries as shared, not static"" OFF); option_with_print(ENABLE_OPENMP ""Enables OpenMP parallelization"" ON); option_with_print(ENABLE_AUTO_BLAS ""Enables CMake to auto-detect BLAS"" ON); option_with_print(ENABLE_AUTO_LAPACK ""Enables CMake to auto-detect LAPACK"" ON); option_with_print(ENABLE_PLUGIN_TESTING ""Test the plugin templates build and run"" OFF); option_with_flags(ENABLE_XHOST ""Enables processor-specific optimization"" ON; ""-xHost"" ""-march=native""); option_with_flags(ENABLE_CODE_COVERAGE ""Enables details on code coverage"" OFF; ""-ftest-coverage""); option_with_flags(ENABLE_BOUNDS_CHECK ""Enables bounds check in Fortran"" OFF; ""-ftrapuv -check all -fpstkchk"" ""-fcheck=all"" ""-fbounds-check -fcheck-array-temporaries""); option_with_flags(ENABLE_ASAN ""Enables address sanitizer"" OFF; ""-fsanitize=address"" ""-fno-omit-frame-pointer""); option_with_flags(ENABLE_TSAN ""Enables thread sanitizer"" OFF; ""-fsanitize=thread"" ""-fno-omit-frame-pointer -pie""); option_with_flags(ENABLE_UBSAN ""Enables undefined behavior sanitizer"" OFF; ""-fsanitize=undefined"" ""-fno-omit-frame-pointer""); option_with_default(MAX_AM_ERI ""Maximum angular momentum for integrals"" 5); option_with_default(CMAKE_BUILD_TYPE ""Build type (Release or Debug)"" Release); option_with_default(FC_SYMBOL ""The type of Fortran name mangling"" 2); option_with_default(BUILD_FPIC ""Compile static libraries with position independent code"" ON). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:13806,sanitiz,sanitizer,13806,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,6,['sanitiz'],['sanitizer']
Security," used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:35411,validat,validator,35411,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,3,['validat'],['validator']
Security," used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; from typing import Any, Dict, Optional, Tuple, Union. from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. class BaseComputer(qcel.models.ProtoModel):; @abc.abstractmethod; def compute(self):; pass. @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., description=""The molecule to use in the computation.""); basis: str = Field(..., description=""The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html:1308,validat,validator,1308,psi4manual/1.6.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/task_base.html,1,['validat'],['validator']
Security," used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(""Wrong number of basis sets supplied to scf_xtpl: %d"" % nbasis); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(""Wrong number of basis sets supplied to corl_xtpl: %d"" % nbasis); else:; raise ValidationError(""Stage treatment must be 'corl' or 'scf', not '%s'"" % xtpl_type). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for item in cbs_metadata:; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(""Stage {:d} doesn't have defined level of theory!"".format(cbs_metadata.index(item))); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(""Stage {:d} doesn't have defined basis sets!"".format(cbs_metadata.index(item))); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:29242,Validat,Validated,29242,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['Validated']
Security," using a reference from the SCF module. """"""; # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). PsiMod.psimrcc(); return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP2 calculation. """"""; optstash = OptionsState(; ['DF_BASIS_MP2']). molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Dimer DFMP2'); PsiMod.print_out('\n'); e_dimer_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer A DFMP2'); PsiMod.print_out('\n');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:43821,Validat,ValidationError,43821,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security," using a reference from the SCF module. """"""; # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). psi4.psimrcc(); return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2']). molecule = psi4.get_active_molecule(); molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Dimer DFMP2'); psi4.print_out('\n'); e_dimer_mp2 = psi4.dfmp2(); psi4.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_A'); psi4.print_out('\n'); p4util.banner('Monomer A HF'); psi4.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Monomer A DFMP2'); psi4.print_out('\n'); e_monom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:46092,Validat,ValidationError,46092,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security," vectors. Notes; -----; This is a generalized cg solver that can also take advantage of solving multiple RHS's simultaneously when; it is advantageous to do so. """""". tstart = time.time(); if printlvl:; core.print_out(""\n -----------------------------------------------------\n""); core.print_out("" "" + ""Generalized CG Solver"".center(52) + ""\n""); core.print_out("" "" + ""by Daniel. G. A. Smith"".center(52) + ""\n""); core.print_out("" -----------------------------------------------------\n""); core.print_out("" Maxiter = %11d\n"" % maxiter); core.print_out("" Convergence = %11.3E\n"" % rcond); core.print_out("" Number of equations = %11ld\n\n"" % len(rhs_vec)); core.print_out("" %4s %14s %12s %6s %6s\n"" % (""Iter"", ""Residual RMS"", ""Max RMS"", ""Remain"", ""Time [s]"")); core.print_out("" -----------------------------------------------------\n""). nrhs = len(rhs_vec); active_mask = [True for x in range(nrhs)]. # Start function; if guess is None:; x_vec = preconditioner(rhs_vec, active_mask); else:; if len(guess) != len(rhs_vec):; raise ValidationError(""CG Solver: Guess vector length does not match RHS vector length.""); x_vec = [x.clone() for x in guess]. Ax_vec = hx_function(x_vec, active_mask). # Set it up; r_vec = [] # Residual vectors; for x in range(nrhs):; tmp_r = rhs_vec[x].clone(); tmp_r.axpy(-1.0, Ax_vec[x]); r_vec.append(tmp_r). z_vec = preconditioner(r_vec, active_mask); p_vec = [x.clone() for x in z_vec]. # First RMS; grad_dot = [x.sum_of_squares() for x in rhs_vec]. resid = [(r_vec[x].sum_of_squares() / grad_dot[x])**0.5 for x in range(nrhs)]. if printer:; resid = printer(0, x_vec, r_vec); elif printlvl:; # core.print_out(' CG Iteration Guess: Rel. RMS = %1.5e\n' % np.mean(resid)); core.print_out("" %5s %14.3e %12.3e %7d %9d\n"" %; (""Guess"", np.mean(resid), np.max(resid), len(z_vec), time.time() - tstart)). rms = np.mean(resid); rz_old = [0.0 for x in range(nrhs)]; alpha = [0.0 for x in range(nrhs)]; active = np.where(active_mask)[0]. # CG iterations; for rot_iter in range(maxiter):.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:3700,Validat,ValidationError,3700,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,4,['Validat'],['ValidationError']
Security," view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irrepped Psi4 objects to diagonally blocked dense arrays if; `True`. Returns a list of arrays otherwise. Returns; -------; ~numpy.ndarray or ~typing.List[~numpy.ndarray]; Returns a single or list of NumPy arrays depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. matrix_views = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return matrix_views. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinstance(matrix, core.Matrix):; ret_type = '2D'; else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % type(matrix)). dim1 = []; dim2 = []; for h in matrix_views:; # Ignore zero dim irreps; if 0 in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1, arr in zip(dim1, matrix_views):; if d1 == 0: continue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object.; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.ni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:7387,Validat,ValidationError,7387,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],['ValidationError']
Security," x 3. 1 2 3. 1 0.0000000 -0.0122978 0.0000000; 2 -0.0051192 0.0040993 -0.0088667; 3 -0.0051192 0.0040993 0.0088667; 4 0.0102384 0.0040993 0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; Matrix object through; psi4.core.get_gradient().; Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the PSI4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documented below. psi4.driver.procrouting.interface_cfour.run_cfour(name[, keep, path])[source]¶; Function that prepares environment and input files; for a calculation calling Stanton and Gauss’s CFO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:22564,Access,Accessible,22564,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,5,['Access'],['Accessible']
Security," x 3. 1 2 3. 1 0.0000000 -0.0122978 0.0000000; 2 -0.0051192 0.0040993 -0.0088667; 3 -0.0051192 0.0040993 0.0088667; 4 0.0102384 0.0040993 0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; psi4.Matrix object through; psi4.get_gradient().; Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the Psi4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documented below. run_cfour(name[, keep, path])[source]¶; Function that prepares environment and input files; for a calculation calling Stanton and Gauss’s CFOUR code.; Also processes results bac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:22629,Access,Accessible,22629,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['Access'],['Accessible']
Security," x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs) -> core.Matrix:; """"""Chains dot products together from a series of Psi4 Matrix classes. Uses :func:`~psi4.core.doublet`. Parameters; ----------; args; Arbitrary number of :class:`~psi4.core.Matrix` arguments to be; multiplied.; trans; Optional iterable of booleans of length number of `args` to designate; transposes, if any. """"""; trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irrepped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_seri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:13936,Validat,ValidationError,13936,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security," {""poles"": np.ndarray, ""residues"": np.ndarray}}. Notes; -----; * Conversion of the broadening parameter :math:`\gamma`.; The lineshape functions are formulated as functions of the angular frequency :math:`\omega`.; When converting to other physical quantities, the broadening parameter has to be modified accordingly.; If :math:`\gamma_{\omega}` is the chosen broadening parameter then:. - Wavelength: :math:`gamma_{\lambda} = \frac{\lambda_{ij}^{2}}{2\pi c}\gamma_{\omega}`; - Frequency: :math:`gamma_{\nu} = \frac{\gamma_{\omega}}{2\pi}`; - Energy: :math:`gamma_{E} = \gamma_{\omega}\hbar`. References; ----------; A. Rizzo, S. Coriani, K. Ruud, ""Response Function Theory Computational Approaches to Linear and Nonlinear Optical Spectroscopy"". In Computational Strategies for Spectroscopy.; https://doi.org/10.1002/9781118008720.ch2; """""". # Transmute inputs to np.ndarray; if isinstance(poles, list):; poles = np.array(poles); if isinstance(residues, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:10100,Validat,Validate,10100,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,4,['Validat'],['Validate']
Security,"  .  · ; 1.3.2;  · . PSI4. Module code. Source code for psi4.driver.procrouting.libcubeprop.cubeprop; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2019 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os. from psi4 import core. from psi4.driver.p4util.exceptions import ValidationError. def cubeprop_compute_properties(self):; """"""Filesystem wrapper for CubeProperties::raw_compute_properties."""""". filepath = core.get_global_option(""CUBEPROP_FILEPATH""). # Is filepath a valid directory?; if not os.path.isdir(os.path.abspath(os.path.expandvars(filepath))):; raise ValidationError(""""""Filepath ""{}"" is not valid. Please create this directory."""""".format(filepath)). geomfile = filepath + os.sep + 'geom.xyz'; xyz = self.basisset().molecule().to_string(dtype='xyz', units='Angstrom'); with open(geomfile, 'w') as fh:; fh.write(xyz). self.raw_compute_properties(). core.CubeProperties.compute_properties = cubeprop_compute_properties. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.3.2;  · . PSI4. Module code. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/libcubeprop/cubeprop.html:1199,Validat,ValidationError,1199,psi4manual/1.3.2/_modules/psi4/driver/procrouting/libcubeprop/cubeprop.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/libcubeprop/cubeprop.html,2,['Validat'],['ValidationError']
Security,"  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC; Y; D; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ; Y; Y;  ;  ;  ;  ;  ;  ;  ; D;  ;  ;  ;  ;  ;  ;  . ccsd(t); CC_TYPE. CCENERGY; D;  ;  ; D;  ;  ; D;  ;  ;  ;  ;  ; D;  ;  ;  ;  ;  . DETCI;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC; Y; D; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ; Y; Y;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . ccsd(at); CC_TYPE. CCENERGY; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DETCI;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ; D; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . cisd; CI_TYPE. CCENERGY;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DETCI; Y;  ;  ;  ;  ;  ; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . Footnotes. [1]Algorithm type selection keyword below. Values to the right: conventional CONV (here abbreviated CV), density-fitted DF, and Cholesky-decomposed CD. [2](1, 2) Also available for KS reference. [3](1, 2) Conditions have no default module (computationally inefficient) and can only be accessed by specifying QC_MODULE. Table Of Contents. Notes on Options; Alternate Implementations. Previous topic; Theoretical Methods: SCF to FCI; Next topic; HF: Hartree–Fock Theory. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/notes_c-1.html:5956,access,accessed,5956,psi4manual/1.0.0/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/notes_c-1.html,2,['access'],['accessed']
Security," ‘’, 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. get_memory()[source]¶; Function to return the total memory allocation. get_num_threads()[source]¶; Function to return the number of threads to parallelize across. set_memory(bytes)[source]¶; Function to reset the total memory allocation. set_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. run_mp2_5(name, **kwargs)[source]¶; Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. Psi variables:. MP2.5 TOTAL ENERGY; MP2.5 CORRELATION ENERGY. >>> energy('mp2.5'). run_plugin_omega(name, **kwargs)[source]¶; Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish’s omega plugin.; >>> energy('plugin_omega'). sherrillgroup_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). Table Of Contents. Python Driver; input; pubchem; psiexceptions; frac; molutil; proc; procutil; driver; physconst; wrappers; qmmm; functional; text; util; aliases. Previous topic; PRINT; Next topic; PsiMod: Linking C++ and Python; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:23157,access,access,23157,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['access'],['access']
Security,""" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); mints.set_rel_basisset(rel_bas). mints.set_print(1); mints.integrals(). def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = core.get_global_option('SCF_TYPE'); supp_jk_type = ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); elif core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); else:; if core.get_global_option('SCF_TYPE') != ""DISK_DF"":; raise ValidationError("" %s requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation."" % name). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html:3957,Validat,ValidationError,3957,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,2,['Validat'],['ValidationError']
Security,""""""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); psi4.set_global_option('BASIS', basis). ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); psi4.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:57715,Sanitiz,Sanitize,57715,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Sanitiz'],['Sanitize']
Security,""""""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if x",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:1522,Validat,ValidationError,1522,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,3,['Validat'],['ValidationError']
Security,"""""""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]; def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When True, do not print to the output file. Returns; -------; int; Number of bytes of memory set. Raises; ------; ValidationError; When <500MiB or disallowed type or misformatted. Examples; --------. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. >>> # Good examples; >>> psi4.set_memory(800000000) # 800000000; >>> psi4.set_memory(2004088624.9) # 2004088624; >>> psi4.set_memory(1.0e9) # 1000000000; >>> psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_mem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:4206,Validat,ValidationError,4206,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,2,['Validat'],['ValidationError']
Security,"""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]; def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.driver.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_cbs_helper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html:21961,Validat,ValidationError,21961,psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"""""""; modobj = None; for per in list(all_casings(module)):; try:; modobj = __import__(per); except ImportError:; pass; else:; break. return modobj. [docs]def extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False):; """"""Function to examine file *sowout* from a sow/reap distributed job; for formatted line with electronic energy information about index; *sownum* to be used for construction of *quantity* computations as; directed by master input file with *linkage* kwarg. When file *sowout*; is missing or incomplete files, function will either return zero; (*allvital* is ``False``) or terminate (*allvital* is ``True``) since; some sow/reap procedures can produce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.split(); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); freagent.close(); return E. Quick search. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:7167,Validat,ValidationError,7167,psi4manual/4.0b5/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for props and freqs; if ptype in [""properties"", ""frequency""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:66419,Sanitiz,Sanitize,66419,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Sanitiz'],['Sanitize']
Security,"""""""Compute the magnitude of vector *v*.""""""; return math.sqrt(sum(v[i] * v[i] for i in range(len(v)))). [docs]def add(v, u):; """"""Compute sum of vectors *v* and *u*.""""""; return [u[i] + v[i] for i in range(len(v))]. [docs]def sub(v, u):; """"""Compute difference of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def normalize(v):; """"""Compute normalized vector *v*.""""""; vmag = norm(v); return [v[i] / vmag for i in range(len(v))]. [docs]def distance(v, u):; """"""Compute the distance between points defined by vectors *v* and *u*.""""""; return norm(sub(v, u)). [docs]def cross(v, u):; """"""Compute cross product of length 3 vectors *v* and *u*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('cross() only defined for vectors of length 3\n'); return [v[1] * u[2] - v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp_unit(axis, perpendicular); third_axis = scale(third_axis, norm(perpendicular)). result = add(parallel, add(scale(perpendicular, math.cos(theta)), scale(third_axis, math.sin(theta)))); for item in range(len(result)):; if math.fabs(result[item]) < ZERO:; result[item] = 0.0; return result. [docs]def perp_unit(u, v):; """"""Compute unit vector perpendicular to length 3 vectors *u* and *v*.""""""; if len(u) != 3 or le",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/vecutil.html:1354,Validat,ValidationError,1354,psi4manual/4.0b3/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/vecutil.html,3,['Validat'],['ValidationError']
Security,"""""""Find computational molecular point group, user can override; this with the ""symmetry"" keyword. Result is highest D2h subgroup; attendant on molecule and allowed by the user. """"""; pg = self.find_highest_point_group(tol) # D2h subgroup; user = self.symmetry_from_input(). if user is not None:; # Need to handle the cases that the user only provides C2, C2v, C2h, Cs.; # These point groups need directionality. # Did the user provide directionality? If they did, the last letter would be x, y, or z; # Directionality given, assume the user is smart enough to know what they're doing.; user_specified_direction = True if user[-1] in ['X', 'x', 'Y', 'y', 'Z', 'z'] else False. if self.symmetry_from_input() != pg.symbol():; user = PointGroup(self.symmetry_from_input()). if user_specified_direction:; # Assume the user knows what they're doing.; # Make sure user is subgroup of pg; if (pg.bits() & user.bits()) != user.bits():; raise ValidationError(""Molecule::find_point_group: User specified point group (%s) is not a subgroup of the highest detected point group (%s)"" % (PointGroup.bits_to_full_name(user.bits()), PointGroup.bits_to_full_name(pg.bits()))). else:; similars, count = similar(user.bits()); found = False; for typ in range(count):; # If what the user specified and the similar type; # matches the full point group we've got a match; if (similars[typ] & pg.bits()) == similars[typ]:; found = True; break. if found:; # Construct a point group object using the found similar; user = PointGroup(similars[typ]). else:; raise ValidationError(""Molecule::find_point_group: User specified point group (%s) is not a subgroup of the highest detected point group (%s). If this is because the symmetry increased, try to start the calculation again from the last geometry, after checking any symmetry-dependent input, such as DOCC."" % (PointGroup.bits_to_full_name(user.bits()), PointGroup.bits_to_full_name(pg.bits()))). # If we make it here, what the user specified is good.; pg = user. return pg. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:73851,Validat,ValidationError,73851,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"""""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:4488,Validat,ValidationError,4488,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_uni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:13815,Validat,ValidationError,13815,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"""""; if name == 'cphf':; psi4.set_global_option('MODULE', 'RCPHF'); if name == 'cis':; psi4.set_global_option('MODULE', 'RCIS'); if name == 'tdhf':; psi4.set_global_option('MODULE', 'RTDHF'); if name == 'cpks':; psi4.set_global_option('MODULE', 'RCPKS'); if name == 'tda':; psi4.set_global_option('MODULE', 'RTDA'); if name == 'tddft':; psi4.set_global_option('MODULE', 'RTDDFT'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). libfock_wfn = psi4.libfock(ref_wfn); libfock_wfn.compute_energy(); return libfock_wfn. [docs]def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', psi4.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = psi4.new_wavefunction(mcscf_molecule, psi4.get_global_option('BASIS')). return psi4.mcscf(new_wfn). [docs]def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']) # yes, this really must be global, not local to SCF. # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if psi4.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). dfmp2_wfn = psi4.dfmp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:50585,Validat,ValidationError,50585,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs] def charge(self):; """"""The ""atomic charge"" of the current atom (for SAD purposes).""""""; return self.PYcharge. [docs] def mass(self):; """"""The atomic mass of the current atom.""""""; return self.PYmass. [docs] def symbol(self):; """"""The atomic symbol.""""""; return self.PYsymbol. [docs] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def set_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basissets(self):; """"""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:10215,Validat,ValidationError,10215,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['Validat'],['ValidationError']
Security,"""""; warnings.warn(; ""Using `psi4.driver.p4util.csx2endict` is deprecated (silently in 1.2), and in 1.3 it will stop working\n"",; category=FutureWarning,; stacklevel=2). blockprefix = [; 'chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant'; ]; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.items():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); except KeyError:; continue; for v in qwer:; vv = v.values(); if vv[0] == prefix + lpv[1]:; enedict[pv] = float(vv[1]). return enedict. [docs]def compare_csx():; """"""Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. """"""; warnings.warn(; ""Using `psi4.driver.p4util.compare_csx` is deprecated (silently in 1.2), and in 1.3 it will stop working\n"",; category=FutureWarning,; stacklevel=2). if 'csx4psi' in sys.modules.keys():; if core.get_global_option('WRITE_CSX'):; enedict = csx2endict(); compare_integers(len(enedict) >= 2, True, 'CSX harvested'); for pv, en in enedict.items():; compare_values(core.variable(pv), en, 6, 'CSX ' + pv + ' ' + str(round(en, 4))). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.3.2;  · . PSI4. Module code. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:23097,validat,validate,23097,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['validat'],['validate']
Security,"""""Collection for handling single or multiple qcdb.WrappedDatabase objects.; Particularly, unifying modelchem and subset names that when inconsistent; across component databases. Also, defining statistics across databases. >>> asdf = qcdb.Database(['s22', 'Nbc10', 'hbc6', 'HSG'], 'DB4'); >>> qwer = qcdb.Database('s22'); """""". def __init__(self, dbnamelist, dbse=None, pythonpath=None, loadfrompickle=False, path=None):; #: internal name of database collection; #:; #: >>> print asdf.dbse; #: 'DB4'; self.dbse = None. #: ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:47325,validat,validation,47325,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,2,"['Validat', 'validat']","['ValidationError', 'validation']"
Security,"""""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; molecule = PsiMod.get_active_molecule(); if 'molecule' in kwargs:; molecule = kwargs.pop('molecule'). if not molecule:; raise ValueNotSet('no molecule found'). PsiMod.scf(). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_local_option('SCF', 'DFT_FUNCTIONAL'); b_user_fctl = PsiMod.has_option_changed('DFT_FUNCTIONAL'); user_ref = PsiMod.get_local_option('SCF', 'REFERENCE'); b_user_ref = PsiMod.has_option_changed('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name,**kwargs) . PsiMod.set_global_option('DFT_FUNCTIONAL', user_fctl); if not b_user_fctl:; PsiMod.revoke_global_option_changed('DFT_FUNCTIONAL'); PsiMod.set_global_option('REFERENCE', user_ref); if not b_user_ref:; PsiMod.revoke_global_option_changed('REFERENCE'). return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; lowername = name.lower(). user_fctl = PsiMod.get_global_option('DFT_FUNCTIONAL'); user_ref = PsiMod.get_global_option('REFERENCE'). PsiMod.set_global_option('DFT_FUNCTIONAL', lowername). if (user_ref == 'RHF'):; PsiMod.set_global_option('REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_global_option('REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise Validat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:17070,Validat,ValidationError,17070,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"""""Set equal to C2 about the y axis. """"""; self.i(); if self.n == 2 or self.n == 3 or self.n == 4:; self.d[1][1] = 1.0; if self.n == 4:; self.d[2][2] = 1.0; elif self.n == 5:; self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[3][3] = 1.0. [docs] def c2_z(self):; """"""Set equal to C2 about the z axis. """"""; self.i(); if self.n == 2 or self.n == 3 or self.n == 4:; self.d[1][1] = 1.0; if self.n == 4:; self.d[2][2] = 1.0; elif self.n == 5:; self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[3][3] = 1.0. # <<< Methods for Operations >>>. [docs] def operate(self, r):; """"""This operates on this with r (i.e. return r * this). """"""; if r.n != self.n:; raise ValidationError(""SymRep::operate(): dimensions don't match""). ret = SymRep(self.n); for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += r[i][k] * self.d[k][j]; ret[i][j] = t; return ret. [docs] def transform(self, r):; """"""This performs the transform r * this * r~. """"""; if r.n != self.n:; raise ValidationError(""SymRep::operate(): dimensions don't match""). foo = SymRep(n); # foo = r * d; for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += r[i][k] * d[k][j]; foo[i][j] = t. ret = SymRep(n); # ret = (r*d)*r~ = foo*r~; for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += foo[i][k] * r[j][k]; ret[i][j] = t. return ret. [docs] def rotation(self, theta):; """"""Set equal to a clockwise rotation by 2pi/n or theta degrees. """"""; if isinstance(theta, int):; theta = 2.0 * math.pi if theta == 0 else 2.0 * math.pi / theta. ctheta = math.cos(theta); stheta = math.sin(theta); c2theta = math.cos(2 * theta); s2theta = math.sin(2 * theta). self.zero(); if self.n == 1:; self.d[0][0] = 1.0. elif self.n == 3:; self.d[0][0] = ctheta; self.d[0][1] = stheta; self.d[1][0] = -stheta; self.d[1][1] = ctheta; self.d[2][2] = 1.0. elif self.n == 2 or self.n == 4:; self.d[0][0] = ctheta; self.d[0][1] = stheta; self.d[1][0] = -stheta; self.d[1][1] = ctheta. # this is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:14095,Validat,ValidationError,14095,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC var",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:114966,Validat,ValidationError,114966,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif not kind in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif not kind in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and not ""cvs"" in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC var",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:112681,Validat,ValidationError,112681,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,""", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:22289,Validat,ValidationError,22289,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['Validat'],['ValidationError']
Security,""".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""xyzabc"", ""points"", ""rotmat""] for f in hint_types):; types = hint_types; else:; raise ValidationError(""""""hint_types not among 'xyzabc', 'points', 'rotmat': {}"""""".format(hint_types)). hints = []; hlen = {""xyzabc"": 6, ""points"": 9, ""rotmat"": 12}; for ifr, fr in enumerate(geom_hints):; try:; hint = [float(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:16422,Validat,ValidationError,16422,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""PsiMod.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # PsiMod.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omega'); #; # """"""; # lowername = name.lower(); # kwargs = kwargs_lower(kwargs); #; # plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; # PsiMod.plugin_load(""%s"" % (plugfile)); #; # PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); # PsiMod.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); # PsiMod.set_global_option('REFERENCE', 'UHF'); # PsiMod.set_global_option('SCF_TYPE', 'DF'); # energy('scf', **kwargs); #; # PsiMod.set_global_option('dft_functional', 'wB97'); # PsiMod.set_global_option('dft_order_spherical', 25); # PsiMod.set_global_option('dft_num_radial', 35); # PsiMod.set_global_option('omega_procedure', 'ip'); # PsiMod.set_global_option('maxiter', 50); # PsiMod.set_global_option('d_convergence', 5); # PsiMod.set_global_option('e_convergence', 7); # PsiMod.plugin(""plugin_omega.so""); #; # return PsiMod.get_variable('SCF ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:4486,access,access,4486,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,1,['access'],['access']
Security,"""; [master 16dbd3e] Records tag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck admins ""Do not allow ..."" and Save changes. >>> git push upstream master. # re-engage admins ""Do not allow ..."" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed. # see note at ""Tag (pre)release"" for why atomic commit needed. Collect docs from GHA artifacts. >>> git push --atomic upstream 1.3.x v1.3.1. Initialize release branch¶. follow tagging procedure; before re-engaging the admins “Do not allow …” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build extra Conda packages for Psi4 channel¶; Once upon a time, “Psi4 stack”, meant packages psi4, psi4-rt, psi4-dev, and psi4-docs.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda.; Package psi4-rt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_release.html:11876,hash,hash,11876,psi4manual/master/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_release.html,2,['hash'],['hash']
Security,"""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,; ro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:88720,Validat,ValidationError,88720,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.update({k: qca.to_dict() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn,;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:75859,Validat,ValidationError,75859,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'):; rsn = core.get_option('THERMO', 'ROTATIONAL_SYMMETRY_NUMBER'); else:; rsn = mol.rotational_symmetry_number(). if irrep is None:; therminfo, thermtext = qcdb.vib.thermo(; vibinfo,; T=core.get_option(""THERMO"", ""T""), # 298.15 [K]; P=core.get_option(""THERMO"", ""P""), # 101325. [Pa]; multiplicity=mol.multiplicity(),; molecular_mass=np.sum(m),; sigma=rsn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:82170,Validat,ValidationError,82170,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,5,['Validat'],['ValidationError']
Security,"""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC gradient""). # throw exception for CONV (approximately); if (corl_type := method_algorithm_type(name).now) not in [""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for DFOCC gradient. See Capabilities Table at {dtl}""). proc_util.check_disk_df(name.upper(), optstash). # throw exception for SCF_TYPE; if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:68261,Validat,ValidationError,68261,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); else:; raise ValidationError('Unidentified method ' % (name)). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if core.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:48722,Validat,ValidationError,48722,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val in ['DISK_DF', 'DF']:; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif type_val == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(""""""Invalid type '%s' for DFOCC"""""" % type_val). return type_val. if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); type_val = set_cholesky_from('MP2_TYPE'); elif name in ['mp2.5', 'omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); type_val = set_cholesky_from('MP_TYPE'); elif name in ['mp3', 'omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); type_val = set_cholesky_from('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); type_val = set_cholesky_from('CC_TYPE'). elif name == 'ccd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'ccsd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'ccsd(at)':; core.set_local_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:44730,Validat,ValidationError,44730,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"""Instantiate class with case insensitive name *dbname*. Module; search path can be prepended with *pythonpath*. """"""; #: internal name of database; #:; #: >>> print asdf.dbse; #: 'NBC1'; self.dbse = None. #: description line; #:; #: >>> print asdf.tagl; #: 'interaction energies of dissociation curves for non-bonded systems'; self.tagl = None. #: OrderedDict of reactions/members; #:; #: >>> print asdf.hrxn.keys(); #: ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']; self.hrxn = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']; self.hrgt = None. #: dict of defined reaction subsets.; #: Note that self.sset['default'] contains all the nonredundant information.; #:; #: >>> print asdf.sset.keys(); #: ['meme', 'mxddpp', '5min', ... 'small']; self.sset = None. # Removing hrxn, hrgt etc. do not reduce the size of the object.; # These attributes are stored for ease of access for adding qc info, etc. #: object of defined reaction subsets.; self.oss = None. # load database; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../databases'); database = psiutil.import_ignorecase(dbname); if not database:; print('\nPython module for database %s failed to load\n\n' % (dbname)); print('\nSearch path that was tried:\n'); print("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(dbname)). # gross validation of database; for item in ['dbse', 'GEOS', 'HRXN', 'ACTV', 'RXNM']:; try:; getattr(database, item); except AttributeError:; raise ValidationError(""""""Database %s severely deformed with %s missing."""""" % (database.__name__, item)); for item in ['TAGL', 'BIND']:; try:; getattr(database, item); except AttributeError:; print(""""""Warning: Database %s possibly deformed with %s missing.\n"""""" % (database.__name__, item)). # form database name; self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:21716,access,access,21716,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['access'],['access']
Security,"""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; g_q = (E[:, 0] - 8.0 * E[:, 1] + 8.0 * E[:, 2] - E[:, 3]) / (12.0 * findifrec[""step""][""size""]); else: # This error SHOULD have already been caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logger.info(info). # Transform the gradient from mass-weighted SALCs to non-mass-weighted Cartesians; B = data[""salc_list""].matrix(); g_cart = np.dot(g_q, B); g_cart = g_cart.reshape(data[""n_atom""], 3); massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); g_cart = (g_cart.T * massweighter).T. if data[""print_lvl""]:; info = ""\n -------------------------------------------------------------\n""; core.print_out(info); logger.info(info). return g_cart. def _process_hessian_symme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:21994,Validat,ValidationError,21994,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['Validat'],['ValidationError']
Security,"""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATIO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:2916,validat,validation,2916,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['validat'],['validation']
Security,"# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional. from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error mes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/exceptions.html:1742,Validat,ValidationError,1742,psi4manual/1.9.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/exceptions.html,2,['Validat'],['ValidationError']
Security,"# Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If we force c1 copy the active molecule; if use_c1:; scf_molecule.update_geometry(); if scf_molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); scf_molecule = scf_molecule.clone(); scf_molecule.reset_point_group('c1'); scf_molecule.fix_orientation(True); scf_molecule.fix_com(True); scf_molecule.update_geometry(). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (core.get_option('SCF', 'REFERENCE') in ['RHF', 'RKS']) and \; ((scf_molecule.natom() > 1) or core.get_option('SCF', 'SAD_FRAC_OCC')):; core.set_local_option('SCF', 'GUESS', 'SAD'); elif core.get_option('SCF', 'REFERENCE') in ['ROHF', 'ROKS', 'UHF', 'UKS']:; core.set_local",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:31758,Validat,ValidationError,31758,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"# but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import collections; import math; import os; import re; import sys. from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:1688,access,access,1688,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,3,['access'],['access']
Security,"# handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:18148,Validat,ValidationError,18148,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"# it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import sys. from psi4 import core; from psi4.driver.util.filesystem import *; from psi4.driver.util import tty. [docs]def sanitize_name(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", ""bitand"", ""bitor"",; ""bool"", ""break"", ""case"", ""catch"", ""char"", ""char16_t"", ""char32_t"",; ""class"", ""compl"", ""concept"", ""const"", ""constexpr"", ""const_cast"",; ""continue"", ""decltype"", ""default"", ""delete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""req",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/plugin.html:1444,sanitiz,sanitized,1444,psi4manual/1.2.1/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/plugin.html,5,['sanitiz'],['sanitized']
Security,"# with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions used by several Python functions."""""". __all__ = [; ""all_casings"",; ""drop_duplicates"",; ""expand_psivars"",; ""format_molecule_for_input"",; ""format_options_for_input"",; ""get_psifile"",; ""getattr_ignorecase"",; ""hold_options_state"",; ""import_ignorecase"",; ""kwargs_lower"",; ""mat2arr"",; ""prepare_options_for_modules"",; ""prepare_options_for_set_options"",; ""provenance_stamp"",; ""state_to_atomicinput"",; ]. import os; import ast; import sys; import math; import pickle; import inspect; import warnings; from contextlib import contextmanager; import collections; from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Union; from types import ModuleType. import numpy as np; from qcelemental.models import AtomicInput. from psi4 import core; from psi4.metadata import __version__; from .exceptions import ValidationError; from . import p4regex. [docs]; def kwargs_lower(kwargs: Dict[str, Any]) -> Dict[str, Any]:; """"""Function to rebuild and return *kwargs* dictionary sanitized. Should be; called by every function that could be called directly by the user. Parameters; ----------; kwargs; Input kwargs for any user-facing function. Returns; -------; lowered : Dict[str, Any]; Sanitized kwargs with all keys made lowercase. Also turns boolean-like; values into actual booleans. Also turns values lowercase if sensible. """"""; caseless_kwargs = {}; for key, value in kwargs.items():; lkey = key.lower(); if lkey in ['subset', 'banner', 'restart_file', 'write_orbitals']: # only kw for which case matters; lvalue = value; else:; try:; lvalue = value.lower(); except (AttributeError, KeyError):; lvalue = value. if lkey in ['irrep', 'check_bsse', 'linkage', 'bsse_type']:; caseless_kwargs[lkey] = lvalue. elif 'dertype' in lkey:; if p4regex.der0th.match(str(lvalue)):; caseless_kwargs[lkey] = 0; elif p4regex.der1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:1964,Validat,ValidationError,1964,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"## return self.__dict__['__dict__'][name]; #; ## if name in self.__dict__:; ## return self.__dict__[name]; ## elif '__dict__' in self.__dict__ and name in self.__dict__['__dict__']:; ## return self.__dict__['__dict__'][name]; ## elif object.__getattribute__(self, 'is_variable')(name):; ## return object.__getattribute__(self, 'get_variable')(name); ## else:; ## raise AttributeError; #; # if not name in self.__dict__:; # if object.__getattribute__(self, 'is_variable')(name):; # return object.__getattribute__(self, 'get_variable')(name); # else:; # raise AttributeError; # else:; # return self.__dict__[name]. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; try:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Molecule::get_anchor_atom: Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:38205,access,accessing,38205,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['access'],['accessing']
Security,"#; # @END LICENSE; #; """"""Plan, run, and assemble QC tasks to obtain many-body expansion and basis-set superposition error treatments. =============; ManyBody Flow; =============; Bullet points are major actions; Lines of dashes denote function calls; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian; `mc_(frag, bas)` := a modelchem index, mc; indices of real fragments, frag; set(bas - frag) are indices of ghost fragments. see ""intermediates_energy"" in big table below for example.; note that there's a lot of natural 1-indexing (1, 2, 3) rather than 0-indexing (0, 1, 2) in manybody. e.g., 2-body energy, Molecule.extract_subsets(1, (1, 2)); note that a ""level"" can be n-body level (how many real molecular fragments) or a modelchem level (`mc_`; e.g., CC on 1-bodies, MP2 on 2-bodies; ""multilevel""). ---------------------------; ManyBodyComputer.__init__(); ---------------------------; * not an explicit function but pydantic handles some defaults and validation; * fields molecule, nfragments, bsse_type, return_total_data, and initial max_nbody set; * BaseComputer.__init__(). task_planner.py::task_planner(); -------------------------------; * computer gets modified from task_planner outside this file!; * modelchem (method and basis) treatment levels for each n-body level determined from user levels kwarg. fields nbodies_per_mc_level set and max_nbody reset; * for each modelchem treatment level, call build_tasks() below via one of four routes, depending on simple MB or layered MB(FD), MB(CBS), or MB(FD(CBS)). ------------------------------; ManyBodyComputer.build_tasks(); ------------------------------; * if supersystem requested as a modelchem level, request (frag, bas) indices for full nbody range of nocp treatment from build_nbody_compute_list(); * otherwise, request (frag, bas) indices for specified nbody range covering specified bsse treatments from build_nbody_compute_list(). build_nbody_compute_list(); --------------------------; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:2081,validat,validation,2081,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,5,['validat'],['validation']
Security,"#; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; r""""""Module to provide mechanism to store and restore option states in driver. """""". __all__ = [; ""OptionState"",; ""OptionsStateCM"",; ""OptionsState"",; ]. import sys; from contextlib import contextmanager; from typing import Optional, Iterator, List. from psi4 import core. from .exceptions import ValidationError. [docs]; class OptionState():; """"""Store the state (value and changed status) of a single `option`. Parameters; ----------; option; Name of read_options keyword. All caps.; module; Name of read_options module or None if global. All caps.; If `module` given, the `option` value and has_changed value is stored; for global, local to `module`, and used by `module` scopes. Otherwise; (used for BASIS keywords), only global scope is stored. Examples; --------; >>> OptionState('E_CONVERGENCE', 'SCF'). >>> print(OptionState('DF_BASIS_MP2')). """""". def __init__(self, option: str, module: Optional[str] = None):; self.option = option.upper(); if module:; self.module = module.upper(); else:; self.module = None. self.value_global = core.get_global_option(option); self.haschanged_global = core.has_global_option_changed(option); if self.module:; self.value_local = core.get_local_option(self.module, option); self.haschanged_local = core.has_local_option_changed(self.module, option); self.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html:1409,Validat,ValidationError,1409,psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html,1,['Validat'],['ValidationError']
Security,"#; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; r""""""Module to provide mechanism to store and restore option states in driver. """""". __all__ = [; ""OptionState"",; ""OptionsStateCM"",; ""OptionsState"",; ]. import sys; from contextlib import contextmanager; from typing import Optional, Iterator, List. from psi4 import core. from .exceptions import ValidationError. [docs]class OptionState():; """"""Store the state (value and changed status) of a single `option`. Parameters; ----------; option; Name of read_options keyword. All caps.; module; Name of read_options module or None if global. All caps.; If `module` given, the `option` value and has_changed value is stored; for global, local to `module`, and used by `module` scopes. Otherwise; (used for BASIS keywords), only global scope is stored. Examples; --------; >>> OptionState('E_CONVERGENCE', 'SCF'). >>> print(OptionState('DF_BASIS_MP2')). """""". def __init__(self, option: str, module: Optional[str] = None):; self.option = option.upper(); if module:; self.module = module.upper(); else:; self.module = None. self.value_global = core.get_global_option(option); self.haschanged_global = core.has_global_option_changed(option); if self.module:; self.value_local = core.get_local_option(self.module, option); self.haschanged_local = core.has_local_option_changed(self.module, option); self.va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/optproc.html:1407,Validat,ValidationError,1407,psi4manual/1.7.x/_modules/psi4/driver/p4util/optproc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/optproc.html,1,['Validat'],['ValidationError']
Security,"%d"" % (name.upper(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); core.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); ref_wfn = run_ccenergy('ccsd', **kwargs); elif name == 'eom-cc2':. user_ref = core.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for EOM-CC2 is not available.' % user_ref). core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC2'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC2'); ref_wfn = run_ccenergy('cc2', **kwargs); elif name == 'eom-cc3':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC3'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC3'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC3'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC3'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC3'); ref_wfn = run_ccenergy('cc3', **kwargs). core.cchbar(ref_wfn); core.cceom(ref_wfn). optstash.restore(); return ref_wfn; # TODO ask if all these cc modules not actually changing wfn. def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; optstash =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:80134,Validat,ValidationError,80134,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"%s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:23924,Validat,ValidationError,23924,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"%s'."" % type(valueLO)). [docs]def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; ""scf_xtpl_truhlar_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - le",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:11362,Validat,ValidationError,11362,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76059,Validat,ValidationError,76059,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); psi4.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:95184,Validat,ValidationError,95184,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX') or n_two > 0:; # WARNING!!! A one-particle property computed _with_ a two-particle property will differ; # from a one-particle property computed by itsel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:99484,Validat,ValidationError,99484,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.items():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetain",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:77240,Validat,ValidationError,77240,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSET) - 1]) - ZETA.index(b)) != 1:; raise ValidationError('Basis set \'%s\' has out-of-order zeta level \'%s\'.' % (basisstring, b)); BSET.append(basisname.group(1) + b + basisname.group(3)); if b == 'd':; b = '2'; if b == 't':; b = '3'; if b == 'q':; b = '4'; ZSET.append(int(b)); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError('Basis set surrounding series indicator [] in \'%s\' is invalid.' % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). return [BSET, ZSET]. # Reform string basis set descriptor from basis set strings, 'cc-pv[q5]z' from [cc-pvqz, cc-pv5z]; [docs]def reconstitute_bracketed_basis(needarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the *f_basis* field of a *NEED* dictionary in; :py:func:`~wrappers.complete_basis_set`. Result is used to print a nicely; formatted basis set string in the results table. """"""; ZETA = {'d': 2, 't': 3, 'q': 4, '5': 5, '6': 6}; ZSET = [''] * len(ZETA); BSET = []. for lvl in needarray.iteritems():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[ze",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:75995,Validat,ValidationError,75995,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"'%s' for DFOCC"""""" % type_val). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); set_cholesky_from('MP2_TYPE'); elif name in ['mp2.5', 'omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); set_cholesky_from('MP_TYPE'); elif name in ['mp3', 'omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); set_cholesky_from('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); set_cholesky_from('CC_TYPE'). elif name == 'ccd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(at)':; core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(AT)'); set_cholesky_from('CC_TYPE'); elif name == 'dfocc':; pass; else:; raise ValidationError('Unidentified method %s' % (name)). # conventional vs. optimized orbitals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'ccsd(at)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""); if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:43805,Validat,ValidationError,43805,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"'%s' for DFOCC"""""" % type_val). if name in ['mp2', 'omp2']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); set_cholesky_from('MP2_TYPE'); elif name in ['mp2.5', 'omp2.5']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); set_cholesky_from('MP_TYPE'); elif name in ['mp3', 'omp3']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); set_cholesky_from('MP_TYPE'); elif name in ['lccd', 'olccd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); set_cholesky_from('CC_TYPE'). elif name == 'ccd':; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd':; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(at)':; psi4.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(AT)'); set_cholesky_from('CC_TYPE'); elif name == 'dfocc':; pass; else:; raise ValidationError('Unidentified method %s' % (name)). # conventional vs. optimized orbitals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'ccsd(at)']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:35536,Validat,ValidationError,35536,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"''; actives += """"""core.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""core.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""core.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\ncore.set_memory_bytes(%s)\n\n"""""" % (core.get_memory()); for chgdopt in core.get_global_option_list():; if core.has_global_option_changed(chgdopt):; chgdoptval = core.get_global_option(chgdopt); #chgdoptval = core.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""core.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""core.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; pass; #raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""core.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""core.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects resul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:19814,Validat,ValidationError,19814,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,2,['Validat'],['ValidationError']
Security,"'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> molecule H2 {\\n0 1\\nH\\nH 1 0.74\\n}; >>> energy('scf'); >>> H2.set_multiplicity(3); >>> energy('detci', bypass_scf=True). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['energy'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:22916,Validat,ValidationError,22916,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); elif (name.lower() == 'sapt2+(3)'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'); e_sapt = PsiMod.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:28554,Validat,ValidationError,28554,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"', 'EOM_CCSD'); ref_wfn = run_eom_cc(name, **kwargs); else:; psi4.print_out('DGAS: proc.py:1599 hitting an undefined sequence'); psi4.clean(); raise ValueError('Hit a wall in proc.py:1599'). psi4.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); psi4.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); psi4.set_local_option('CCDENSITY', 'XI', 'TRUE'); psi4.cclambda(ref_wfn); psi4.ccdensity(ref_wfn); psi4.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); psi4.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); psi4.set_local_option('CCDENSITY', 'XI', 'FALSE'); psi4.cclambda(ref_wfn); psi4.ccdensity(ref_wfn). derivobj = psi4.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. [docs]def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if psi4.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). return psi4.adc(ref_wfn). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:69586,Validat,ValidationError,69586,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"', 'key =', key, 'aux =', aux, 'fitrole =', fitrole, 'orb =', orb, 'orbonly =', orbonly #, mol. # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # Apply requested basis set(s) to the molecule; # - basstrings only a temp object so using fitrole as dict key instead of psi4 keyword; # - error checking not needed since C-side already checked for NULL ptr; mol.clear_basis_all_atoms(); # TODO now need to clear shells, too; basstrings = defaultdict(dict); if orb is None or orb == '':; raise ValidationError(""""""Orbital basis argument must not be empty.""""""); elif callable(orb):; basstrings['BASIS'] = orb(mol, 'BASIS'); elif isinstance(orb, basestring):; mol.set_basis_all_atoms(orb, role='BASIS'); else:; raise ValidationError(""""""Orbital basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). if aux is None or aux == '':; pass; elif callable(aux):; basstrings[fitrole] = aux(mol, fitrole); elif isinstance(aux, basestring):; mol.set_basis_all_atoms(aux, role=fitrole); else:; raise ValidationError(""""""Auxiliary basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). # Not like we're ever using a non-G94 format; parser = Gaussian94BasisSetParser(). # Molecule and parser prepped, call the constructor; bs, msg = BasisSet.construct(parser, mol, fitrole, None if fitrole == 'BASIS' else fitrole, basstrings[fitrole]). text = """""" => Loading Basis Set <=\n\n""""""; text += """""" Role: %s\n"""""" % (fitrole); text += """""" Keyword: %s\n"""""" % (key); text += """""" Name: %s\n"""""" % (target); text += msg. if returnBasisSet:; #print text; return bs; else:; bsdict = {}; bsdict['message'] = text; bsdict['name'] = bs.name; bsdict['pure",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:19789,Validat,ValidationError,19789,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['Validat'],['ValidationError']
Security,"', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = core.get_datadir(); #nolongerpredictable psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; driver_loc = os.path.dirname(os.path.abspath(__file__)); dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath + \; ':' + driver_loc # so the databases can ""import qcdb"". sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html:10014,Validat,ValidationError,10014,psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"', True); elif (name.lower() == 'sapt2+(ccd)-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); PsiMod.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+(3)(ccd)-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); PsiMod.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+3(ccd)-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.set_local_option('SAPT', 'DO_CCD_DISP', True); PsiMod.print_out('\n'); banner('SAPT Charge Transfer'); PsiMod.print_out('\n'). # if the df_basis_sapt basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SAPT') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_SAPT', ribasis); PsiMod.print_out(' No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). PsiMod.print_out('\n'); banner('Dimer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = PsiMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:62138,Validat,ValidationError,62138,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"', corl_basis='cc-pv[dt]z'); energy(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z"", ""scheme"": ""corl_xtpl_helgaker_2""}]). Caution; In PSI4 previous to Spring 2022 and v1.6, calling certain; cbs-related functions like the above looked like; energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z'). energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z"", ""scheme"": corl_xtpl_helgaker_2}]). The difference is that the main function; psi4.driver.cbs() and extrapolation schemes like; psi4.driver.driver_cbs_helper.xtpl_highest_1() and; psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2() and composite; aliases like psi4.driver.aliases.sherrill_gold_standard(); and psi4.driver.aliases.allen_focal_point() in the old way; passed the Python function directly, whereas the new way uses the; string of the function name. A CCSD(T) DT coupled-cluster correction atop a TQ MP2 extrapolation; geometry optimization can also be accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(""cbs"", corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:; complete_basis_set(). Returns:; (float) – Total ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cbs.html:1735,access,accessed,1735,psi4manual/master/cbs.html,https://psicode.org,https://psicode.org/psi4manual/master/cbs.html,4,['access'],['accessed']
Security,"', dbmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""core.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (core.variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); core.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); core.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:23476,Validat,ValidationError,23476,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"', psi4.get_active_molecule()); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass scf_helper a reference wavefunction""). # Second-order SCF requires non-symmetric density matrix support; if psi4.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if psi4.has_option_changed('SCF', 'BASIS_GUESS'):; cast = psi4.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that can't query PUREAM option directly, as it only; # reflects user changes to value, so load basis and; # read effective PUREAM setting off of it; #psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')); #psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; scf_molecule.set_multiplicity(3); psi4.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); psi4.print_out('\n'). # cast set-up; if (cast):. if yes.match(str(ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:27777,Validat,ValidationError,27777,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"'.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n -----------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43620,Validat,ValidationError,43620,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"'30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. :good examples:. 800000000 # 800000000; 2004088624.9 # 2004088624; 1.0e9 # 1000000000; '600 mb' # 600000000; '600.0 MiB' # 629145600; '.6 Gb' # 600000000; ' 100000000kB ' # 100000000000; '2 eb' # 2000000000000000000. :bad examples:. {} # odd type; '' # no info; ""8 dimms"" # unacceptable units; ""1e5 gb"" # string w/ exponent; ""5e5"" # string w/o units; 2000 # mem too small; -5e5 # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(""""""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more."""""".format(; memory_amount / 1024 ** 2, memory_amount / 1000 ** 2)). if execute:; core.set_memory_bytes(memory_amount); return memory_amount. [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return core.get_memory(). [docs]def success(label):; """"""Function to print a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:4722,Validat,ValidationError,4722,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"'; elif np.array_equal(Iidx, np.asarray([0, 1, 2])):; ar = 'IIIR'; elif np.array_equal(Iidx, np.asarray([2, 1, 0])):; ar = 'IL'; elif np.array_equal(Iidx, np.asarray([0, 2, 1])):; ar = 'IIL'; elif np.array_equal(Iidx, np.asarray([1, 0, 2])):; ar = 'IIIL'. # if inertial tensor has non-zero off-diagonals, this whole classification is iffy; if np.count_nonzero(it - np.diag(np.diagonal(it))):; ar = '~' + ar. return ar. [docs] def to_arrays(self, dummy: bool = False, ghost_as_dummy: bool = False) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:; """"""Exports coordinate info into NumPy arrays. Parameters; ----------; dummy; Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy; Whether or not to treat ghost atoms as dummies. Returns; -------; geom, mass, elem, elez, uniq : numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:35124,hash,hash,35124,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,4,['hash'],['hash']
Security,"'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.5996",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:22615,Validat,ValidationError,22615,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['Validat'],['ValidationError']
Security,"'C2_y'] | SymmOps['Sigma_xz'] | SymmOps['i'],; 'C2hZ': SymmOps['E'] | SymmOps['C2_z'] | SymmOps['Sigma_xy'] | SymmOps['i'],; 'D2h': SymmOps['E'] | SymmOps['C2_x'] | SymmOps['C2_y'] | SymmOps['C2_z'] | SymmOps['i'] | \; SymmOps['Sigma_xy'] | SymmOps['Sigma_xz'] | SymmOps['Sigma_yz']; }. # changed signature from def similar(bits, sim, cnt):; [docs]def similar(bits):; """"""From *bits* of a directionalized point group, returns array of; bits of all directions. """"""; cs = [PointGroups['CsX'], PointGroups['CsY'], PointGroups['CsZ']]; c2v = [PointGroups['C2vZ'], PointGroups['C2vY'], PointGroups['C2vX']]; c2h = [PointGroups['C2hZ'], PointGroups['C2hY'], PointGroups['C2hX']]; c2 = [PointGroups['C2Z'], PointGroups['C2Y'], PointGroups['C2X']]; d2h = [PointGroups['D2h']]; d2 = [PointGroups['D2']]; ci = [PointGroups['Ci']]; c1 = [PointGroups['C1']]. if bits in cs:; sim = cs; elif bits in c2v:; sim = c2v; elif bits in c2h:; sim = c2h; elif bits in c2:; sim = c2; elif bits in d2h:; sim = d2h; elif bits in ci:; sim = ci; elif bits in c1:; sim = c1; elif bits in d2:; sim = d2; else:; raise ValidationError('PointGroups::similar: Should not have reached here.'). return sim, len(sim). [docs]class SymmetryOperation(object):; """"""The SymmetryOperation class provides a 3 by 3 matrix; representation of a symmetry operation, such as a rotation or reflection. """""". def __init__(self, *args):; """"""Constructor"""""". # matrix representation; self.d = zero(3, 3); # bits representation; self.bits = 0. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 1 and \; isinstance(args[0], SymmetryOperation):; self.constructor_symmetryoperation(*args); else:; raise ValidationError('SymmetryOperation::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_symmetryoperation(self, so):; self.bits = so.bits; self.d = [row[:] for row in so.d]. # <<< Simple Methods for Basic SymmetryOperation Information >>>. [docs] def ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:4105,Validat,ValidationError,4105,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"'DFOCC', 'WFN_TYPE', 'DF-CCSD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); elif name in ['ccsd(t)']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); else:; raise ValidationError('Unidentified method %s' % (name)). if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd', 'ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:49345,Validat,ValidationError,49345,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); else:; raise ValidationError('Unidentified method ' % (name)). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if psi4.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_local_option('DFOCC', 'OEPROP', 'TRUE'); psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:39228,Validat,ValidationError,39228,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"'FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(""""""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out('\n Based on options and gradient (r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:69221,Validat,ValidationError,69221,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"'Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'); self.set_has_zmatrix(zmatrix). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:22313,Validat,ValidationError,22313,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:132168,Validat,ValidationError,132168,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"'SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). core.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = core.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); return wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name in ['mp', 'mp2', 'mp3', 'mp4']:; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'); if name == 'mp2':; level = 2; elif name == 'mp3':; level = 3; elif name == 'mp4':; level = 4; else:; level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name == 'ccsd':; # untested; core.set_local_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:86612,Validat,ValidationError,86612,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"'ZETA'],; ['CCLAMBDA', 'ZETA'],; ['DERTYPE'],; ['CCDENSITY', 'WFN'],; ['CCLAMBDA', 'WFN']). psi4.set_global_option('DERTYPE', 'FIRST'). if (name.lower() == 'eom-ccsd'):; psi4.set_local_option('CCLAMBDA', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCDENSITY', 'WFN', 'EOM_CCSD'); run_eom_cc(name, **kwargs). psi4.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); psi4.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); psi4.set_local_option('CCDENSITY', 'XI', 'TRUE'); psi4.cclambda(); psi4.ccdensity(); psi4.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); psi4.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); psi4.set_local_option('CCDENSITY', 'XI', 'FALSE'); psi4.cclambda(); psi4.ccdensity(); psi4.deriv(). optstash.restore(). [docs]def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if (psi4.get_option('ADC', 'REFERENCE') != 'RHF'):; raise ValidationError('ADC requires reference RHF'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return psi4.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:37103,Validat,ValidationError,37103,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"'\n'); p4util.banner(name.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n"");; core.print_out("" "" + banner.center(58));. scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(scf_wfn). # The wfn from_file routine adds the npy suffix if needed, but we add it here so that; # we can use os.path.isfile to query whether the file exists before attempting to read; read_filename = scf_wfn.get_scratch_filename(180) + '.npy'. if (core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename):; old_wfn = core.Wavefunction.from_file(read_filename); Ca_occ = old_wfn.Ca_subset(""SO"", ""OCC""); Cb_occ = old_wfn.Cb_subset(""SO"", ""OCC""). if old_wfn.molecule().schoenflies_symbol() != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if old_wfn.basisset().name() == scf_wfn.basisset().name():; core.print_out("" Reading orbitals from file 180, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out("" Reading orbitals from file 180, projecting to new basis.\n\n""); core.print_out("" Computing basis projection from %s to %s\n\n"" % (old_wfn.basisset().name(), scf_wfn.basisset().name())). pCa = scf_wfn.basis_projection(Ca_occ, old_wfn.nalphapi(), old_wfn.basisset(), scf_wfn.basisset()); pCb = scf_wfn.basis_projection(Cb_occ, old_wfn.nbetapi(), old_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Strip off headers to only get R, RO, U, CU; old_ref = old_wfn.name().replace(""KS"", """").replace(""HF"", """"); new_ref = scf_wfn.name().replace(""KS"", """").replace(""HF"", """"); if old_ref != new_ref:; scf_wfn.reset_occ_ = True. elif (core.get_option('SCF', 'GUESS') == 'READ') and not os.path.isfile(read_filename):; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:36295,Validat,ValidationError,36295,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:31482,Validat,ValidationError,31482,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:31129,Validat,ValidationError,31129,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternative",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:14969,Validat,ValidationError,14969,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); core.print_out(instructions). # Loop through chemical systems;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:14893,Validat,ValidationError,14893,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,7,['Validat'],['ValidationError']
Security,"'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'. elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. # Call appropriate wrappers; if gradient_type == 'nbody_gufunc':; return driver_nbody.nbody_gufunc(hessian, name.lower(), ptype='hessian', **kwargs); # Check if this is a CBS extrapolation; elif gradient_type == ""cbs_gufunc"":; return driver_cbs._cbs_gufunc(hessian, name.lower(), **kwargs, ptype=""hessian""); elif gradient_type == ""cbs_wrapper"":; return driver_cbs.cbs(hessian, ""cbs"", **kwargs, ptype=""hessian""); elif gradient_type != ""conventional"":; raise ValidationError(""Hessian: Does not yet support custom functions.""); else:; lowername = name.lower(). return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 ir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:63545,Validat,ValidationError,63545,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec banners. try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:28922,Validat,ValidationError,28922,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_Karton_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_helgaker_3(functionname, zLO, valueLO, zMD, valueMD, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0; """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(""scf_xtpl_helgaker_3: Inputs must be of the same datatype! (%s, %s, %s)""; % (type(valueLO), type(valueMD), type(valueHI))). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" MD-zeta (%s) Energy: % 16.12f\n"""""" % (str(zMD), valueMD); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zMD].upper()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:14302,Validat,ValidationError,14302,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"(""""""\nmolecule %s {\n%s\n}\n"""""", 0)\n' % (mol_name, mol_string); return eval(commands). [docs]def format_options_for_input():; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Does not cover local (as opposed to global) options. - Does not work with array-type options. """"""; commands = ''; commands += """"""\npsi4.set_memory(%s)\n\n"""""" % (psi4.get_memory()); for chgdopt in psi4.get_global_option_list():; if psi4.has_global_option_changed(chgdopt):; chgdoptval = psi4.get_global_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""psi4.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed.' % (chgdopt)); return commands. [docs]def format_kwargs_for_input(filename, lmode=1, **kwargs):; """"""Function to pickle to file *filename* the options dictionary; *kwargs*. Mode *lmode* =2 pickles appropriate settings for; reap mode. Used to capture Python options information for; distributed (sow/reap) input files. """"""; if lmode == 2:; kwargs['mode'] = 'reap'; kwargs['linkage'] = os.getpid(); filename.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, filename); filename.write('''"""""")\n'''); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casing",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:4216,Validat,ValidationError,4216,psi4manual/4.0b5/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:82825,Validat,ValidationError,82825,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']) # yes, this really must be global, not local to SCF. # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_loca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:67274,Validat,ValidationError,67274,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if (db_mode.lower() == 'sow'):; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:37266,access,accessed,37266,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['access'],['accessed']
Security,('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:;,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:32824,Validat,ValidationError,32824,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:14354,Validat,ValidationError,14354,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,3,['Validat'],['ValidationError']
Security,"('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print (""De = %f"" % D_e). h2 = psi4.geometry(""""""; H; H 1 0.9; """"""). psi4.set_options({""basis"": ""cc-pvdz"",; ""reference"": ""rhf""}); h2_energy = psi4.energy('scf'). h = psi4.geometry(""""""; H; """"""). psi4.set_options({""basis"": ""cc-pvdz"",; ""reference"": ""uhf""}); h_energy = psi4.energy('scf'). D_e = psi4.constants.hartree2kcalmol * (2*h_energy - h2_energy); print(""De = %f"" % D_e). The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available. PSIthonPsiAPIe_mp2 = variable('MP2 TOTAL ENERGY'); e_scs_mp2 = variable('SCS-MP2 TOTAL ENERGY'). e_mp2 = psi4.variable('MP2 TOTAL ENERGY'); e_scs_mp2 = psi4.variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation func",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:8928,access,accessed,8928,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['access'],['accessed']
Security,"())); core.print_out(' -------------------------\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). optstash.restore(); return scf_wfn. def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). core.set_local_option('SCF', 'DFT_FUNCTIONAL', name.upper()). user_ref = core.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). wfn = run_scf_gradient(name, **kwargs). optstash.restore(); return wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:85973,Validat,ValidationError,85973,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def _np_read(; self: Union[core.Matrix, core.Vector],; filename: str,; prefix: str = """",; ) -> Union[core.Matrix, core.Vector]:; """"""Reads the data from a NumPy compressed or uncompressed file using; :func:`numpy.load`. Parameters; ----------; self; Pointer to which class to be constructed.; filename; File name to read.; prefix; Name under which array was saved for NumPy.; """""". if isinstance(filename, np.lib.npyio.NpzFile):; data = filename; elif isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(self: Union[core.Matrix, core.Vector]) -> Dict[str, Any]:; """"""; Converts an object with a ``.nph`` accessor to a serialized dictionary. Parameters; ----------; self; Matrix or Vector instance. Returns; -------; ~typing.Dict[str, ~typing.Any]; Serialized dictionary with keys:. - shape; - data : List[str]; - type : {'matrix', 'vector'}. """"""; json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:11183,Validat,ValidationError,11183,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,"(); ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']. hrxn = None¶; OrderedDict of reactions/members; >>> print asdf.hrxn.keys(); ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']. integer_reactions()[source]¶; Returns boolean of whether reaction names need to be cast to integer. static load_pickled(dbname, path=None)[source]¶. load_qcdata(modname, funcname, pythonpath=None, failoninc=True)[source]¶; Loads qcdb.ReactionDatums from module modname function; funcname. Module search path can be prepended with pythonpath. load_qcdata_byproject(project, pythonpath=None)[source]¶; Loads qcdb.ReactionDatums from standard location for project; :module dbse_project and function load_project. Module search path; can be prepended with pythonpath. load_qcdata_hdf5_trusted(project, path=None)[source]¶; Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. load_qcdata_hrxn_byproject(project, path=None)[source]¶. load_subsets(modname='subsetgenerator', pythonpath=None)[source]¶; Loads subsets from all functions in module modname. oss = None¶; object of defined reaction subsets. sset = None¶; dict of defined reaction subsets.; Note that self.sset[‘default’] contains all the nonredundant information.; >>> print asdf.sset.keys(); ['meme', 'mxddpp', '5min', ... 'small']. tagl = None¶; description line; >>> print asdf.tagl; 'interaction energies of dissociation curves for non-bonded systems'. average_errors(*args)[source]¶; Each item in args should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in args. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. balanced_error(refrxn, refeq, rrat, m=0.03, p=10.0)[source]¶. Parameters:; refrxn – ; refeq – ; rrat – ; m – minimum ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:48990,validat,validated,48990,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['validat'],['validated']
Security,"(*saveas*; ends in '/' to indicate directory only) (able to expand '.'). A full; absolute filename is returned, lacking only file extension. Based on; analysis of missing parts of *saveas*, path information from *def_path*; and/or filename information from *def_prefix* + *def_filename* is; inserted. *def_prefix* is intended to be something like ``mplthread_``; to identify the type of figure. """"""; defname = def_prefix + def_filename.replace(' ', '_'); if saveas is None:; pth = def_path; fil = defname; else:; pth, fil = os.path.split(saveas); pth = pth if pth != '' else def_path; fil = fil if fil != '' else defname. abspathfile = os.path.join(os.path.abspath(pth), fil); if relpath:; return os.path.relpath(abspathfile, os.getcwd()); else:; return abspathfile. [docs]def segment_color(argcolor, saptcolor):; """"""Find appropriate color expression between overall color directive; *argcolor* and particular color availibility *rxncolor*. """"""; import matplotlib. # validate any sapt color; if saptcolor is not None:; if saptcolor < 0.0 or saptcolor > 1.0:; saptcolor = None. if argcolor is None:; # no color argument, so take from rxn; if rxncolor is None:; clr = 'grey'; elif saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = rxncolor; elif argcolor == 'sapt':; # sapt color from rxn if available; if saptcolor is not None:; clr = matplotlib.cm.jet(saptcolor); else:; clr = 'grey'; elif argcolor == 'rgb':; # HB/MX/DD sapt color from rxn if available; if saptcolor is not None:; if saptcolor < 0.333:; clr = 'blue'; elif saptcolor < 0.667:; clr = 'green'; else:; clr = 'red'; else:; clr = 'grey'; else:; # color argument is name of mpl color; clr = argcolor. return clr. [docs]def bars(data, title='', saveas=None, relpath=False, graphicsformat=['pdf'], view=True):; """"""Generates a 'gray-bars' diagram between model chemistries with error; statistics in list *data*, which is supplied as part of the dictionary; for each participating bar/modelchem, along with *mc* keys in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:1639,validat,validate,1639,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['validat'],['validate']
Security,"(PSIMRCC). TIKHONOW_TRIPLES (PSIMRCC). TILE_SZ (SCF). TPDM (DCFT). (DETCI). TPDM_ABCD_TYPE (OCC). TPDM_ADD_REF (TRANSQT). TPDM_FILE (TRANSQT). TPDM_PRINT (DETCI). transition state; . geometry optimization. translate() LibmintsMolecule method. transpose() in module qcdb.vecutil. TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_LOW_MEMORY (FNOCC). TURN_ON_ACTV (MCSCF). TWO-ELECTRONENERGY. type() CartesianEntry method. NumberValue method. VariableValue method. ZMatrixEntry method. typecheck() Keyword method. U. UNCP-CORRECTED2-BODYINTERACTIONENERGY. unique() LibmintsMolecule method. units; . molecule. UNITS (GLOBALS). units() LibmintsMolecule method. UPDATE (DETCI). update_geometry() LibmintsMolecule method. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). useful() in module qcdb.dbproc. V. VAL_EX_LEVEL (DETCI). valid_atom_map() LibmintsMolecule method. validate_bracketed_basis() in module wrappers. validate_scheme_args() in module wrappers. ValidationError, [1]. variable_to_string() NumberValue method. VariableValue method. VariableValue class in qcdb.libmintscoordentry. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). VECS_WRITE (DETCI). verify_cavity() in module pcmpreprocess. verify_green() in module pcmpreprocess. verify_medium() in module pcmpreprocess. verify_spheres() in module pcmpreprocess. verify_top() in module pcmpreprocess. visualization. W. WABEI_LOWDISK (CCHBAR). WebMO. WFN (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CCTRIPLES). (CPHF). (DETCI). (GLOBALS). (SCF). (TRANSQT). (TRANSQT2). WFN_SYM (MCSCF). (PSIMRCC). WFN_TYPE (OCC). wrappers module. WRITER_FILE_LABEL (GLOBALS). X. x() LibmintsMolecule method. XI (CCDENSITY). XI_CONNECT (CCDENSITY). xvalidate() Keyword method. Section method. xyz() LibmintsMolecule method. Y. y() LibmintsMolecule method. yes GetkwParser attribute. Z. Z() CoordEntry method. LibmintsMolecule method. z() LibmintsMolecule method. ZAPTnCORRELATIONENERGY. ZAPTnTOTAL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:48848,Validat,ValidationError,48848,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['Validat'],['ValidationError']
Security,"([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!"");",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:30753,Validat,ValidationError,30753,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"(auto)'¶. field molecule: Any [Required]¶; The target molecule, if not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end. field nfragments: int = -1¶; Number of distinct fragments comprising full molecular supersystem. Validated by:. set_nfragments. field quiet: bool = False¶; Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted. field return_total_data: Optional[bool] = None¶; When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False. Validated by:. set_return_total_data. field task_list: Dict[str, Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]] = {}¶. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:17067,Validat,Validated,17067,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,4,['Validat'],['Validated']
Security,"(client=None)[source]¶; Run quantum chemistry. Parameters; client (Optional[FractalClient]) – . classmethod construct(_fields_set=None, **values)¶; Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data.; Default values are respected, but no other validation is performed.; Behaves as if Config.extra = ‘allow’ was set since it adds all passed values. Return type; Model. Parameters. _fields_set (Optional[SetStr]) – ; values (Any) – . copy(*, include=None, exclude=None, update=None, deep=False)¶; Duplicate a model, optionally choose which fields to include, exclude and change. Parameters. include (Union[AbstractSetIntStr, MappingIntStrAny]) – fields to include in new model; exclude (Union[AbstractSetIntStr, MappingIntStrAny]) – fields to exclude from new model, as with values this takes precedence over include; update (DictStrAny) – values to change/add in the new model. Note: the data is not validated before creating; the new model: you should trust this data; deep (bool) – set to True to make a deep copy of the model; self (Model) – . Return type; Model. Returns; new model instance. dict(**kwargs)¶; Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Return type; Dict[str, Any]. classmethod from_orm(obj)¶. Return type; Model. Parameters; obj (Any) – . get_results(client=None)[source]¶; Return results as Atomic-flavored QCSchema. Return type; AtomicResult. Parameters; client (Optional[FractalClient]) – . json(**kwargs)¶; Generate a JSON representation of the model, include and exclude arguments as per dict().; encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps(). classmethod parse_file(path, *, encoding=None)¶; Parses a file into a Model object. Parameters. path (Union[str, Path]) – The path to the file.; encoding (str, optional) – The type of the files, available types are: {‘json’, ‘msgpack’, ‘pickle’}. Attempts to; automat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html:3660,validat,validated,3660,psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,1,['validat'],['validated']
Security,"(dash_server(func, dashlvl, 'dftd3')); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); numAtoms = self.natom(); geom = self.save_string_xyz(); reals = []; for line in geom.splitlines():; if line.split()[0] == 'Gh':; numAtoms -= 1; else:; reals.append(line); ; gfile.write(str(numAtoms)+'\n'); for line in reals:; gfile.write(line.strip()+'\n'); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; i = 0; for line in geom.splitlines():; if i == 0:; i += 1; else:; if line.split()[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; temp = dfile.readline(); dashdderiv.append([float(x.replace('D', 'E')) for x in temp.split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())); psi_dashdderiv = PsiMod.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; verbose = PsiMod.get_option('SCF', 'PRINT'); if verbose >= 3:; PsiMod.print_out('\n ==> DFTD3 Output <==\n'); PsiMod.print_out(out); dfile = open(derivfile, 'r'); PsiMod.print_out(dfile.read().replace('D', 'E')); dfile.close(); PsiMod.print_out('\n'). # Clean up files and remove scratch directory; os.unlink(paramfile); os.un",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:10562,Validat,ValidationError,10562,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"(dash_server(func, dashlvl, 'dftd3')); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); numAtoms = self.natom(); geom = self.save_string_xyz(); reals = []; for line in geom.splitlines():; if line.split()[0] == 'Gh':; numAtoms -= 1; else:; reals.append(line); ; gfile.write(str(numAtoms)+'\n'); for line in reals:; gfile.write(line.strip()+'\n'); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; i = 0; for line in geom.splitlines():; if i == 0:; i += 1; else:; if line.split()[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; temp = dfile.readline(); dashdderiv.append([float(x.replace('D', 'E')) for x in temp.split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())); psi_dashdderiv = psi4.Matrix(self.natom(), 3); psi_dashdderiv.set(dashdderiv). # Print program output to file if verbose; verbose = psi4.get_option('SCF', 'PRINT'); if verbose >= 3:; psi4.print_out('\n ==> DFTD3 Output <==\n'); psi4.print_out(out); dfile = open(derivfile, 'r'); psi4.print_out(dfile.read().replace('D', 'E')); dfile.close(); psi4.print_out('\n'). # Clean up files and remove scratch directory; os.unlink(paramfile); os.unlink(geomfil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:11393,Validat,ValidationError,11393,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"(dims, (tuple, list, np.ndarray)):; irreps = len(dims); elif isinstance(dims, core.Dimension):; irreps = dims.n(); else:; raise ValidationError(""Dimension from list: Type '%s' not understood"" % type(dims)). ret = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(dim):; """"""; Converts a core.Dimension object to a tuple.; """""". if isinstance(dim, (tuple, list)):; return tuple(dim). irreps = dim.n(); ret = []; for i in range(irreps):; ret.append(dim[i]); return tuple(ret). def _dimension_iter(dim):; """"""; Provides an iterator class for the Dimension object. Allows:; dim = psi4.core.Dimension(...); list(dim); """""". for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. # General functions for NumPy array manipulation; def block_diagonal_array(*args):; """"""; Convert square NumPy array to a single block diagonal array.; Mimic of SciPy's block_diag.; """""". # Validate the input matrices.; dim = 0; for matrix in args:; try:; shape = matrix.shape; dim += shape[0]; except (AttributeError, TypeError):; raise ValidationError(""Cannot construct block diagonal from non-arrays.""); if len(shape) != 2:; raise ValidationError(""Cannot construct block diagonal from non-2D arrays.""); if shape[0] != shape[1]:; raise ValidationError(""Cannot construct block diagonal from non-square arrays.""). # If this is too slow, try a sparse matrix?; block_diag = np.zeros((dim, dim)); start = 0; for matrix in args:; next_block = slice(start, start + matrix.shape[0]); block_diag[next_block, next_block] = matrix; start += matrix.shape[0]. return block_diag. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.4;  · . PSI4. Module code; psi4.driver.p4util.numpy_helper. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:15084,Validat,Validate,15084,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],"['Validate', 'ValidationError']"
Security,"(dims, (tuple, list, np.ndarray)):; irreps = len(dims); elif isinstance(dims, core.Dimension):; irreps = dims.n(); else:; raise ValidationError(""Dimension from list: Type '%s' not understood"" % type(dims)). ret = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(dim):; """"""; Converts a core.Dimension object to a tuple.; """""". if isinstance(dim, (tuple, list)):; return tuple(dim). irreps = dim.n(); ret = []; for i in range(irreps):; ret.append(dim[i]); return tuple(ret). def _dimension_iter(dim):; """"""; Provides an iterator class for the Dimension object. Allows:; dim = psi4.core.Dimension(...); list(dim); """""". for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. # General functions for NumPy array manipulation; def block_diagonal_array(*args):; """"""; Convert square NumPy array to a single block diagonal array.; Mimic of SciPy's block_diag.; """""". # Validate the input matrices.; dim = 0; for matrix in args:; try:; shape = matrix.shape; dim += shape[0]; except (AttributeError, TypeError):; raise ValidationError(""Cannot construct block diagonal from non-arrays.""); if len(shape) != 2:; raise ValidationError(""Cannot construct block diagonal from non-2D arrays.""); if shape[0] != shape[1]:; raise ValidationError(""Cannot construct block diagonal from non-square arrays.""). # If this is too slow, try a sparse matrix?; block_diag = np.zeros((dim, dim)); start = 0; for matrix in args:; next_block = slice(start, start + matrix.shape[0]); block_diag[next_block, next_block] = matrix; start += matrix.shape[0]. return block_diag. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.5;  · . PSI4. Module code; psi4.driver.p4util.numpy_helper. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/p4util/numpy_helper.html:15084,Validat,Validate,15084,psi4manual/1.5.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],"['Validate', 'ValidationError']"
Security,"(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:17968,Validat,ValidationError,17968,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 1.63`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [1]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63`. References; ----------. .. [1] Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; ""scf_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:8290,Validat,ValidationError,8290,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"(gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3; Default: FALSE. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. INTEGRAL_PACKAGE¶. Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT1, SIMINT, LIBINT2; Default: LIBINT2. LITERAL_CFOUR¶. Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. MAX_RADIAL_MOMENT¶. Maximum Radial Moment to Calculate. Type: integer; Default: 4. MBIS_D_CONVERGENCE¶. MBIS Convergence Criteria. Type: conv double; Default: 1.0e-8. MBIS_MAXITER¶. Maximum Number of MBIS Iterations. Type: integer; Default: 500. MBIS_PRUNING_SCHEME¶. Pruning scheme for MBIS Grid. Type: string; Default: ROBUST. MBIS_RADIAL_POINTS¶. MBIS Number of Radial Points. Type: integer; Default: 75. MBIS_SPHERICAL_POINTS¶. MBIS Number of Spherical Points. Type: integer; Default: 302. MOLDEN_WITH_VIRTUAL¶. Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MP2_TYPE¶. Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE¶. Algorithm to use for MPn ( \(n>2\) ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Since v1.4, default for non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html:4348,Access,Access,4348,psi4manual/1.4.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html,5,['Access'],['Access']
Security,"(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" %; (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.PYinput_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.PYinput_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.0000000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:12243,Validat,ValidationError,12243,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)); except IndexError:; raise ValidationError(""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_xyz(self, save_ghosts=True, save_natom=False):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.00000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:9545,Validat,ValidationError,9545,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"(other)[source]¶; Whether this atom has the same mass and ghost status as atom other.; Also compares basis set assignment down to nbf(), has_puream() level; with code borrowed from Robert M. Parrish’s SAD guess in Psi4. is_ghosted()[source]¶; Whether the current atom is ghosted or not. label()[source]¶; The atom label. mass()[source]¶; The atomic mass of the current atom. static r(a1, a2)[source]¶; Computes the distance between two sets of coordinates. set_basisset(name, role='BASIS')[source]¶; Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. set_ghosted(gh)[source]¶; Flag the atom as either ghost or real. set_shell(bshash, key='BASIS')[source]¶; Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. shell(key='BASIS')[source]¶; Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. shells()[source]¶; Returns shells sets to atom map. symbol()[source]¶; The atomic symbol. class CoordValue(fixed=False, computed=False)[source]¶; An abstract class to handle storage of Cartesian coordinate values, which; may be defined in terms of other variables through this mechanism, greatly; simplifying Z-matrix specification, for example. everything()[source]¶. fixed()[source]¶; Get whether the coordinate value is fixed or not. invalidate()[source]¶; Flag the current value as outdated. set_fixed(fixed)[source]¶; Set whether the coordinate value is fixed or not. class NumberValue(value, fixed=False)[source]¶; Specialization of CoordValue that is simply a number to be stored. clone()[source]¶; Returns new, independent NumberValue object. compute()[source]¶; Computes value of coordinate from member data. everything()[source]¶. rset(val)[source]¶; Resets value of coordinate if not fixed. type()[source]¶; Gets specialization type of CoordValue. variable_to_string(pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:116128,hash,hash,116128,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['hash'],['hash']
Security,"(self). copy(self, arg0); Returns a copy of the matrix. dim(self[, h]); Returns the dimensions of the vector per irrep h. dimpi(self); Returns the Dimension object. from_array([name, dim1, dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_list(x). from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get_block(self, slice); Get a vector block. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. print_out(self); Prints the vector to the output file. scale(self, sc); Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set_block(self, slice, block); Set a vector block. to_array([copy, dense]); Converts a Psi4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Attributes Documentation. name¶; The name of the Vector. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. array_interface(self: psi4.core.Vector) → list¶. copy(self: psi4.core.Vector, arg0: psi4.core.Vector) → None¶; Returns a copy of the matrix. dim(self: psi4.core.Vector, h: int = 0) → int¶; Returns the dimensions of the vector per irrep h. dimpi(self: psi4.core.Vector) → psi4.core.Dimension¶; Returns the Dimension object. classmethod from_array(name='New Matrix', dim1=None, dim2=None)¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters. arr (Union[ndarray, List[ndarray]]) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (Union[List, Tuple, Dimension, None]) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.vector.html:1397,access,accessor,1397,psi4manual/1.5.0/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.vector.html,1,['access'],['accessor']
Security,"(self, arg0, arg1, arg2); add string option. add_str_i(self, arg0, arg1, arg2); add string option. get_bool(self, arg0); get boolean option. get_current_module(self); gets current module. get_double(self, arg0); get double option. get_int(self, arg0); get integer option. get_int_vector(self, arg0); get int vector option. get_str(*args, **kwargs); Overloaded function. print_global_options(self); print the global, cross-module options. print_module_options(self); print global and local options prepared for current module. read_globals(self); expert. set_array(self, arg0, arg1); set array option. set_bool(self, arg0, arg1, arg2); set bool option. set_current_module(self, arg0); sets arg0 (all CAPS) as current module. set_double(self, arg0, arg1, arg2); set double option. set_int(self, arg0, arg1, arg2); set int option. set_read_globals(self, arg0); expert. set_str(self, arg0, arg1, arg2); set string option. set_str_i(self, arg0, arg1, arg2); set string option. validate_options(self); validate options for arg0 module. Methods Documentation. add_array(self: psi4.core.Options, arg0: str) → None¶; add array option. add_bool(self: psi4.core.Options, arg0: str, arg1: bool) → None¶; add bool option. add_int(self: psi4.core.Options, arg0: str, arg1: int) → None¶; add int option. add_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; add string option. add_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; add string option. get_bool(self: psi4.core.Options, arg0: str) → bool¶; get boolean option. get_current_module(self: psi4.core.Options) → str¶; gets current module. get_double(self: psi4.core.Options, arg0: str) → float¶; get double option. get_int(self: psi4.core.Options, arg0: str) → int¶; get integer option. get_int_vector(self: psi4.core.Options, arg0: str) → List[int]¶; get int vector option. get_str(*args, **kwargs)¶; Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.options.html:1354,validat,validate,1354,psi4manual/1.3.2/api/psi4.core.options.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.options.html,7,['validat'],['validate']
Security,"(self, arg0, arg1, arg2); add string option. add_str_i(self, arg0, arg1, arg2); add string option. get_bool(self, arg0); get boolean option. get_current_module(self); gets current module. get_double(self, arg0); get double option. get_int(self, arg0); get integer option. get_int_vector(self, arg0); get int vector option. get_str(*args, **kwargs); Overloaded function. print_global_options(self); print the global, cross-module options. print_module_options(self); print global and local options prepared for current module. read_globals(self); expert. set_array(self, arg0, arg1); set array option. set_bool(self, arg0, arg1, arg2); set bool option. set_current_module(self, arg0); sets arg0 (all CAPS) as current module. set_double(self, arg0, arg1, arg2); set double option. set_int(self, arg0, arg1, arg2); set int option. set_read_globals(self, arg0); expert. set_str(self, arg0, arg1, arg2); set string option. set_str_i(self, arg0, arg1, arg2); set string option. validate_options(self); validate options for arg0 module. Methods Documentation. add_array(self: psi4.core.Options, arg0: str) → None¶; add array option. add_bool(self: psi4.core.Options, arg0: str, arg1: bool) → None¶; add bool option. add_int(self: psi4.core.Options, arg0: str, arg1: int) → None¶; add int option. add_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; add string option. add_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; add string option. get_bool(self: psi4.core.Options, arg0: str) → bool¶; get boolean option. get_current_module(self: psi4.core.Options) → str¶; gets current module. get_double(self: psi4.core.Options, arg0: str) → float¶; get double option. get_int(self: psi4.core.Options, arg0: str) → int¶; get integer option. get_int_vector(self: psi4.core.Options, arg0: str) → list[int]¶; get int vector option. get_str(*args, **kwargs)¶; Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Options.html:1352,validat,validate,1352,psi4manual/master/api/psi4.core.Options.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Options.html,1,['validat'],['validate']
Security,"(self: psi4.core.Wavefunction) → psi4.core.SOBasisSet¶; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of singly occupied orbitals per irrep. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. to_file(filename=None)¶; Converts a Wavefunction object to a base class. Parameters. wfn (Wavefunction) – A Wavefunction or inherited class; filename (Optional[str]) – An optional filename to write the data to. Returns; A dictionary and NumPy representation of the Wavefunction. Return type; dict. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns; Whether some form of DIIS is enabled during SCF. Return type; bool. variable(key)¶; Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. Returns; Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles) are returned as numpy.ndarray of natural dimensionality.; Other array variables are returned as Matrix and may have an extra dimension with symmetry information. Return type; float or numpy.ndarray or Matrix. Parameters. cls (psi4.core.Wavefunction) – ; key (str) – . Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:34965,Validat,ValidationError,34965,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,5,['Validat'],['ValidationError']
Security,"(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:32273,validat,validation,32273,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['validat'],['validation']
Security,"(str(castdf)):; castdf = False. if castdf:; core.set_local_option('SCF', 'SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, (unicode, str)):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If we force c1 copy the active molecule; if use_c1:; scf_molecule.update_geometry(); if scf_molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); scf_molecule = scf_molecule.clone(); scf_molecule.reset_point_group('c1'); scf_molecule.fix_orientation(True); scf_molecule.fix_co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:31359,Validat,ValidationError,31359,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:34964,Validat,ValidationError,34964,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,") 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """""". ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function; from __future__ import absolute_import. import re; import os; import sys; import random; import pubchem; from p4util.exceptions import *. # inputfile contents to be preserved from the processor; literals = {}. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; message = ('Unsupported syntax:\n\n%s\n\n' % (line)); raise TestComparisonError(message). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if dollar:; # This is a python variable, make sure that it starts with a letter; if re.match(r'^[A-Za-z][\w]*', val):; return val; else:; message = (""Invalid Python variable: %s"" % (val)); raise TestComparisonError(message); elif re.match(r'^-?\d+\.?\d*(?:[E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html:1263,access,access,1263,psi4manual/1.0.0/_modules/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/inputparser.html,1,['access'],['access']
Security,") == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap inst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:37142,Validat,ValidationError,37142,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:131227,Validat,ValidationError,131227,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,6,['Validat'],['ValidationError']
Security,") Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3 - (X-1)^3}$; # Solution equation in LaTeX: $\beta = \frac{E_{corl}^{X} - E_{corl}^{X-1}}{X^{-3} - (X-1)^{-3}}$; [docs]def corl_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'corl', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'corl', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; zHI = NEED['HI']['f_zeta']; eLO = NEED['LO']['f_energy']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; energypiece = (eHI * zHI ** 3 - eLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (eHI - eLO) / (zHI ** (-3) - zLO ** (-3)). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:79403,Validat,ValidationError,79403,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,") from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type:; dict. fctldash¶; If dashparams for dashlevel corresponds to a defined,; named, untweaked “functional-dashlevel” set, then that; functional. Otherwise, empty string. Type:; str. description¶; Tagline for dispersion dashlevel. Type:; str. dashlevel_citation¶; Literature reference for dispersion dashlevel in general,; not necessarily for dashparams. Type:; str. dashparams_citation¶; Literature reference for dispersion parameters, if dashparams; corresponds to a defined, named, untweaked “functional-dashlevel”; set with a citation. Otherwise, empty string. Type:; str. dashcoeff_supplement¶; See description in qcengine.programs.empirical_dispersion_resources.from_arrays. Used; here to “bless” the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; qcengine.programs.empirical_dispersion_resources.dashcoeff itself for purposes of; validating fctldash. Type:; dict. engine¶; {‘libdisp’, “s-dftd3”, ‘dftd3’, ‘nl’, ‘mp2d’, “dftd4”}; Compute engine for dispersion. One of Psi4’s internal libdisp; library, external Grimme or Beran projects, or nl. Type:; str. disp¶; Only present for engine =libdisp. Psi4 class instance prepared; to compute dispersion. Type:; Dispersion. ordered_params¶; Fixed-order list of relevant parameters for dashlevel. Matches; DISPERSION CORRECTION ENERGY ordering. Used for printing. Type:; list. Parameters:. name_hint (Optional[str]) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (Optional[str]) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in das",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dftd3.html:18314,validat,validating,18314,psi4manual/master/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/master/dftd3.html,6,['validat'],['validating']
Security,") from name_hint and/or; dashcoeff_supplement and/or user param_tweaks. Type:; dict. fctldash¶; If dashparams for dashlevel corresponds to a defined,; named, untweaked “functional-dashlevel” set, then that; functional. Otherwise, empty string. Type:; str. description¶; Tagline for dispersion dashlevel. Type:; str. dashlevel_citation¶; Literature reference for dispersion dashlevel in general,; not necessarily for dashparams. Type:; str. dashparams_citation¶; Literature reference for dispersion parameters, if dashparams; corresponds to a defined, named, untweaked “functional-dashlevel”; set with a citation. Otherwise, empty string. Type:; str. dashcoeff_supplement¶; See description in qcengine.programs.empirical_dispersion_resources.from_arrays. Used; here to “bless” the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; qcengine.programs.empirical_dispersion_resources.dashcoeff itself for purposes of; validating fctldash. Type:; dict. engine¶; {‘libdisp’, “s-dftd3”, ‘dftd3’, ‘nl’, ‘mp2d’, “dftd4”}; Compute engine for dispersion. One of Psi4’s internal libdisp; library, external Grimme or Beran projects, or nl. Type:; str. disp¶; Only present for engine =libdisp. Psi4 class instance prepared; to compute dispersion. Type:; Dispersion. ordered_params¶; Fixed-order list of relevant parameters for dashlevel. Matches; DISPERSION CORRECTION ENERGY ordering. Used for printing. Type:; list. Parameters:. name_hint (str) – Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; dashcoeff[dashlevel][functional-without-dashlevel] or; dashcoeff_supplement[dashlevel][functional-with-dashlevel]; can be overwritten via param_tweaks.; level_hint (str) – Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or “alias” or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html:1961,validat,validating,1961,psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.EmpiricalDispersion.html,2,['validat'],['validating']
Security,")' + NUMBER + '(?:\s*)', re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). elif xyzC.match(text[2 + i]):. fileAtom = int(float(xyzC.match(text[2 + i]).group(1))); fileX = float(xyzC.match(text[2 + i]).group(2)); fileY = float(xyzC.match(text[2 + i]).group(3)); fileZ = float(xyzC.match(text[2 + i]).group(4)). # Check that the atomic number is valid; if not fileAtom in z2el:; raise ValidationError('Illegal atom symbol in geometry specification: %d' % (fileAtom)). # Add it to the molecule.; instance.add_atom(fileAtom, fileX, fileY, fileZ, z2el[fileAtom], z2mass[fileAtom], fileAtom). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:4694,Validat,ValidationError,4694,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,")' + NUMBER + '(?:\s*)', re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). elif xyzC.match(text[2 + i]):. fileAtom = int(float(xyzC.match(text[2 + i]).group(1))); fileX = float(xyzC.match(text[2 + i]).group(2)); fileY = float(xyzC.match(text[2 + i]).group(3)); fileZ = float(xyzC.match(text[2 + i]).group(4)). # Check that the atomic number is valid; if not fileAtom in z2el:; raise ValidationError('Illegal atom symbol in geometry specification: %d' % (fileAtom)). # Add it to the molecule.; instance.add_atom(fileAtom, fileX, fileY, fileZ, z2el[fileAtom], z2mass[fileAtom], fileAtom). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d.\n%s:%s"" %; (i + 3, xyzfilename, text[i + 2])); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3,; text[i + 2])). # We need t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:7359,Validat,ValidationError,7359,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,")', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']); or core.get_option('CCTRANSORT', 'SEMICANONICAL'))):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn); if core.get_global_option('PE'):; ccwfn.pe_state = ref_wfn.pe_state. if name == 'a-ccsd(t)':; core.cchbar(ref_wfn); lambdawfn = core.cclambda(ref_wfn); for k, v in lambdawfn.variables().items():; ccwfn.set_variable(k, v). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') not in [""FALSE"", ""0""]:; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:93427,Validat,ValidationError,93427,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,")', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). reference = core.get_option('SCF', 'REFERENCE'); if core.get_global_option('CC_TYPE') != ""CONV"":; raise ValidationError(""""""CEPA methods from FNOCC module require 'cc_type conv'.""""""). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron proper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:162344,Validat,ValidationError,162344,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,")', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). reference = core.get_option('SCF', 'REFERENCE'); if core.get_global_option('CC_TYPE') != ""CONV"":; raise ValidationError(""""""CEPA methods from FNOCC module require 'cc_type conv'.""""""). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:170955,Validat,ValidationError,170955,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,")). ret = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(self: core.Dimension) -> Tuple[int]:; """"""Serializes :class:`~psi4.core.Dimension` to a tuple."""""". if isinstance(self, (tuple, list)):; return tuple(self). irreps = self.n(); ret = []; for i in range(irreps):; ret.append(self[i]); return tuple(ret). def _dimension_iter(dim) -> Iterator[int]:; """"""; Provides an iterator class for the Dimension object. Example; -------; >>> dim = psi4.core.Dimension(...); >>> list(dim). """"""; for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. # General functions for NumPy array manipulation; [docs]def block_diagonal_array(*args: List[np.ndarray]) -> np.ndarray:; """"""; Convert square NumPy array to a single block diagonal array.; Mimic of SciPy's :func:`scipy.linalg.block_diag`. Parameters; ----------; args; Arbitrary number of square arrays.; """""". # Validate the input matrices.; dim = 0; for matrix in args:; try:; shape = matrix.shape; dim += shape[0]; except (AttributeError, TypeError):; raise ValidationError(""Cannot construct block diagonal from non-arrays.""); if len(shape) != 2:; raise ValidationError(""Cannot construct block diagonal from non-2D arrays.""); if shape[0] != shape[1]:; raise ValidationError(""Cannot construct block diagonal from non-square arrays.""). # If this is too slow, try a sparse matrix?; block_diag = np.zeros((dim, dim)); start = 0; for matrix in args:; next_block = slice(start, start + matrix.shape[0]); block_diag[next_block, next_block] = matrix; start += matrix.shape[0]. return block_diag. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.numpy_helper. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:17584,Validat,Validate,17584,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],"['Validate', 'ValidationError']"
Security,")); data.update(scf_wfn.Cb().np_write(None, prefix=""Cb"")). Ca_occ = scf_wfn.Ca_subset(""SO"", ""OCC""); data.update(Ca_occ.np_write(None, prefix=""Ca_occ"")). Cb_occ = scf_wfn.Cb_subset(""SO"", ""OCC""); data.update(Cb_occ.np_write(None, prefix=""Cb_occ"")). data[""reference""] = core.get_option('SCF', 'REFERENCE'); data[""nsoccpi""] = scf_wfn.soccpi().to_tuple(); data[""ndoccpi""] = scf_wfn.doccpi().to_tuple(); data[""nalphapi""] = scf_wfn.nalphapi().to_tuple(); data[""nbetapi""] = scf_wfn.nbetapi().to_tuple(); data[""symmetry""] = scf_molecule.schoenflies_symbol(); data[""BasisSet""] = scf_wfn.basisset().name(); data[""BasisSet PUREAM""] = scf_wfn.basisset().has_puream(); np.savez(write_filename, **data); extras.register_numpy_file(write_filename). if do_timer:; core.tstop(). optstash.restore(); return scf_wfn. def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """""". if (core.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCFT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCFT_TYPE"") == ""DF""):; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCFT"",; core.get_global_option(""DF_BASIS_DCFT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCFT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn). dcft_wfn = core.dcft(ref_wfn); return dcft_wfn. def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:40270,Validat,ValidationError,40270,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,")); proc.append('df-hf,'); proc.append('df-ks,'); proc.append('sapt; monomerA'); options['DF-HF,']['OPTIONS']['value'] = """"""basis=jkfit,locorb=0; start,atdens; save,1101.2""""""; options['DF-KS,']['OPTIONS']['value'] = """"""lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,1101.2; save,2101.2"""""". proc.append(mol.extract_fragments(2, 1).format_molecule_for_molpro()); proc.append('df-hf'); proc.append('df-ks'); proc.append('sapt; monomerB'); options['DF-HF']['OPTIONS']['value'] = """""",basis=jkfit,locorb=0; start,atdens; save,1102.2""""""; options['DF-KS']['OPTIONS']['value'] = """""",lhf,df_basis=dflhf,basis_coul=jkfitb,basis_exch=jkfitb; dftfac,1.0; start,1102.2; save,2102.2"""""". proc.append(mol.format_molecule_for_molpro()); proc.append('sapt; intermol'); options['SAPT; INTERMOL']['OPTIONS']['value'] = """""",saptlevel=3,ca=2101.2,cb=2102.2,icpks=0,fitlevel=3,nlexfac=0.0,cfac=0.0; dfit,basis_coul=jkfit,basis_exch=jkfit,cfit_scf=3"""""". else:; raise ValidationError(""""""Requested Cfour computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options, proc. procedures = {; 'energy': {; 'mp2c' : muster_modelchem,; 'ccsd(t)-f12' : muster_modelchem,; 'ccsd(t)-f12c' : muster_modelchem,; 'ccsd(t)-f12-optri' : muster_modelchem,; 'ccsd(t)-f12-cabsfit' : muster_modelchem,; #'sapt0' : muster_modelchem,; #'sapt2+' : muster_modelchem,; #'sapt2+(3)' : muster_modelchem,; #'sapt2+3(ccd)' : muster_modelchem,; }; }. qcmtdIN = procedures['energy']. [docs]def psi4_list():; """"""Return an array of Psi4 methods with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:23166,Validat,ValidationError,23166,psi4manual/1.0.0/_modules/qcdb/molpro2.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html,1,['Validat'],['ValidationError']
Security,")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = core.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:148026,Validat,ValidationError,148026,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,")); return returnstring. # Return parameter list for Dispersion.build function; # d2p4: name=-D2 s6=s6 p1=None p2=None p3=None (damping parameter fixed in Dispersion class); # d2gr: name=-D2GR s6=s6 p1=alpha6 p2=None p3=None; # d3zero: name=-D3ZERO s6=s6 p1=sr6 p2=s8 p3=alpha6; # d3bj: name=-D3BJ s6=s6 p1=a1 p2=s8 p3=a2. # d3mzero: name=-D3M s6=s6 p1=sr6 p2=s8 beta alpha6=14.0 version=5; # d3mbj: name=-D3MBJ s6=s6 p1=a1 p2=s8 p3=a2; elif mode.lower() == 'psi4':; if dashlvleff == 'd2p4':; return '-D2', \; dashcoeff[dashlvleff][func]['s6'], \; 0.0, 0.0, 0.0; elif dashlvleff == 'd2gr':; return '-D2GR', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['alpha6'], \; 0.0, 0.0; elif dashlvleff == 'd3zero':; return '-D3ZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['alpha6']; elif dashlvleff == 'd3bj':; return '-D3BJ', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['a1'], \; dashcoeff[dashlvleff][func]['a2']; elif dashlvleff == 'd3mzero':; return '-D3MZERO', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['sr6'], \; dashcoeff[dashlvleff][func]['beta']; elif dashlvleff == 'd3mbj':; return '-D3MBJ', \; dashcoeff[dashlvleff][func]['s6'], \; dashcoeff[dashlvleff][func]['s8'], \; dashcoeff[dashlvleff][func]['a1'], \; dashcoeff[dashlvleff][func]['a2']; else:; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). else:; raise ValidationError(""""""-D return format %s is not available. Choose 'psi4' or 'dftd3'.""""""). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html:14890,Validat,ValidationError,14890,psi4manual/1.0.0/_modules/qcdb/dashparam.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html,2,['Validat'],['ValidationError']
Security,"), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to inp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:6571,Validat,ValidationError,6571,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,3,['Validat'],['ValidationError']
Security,"), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ndarray; Eponymous function applied to input zetas and val",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:6537,Validat,ValidationError,6537,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:6565,Validat,ValidationError,6565,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in [""omp2.5""]:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['mp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccd']:; core.set_local_option('DFOCC', '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:59081,Validat,ValidationError,59081,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"). For example excitation energies for ADC(2) are thus; available via the variable ADC(2) excitation energies. Ground state energy terms like MP2 correlation energy, MP3 correlation energy,; MP2 total energy, MP3 total energy, current correlation energy and current energy.; number of iterations: The number of iterations the iterative solver required to converge.; number of excited states: The number of excited states, which were computed.; <method> excitation energies: The obtained excitation energies as a Matrix.; MP2 dipole X and the other components: Ground state dipole moments at MP(2) level.; <method> transition dipoles, <method> oscillator strengths,; <method> rotational strengths and <method> dipoles:; The respective properties as Matrix. The following attribute is set on returned wavefunctions:. adcc_state: The adcc.ExcitedStates; object used by adcc to store the ADC(n) excitation energies and all precomputed data; in the format used by adcc.; Provides direct access to analysis and plotting capabilities from adcc.; For example adcc_state.plot_spectrum() plots a broadened excited states spectrum; in matplotlib. See the adcc calculations documentation; for details. Tips for convergence issues.; If you encounter convergence issues inside adcc, the following parameters; are worth tweaking:. MAX_NUM_VECS: Specifies the maximal number of subspace vectors; in the Jacobi-Davidson scheme before a restart occurs. The defaults are usually; good, but do not be shy to increase this value if you encounter convergence problems.; NUM_GUESSES: By default adcc uses twice as many guess vectors as; states to be computed. Sometimes increasing this value by a few vectors can be helpful.; If you encounter a convergence to zero eigenvalues, than decreasing this parameter might; solve the problems. Built-in ADC(2) code¶; Code author: Masaaki Saitow; Section author: Masaaki Saitow; The ADC code built into PSI4 is capable of ADC(2) computations; of singlet excited states only.; It make",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/adc-1.html:11373,access,access,11373,psi4manual/1.4.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/adc-1.html,4,['access'],['access']
Security,"). keywords = {k.lower(): v for k, v in prepare_options_for_set_options().items()}; if function_kwargs is not None:; keywords[""function_kwargs""] = function_kwargs. kw_basis = keywords.pop(""basis"", None); basis = basis or kw_basis. resi = AtomicInput(; **{; ""driver"": driver,; ""extras"": {; ""wfn_qcvars_only"": True,; },; ""model"": {; ""method"": method,; ""basis"": basis,; },; ""keywords"": keywords,; ""molecule"": molecule.to_schema(dtype=2),; ""provenance"": provenance_stamp(__name__),; }). return resi. [docs]def mat2arr(mat: core.Matrix) -> List[List[float]]:; """"""Convert Matrix to List. Parameters; ----------; mat; |PSIfour| matrix. Should be flat with respect to symmetry. Returns; -------; List[List[float]]; Pure Python representation of `mat`. """"""; warnings.warn(; ""Using `psi4.driver.p4util.mat2arr` instead of `MatrixInstance.to_array().tolist()` is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2). if mat.rowdim().n() != 1:; raise ValidationError('Cannot convert Matrix with symmetry.'); arr = []; for row in range(mat.rowdim()[0]):; temp = []; for col in range(mat.coldim()[0]):; temp.append(mat.get(row, col)); arr.append(temp); return arr. [docs]def expand_psivars(; pvdefs: Dict[str, Dict[str, Union[List[str], Callable]]],; verbose: Optional[int] = None):; """"""From rules on building QCVariables from others, set new variables to; P::e if all the contributors are available. Parameters; ----------; pvdefs; Dictionary with keys with names of QCVariables to be created and values; with dictionary of two keys: 'args', the QCVariables that contribute to; the key and 'func', a function (or lambda) to combine them.; verbose; Control print level. If unspecified (None), value taken from; :term:`PRINT <PRINT (GLOBALS)>`. Status printing when verbose > 2. Examples; --------; >>> pv1 = dict(); >>> pv1['SAPT CCD DISP'] = {'func': lambda x: x[0] * x[1] + x[2] + x[3] + x[4],; 'args': ['SAPT EXCHSCAL', 'SAPT EXCH-DISP20 ENERGY', 'SAPT DISP2(CCD) ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:17791,Validat,ValidationError,17791,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"). ndisp = len(displacements); print("""""" %d displacements needed."""""" % ndisp); gradients = []; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """"""# to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """"""# has produced a number of input files (FREQ-*.in) for individual components\n""""""; instructionsO += """"""# and a single input file (FREQ-master.in) with a frequency(mode='reap') command.\n""""""; instructionsO += """"""# These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """"""# rather than normal input. Follow the instructions below (repeated in FREQ-master.in)\n""""""; instructionsO += """"""# to continue.\n#\n""""""; instructionsO += """"""# Alternatively, a single-job execution of the hessian may be accessed through\n""""""; instructionsO += """"""# the frequency wrapper option mode='continuous'.\n#\n""""""; core.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this frequency computation.\n#\n""""""; instructionsM += """"""# (1) Run all of the FREQ-*.in input files on any variety of computer architecture.\n""""""; instructionsM += """"""# The output file names must be as given below (these are the defaults when executed\n""""""; instructionsM += """"""# as `psi4 FREQ-1.in`, etc.).\n#\n""""""; for rgt in range(ndisp):; pre = 'FREQ-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# FREQ-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the frequency computation in its output file.\n#\n""""""; instructionsM += """"""# psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:69153,access,accessed,69153,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['access'],['accessed']
Security,"). ndisp = len(displacements); print("""""" %d displacements needed."""""" % ndisp); gradients = []; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """"""# to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """"""# has produced a number of input files (FREQ-*.in) for individual components\n""""""; instructionsO += """"""# and a single input file (FREQ-master.in) with a frequency(mode='reap') command.\n""""""; instructionsO += """"""# These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """"""# rather than normal input. Follow the instructions below (repeated in FREQ-master.in)\n""""""; instructionsO += """"""# to continue.\n#\n""""""; instructionsO += """"""# Alternatively, a single-job execution of the hessian may be accessed through\n""""""; instructionsO += """"""# the frequency wrapper option mode='continuous'.\n#\n""""""; psi4.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this frequency computation.\n#\n""""""; instructionsM += """"""# (1) Run all of the FREQ-*.in input files on any variety of computer architecture.\n""""""; instructionsM += """"""# The output file names must be as given below (these are the defaults when executed\n""""""; instructionsM += """"""# as `psi4 FREQ-1.in`, etc.).\n#\n""""""; for rgt in range(ndisp):; pre = 'FREQ-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# FREQ-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the frequency computation in its output file.\n#\n""""""; instructionsM += """"""# psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:67173,access,accessed,67173,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['access'],['accessed']
Security,"). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. # Establish method for reference energy; if do_corl and cbs_corl_wfn.startswith('c4-'):; default_scf = 'c4-hf'; else:; default_scf = 'hf'; cbs_scf_wfn = kwargs.pop('scf_wfn', default_scf).lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # ... resume correlation logic; if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:39416,Validat,ValidationError,39416,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,").group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] def print_out(self):; """"""Print the molecule.; (method name in libmints is print). >>> H2OH2O.print_out(); Geometry (in Angstrom), charge = -2, multiplicity = 3:; Center X Y Z; ------------ ----------------- ----------------- -----------------; O -1.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:22498,Validat,ValidationError,22498,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['Validat'],['ValidationError']
Security,"):; 				self.kw[i]=deepcopy(templ.kw[i]); 		for i in templ.sect:; 			if not self.sect.has_key(i):; 				self.sect[i]={None : deepcopy(templ.sect[i][None])}; 			for tag in self.sect[i]:; 				self.sect[i][tag].equalize(templ.sect[i][None]). [docs]	def run_callbacks(self, templ):; 		if templ.callback is not None:; 			templ.callback(self); 		for i in templ.kw:; 			cb=templ.kw[i]; 			if cb.callback is not None:; 				cb.callback(self.kw[i]); 		for i in templ.sect:; 			for tag in self.sect[i]:; 				self.sect[i][tag].run_callbacks(templ.sect[i][None]). #verify!; [docs]	def sanity_check(self,path=None):; 		dlm=''; 		if path is None:; 			path=''; 		else:; 			path=path+dlm+self.name; 			dlm='.'; 		if self.req and not self.isset:; 			print '>>> Required section not set: %s \n' % (path); 			sys.exit(0); 		for i in self.kw:; 			i.sanity_check(path); 		for i in self.sect:; 			for j in self.sect[i]:; 				j.sanity_check(path). 	#cross-validate against a template; [docs]	def xvalidate(self,templ,path=None):; 		dlm=''; 		if path is None:; 			path=''; 		else:; 			path=path+dlm+self.name; 			dlm='.'; 		if templ.req and not self.isset:; 			print '>>> Required section not set: %s \n' % path; 			sys.exit(1); 		for i in self.kw:; 			j=templ.fetch_kw(i) ; 			if j is None:; 				print '>>> Invalid keyword: %s ' % (path+dlm+i); 				sys.exit(1); 			self.kw[i].xvalidate(j,path); 		for i in self.sect:; 			j=templ.fetch_sect(i) ; 			if j is None:; 				print '>>> Invalid section: %s ' % (path+dlm+i); 				sys.exit(1); 			for tag in self.sect[i]:; 				self.sect[i][tag].xvalidate(j,path). 	def __str__(self):; 		nsect=0; 		for i in self.sect:; 			for tag in self.sect[i]:; 				nsect=nsect+1; 		nkw=0; 		for i in self.kw:; 			nkw=nkw+1; 		; 		s=""SECT %s %d %s\n"" % (self.name, nsect, self.isset); 		if self.tag is not None:; 			s=s+""TAG T KW %d\n"" % (nkw); 			s=s+self.tag+'\n'; 		else:; 			s=s+""TAG F KW %d\n"" % (nkw). 		for i in self.kw:; 			s=s+str(self.kw[i]); 		for i in self.sect:; 			for tag in self.sect[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/pcmgetkw.html:6101,validat,validate,6101,psi4manual/4.0b5/_modules/pcmgetkw.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pcmgetkw.html,1,['validat'],['validate']
Security,"):; PsiMod.set_local_option('FNOCC','RUN_MP4', True); PsiMod.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES', False); PsiMod.set_local_option('FNOCC','COMPUTE_TRIPLES', False); PsiMod.set_local_option('FNOCC','NAT_ORBS', True); elif (lowername == 'fnocc-mp') and (level == 3):; PsiMod.set_local_option('FNOCC','RUN_MP3', True); elif (lowername == 'fnocc-mp') and (level == 4):; PsiMod.set_local_option('FNOCC','RUN_MP4', True); PsiMod.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES', True); PsiMod.set_local_option('FNOCC','COMPUTE_TRIPLES', True). # override symmetry for fno-cc; if (PsiMod.get_option('FNOCC','NAT_ORBS')):; molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' FNOCC does not make use of molecular symmetry, further calculations in C1 point group.\n'). # throw an exception for open-shells; if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). # scf; scf_helper(name,**kwargs). # if the scf type is df, then the ao integrals were never generated.; if PsiMod.get_option('SCF','SCF_TYPE') == 'DF' :; mints = PsiMod.MintsHelper(); mints.integrals(). # if this is not cim or FNO-CC, run transqt2. otherwise, libtrans will be used; if PsiMod.get_option('FNOCC','NAT_ORBS') == False and PsiMod.get_option('FNOCC','RUN_MP2') == False:; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); PsiMod.transqt2(). # run ccsd; PsiMod.fnocc(). # set current correlation energy and total energy. only need to treat mpn here.; if (lowername == 'fnocc-mp') and (level == 3):; emp3 = PsiMod.get_variable(""MP3 TOTAL ENERGY""); cemp3 = PsiMod.get_variable(""MP3 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp3); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp3); elif ( lowername == 'fno-mp3' ):; emp3 = PsiMod.get_variable(""MP3 TOTAL ENERGY""); cemp3 = PsiMod.get_variable(""MP3 C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:73738,Validat,ValidationError,73738,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"):; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(val)); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). def _core_wavefunction_set_variable(cls, key, val):; if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(val)); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). def _core_del_variable(key):; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls, key):; if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables():; return {**core.scalar_variables(), **core.array_variables()}. def _core_wavefunction_variables(cls):; return {**cls.scalar_variables(), **cls.array_variables()}. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:19775,Validat,ValidationError,19775,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs] @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs] @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs] def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of task computers to instantiate and add to self.task_list. Usually :class:`~psi4.driver.AtomicComputer` but may be other when wrappers are layered.; mc_level_idx; Position in field self.nbodies_per_mc_level used to obtain ``nbodies``, the list of n-body; levels (e.g., `[1]` or `[1, 2]` or `[""supersystem""]`) to which the modelchem specified in **kwargs** applies.; That is, `nbodies = self.nbodies_per_mc_level[mc_level_idx]`.; Note the natural 1-indexing of ``nbodies`` _contents_, so `[1]` covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, `mc_level_lbl = mc_level_idx + 1`; Formerly nlevel as in `nbody = self.nbody_list[nbody_level=nlevel]`.; kwargs; Other arguments for initializing **mb_computer**. In particular, specifies model chemistry. Returns; -------; count : int; Number of new tasks planned by this call.; Formerly, didn't include",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:36268,access,accessed,36268,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['access'],['accessed']
Security,"):; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute dftd3; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:47553,Validat,ValidationError,47553,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irrepped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irrepped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:4819,Validat,ValidationError,4819,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],['ValidationError']
Security,"); >>> vec = psi4.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; 1; 2>>> new_mat = psi4.Matrix.from_array(mat); >>> new_vec = psi4.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; 1; 2; 3; 4; 5; 6; 7; 8>>> dim = psi4.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/numpy-1.html:1843,access,access,1843,psi4manual/1.2.1/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/numpy-1.html,4,['access'],['access']
Security,"); >>> vec = psi4.Vector(3). # Convert to a NumPy array; >>> numpy_mat = np.array(mat); >>> numpy_vec = np.array(vec). Here the data is copied into new NumPy arrays. NumPy arrays can be converted; back to PSI4 objects using the from_array interface:; 1; 2>>> new_mat = psi4.Matrix.from_array(mat); >>> new_vec = psi4.Vector.from_array(vec). NumPy Views¶; Copying the data between NumPy and Psi4 objects can lead to excessive data; movement and convoluted code. Here we introduce the idea of “Views” where the; same data can be viewed by multiple objects. However, this can lead to very; subtle errors if used incorrectly and care needs to be taken when using these; views. Views can be created in two ways:; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. Warning; The following will lead to reference errors: view =; psi4.Matrix(3, 3).np. Here, the Python garbage collection deletes the Matrix; object, the view then points to deleted data resulting in the view effectively; reading random data. As a general rule, never assign the .nph or .np; accessors. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; 1; 2; 3; 4; 5; 6; 7; 8>>> dim = psi4.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/numpy-1.html:1883,access,access,1883,psi4manual/1.1.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/numpy-1.html,2,['access'],['access']
Security,"); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:84992,Validat,ValidationError,84992,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"); core.set_global_option(""PRINT"", 0). # If we force c1 copy the active molecule; scf_molecule.update_geometry(); core.print_out(""""""\n A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n\n""""""); c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); c1_basis = core.BasisSet.build(c1_molecule, ""ORBITAL"", core.get_global_option('BASIS'), quiet=True); tmp = scf_wfn.c1_deep_copy(c1_basis); c1_jkbasis = core.BasisSet.build(c1_molecule, ""DF_BASIS_SCF"",; core.get_global_option(""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'), quiet=True); tmp.set_basisset(""DF_BASIS_SCF"", c1_jkbasis); c1_optstash.restore(); return tmp. def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """""". if (core.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCFT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCFT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCFT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCFT"",; core.get_global_option(""DF_BASIS_DCFT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCFT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dcft_wfn = core.dcft(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCFT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dcft_wfn = core.dcft(ref_wfn). return dcf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:42257,Validat,ValidationError,42257,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_global_option('SCF_TYPE') not in ['CD', 'DISK_DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). fnocc_wfn = cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:120306,Validat,ValidationError,120306,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_global_option('SCF_TYPE') not in ['CD', 'DISK_DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_glo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:154028,Validat,ValidationError,154028,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at1, at2, bondorder), ...]: {}"".format(connectivity); ). if units.capitalize() in [""Angstrom"", ""Bohr""]:; molinit[""units""] = units.capitalize(); else:; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; el",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:14727,Validat,ValidationError,14727,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"); if not self.haschanged_local:; core.revoke_local_option_changed(self.module, self.option). [docs]class OptionsState():; """"""Store multiple :py:func:`OptionState` objects.; Use in driver functions to collect several keywords before altering them,; then restore them before function return. Parameters; ----------; largs; Specify which keywords to store value and has_changed state. Examples; --------; >>> optstash = OptionsState(; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). """""". def __init__(self, *largs: List[List[str]]):; self.data = {}; for item in largs:; self.add_option(item). [docs] def add_option(self, item: List[str]):; """"""Store info for another keyword, `item`. Parameters; ----------; item; A one-membered list with a global keyword or a two-membered list; with a module keyword and module. """"""; if len(item) == 2:; key = (item[1], item[0]); elif len(item) == 1:; key = (item[0], ); else:; raise ValidationError(; 'Each argument to OptionsState should be an array, the first element of which is the module scope and the second element of which is the module name. Bad argument: %s'; % (item)). if key in self.data:; raise ValidationError(; 'Malformed options state, duplicate key adds of ""{}"". This should not happen, please raise a issue on github.com/psi4/psi4'.format(key)); else:; self.data[key] = OptionState(*key). def __str__(self):; text = ''; for key, item in self.data.items():; text += str(item); return text. [docs] def restore(self):; """"""Restore value and has_changed status of each keyword to saved condition.""""""; for key, item in self.data.items():; item.restore(). [docs]@contextmanager; def OptionsStateCM(osd) -> Iterator[None]:; """"""Return a context manager that will collect the state (value and changed; status) of a list of keywords `osd` that can initialize; :py:class:`OptionsState` on entry to the with-statement and restore the; collected state when exiting the with-statement. """"""; oso = OptionsState(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/optproc.html:4616,Validat,ValidationError,4616,psi4manual/1.7.x/_modules/psi4/driver/p4util/optproc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/optproc.html,1,['Validat'],['ValidationError']
Security,"); raise ConvergenceError(""""""geometry optimization"""""", n - 1). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Hessian: Cannot specify bsse_type for hessian yet.""). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. if gradient_type != 'conventional':; raise ValidationError(""Hessian: Does not yet support more advanced input or custom functions.""). lowername = name.lower(). # Check if this is a CBS extrapolation; if ""/"" in lowername:; return driver_cbs._cbs_gufunc('hessian', lowername, **kwargs). return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:64455,Validat,ValidationError,64455,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_MAXITER', False); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:72824,Validat,ValidationError,72824,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False. @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationError('ERROR: d() only defined for Vector3\n'); eBA = sub(a2, a1); eDC = sub(a4, a3); eCB = sub(a3, a2); CBNorm = norm(eCB); DCxCB = cross(eDC, eCB); CBxBA = cross(eCB, eBA); return -1.0 * math.atan2(CBNorm * dot(eDC, CBxBA), dot(DCxCB, CBxBA)). [docs] def is_computed(self):; """"""Whether the current atom's coordinates are up-to-date.""""""; return self.computed. [docs] def is_equivalent_to(self, other):; """"""Whether this atom has the same mass and ghost status as atom *other*.; Unlike the libmints version, this does not compare basisset assignment. """"""; if other.PYZ != self.PYZ:; return False; if other.PYmass != self.PYmass:; return False; if other.ghosted != self.ghosted:; return False; return True. [docs] def is_ghosted(self):; """"""Whether the current atom is ghosted or not.""""""; return self.ghosted. [docs] def set_ghosted(self, gh):; """"""Flag the atom as either ghost or real.""""""; self.ghosted = gh. [docs] def Z(self):; """"""The nuclear charge of the current atom (0 if ghosted).""""""; if self.ghosted:; return 0.0; else:; return self.PYZ. [docs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html:5888,Validat,ValidationError,5888,psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintscoordentry.html,3,['Validat'],['ValidationError']
Security,")[source]¶; Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. pubchem¶. class PubChemObj(cid, mf, iupac)[source]¶. getCartesian()[source]¶; Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. getMoleculeString()[source]¶; Function to obtain a molecule string through; getCartesian() or fail. getSDF()[source]¶; Function to return the SDF (structure-data file) of the PubChem object. getXYZFile()[source]¶; Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. name()[source]¶; Function to return the IUPAC name of the PubChem object. getPubChemResults(name)[source]¶; Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. psiexceptions¶; Module with non-generic exceptions classes. exception PsiException[source]¶; Error class for Psi. exception ValidationError(msg)[source]¶; Error called for problems with the input file. Prints; error message msg to standard output stream and output file. frac¶. frac_nuke(mol, **kwargs)[source]¶. frac_traverse(mol, **kwargs)[source]¶. ip_fitting(mol, omega_l, omega_r, **kwargs)[source]¶. molutil¶; Module with utility functions that act on molecule objects. BFS(self)[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. activate(mol)[source]¶; Function to set molecule object mol as the current active molecule. dynamic_variable_bind(cls)[source]¶; Function to dynamically add extra members to; the PsiMod.Molecule class. extract_cluster_indexing(mol, cluster_size=0)[source]¶; Function to returns a LIST of all subclusters of the molecule mol of; real size cluster_size. If cluster_size = 0, returns all possible; combinations of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:5848,Validat,ValidationError,5848,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['Validat'],['ValidationError']
Security,")[source]¶; Function to wrap anything that looks like a string in quotes; and to remove leading dollar signs from python variables. pubchem¶. class PubChemObj(cid, mf, iupac)[source]¶. getCartesian()[source]¶; Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. getMoleculeString()[source]¶; Function to obtain a molecule string through; getCartesian() or fail. getSDF()[source]¶; Function to return the SDF (structure-data file) of the PubChem object. getXYZFile()[source]¶; Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. name()[source]¶; Function to return the IUPAC name of the PubChem object. getPubChemResults(name)[source]¶; Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. psiexceptions¶; Module with non-generic exceptions classes. exception PsiException[source]¶; Error class for Psi. exception ValidationError(msg)[source]¶; Error called for problems with the input file. Prints; error message msg to standard output stream and output file. frac¶. frac_nuke(mol, **kwargs)[source]¶. frac_traverse(mol, **kwargs)[source]¶. ip_fitting(mol, omega_l, omega_r, **kwargs)[source]¶. molutil¶; Module with utility functions that act on molecule objects. BFS(self)¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. activate(mol)[source]¶; Function to set molecule object mol as the current active molecule. dynamic_variable_bind(cls)[source]¶; Function to dynamically add extra members to; the PsiMod.Molecule class. extract_cluster_indexing(mol, cluster_size=0)[source]¶; Function to returns a LIST of all subclusters of the molecule mol of; real size cluster_size. If cluster_size = 0, returns all possible; combinations of cluster",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:5848,Validat,ValidationError,5848,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['Validat'],['ValidationError']
Security,")[source]¶; Imitates BasisSet.make_filename() without the gbs extension. check_parentheses_and_brackets(input_string, exit_on_error)[source]¶; Function to check that all parenthesis and brackets; in input_string are paired. On that condition, exit_on_error =1,; otherwise 0. parse_multiline_array(input_list)[source]¶; Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. process_basis_block(matchobj)[source]¶; Function to process match of basis name? { ... }. process_cfour_command(matchobj)[source]¶; Function to process match of cfour name? { ... }. process_external_command(matchobj)[source]¶; Function to process match of external name? { ... }. process_extract_command(matchobj)[source]¶; Function to process match of extract_subsets. process_from_file_command(matchobj)[source]¶; Function that process a match of from_file in molecule block. process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; raw_input is printed to the output file unless print_level =0. Does; a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. process_literal_blocks(matchobj)[source]¶; Function to process match of literals_psi4_yo-.... process_memory_command(matchobj)[source]¶; Function to process match of memory .... process_molecule_command(matchobj)[source]¶; Function to process match of molecule name? { ... }. process_multiline_arrays(inputfile)[source]¶; Function to find array inputs that are spread across multiple; lines and squash them into a single line. process_option(spaces, module, key, value, line)[source]¶; Function to pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:5864,validat,validate,5864,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['validat'],['validate']
Security,")\n""""""; # banners += """"""banner(' MP2.5 ')\n""""""; # banners += """"""psi4.print_out('\\n')\n\n""""""; # exec(banners); #; # tables = ''; # tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); # tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); # tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); # tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); # tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); # tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); # tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); # psi4.print_out(tables); #; # return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options; # are set for different qc steps.; #def run_plugin_omega(name, **kwargs):; # r""""""Function encoding sequence of PSI module and plugin calls, as well; # as typical options, to access Rob Parrish's omega plugin.; #; # >>> energy('plugin_omega'); #; # """"""; # lowername = name.lower(); # kwargs = p4util.kwargs_lower(kwargs); #; # plugfile = psi4.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; # psi4.plugin_load(""%s"" % (plugfile)); #; # psi4.set_global_option('BASIS', 'AUG-CC-PVDZ'); # psi4.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); # psi4.set_global_option('REFERENCE', 'UHF'); # psi4.set_global_option('SCF_TYPE', 'DF'); # energy('scf', **kwargs); #; # psi4.set_global_option('dft_functional', 'wB97'); # psi4.set_global_option('dft_order_spherical', 25); # psi4.set_global_option('dft_num_radial', 35); # psi4.set_global_option('omega_procedure', 'ip'); # psi4.set_global_option('maxiter', 50); # psi4.set_global_option('d_convergence', 5); # psi4.set_global_option('e_convergence', 7); # psi4.plugin(""plugin_omega.so""); #; # return psi4.get_variable('SCF TOTAL ENERGY'). # Integ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:8643,access,access,8643,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,1,['access'],['access']
Security,")}; ((1, 2), (1, 2))} }; }. Subdicts below are always returned. Any may be empty if not requested through *bsse_type*. * ``'all'`` |w---w| full list of computations required; * ``'cp'`` |w---w| list of computations required for CP procedure; * ``'nocp'`` |w---w| list of computations required for non-CP procedure; * ``'vmfc_compute'`` |w---w| list of computations required for VMFC procedure; * ``'vmfc_levels'`` |w---w| list of levels required for VMFC procedure. """"""; # What levels do we need?; fragment_range = range(1, nfragments + 1). # Need nbodies and all lower-body in full basis; cp_compute_list = {x: set() for x in nbodies}; nocp_compute_list = {x: set() for x in nbodies}; vmfc_compute_list = {x: set() for x in nbodies}; vmfc_level_list = {x: set() for x in nbodies} # Need to sum something slightly different. # Verify proper passing of bsse_type. already validated in Computer; bsse_type_remainder = set(bsse_type) - {e.value for e in BsseEnum}; if bsse_type_remainder:; raise ValidationError(""""""Unrecognized BSSE type(s): {bsse_type_remainder}""""""). # Build up compute sets; if 'cp' in bsse_type:; # Everything is in full n-mer basis; basis_tuple = tuple(fragment_range). for nb in nbodies:; if nb > 1:; for sublevel in range(1, nb + 1):; for x in itertools.combinations(fragment_range, sublevel):; # below was `nbodies`, which would never hit. present is closest to pre-DDD. purpose unclear to me.; # if self.max_nbody == 1: break; cp_compute_list[nb].add((x, basis_tuple)). if 'nocp' in bsse_type or return_total_data:; # Everything in monomer basis; for nb in nbodies:; for sublevel in range(1, nb + 1):; for x in itertools.combinations(fragment_range, sublevel):; nocp_compute_list[nb].add((x, x)). if 'vmfc' in bsse_type:; # Like a CP for all combinations of pairs or greater; for nb in nbodies:; for cp_combos in itertools.combinations(fragment_range, nb):; basis_tuple = tuple(cp_combos); for interior_nbody in range(1, nb + 1):; for x in itertools.combinations(cp_combos, inter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:17883,Validat,ValidationError,17883,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,5,['Validat'],['ValidationError']
Security,"* (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Helgaker SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Helgaker SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_helgaker_3(functionname, zLO, valueLO, zMD, valueMD, zHI, valueHI, verbose=True):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}; """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(""scf_xtpl_helgaker_3: Inputs must be of the same datatype! (%s, %s, %s)""; % (type(valueLO), type(valueMD), type(valueHI))). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Hel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:7557,Validat,ValidationError,7557,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"** H2O CCSD optimization by energies, with Z-Matrix input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. fci-h2o-2; 6-31G H2O Test FCI Energy Point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fnocc7; Test fnocc with linear dependencies. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. freq-masses; che",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:11189,validat,validate,11189,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['validat'],['validate']
Security,"*dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, psi4.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:2876,Validat,Validate,2876,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['Validate']
Security,"*kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC. See Capabilities Table at {dtl}""""""). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). director = {; ""mp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:62996,Validat,ValidationError,62996,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"*kwargs):; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]. cbs_methods = []; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_lis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:65747,Validat,ValidationError,65747,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(ssmod, func)):; self.add_Subset(getattr(ssmod, func).__doc__, getattr(ssmod, func)). print(""""""WrappedDatabase %s: Defined subsets loaded"""""" % (self.dbse)). [docs] def get_pec_weightinfo(self):; """""". """"""; def closest(u, options):; return max(options, key=lambda v: len(os.path.commonprefix([u, v]))). dbdat = {}; oss = self.oss['default']; eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; for rxnix, rxn in enumerate(oss.hrxn):; dbdat[rxn] = {'eq': closest(rxn, eqrxns),; 'Rrat': oss.axis['Rrat'][rxnix]}; return dbdat. # def table_simple1(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'S22', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'S22', 'MX', textables.val,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:42862,Validat,ValidationError,42862,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"+ 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if not 'DF' in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; core.set_variable('CURRENT ENERGY', core.variable('SCS-MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; core.set_variable('CURRENT ENERGY', core.variable('MP2 TOTAL ENERGY')); core.set_variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:81685,Validat,ValidationError,81685,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"+ 1)); oe.set_Da_so(Da); if core.get_global_option(""REFERENCE"") == ""UHF"":; Db = ccwfn.variable(""CC ROOT {} Db"".format(rn + 1)); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if not 'DF' in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:102907,Validat,ValidationError,102907,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"+ core.outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen([cfour_executable], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); data = data.decode('utf-8'); if not data:; break; core.print_out(data); c4out += data; internal_p4c4_info['output'] = c4out. c4files = {}; core.print_out('\n'); for item in ['GRD', 'FCMFINAL', 'DIPOL']:; try:; with open(psioh.get_default_path() + cfour_tmpdir + '/' + item, 'r') as handle:; c4files[item] = handle.read(); core.print_out(' CFOUR scratch file %s has been read\n' % (item)); core.print_out('%s\n' % c4files[item]); internal_p4c4_info[item.lower()] = c4files[item]; except IOError:; pass; core.print_out('\n'). if molecule.name() == 'blank_molecule_psi4_yo':; qcdbmolecule = None; else:; molecule.update_geometry(); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.update_geometry(). # c4mol, if it exists, is dinky, just a clue to geometry of cfour results; psivar, c4grad, c4mol = qcdb.cfour.harvest(qcdbmolecule, c4out, **c4files). # Absorb results into psi4 data ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html:8436,Validat,ValidationError,8436,psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,1,['Validat'],['ValidationError']
Security,"+ zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. ## Aliases ##; cbs = complete_basis_set. def _cbs_wrapper_methods(**kwargs):; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]. cbs_methods = []; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?![^\[\]]*\]|[^\(\)]*\))"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:56817,Validat,ValidationError,56817,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"+ zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. ## Aliases ##; complete_basis_set = cbs. def _cbs_wrapper_methods(**kwargs):; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]. cbs_methods = []; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?![^\[\]]*\]|[^\(\)]*\))"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:57227,Validat,ValidationError,57227,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,", 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; psi4.set_local_option('SCF', 'REFERENCE', 'ROHF'). scf_helper(name, **kwargs). optstash.restore(). [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). if (psi4.get_option('SCF', 'SCF_TYPE') == 'DF'):. # if the df_basis_scf basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SCF') == '':; jkbasis = p4util.corresponding_jkfit(psi4.get_global_option('BASIS')); if jkbasis:; psi4.set_global_option('DF_BASIS_SCF', jkbasis); psi4.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). psi4.scfgrad(); optstash.restore(). [docs]def run_libfock(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. """"""; if (name.lower() == 'cphf'):; psi4.set_global_option('MODULE', 'RCPHF'); if (name.lower() == 'cis'):; psi4.set_global_option('MODULE', 'RCIS'); if (name.lower() == 'tdhf'):; psi4.set_global_option('MODULE', 'RTDHF'); if (name.lower() == 'cpks'):; psi4.set_global_option('MODULE', 'RCPKS'); if (name.lower() == 'tda'):; psi4.set_global_option('MODULE', 'RTDA'); if (name.lower() == 'tddft'):; psi4.set_global_option('MODULE', 'RTDDFT'). psi4.libfock(). [docs]def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; return psi4.mcscf(). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:15001,Validat,ValidationError,15001,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,", 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX') or n_two > 0:; # WARNING!!! A one-particle property computed _with_ a two-particle property will differ; # from a one-particle property computed by itself. There are no two-particle properties at; # present, so we can kick the issue further down the road.; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; core.set_global_option('DERTYPE', 'RESPONSE'); core.cclambda(ccwfn); for prop in response:; core.set_global_option('PROPERTY', prop); core.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX'):; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). # => Make OEProp calls <=; if n_one > 0:; # ==> Initialize OEProp <==; oe = core.OEProp(ccwfn); for oe_prop_name in one:; oe.add(oe_prop_name.upper()); # ==> OEProp for the ground state <==; # TODO: When Psi is Py 3.9+, transition to the removeprefix version.; title = name.upper().replace(""EOM-"", """"); #title = name.upper().removeprefix(""EOM-""); oe.set_title(title); set_of_names = {title + "" {}"", ""CC {}""}; if name.startswith(""eom""):; gs_h = 0; for h, i in e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:101173,Validat,ValidationError,101173,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,", 'REFERENCE') != 'RHF'):; raise ValidationError('ADC requires reference RHF'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return psi4.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:38081,Validat,ValidationError,38081,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,", 'WFN', 'EOM_CCSD'); ref_wfn = run_eom_cc(name, **kwargs); else:; core.print_out('DGAS: proc.py:1599 hitting an undefined sequence'); core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). return core.adc(ref_wfn). def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). if name == 'zapt':; core.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = int((level + 1) / 2) + (leve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:89108,Validat,ValidationError,89108,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,", 'WFN', 'EOM_CCSD'); ref_wfn = run_eom_cc(name, **kwargs); else:; core.print_out('DGAS: proc.py:1599 hitting an undefined sequence'); core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn). return core.adc(ref_wfn). def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_local_option('SCF', 'SCF_TYPE', 'DF'). core.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = core.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:82425,Validat,ValidationError,82425,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,", 'a-ccsd(t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; core.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn); if core.get_global_option('PE'):; ccwfn.pe_state = ref_wfn.pe_state. if name == 'a-ccsd(t)':; core.cchbar(ref_wfn); lambdawfn = core.cclambda(ref_wfn); for k, v in lambdawfn.variables().items():; ccwfn.set_variable(k, v). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') not in [""FALSE"", ""0""]:; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:89283,Validat,ValidationError,89283,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,", --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename with any; any “.in” or “.dat” extension replaced by “.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; 1; 2>>> psi4 --version; 0.4.262. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Linux/Win",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/external-1.html:18144,access,access,18144,psi4manual/1.2.1/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/external-1.html,4,['access'],['access']
Security,", --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename with any; any ”.in” or ”.dat” extension replaced by ”.out”. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -s <name>, --scratch <name>¶; This overrides the value of PSI_SCRATCH and provides; a path to the location of scratch files. -v, --verbose¶; Print a lot of information, including the Psithon translation of the input file. -V, --version¶; Print version information.; 1; 2>>> psi4 --version; 0.4.262. Environment Variables¶; These environment variables will influence PSI4‘s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; Configuring PSI4 through PSIPATH is preferred; to modifying this environment variable. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux shell commands before invoking psi4; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /scratch/user. # sh, bash: add to shell or ~/.bashrc (Linux/Win",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:18033,access,access,18033,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,2,['access'],['access']
Security,", -0.7062681346308132, -1.4334725450878665]. y(atom)[source]¶; y position of atom (0-indexed) in Bohr; >>> print H2OH2O.y(4); -0.706268134631. z(atom)[source]¶; z position of atom (0-indexed) in Bohr; >>> print H2OH2O.z(4); -1.43347254509. Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; File to. dictify_database_docstrings()[source]¶. useful()[source]¶. Module with non-generic exceptions classes. exception FeatureNotImplemented(msg)[source]¶; Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. exception IncompleteAtomError(msg)[source]¶; Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. exception QcdbException[source]¶; Error class for QCDB. exception ValidationError(msg)[source]¶; Error called for problems with syntax input file. Prints; error message msg to standard output stream. class Molecule(psi4molstr=None)[source]¶; Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. BFS()[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. auto_fragments()[source]¶; Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. format_string_for_qchem()[source]¶. classmethod init_with_xyz(xyzfilename, no_com=False, no_reorient=False)[source]¶; Pull information from an XYZ file. No fragment info detected.; Charge, multiplicit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:61689,Validat,ValidationError,61689,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,4,['Validat'],['ValidationError']
Security,", Dnorm). def scf_finalize_energy(self):; """"""Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. """""". # post-scf vv10 correlation; if core.get_option('SCF', ""DFT_VV10_POSTSCF"") and self.functional().vv10_b() > 0.0:; self.functional().set_lock(False); self.functional().set_do_vv10(True); self.functional().set_lock(True); core.print_out("" ==> Computing Non-Self-Consistent VV10 Energy Correction <==\n\n""); SCFE = 0.0; self.form_V(); SCFE += self.compute_E(); self.set_energies(""Total Energy"", SCFE). # Perform wavefunction stability analysis before doing; # anything on a wavefunction that may not be truly converged.; if core.get_option('SCF', 'STABILITY_ANALYSIS') != ""NONE"":. # Don't bother computing needed integrals if we can't do anything with them.; if self.functional().needs_xc():; raise ValidationError(""Stability analysis not yet supported for XC functionals.""). # We need the integral file, make sure it is written and; # compute it if needed; if core.get_option('SCF', 'REFERENCE') != ""UHF"":; psio = core.IO.shared_object(); #psio.open(constants.PSIF_SO_TEI, 1) # PSIO_OPEN_OLD; #try:; # psio.tocscan(constants.PSIF_SO_TEI, ""IWL Buffers""); #except TypeError:; # # ""IWL Buffers"" actually found but psio_tocentry can't be returned to Py; # psio.close(constants.PSIF_SO_TEI, 1); #else:; # # tocscan returned None; # psio.close(constants.PSIF_SO_TEI, 1). # logic above foiled by psio_tocentry not returning None<--nullptr in pb11 2.2.1; # so forcibly recomputing for now until stability revamp; core.print_out("" SO Integrals not on disk. Computing...""); mints = core.MintsHelper(self.basisset()); #next 2 lines fix a bug that prohibits relativistic stability analysis; if core.get_global_option('RELATIVISTIC') in ['X2C', 'DKH']:; mints.set_rel_basisset(self.get_basisset('BASIS_RELATIVISTIC')); mints.integrals(); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:14797,Validat,ValidationError,14797,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,", MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]; def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix, core.Vector]:; """"""; Converts a `NumPy array; <https://numpy.org/doc/stable/reference/arrays.ndarray.html>`_ or list of; NumPy arrays into a |PSIfour| :class:`~psi4.core.Matrix` or; :class:`~psi4.core.Vector` (irrepped if list). Parameters; ----------; self; Matrix or Vector class.; arr; NumPy array or list of arrays to use as the data for a new; :class:`~psi4.core.Matrix` or :class:`~psi4.core.Vector`.; name; Name to give the new :class:`~psi4.core.Matrix`.; dim1; If a single dense NumPy array is given,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:2089,Validat,ValidationError,2089,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,", allowed; 		sys.exit(1). 	if (type.get() == 'UniformDielectric'):; 		if not eps.is_set():; 			print ""Eps not defined for UniformDielectric""; 			sys.exit(1). 	if (type.get() == 'MetalSphere'):; 		if not (eps.is_set() and epsre.is_set and epsimg.is_set()):; 			print ""Eps and/or EpsImg not defined for MetalSphere""; 			sys.exit(1); 		if not (position.is_set() and radius.is_set()):; 			print ""SpherePosition and/or SphereRadius not defined for MetalSphere""; 			sys.exit(1); 		if (len(position.get()) != 3):; 			print ""SpherePosition error""; 			sys.exit(1); 		if (radius.get() < 0.1):; 			print ""Minimum value allowed for Radius is 0.1""; 			sys.exit(1). 	if (type.get() == 'GreensFunctionSum'):; 		if not (green1.is_set() and green2.is_set()):; 			print ""One or both components not defined for GreensFunctionSum""; 			sys.exit(1). [docs]def verify_spheres(keyword):; 	length=len(keyword.get()); 	if (length % 4 != 0):; print ""Empty or incoherent Spheres list.""; 		sys.exit(1); 	convert_length_array(keyword). [docs]def convert_length_array(keyword):; 	length=len(keyword.get()); 	if (isAngstrom):; 		for i in range(length):; 			keyword[i] *= toAtomicUnits. [docs]def convert_length_scalar(keyword):; 	if (isAngstrom):; 		keyword[0] *= toAtomicUnits. [docs]def convert_area_scalar(keyword):; 	if (isAngstrom):; 		keyword[0] *= toAtomicUnits * toAtomicUnits. [docs]def preprocess():; """""" Takes the PCM input file in @pcmsolver.inp, and preprocesses to make it machine-readable.""""""; valid_keywords = setup_keywords(); input=getkw.GetkwParser(); inkw=input.parseFile('@pcmsolver.inp'); inkw.sanitize(valid_keywords); topsect=inkw.get_topsect(); inkw.run_callbacks(valid_keywords). xfile='@pcmsolver.inp'; fd=open(xfile,'w'); fd.write(str(inkw.top)); fd.close(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html:8598,sanitiz,sanitize,8598,psi4manual/4.0b5/_modules/pcmpreprocess.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pcmpreprocess.html,1,['sanitiz'],['sanitize']
Security,", dashcoeff[dashlvl][func]['sr6'], dashcoeff[dashlvl][func]['s8'],; 0.0, dashcoeff[dashlvl][func]['alpha6'], 2)); elif dashlvl == 'd3zero':; # d3zero: s6 sr6 s8 a2=None alpha6 version=3; pfile.write('%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' %; (dashcoeff[dashlvl][func]['s6'], dashcoeff[dashlvl][func]['sr6'], dashcoeff[dashlvl][func]['s8'],; 1.0, dashcoeff[dashlvl][func]['alpha6'], 3)); elif dashlvl == 'd3bj':; # d3bj: s6 a1 s8 a2 alpha6=None version=4; pfile.write('%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' %; (dashcoeff[dashlvl][func]['s6'], dashcoeff[dashlvl][func]['a1'], dashcoeff[dashlvl][func]['s8'],; dashcoeff[dashlvl][func]['a2'], 0.0, 4)); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); gfile.write(self.save_string_xyz()); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(); if verbosity >= 3:; print out. # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for at in dfile.readlines():; dashdderiv.append([float(x.replace('D', 'E')) for x in at.split()]); dfile.close(); if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Clean up files and remove scratch directory; # os.unlink(paramfile); # os.unlink(geomfile); # os.unlink(derivfile); if defmoved is True:; os.rename(defaultf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:29496,Validat,ValidationError,29496,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,", dertype='energy', mode='sow'). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; psi4.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = psi4.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and psi4.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()). # If we are feezing cartesian, do not orient or COM; if psi4.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= psi4.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:55850,Validat,ValidationError,55850,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,", float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(""""""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more."""""".format(; memory_amount / 1024 ** 2, memory_amount / 1000 ** 2)). if execute:; core.set_memory_bytes(memory_amount); return memory_amount. [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return core.get_memory(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); core.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label, exitonfail=True):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*; (or to *digits* itself when *digits* < 1 e.g. digits=0.04). Performs; a system exit on failure unless *exito",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:5316,Validat,ValidationError,5316,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,", hrxn, tagl=None, axis=None):; # identifier; self.name = name; # array of reactions names; self.hrxn = hrxn; # description line; self.tagl = tagl; # mathematical relationships of reactions; self.axis = OrderedDict(). def __str__(self):; text = ''; text += """""" ==> %s Subset <==\n\n"""""" % (self.name); text += """""" Tagline: %s\n"""""" % (self.tagl); text += """""" %20s"""""" % ('Reactions'); for ax in self.axis.keys():; text += """""" %8s"""""" % (ax); text += """"""\n""""""; for ix in range(len(self.hrxn)):; text += """""" %20s"""""" % (str(self.hrxn[ix])); for ax in self.axis.values():; text += """""" %8.3f"""""" % (ax[ix]); text += """"""\n""""""; text += """"""\n""""""; return text. [docs]class Reagent(object):; """"""Chemical entity only slightly dresed up from qcdb.Molecule. """""". def __init__(self, name, mol, tagl=None, comment=None):; # full name, e.g., 'S22-2-dimer' or 'NBC1-BzMe-8.0-monoA-CP' or 'HTBH-HCl-reagent'; self.name = name; # qcdb.Molecule; try:; self.NRE = mol.nuclear_repulsion_energy(); except AttributeError:; raise ValidationError(""""""Reagent must be instantiated with qcdb.Molecule object.""""""); else:; self.mol = mol.create_psi4_string_from_molecule(); # description line; self.tagl = tagl; # # addl comments; # self.comment = comment; # # fragmentation; # self.fragments = mol.fragments; # # frag activation; # self.frtype = mol.fragment_types; # # frag charge; # self.frchg = mol.fragment_charges; # # frag multiplicity; # self.frmult = mol.fragment_multiplicities; self.charge = mol.molecular_charge(). def __str__(self):; text = ''; text += """""" ==> %s Reagent <==\n\n"""""" % (self.name); text += """""" Tagline: %s\n"""""" % (self.tagl); # text += """""" Comment: %s\n"""""" % (self.comment); text += """""" NRE: %f\n"""""" % (self.NRE); # text += """""" Charge: %+d\n""""""; # text += """""" Fragments: %d\n"""""" % (len(self.fragments)); # text += """""" FrgNo Actv Chg Mult AtomRange\n""""""; # for fr in range(len(self.fragments)):; # text += """""" %-4d %1s %+2d %2d %s\n"""""" % (fr + 1,; # '*' if self.frtype[fr] == 'Real' else '',; # self.frchg[fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:12960,Validat,ValidationError,12960,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,", input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""x",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:15804,Validat,ValidationError,15804,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,", item[2])). # Clean up cfour scratch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; core.get_gradient().print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; core.get_gradient().print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; gobas = core.get_global_option('BASIS') if core.get_global_option('BASIS') else 'sto-3g'; basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = core.get_gradient(); wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:12853,Validat,ValidationError,12853,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,3,['Validat'],['ValidationError']
Security,", item[2])). # Clean up cfour scratch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; p4out.write('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory); p4out.close(); psi4.reopen_outfile(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). psi4.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); psi4.print_variables(); if c4grad:; psi4.get_gradient().print_out(). # Quit if Cfour threw error; if psi4.get_variable('CFOUR ERROR CODE'):; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). [docs]def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). [docs]def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). [docs]def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). [docs]def write_zmat(name, dertype):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * psi4.get_memory()); if mem == 256:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; molecule = psi4.get_active_molecule(); if molecule.name() == 'blank_molecule_psi4_y",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:13241,Validat,ValidationError,13241,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html,1,['Validat'],['ValidationError']
Security,", now_dval); return text; # outfile. [docs] def set_coordinates(self, x, y, z):; """"""Given the current set of coordinates, updates the values of this; atom's coordinates, and any variables that may depend on it. """"""; self.coordinates[0] = 0.0 if math.fabs(x) < 1.0E-14 else x; self.coordinates[1] = 0.0 if math.fabs(y) < 1.0E-14 else y; self.coordinates[2] = 0.0 if math.fabs(z) < 1.0E-14 else z. if self.rto != None:; if not self.rto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); self.rval.rset(self.r(self.coordinates, self.rto.compute())). if self.ato != None:; if not self.ato.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); aval = self.a(self.coordinates, self.rto.compute(), self.ato.compute()); # Noise creeps in for linear molecules. Force linearity, if it is close enough.; val = aval * 180.0 / math.pi; self.aval.rset(val). if self.dto != None:; if not self.dto.is_computed():; raise ValidationError(""Coordinates have been set in the wrong order""); val = self.d(self.coordinates, self.rto.compute(), self.ato.compute(), self.dto.compute()); # Check for NaN, and don't update if we find one; # what is this? proper py traslation?; if val == val:; self.dval.rset(val * 180.0 / math.pi). self.computed = True. [docs] def type(self):; """"""The type of CoordEntry specialization.""""""; return 'ZMatrixCoord'. [docs] def clone(self):; """"""Returns new, independent ZMatrixEntry object.""""""; return copy.deepcopy(self). [docs] def compute(self):; """"""Compute the Cartesian coordinates in Bohr of current atom's entry."""""". if self.computed:; return self.coordinates. # place first atom at the origin; if self.rto == None and self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = 0.0. # place second atom directly above the first; elif self.ato == None and self.dto == None:; self.coordinates[0] = 0.0; self.coordinates[1] = 0.0; self.coordinates[2] = self.rval.comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:17729,Validat,ValidationError,17729,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,4,['Validat'],['ValidationError']
Security,", return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/freq-1.html:1778,access,accesses,1778,psi4manual/1.4.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/freq-1.html,5,['access'],['accesses']
Security,", this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.molutil import *; from psi4.driver.p4util.exceptions import *; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.energy` or :py:func:`~psi4.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: str; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:2399,access,accessible,2399,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,3,['access'],['accessible']
Security,", val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.ProtoVector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector]) – Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {‘matrix’, ‘vector’}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector) → float¶; Take the dot product of two vectors. zero(self: psi4.core.Vector) → None¶; Zeros the vector. table of contents. Vector; Vector; Vector.name; Vector.np; Vector.nph; Vector.shape; Vector.add(); Vector.array_interface(); Vector.axpby(); Vector.axpy(); Vector.clone(); Vector.copy(); Vector.dim(); Vector.dimpi(); Vector.from_array(); Vector.from_list(); Vector.from_serial(); Vector.get(); Vector.get_block(); Vector.init(); Vector.load(); Vector.nirrep(); Vector.np_read(); Vector.np_write(); Vector.print_out(); Vector.save(); Vector.scale(); Vector.set(); Vector.set_block(); Vector.to_array(); Vector.to_serial(); Vector.vector_dot(); Vector.zero(). «; hide menu. menu; sidebar; »; . Navigation. Index. module",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:7630,access,accessor,7630,psi4manual/1.8.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html,3,['access'],['accessor']
Security,", while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE (CFOUR); CFOUR — Specifies the step length in mass-weighted coordinates (in \(10^{-4} amu^{1/2} bohr\) ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP (CFOUR); CFOUR — In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type: string; Possible Values: FULL, COMP; Default: FULL. CFOUR_FILE_RECSIZ (CFOUR); CFOUR — This specifies the physical length (in integer words) of the records used in the word-addressable direct access files used by CFOUR. This value should always be chosen as a multiple of 512 bytes, as your local system manager certainly understands. Type: integer; Default: 2048. CFOUR_FILE_STRIPE (CFOUR); CFOUR — This option allows the splitting of files. Input is required in the form N1/N2/N3/N4/N5, where N1, N2, N3, N4, and N5 specify the number of files in which MOINTS, GAMLAM, MOABCD, DERINT, and DERGAM are split, respectively. Type: string; Default: 0/0/0/0/0. CFOUR_FINITE_PERTURBATION (CFOUR); CFOUR — Specifies the field strength for a perturbation (defined within a %perturbation section). The value must be given as an integer, and the field strength used by the program will be then the value of the keyword \(\times 10^{-6}\). Type: integer; Default: 0. CFOUR_FOCK (CFOUR); CFOUR — This option is used to control the algorithm used for construction of the Fock matrix in SCF calculations. PK (=0) uses the PK-supermatrix approach wh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:43476,access,access,43476,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['access'],['access']
Security,", with the following alterations:; * output goes to output file; * gradient returned as psi4.core.Matrix, not list o'lists; * scratch is written to randomly named subdirectory of psi scratch; * psivar ""DISPERSION CORRECTION ENERGY"" is set; * `verbose` triggered when PRINT keywork of SCF module >=3. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, (Molecule, core.Molecule)):; # 1st: called on a qcdb.Molecule; # 2nd: called on a python export of a psi4.Molecule (py-side through Psi4's driver); pass; elif isinstance(mol, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); mol = Molecule(mol); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError(""""""Requested derivative level 'dertype' %s not valid for run_dftd3."""""" % (dertype)); else:; raise ValidationError(""""""Requested derivative level 'dertype' %s not valid for run_dftd3."""""" % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = get_dispersion_aliases()[dashlvl] if dashlvl in get_dispersion_aliases() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(dashparam). # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:4942,Validat,ValidationError,4942,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,", zorder=10); vmcdata.append(rxn['mcdata']); vaxis.append(rxn['axis']); vmin = min(0, vmin, rxn['mcdata']); vmax = max(0, vmax, rxn['mcdata']). if rxn['bmdata'] is not None:; ax1.plot(rxn['axis'], rxn['bmdata'], 'o', color='black', markersize=6.0, zorder=1); vmin = min(0, vmin, rxn['bmdata']); vmax = max(0, vmax, rxn['bmdata']). if rxn['error'][0] is not None:; ax2.plot(rxn['axis'], rxn['error'][0], 's', color=clr, mew=0, zorder=8); emin = min(0, emin, rxn['error'][0]); emax = max(0, emax, rxn['error'][0]); verror.append(rxn['error'][0]). ls = next(linecycler); ax1.plot(vaxis, vmcdata, ls, color='grey', label=trace, zorder=3); ax2.plot(vaxis, verror, ls, color='grey', label=trace, zorder=4). xbuf = max(0.05, abs(0.02 * xmax)); vbuf = max(0.1, abs(0.02 * vmax)); ebuf = max(0.01, abs(0.02 * emax)); plt.xlim([xmin - xbuf, xmax + xbuf]); ax1.set_ylim([vmin - vbuf, vmax + vbuf]); plt.legend(fontsize='x-small', frameon=False); ax2.set_ylim([emin - ebuf, emax + ebuf]). # save and show; pltuid = title + '_' + hashlib.sha1(title).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='valerr_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. [docs]def disthist(data, title='', xtitle='', xmin=None, xmax=None,; me=None, stde=None, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with name *saveas* with a histogram representation; of the reaction errors in *data*. Also plots a gaussian distribution; with mean *me* and standard deviation *stde*. Plot has x-range; *xmin* to *xmax*, x-axis label *xtitle* and overall title *title*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt. def gaussianpdf(u, v, x):; """"""*u* is mean, *v* is variance, *x* is value, returns probability""""""; retur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:10825,hash,hashlib,10825,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,",; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import re; import sys; import math. import numpy as np. from psi4 import core; from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver import driver_util; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list. zeta_values = ['d', 't', 'q', '5', '6', '7', '8']; zeta_val2sym = {k + 2: v for k, v in zip(range(7), zeta_values)}; zeta_sym2val = {v: k for k, v in zeta_val2sym.items()}. def _expand_bracketed_basis(basisstring, molecule=None):; """"""Function to transform and validate basis series specification for cbs(). Parameters; ----------; basisstring : string; A string containing the basis sets to be expanded.; A basis set with no paired square brackets is passed through; with zeta level 0 (e.g., ``'6-31+G(d,p)'`` is returned as; ``([""6-31+G(d,p)""], [0])``). A basis set with square brackets is checked; for sensible sequence and returned as separate basis sets; (e.g., ``'cc-pV[Q5]Z'` is returned as ``([""cc-pVQZ"", ""cc-pV5Z""], [4, 5])``).; Allows out-of-order zeta specification (e.g., ``[qtd]``) and numeral for; number (e.g., ``[23]``). Does not allow skipped zetas (e.g., ``[dq]``), zetas; outside the [2,8] range, non-Dunning, non-Ahlrichs, or non-Jensen sets,; or non-findable .gbs sets.; molecule : qcdb.molecule or psi4.core.Molecule; This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Returns; -------; tuple; Tuple in the ``([basis set names], [basis set zetas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:1675,validat,validate,1675,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validate']
Security,",; 'pbe0' : {'s6': 1.000, 's8': 0.528823, 'a1': 0.007912, 'a2': 6.162326},; 'lcwpbe' : {'s6': 1.000, 's8': 0.906564, 'a1': 0.563761, 'a2': 3.593680},; },; }. [docs]def dash_server(func, dashlvl, mode='psi4'):; """"""Function to serve up dispersion correction parameters in whatever form needed.; When *mode* is 'dftd3', returns a string suitable for writing to ./dftd3_parameters; to calculuate the correction at *dashlvl* with the default parameters for functional; *func*. When *mode* is 'psi4', returns a tuple of arguments suitable for building; a Dispersion object with *dashlvl* parameters for functional *func*. There are four computational *dashlvl* choices. 'd2p4' calls the -D2 correction; within psi4 (hence, faked for mode='dftd3'). The other three, 'd2gr', 'd3zero',; and 'd3bj' call the three dftd3 modes of operation (corresponding to -old, -zero, -bj).; Additionally, there are three aliased *dashlvl* choices since the aliases in dash_alias; above are imposed. """"""; # Validate input arguments; dashlvl = dashlvl.lower(); dashlvleff = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl. func = func.lower(); if func not in dashcoeff[dashlvleff].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)). # Return strings for dftd3 program parameter file; # s6 rs6 s18 rs8 alpha6 version; # d2p4: s6 sr6=1.1 s8=0.0 a2=None alpha6=20.0 version=2; # d2gr: s6 sr6=1.1 s8=0.0 a2=None alpha6 version=2; # d3zero: s6 sr6 s8 a2=None alpha6 version=3; # d3bj: s6 a1 s8 a2 alpha6=None version=4; # d3mzero: s6 sr6 s8 beta alpha6=14.0 version=5; # d3mbj: s6 a1 s8 a2 alpha6=None version=6. if mode.lower() == 'dftd3':; if dashlvleff.lower() == 'd2p4':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; 1.1, 0.0, 0.0, 20.0, 2); elif dashlvleff.lower() == 'd2gr':; returnstring = '%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' % \; (dashcoeff[dashlvleff][func]['s6'],; 1.1, 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html:11152,Validat,Validate,11152,psi4manual/1.0.0/_modules/qcdb/dashparam.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dashparam.html,1,['Validat'],['Validate']
Security,",; ['DERTYPE'],; ['CCDENSITY', 'WFN'],; ['CCLAMBDA', 'WFN']). PsiMod.set_global_option('DERTYPE', 'FIRST'). if (name.lower() == 'eom-ccsd'):; PsiMod.set_local_option('CCLAMBDA', 'WFN', 'EOM_CCSD'); PsiMod.set_local_option('CCDENSITY', 'WFN', 'EOM_CCSD'); run_eom_cc(name, **kwargs). PsiMod.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); PsiMod.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); PsiMod.set_local_option('CCDENSITY', 'XI', 'TRUE'); PsiMod.cclambda(); PsiMod.ccdensity(); PsiMod.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); PsiMod.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); PsiMod.set_local_option('CCDENSITY', 'XI', 'FALSE'); PsiMod.cclambda(); PsiMod.ccdensity(); PsiMod.deriv(). optstash.restore(). [docs]def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if (PsiMod.get_option('ADC', 'REFERENCE') != 'RHF'):; raise ValidationError('ADC requires reference RHF'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationErro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:34755,Validat,ValidationError,34755,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,",subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:29295,Validat,ValidationError,29295,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC gradient""). # throw exception for CONV (approximately); if (corl_type := method_algorithm_type(name).now) not in [""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for DFOCC gradient. See Capabilities Table at {dtl}""). proc_util.check_disk_df(name.upper(), optstash). # throw exception for SCF_TYPE; if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:67839,Validat,ValidationError,67839,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"- len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; psi4.print_out(cbsscheme). return value. elif isinstance(valueLO, (psi4.Matrix, psi4.Vector)):; beta = valueHI.clone(); beta.set_name('Helgaker SCF (%s, %s) beta' % (zLO, zHI)); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.set_name('Helgaker SCF (%s, %s) data' % (zLO, zHI)). if verbose > 2:; psi4.print_out(""""""\n ==> Helgaker 2-point SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper())); psi4.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); psi4.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); psi4.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); psi4.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); psi4.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); psi4.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); psi4.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_helgaker_3(functionname, zLO, valueLO, zMD, valueMD, zHI, valueHI, verbose=True):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~driver_cbs.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}; """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(""scf_xtpl_helgaker_3: Inputs must be of the same datatype! (%s, %s, %s)""; % (type(valueLO), type(valueMD), type(valueHI))). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 3-point SCF extrapolation for method: %s <==\n\n"""""" % (funct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:7279,Validat,ValidationError,7279,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"--+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | IR_intensity | infrared intensity | km/mol | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+. Examples; --------; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). """"""; if (mass.shape[0] == geom.shape[0] == (hess.shape[0] // 3) == (hess.shape[1] // 3)) and (geom.shape[1] == 3):; pass; else:; raise ValidationError(; f""""""Dimension mismatch among mass ({mass.shape}), geometry ({geom.shape}), and Hessian ({hess.shape})""""""). def mat_symm_info(a, atol=1e-14, lbl='array', stol=None):; symm = np.allclose(a, a.T, atol=atol); herm = np.allclose(a, a.conj().T, atol=atol); ivrt = a.shape[0] - np.linalg.matrix_rank(a, tol=stol); return """""" {:32} Symmetric? {} Hermitian? {} Lin Dep Dim? {:2}"""""".format(lbl + ':', symm, herm, ivrt). def vec_in_space(vec, space, tol=1.0e-4):; merged = np.vstack((space, vec)); u, s, v = np.linalg.svd(merged); return (s[-1] < tol). vibinfo = {}; text = []. nat = len(mass); text.append(""""""\n\n ==> Harmonic Vibrational Analysis <==\n""""""). if nat == 1:; nrt_expected = 3; elif np.linalg.matrix_rank(geom) == 1:; nrt_expected = 5; else:; nrt_expected = 6. nmwhess = hess.copy(); text.append(mat_symm_info(nmwhess, lbl='non-mass-weighted Hessian') + ' (0)'). # get SALC object, possibly w/o trans & rot; mints = psi4.core.MintsHelper(basisset); cdsalcs = mints.cdsalcs(0xFF, project_tran",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html:15911,Validat,ValidationError,15911,psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,12,['Validat'],['ValidationError']
Security,"------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734908 -76.026632734908 0.01523518 0.01245755 0.02742222 0.02277530 ~; 2 -76.027022666011 -0.000389931104 0.00178779 0.00142946 0.01008137 0.00594928 ~; 3 -76.027032729374 -0.000010063363 0.00014019 0.00008488 0.00077463 0.00044738 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:9031,access,access,9031,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,2,['access'],['access']
Security,"----------------------+; | ccsd | coupled cluster singles and doubles (CCSD) |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD |; +-------------------------+---------------------------------------------------------------------------------------+. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:34969,access,accesses,34969,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['access'],['accesses']
Security,"--------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce (someday) if name is function; if hasattr(name, '__call__'):; raise ValidationError(""Frequency: Cannot use custom function""). lowername = name.lower(). old_global_basis = None; if ""/"" in lowername:; if (""+"" in lowername) or (""["" in lowername) or (lowername.count('/') > 1):; raise ValidationError(""Frequency: Cannot extrapolate or delta correct frequencies yet.""); else:; old_global_basis = core.get_global_option(""BASIS""); lowername, new_basis = lowername.split('/'); core.set_global_option('BASIS', new_basis). if kwargs.get('bsse_type', None) is not None:; raise ValdiationError(""Frequency: Does not currently support 'bsse_type' arguements""). return_wfn = kwargs.pop('return_wfn', False). # are we in sow/reap mode?; freq_mode = kwargs.get('mode', 'continuous').lower(); if freq_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(lowername, return_wfn=True, molecule=molecule, **kwargs). # S/R: Quit after getting new displacements; if freq_mode == 'sow':; return 0.0. wfn.frequencies().print_out(); core.thermo(wfn, wfn.frequencies()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:84854,Validat,ValidationError,84854,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"----------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: autodoc_dft_opt.rst. .. include:: cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; psi4.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = psi4.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and psi4.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()). # If we are feezing cartesian, do not orien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:55315,Validat,ValidationError,55315,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"------------------------------------------------------------------------------------------------ ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.119",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:9287,access,access,9287,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['access'],['access']
Security,"----------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:9290,access,access,9290,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['access'],['access']
Security,"------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce (someday) if name is function; if hasattr(name, '__call__'):; raise ValidationError(""Frequency: Cannot use custom function""). lowername = name.lower(). if ""/"" in lowername:; return driver_cbs._cbs_gufunc(frequency, name, ptype='frequency', **kwargs). if kwargs.get('bsse_type', None) is not None:; raise ValdiationError(""Frequency: Does not currently support 'bsse_type' arguements""). return_wfn = kwargs.pop('return_wfn', False). # are we in sow/reap mode?; freq_mode = kwargs.get('mode', 'continuous').lower(); if freq_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(lowername, return_wfn=True, molecule=molecule, **kwargs). # S/R: Quit after getting new displacements; if freq_mode == 'sow':; return 0.0. # Project final frequencies?; translations_projection_sound, rotations_proje",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:88411,Validat,ValidationError,88411,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"----------------; * fill in results from TROVE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_cfour import cfour_psivar_list; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html:4974,validat,validator,4974,psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,4,['validat'],['validator']
Security,"------; provenance : Dict[str, str]; Dictionary satisfying QCSchema, with |PSIfour| credentials for creator; and version.; https://github.com/MolSSI/QCSchema/blob/master/qcschema/dev/definitions.py#L23-L41. """"""; prov = {'creator': 'Psi4', 'version': __version__, 'routine': routine}; if module:; prov[""module""] = module. return prov. [docs]def plump_qcvar(; val: Union[float, str, List],; shape_clue: str,; ret: str = 'np') -> Union[float, np.ndarray, core.Matrix]:; """"""Prepare serialized QCVariable for :py:func:`~psi4.core.set_variable` by; converting flat arrays into shaped ones and floating strings. Parameters; ----------; val; flat (?, ) list or scalar or string, probably from JSON storage.; shape_clue; Label that includes (case insensitive) one of the following as; a clue to the array's natural dimensions: 'gradient', 'hessian'; ret; {'np', 'psi4'}; Whether for arrays to return :py:class:`numpy.ndarray` or; :py:class:`psi4.core.Matrix`. Returns; -------; float or numpy.ndarray or Matrix; Reshaped array of type `ret` with natural dimensions of `shape_clue`. """"""; if isinstance(val, (np.ndarray, core.Matrix)):; raise TypeError; elif isinstance(val, list):; tgt = np.asarray(val); else:; # presumably scalar. may be string; return float(val); # TODO choose float vs Decimal for return if string?. if 'gradient' in shape_clue.lower():; reshaper = (-1, 3); elif 'hessian' in shape_clue.lower():; ndof = int(math.sqrt(len(tgt))); reshaper = (ndof, ndof); else:; raise ValidationError(f'Uncertain how to reshape array: {shape_clue}'). if ret == 'np':; return tgt.reshape(reshaper); elif ret == 'psi4':; return core.Matrix.from_array(tgt.reshape(reshaper)); else:; raise ValidationError(f'Return type not among [np, psi4]: {ret}'). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.p4util.procutil. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:21365,Validat,ValidationError,21365,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,2,['Validat'],['ValidationError']
Security,"--messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4) or databases.; Modification of PYTHONPATH can be done in three ways, equivalently. Normal Linux shell commands. First line for C shell; second for bash.; setenv PYTHONPATH /home/user/psiadditions:$PYTHONPATH; PYTHONPATH=/home/user/psiadditions:$PYTHONPATH; export PYTHONPATH. Place the path in the ~/.psi4rc file so that it is available for; every PSI4 instance.; sys.path.insert(0, '/home/user/psiadditions'). Place the path in the input file, either absolute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:9912,access,access,9912,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['access'],['access']
Security,"--messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --version¶; Print version information. -w, --wipe¶; Clean out scratch area. Environment Variables¶; These environment variables will influence PSI4’s behavior. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for executables. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc. PYTHONPATH¶; Path in which the Python interpreter looks for modules to import. For; PSI4, these are generally plugins (see Plugins: Adding New Functionality to PSI4). Table Of Contents. Configuration: Preparing PSI4’s Environment; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. Previous topic; A PSI4 Tutorial; Next topic; Psithon: Structuring an Input File; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/external-1.html:8906,access,access,8906,psi4manual/4.0b2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/external-1.html,2,['access'],['access']
Security,"-7,GRID=1.e-8\n\n""""""; else:; text += """"""GTHRESH,ZERO=1.e-14,ONEINT=1.e-14,TWOINT=1.e-14,ENERGY=1.e-9\n\n"""""". return text. [docs] def format_basis(self):; text = ''; text += """"""basis={\n"""""". try:; # jaxz, maxz, etc.; for line in molpro_basissets.altbasis[self.basis]:; text += """"""%s\n"""""" % (line); text += '\n'; except KeyError:; # haxz; if self.basis.startswith('heavy-aug-'):; text += """"""set,orbital; default,%s,H=%s\n"""""" % (self.basis[6:], self.unaugbasis); # xz, axz, 6-31g*; else:; text += """"""set,orbital; default,%s\n"""""" % (self.basis). if ('df-' in self.method) or ('f12' in self.method) or (self.method in ['mp2c', 'dft-sapt', 'dft-sapt-pbe0acalda']):; if self.unaugbasis and self.auxbasis:. text += """"""set,jkfit; default,%s/jkfit\n"""""" % (self.auxbasis); text += """"""set,jkfitb; default,%s/jkfit\n"""""" % (self.unaugbasis); text += """"""set,mp2fit; default,%s/mp2fit\n"""""" % (self.auxbasis); text += """"""set,dflhf; default,%s/jkfit\n"""""" % (self.auxbasis); else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)). text += """"""}\n\n""""""; return text. [docs] def format_infile_string(self):; text = ''. # format comment and memory; text += """"""***, %s %s\n"""""" % (self.index, self.molecule.tagline); text += """"""memory,%d,m\n"""""" % (self.memory). # format molecule, incl. charges and dummy atoms; text += self.molecule.format_molecule_for_molpro(). # format global convergence directions; text += self.format_global_parameters(). # format castup directions; if self.castup is True:; text += """"""basis=sto-3g\n""""""; text += """"""rhf\n""""""; text += '\n'. # format basis set; text += self.format_basis(). # format method; for line in qcmtdIN[self.method]:; text += """"""%s\n"""""" % (line); text += """"""show[1,20f20.12],ee*,ce*,te*\n""""""; text += """"""show[1,60f20.12],_E*\n""""""; text += '\n'. return text. qcmtdIN = {; 'ccsd(t)-f12': [; 'rhf',; 'eehf=energy',; 'ccsd(t)-f12,df_basis=mp2fit,df_basis_exch=jkfitb,ri_basis=jkfitb',; 'eemp2=emp2',; 'cemp2=eemp2-eehf',; 'eemp3=em",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html:2866,Validat,ValidationError,2866,psi4manual/1.0.0/_modules/qcdb/molpro.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro.html,1,['Validat'],['ValidationError']
Security,"-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:85832,Validat,ValidationError,85832,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"-based props; if (n_one > 0 or n_two > 0):; if (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.set_global_option('ONEPDM', 'TRUE'); PsiMod.cceom(); elif (name.lower() == 'eom-cc2'):; PsiMod.set_global_option('WFN', 'EOM_CC2'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.set_global_option('ONEPDM', 'TRUE'); PsiMod.cceom(); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.set_global_option('ONEPDM', 'TRUE'); PsiMod.cclambda(); PsiMod.ccdensity(). # Need ccresponse only for response-type props; if (n_response > 0):; PsiMod.set_global_option('DERTYPE', 'RESPONSE'); PsiMod.cclambda(); for prop in response:; PsiMod.set_global_option('PROPERTY', prop); PsiMod.ccresponse(). # Excited-state transition properties; if (n_excited > 0):; if (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); elif (name.lower() == 'eom-cc2'):; PsiMod.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""Unknown excited-state CC wave function.""); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.set_global_option('ONEPDM', 'TRUE'); PsiMod.cceom(); PsiMod.cclambda(); PsiMod.ccdensity(). PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.revoke_global_option_changed('DERTYPE'). [docs]def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). PsiMod.set_global_option('ONEPDM', 'TRUE'); PsiMod.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; #PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF') # insufficient b/c SCF option read in DFMP2; PsiMod.set_global_option('SCF_TYPE', 'DF'). if not PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 properties",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:29403,Validat,ValidationError,29403,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"-based props; if (n_one > 0 or n_two > 0):; if (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.set_global_option('ONEPDM', 'TRUE'); PsiMod.cceom(); elif (name.lower() == 'eom-cc2'):; PsiMod.set_global_option('WFN', 'EOM_CC2'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.set_global_option('ONEPDM', 'TRUE'); PsiMod.cceom(); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.set_global_option('ONEPDM', 'TRUE'); PsiMod.cclambda(); PsiMod.ccdensity(). # Need ccresponse only for response-type props; if (n_response > 0):; PsiMod.set_global_option('DERTYPE', 'RESPONSE'); PsiMod.cclambda(); for prop in response:; PsiMod.set_global_option('PROPERTY', prop); PsiMod.ccresponse(). # Excited-state transition properties; if (n_excited > 0):; if (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); elif (name.lower() == 'eom-cc2'):; PsiMod.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""Unknown excited-state CC wave function.""); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.set_global_option('ONEPDM', 'TRUE'); PsiMod.cceom(); PsiMod.cclambda(); PsiMod.ccdensity(). PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.revoke_global_option_changed('DERTYPE'). [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; if (name.lower() == 'eom-ccsd'):; PsiMod.set_global_option('WFN', 'EOM_CCSD'); run_ccenergy('ccsd', **kwargs); PsiMod.set_global_option('WFN', 'EOM_CCSD'); elif (name.lower() == 'eom-cc2'):; PsiMod.set_global_option('WFN', 'EOM_CC2'); run_ccenergy('cc2', **kwargs); PsiMod.set_global_option('WFN', 'EOM_CC2'); elif (name.lower() == 'eom-cc3'):; PsiMod.set_global_option('WFN', 'EOM_CC3'); run_ccenergy('cc3', **kwargs); PsiMod.set_global_option('WFN', 'EOM_CC3'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:19535,Validat,ValidationError,19535,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:34448,Validat,ValidationError,34448,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; data",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35165,Validat,ValidationError,35165,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_follow[lgeom[il]]:; raise ValidationError(; """"""This is not how a Zmat works - aim for lower triangular. Line len ({}) may be followed by line len ({}), not ({})."""""".format(; lgeom[il], allowed_to_follow[lgeom[il]]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:22093,Validat,ValidationError,22093,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are feezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:57692,Validat,ValidationError,57692,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,". """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When True, do not print to the output file. Returns; -------; int; Number of bytes of memory set. Raises; ------; ValidationError; When <500MiB or disallowed type or misformatted. Examples; --------. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. >>> # Good examples; >>> psi4.set_memory(800000000) # 800000000; >>> psi4.set_memory(2004088624.9) # 2004088624; >>> psi4.set_memory(1.0e9) # 1000000000; >>> psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_mem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:4147,Validat,ValidationError,4147,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,". CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFJCOSK; docstring. DFJLinK; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ExternalPotential; Stores external potential field, computes external potential matrix. FCHKWriter; Extracts information from a wavefunction object, and writes it to an FCHK file. FDDS_Dispersion; docstring. FISAPT; A Fragment-SAPT Wavefunction. FittedSlaterCorrelationFactor; docstring. FittingMetric; docstring. FragmentType; Fragment activation status. Functional; docstring. GaussianShell; Class containing information about basis functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:11759,access,access,11759,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['access'],['access']
Security,". Keys are _f_fields. Formerly JOBS_EXT.; trove: List[Dict[str, Any]] = []. # Minimal (enlightened) list of jobs to run to satisfy full CBS. Keys are _f_fields. Formerly JOBS.; compute_list: List[Dict[str, Any]] = []. # One-to-One list of AtomicComputer-s corresponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""bas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:54091,Validat,ValidationError,54091,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,". LINEQ_SOLVER (DFOCC)¶DFOCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINEQ_SOLVER (OCC)¶OCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINESEARCH_STATIC_MAX (OPTKING)¶OPTKING — If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.100. LINESEARCH_STATIC_MIN (OPTKING)¶OPTKING — If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.001. LINESEARCH_STATIC_N (OPTKING)¶OPTKING — If doing a static line search, scan this many points. Type: integer; Default: 8. LITERAL_CFOUR (GLOBALS)¶GLOBALS — Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. LOCAL (CCENERGY)¶CCENERGY — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCEOM)¶CCEOM — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCLAMBDA)¶CCLAMBDA — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCRESPONSE)¶CCRESPONSE — Do simulate local correlation?. Type: boolean; Default: false. LOCAL_CONVERGENCE (DLPNO)¶DLPNO — Convergence criteria for the Foster-Boys orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_CONVERGENCE (FISAPT)¶FISAPT — Relative convergence in orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_CONVERGENCE (SCF)¶SCF — The convergence on the orbital localization procedure. Type: conv double; Default: 1e-12. LOCAL_CPHF_CUTOFF (CCENERGY)¶CCENERGY — Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:152109,Access,Access,152109,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,2,['Access'],['Access']
Security,". LINEQ_SOLVER (DFOCC)¶DFOCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINEQ_SOLVER (OCC)¶OCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINESEARCH_STATIC_MAX (OPTKING)¶OPTKING — If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.100. LINESEARCH_STATIC_MIN (OPTKING)¶OPTKING — If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.001. LINESEARCH_STATIC_N (OPTKING)¶OPTKING — If doing a static line search, scan this many points. Type: integer; Default: 8. LITERAL_CFOUR (GLOBALS)¶GLOBALS — Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. LOCAL (CCENERGY)¶CCENERGY — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCEOM)¶CCEOM — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCLAMBDA)¶CCLAMBDA — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCRESPONSE)¶CCRESPONSE — Do simulate local correlation?. Type: boolean; Default: false. LOCAL_CONVERGENCE (FISAPT)¶FISAPT — Relative convergence in orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_CONVERGENCE (SCF)¶SCF — The convergence on the orbital localization procedure. Type: conv double; Default: 1e-12. LOCAL_CPHF_CUTOFF (CCENERGY)¶CCENERGY — Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_CPHF_CUTOFF (CCLAMBDA)¶CCLAMBDA — Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_CPHF_CUTO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:151348,Access,Access,151348,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['Access'],['Access']
Security,". OCC;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . ccsd; CC_TYPE. CCENERGY; D;  ;  ; D;  ;  ; D;  ;  ; D;  ;  ; D;  ;  ; D;  ;  . DETCI;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC; Y; D; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ; Y; Y;  ;  ;  ;  ;  ;  ;  ; D;  ;  ;  ;  ;  ;  ;  . ccsd(t); CC_TYPE. CCENERGY; D;  ;  ; D;  ;  ; D;  ;  ; D;  ;  ; D;  ;  ;  ;  ;  . DETCI;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC; Y; D; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ; Y; Y;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . ccsd(at); CC_TYPE. CCENERGY; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DETCI;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ; D; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . cisd; CI_TYPE. CCENERGY;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DETCI; Y;  ;  ;  ;  ;  ; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . Footnotes. [1]Algorithm type selection keyword below. Values to the right: conventional CONV (here abbreviated CV), density-fitted DF, and Cholesky-decomposed CD. [2](1, 2) Also available for KS reference. [3](1, 2) Conditions have no default module (computationally inefficient) and can only be accessed by specifying QC_MODULE. table of contents. Notes on Options; Alternate Implementations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/notes_c-1.html:5965,access,accessed,5965,psi4manual/1.3.2/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/notes_c-1.html,2,['access'],['accessed']
Security,". Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to input zetas and values; type from `valueLO`. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; f""scf_xtpl_truhlar_2: Inputs must be of the same datatype! ({type(valueLO)}, {type(valueHI)})""). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI**(-1 * alpha) - zLO**(-1 * alpha)); beta_mult = zHI**(-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:7942,Validat,ValidationError,7942,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,4,['Validat'],['ValidationError']
Security,". Replace\n\n\t\tpubchem:%s\n\n"" % (string); msg += ""\twith the Chemical ID number or exact name from one of the following and re-run.\n\n""; msg += ""\t Chemical ID IUPAC Name\n\n""; for result in results:; msg += ""%s"" % (result); if result.name().lower() == string.lower():; #We've found an exact match!; return result.getMoleculeString(); return msg. def process_molecule_command(matchobj):; """"""Function to process match of ``molecule name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); geometry = matchobj.group(3); geometry = pubchemre.sub(process_pubchem_command, geometry); from_filere = re.compile(r'^(\s*from_file\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE); geometry = from_filere.sub(process_from_file_command, geometry); molecule = spaces. if name != """":; if sys.version_info >= (3, 0):; if not name.isidentifier():; raise ValidationError('Molecule name not valid Python identifier: ' + name); else:; if not re.match(r'^[^\d\W]\w*\Z', name):; raise ValidationError('Molecule name not valid Python identifier: ' + name). molecule += 'core.efp_init()\n' # clear EFP object before Molecule read in; molecule += spaces. if name != """":; molecule += '%s = ' % (name). molecule += 'geometry(""""""%s""""""' % (geometry); if name != """":; molecule += ',""%s""' % (name). molecule += "")\n""; molecule += '%score.IO.set_default_namespace(""%s"")' % (spaces, name). return molecule. def process_literal_blocks(matchobj):; """"""Function to process match of ``literals_psi4_yo-...``.""""""; return literals[matchobj.group(1)]. def process_cfour_command(matchobj):; """"""Function to process match of ``cfour name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); cfourblock = matchobj.group(3). literalkey = str(uuid.uuid4())[:8]; literals[literalkey] = cfourblock; return ""%score.set_global_option(\""%s\"", \""\""\""%s\n\""\""\"")\n"" % \; (spaces, 'LITERAL_CFOUR', 'literals_psi4_yo-' + literalkey). def process_extract_command(matchobj):; """"""Function to process match of ``extract_su",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/inputparser.html:8112,Validat,ValidationError,8112,psi4manual/1.2.1/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/inputparser.html,1,['Validat'],['ValidationError']
Security,". To explicitly specify the location of the the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documented below. run_cfour(name[, keep, path])[source]¶; Function that prepares environment and input files; for a calculation calling Stanton and Gauss’s CFOUR code.; Also processes results back into Psi4 format.; This function is not called directly but is instead called by; energy() or optimize() when a Cfour; method is requested (through name argument). In order to function; correctly, the Cfour executable xcfour must be present in; PATH or PSIPATH. Many PSI Variables extracted from the Cfour output; Python dictionary of associated file constants accessible as P4C4_INFO['zmat'], P4C4_INFO['output'], P4C4_INFO['grd'], etc. Parameters:; name (string) – 'c4-scf' || 'c4-ccsd(t)' || 'cfour' || etc.; First argument, usually unlabeled. Indicates the computational; method to be applied to the system. keep (boolean) – 'on' || 'off' ; Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. path (string) – Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory.; If specified, GENBAS and/or ZMAT within will be used. genbas (string) – Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; Psi4‘s BASIS keyword. In that case, a GENBAS is written from; LibMints and all is well. Otherwise, a GENBAS is looked for in; the usual places: PSIPATH, PATH, PSIDATADIR/basis. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:24031,access,accessible,24031,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['access'],['accessible']
Security,". Values: list of atom charges for that fragment.""). return_total_data: Optional[bool] = Field(None, description=""When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs] @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs] @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs] @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs] @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs] @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_ch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:34713,validat,validator,34713,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,". castdf = 'DF' in core.get_global_option('SCF_TYPE'). if core.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast:; # Cast is a special case; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:49752,Validat,ValidationError,49752,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,". castdf = 'DF' in core.get_global_option('SCF_TYPE'). if core.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'); elif name in ['r2scan3c', 'r2scan-3c']:; core.set_global_option('BASIS', 'def2-mTZVPP'); elif name in ['b973c', 'b97-3c']:; core.set_global_option('BASIS', 'def2-mTZVP'); elif name in ['wb97x3c', 'wb97x-3c']:; core.set_global_option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:50041,Validat,ValidationError,50041,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,". def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:131404,Validat,ValidationError,131404,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,6,['Validat'],['ValidationError']
Security,". else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise FeatureNotImplemented('Molecule::init_with_checkpoint') # FINAL. [docs] def init_with_io(self, psio):; """""" **NYI** Pull information from a chkpt object created from psio; (method name in libmints is init_with_psio). """"""; raise FeatureNotImplemented('Molecule::init_with_io') # FINAL. @classmethod; [docs] def init_with_xyz(cls, xyzfilename):; """"""Pull information from an XYZ file. No fragment or chg/mult info detected. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:20979,Validat,ValidationError,20979,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,". from psi4.driver import psifiles as psif; from psi4.driver.p4util.testing import compare_integers, compare_values, compare_recursive; from psi4.driver.procrouting.proc_util import check_iwl_file_from_scf_type. from psi4 import core; from .exceptions import ValidationError, TestComparisonError. [docs]; def fcidump(wfn: core.Wavefunction, fname: str = 'INTDUMP', oe_ints: Optional[List] = None):; """"""Save integrals to file in FCIDUMP format as defined in Comp. Phys. Commun. 54 75 (1989),; https://doi.org/10.1016/0010-4655(89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html:2351,Validat,ValidationError,2351,psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fcidump.html,1,['Validat'],['ValidationError']
Security,". psi4.print_out(""\n""); p4util.banner(""CP Computation: Results.""); psi4.print_out(""\n""). p4util.banner(""Hartree"", 2); psi4.print_out(""\n""). psi4.print_out(str(cp_table)). psi4.print_out(""\n""); p4util.banner(""kcal*mol^-1"", 2); psi4.print_out(""\n""). cp_table.scale(). psi4.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:23802,access,accessible,23802,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['access'],['accessible']
Security,". self.sset[label] = OrderedDict(); for rxn in lsslist:; self.sset[label][rxn] = self.hrxn[rxn]; self.oss[label] = Subset(name=label,; hrxn=self.sset[label].keys(),; tagl=tagl); print(""""""WrappedDatabase %s: Subset %s formed: %d"""""" % (self.dbse, label, len(self.sset[label].keys()))). [docs] def compute_errors(self, modelchem, benchmark='default', sset='default', failoninc=True, verbose=False):; """"""For full database or subset *sset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if isinstance(sset, basestring):; # sset is normal subset name 'MX' corresponding to HRXN_MX or MX array in database module; try:; lsset = self.sset[sset.lower()]; except KeyError as e:; # raise ValidationError(""""""Subset named %s not available"""""" % (str(e))); lsset = OrderedDict(); else:; if callable(sset):; # sset is function that will generate subset of HRXN from sset(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset(self)]; else:; # sset is array containing reactions; lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in sset]; # assemble dict of qcdb.Reaction objects from array of reaction names; lsset = OrderedDict(); for rxn in lsslist:; lsset[rxn] = self.hrxn[rxn]. # cureinfo = self.get_pec_weightinfo(); err = {}; for rxn, oRxn in lsset.iteritems():; lbench = oRxn.benchmark if benchmark == 'default' else benchmark; try:; mcLesser = oRxn.data[modelchem].value; except KeyError as e:; if failoninc:; raise ValidationError(""""""Reaction %s missing datum %s."""""" % (str(rxn), str(e))); else:; continue; try:; mcGreater = oRxn.data[lbench].value; except KeyError as e:; if lbench == 'ZEROS':; pass; else:; print(""""""Reaction %s missing benchmark"""""" % (str(rxn))); continue; # handle particulars of PEC error measures; # rxncureinfo = cur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:32253,Validat,ValidationError,32253,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,". set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. shape¶; Shape of the Psi4 data object. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: pybind11_builtins.pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of unit length and arg1 direction. class psi4.core.VectorMatrix¶; Bases: pybind11_builtins.pybind11_object. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:213594,access,accessor,213594,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['access'],['accessor']
Security,". user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:71062,Validat,ValidationError,71062,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,".2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); dftd3_tmpdir = 'dftd3_' + str(random.randint(0, 99999)); if os.path.exists(dftd3_tmpdir) is False:; os.mkdir(dftd3_tmpdir); os.chdir(dftd3_tmpdir). # Write dftd3_parameters file that governs dispersion calc; paramfile = './",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:27278,Validat,ValidationError,27278,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,".26601138679877; # C 0.00000000000000 0.00000000000000 -3.15195886530135; # H 0.00000000000000 0.00000000000000 7.28558683837122; # H 0.00000000000000 0.00000000000000 -1.12178201232889; # N 0.00000000000000 0.00000000000000 3.08339310458383; # N 0.00000000000000 0.00000000000000 -5.33865984413460. sapt = {'mol1': -0.0105313323529,; 'mol2': -0.00839486625709}. nre = {'mol1': 38.8138764635,; 'mol2': 72.3451968428}. set basis jun-cc-pvdz. for mol in ['mol1', 'mol2']:; filen = mol + '.xyz'; p4mol = Molecule.init_with_xyz(filen) # create molecule from file above; fragmentedmol = auto_fragments(molecule=p4mol) # fragment with BFS algorithm; activate(fragmentedmol) # activate returned molecule (for sapt). e = energy('sapt0') # run SAPT that requires 2 fragments; compare_values(sapt[mol], e, 5, '%s sapt ok' % mol); compare_values(nre[mol], p4mol.nuclear_repulsion_energy(), 4, '%s ok' % mol); clean() # clean scratch between loop calcs. The essential element, mass and coordinate information of the molecule is accessible; molecule eneyne {; 0 1; C_ene 0.000000 -0.667578 -2.124659; C_ene 0.000000 0.667578 -2.124659; H_ene@2.014 0.923621 -1.232253 -2.126185; H_ene -0.923621 -1.232253 -2.126185; H_ene -0.923621 1.232253 -2.126185; Gh(H_ene) 0.923621 1.232253 -2.126185; --; 0 1; X 9.0 9.0 9.0; C_yne 0.000000 0.000000 2.900503; C_yne 0.000000 0.000000 1.693240; H_yne 0.000000 0.000000 0.627352; H_yne 0.000000 0.000000 3.963929; }. eneyne.update_geometry(). for iat in range(eneyne.natom()):; print """"""{:4} {:4} {:12} {:8.4f} {:12.6f} {:12.6f} {:12.6f} {:12.6f}"""""".format(; eneyne.Z(iat), # atomic number; eneyne.symbol(iat), # element symbol; eneyne.label(iat), # input element label; eneyne.charge(iat), # element charge; eneyne.x(iat), # x-coordinate; eneyne.y(iat), # y-coordinate; eneyne.z(iat), # z-coordinate; eneyne.mass(iat), # mass; ). # 6.0 C C_ENE 6.0000 -0.031900 -1.218981 -3.948079 12.000000; # 6.0 C C_ENE 6.0000 -0.031900 1.304098 -3.948079 12.000000; # 1.0 H H_ENE 1.0000 1.7",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithonmol.html:19963,access,accessible,19963,psi4manual/master/psithonmol.html,https://psicode.org,https://psicode.org/psi4manual/master/psithonmol.html,11,['access'],['accessible']
Security,".5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""a-ccsd(t)"": {""wfn_type"": ""DF-CCSD(AT)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC energy""). # throw exception for CONV (approximately). run reference defaulting logic; set_cholesky_from(method_algorithm_type(name).now). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:64471,Validat,ValidationError,64471,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,".; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys. import numpy as np. from psi4 import core; from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr : array or list of arrays; Numpy array or list of arrays to use as the data for a new core.Matrix; name : str; Name to give the new core.Matrix; dim1 : list, tuple, or core.Dimension (optional); If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 :; Same as dim1 only if using a psi4.core.Dimension object. Returns; -------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Returns the given Psi4 object. Notes; -----; This is a generalized function to convert a NumPy array to a Psi4 object. Examples; --------. >>> data = np.random.ran",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:1851,Validat,ValidationError,1851,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,".; frequency() is the only command most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'hessian' || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/freq-1.html:1435,access,accessed,1435,psi4manual/1.0.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/freq-1.html,2,['access'],['accessed']
Security,".ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Specia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:35688,Validat,ValidationError,35688,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,".Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs):; """"""; Chains dot products together from a series of Psi4 Matrix classes. By default there is no transposes, an optional vector of booleans can be passed in.; """""". trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irreped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:12211,access,accessing,12211,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,3,['access'],['accessing']
Security,".Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs):; """"""; Chains dot products together from a series of Psi4 Matrix classes. By default there is no transposes, an optional vector of booleans can be passed in.; """""". trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irreped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; ""irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:12142,access,accessing,12142,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,1,['access'],['accessing']
Security,".Vector, psio: psi4.core.IO, file: int) → None¶; Save the vector to disk. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.ProtoVector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector]) – Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {‘matrix’, ‘vector’}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector) → float¶; Take the dot product of two vectors. zero(self: psi4.core.Vector) → None¶; Zeros the vector. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; Vector. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Vector.html:7312,access,accessor,7312,psi4manual/1.7.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Vector.html,1,['access'],['accessor']
Security,".array_interfaces()):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1 ; start2 += d2. return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. elif arr_type == psi4.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""); ; dim1 = psi4.Dimension.from_list(dim1) ; ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.array_interfaces()):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1 . return ret; ; # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret_view = np.asarray(ret); ret_view[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def to_array(matrix, copy=True, dense=False):; """"""; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view.; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. ret = []; for h in matrix.array_interfaces():; if 0 in h.__array_interface__[""shape""]:; ret.append(np.empty(shape = h.__array_interface__[""shape""])); else:; ret.append(np.array(h, copy=copy)). # Return the list of arrays; if dense is False:; return ret; ; # Build the dense matrix; if isinstance(matrix, psi4.Vector):; ret_type = '1D'; elif isinstance(matrix, psi4.Matrix):; ret_type = '2D'; else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % type(matrix)). dim1 = []; dim2 = []; for h in ret:; # Ignore zero dim irreps; if 0 in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). nd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html:5970,Validat,ValidationError,5970,psi4manual/1.0.0/_modules/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,".core.Slice) → psi4.core.Vector¶; Get a vector block. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; Vector. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.vector.html:5172,access,accessor,5172,psi4manual/1.4.0/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.vector.html,1,['access'],['accessor']
Security,".core.Slice) → psi4.core.Vector¶; Get a vector block. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a NumPy array. Either copies the data or simply; constructs a view. Parameters. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns; Returns either a list of np.array’s or the base array depending on options. Return type; numpy.ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; Vector. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.vector.html:5174,access,accessor,5174,psi4manual/1.5.0/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.vector.html,1,['access'],['accessor']
Security,".get_variable('SCS-MP2 CORRELATION ENERGY'). else:; psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). user_ref = psi4.get_option('DETCI', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'ROHF'):; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if (name.lower() == 'zapt'):; psi4.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; psi4.set_local_option('DETCI', 'MA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:40053,Validat,ValidationError,40053,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,".group('pre') + ""{0:d}"".format(zeta_sym2val[b] - 1)); # assemble nZaPa basis sets; elif zapa_basis.match(basisname.group('post')):; bzapa = b.replace(""d"",""2"").replace(""t"",""3"").replace(""q"",""4""); BSET.append(basisname.group('pre') + bzapa + basisname.group('post')); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(; """"""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]' or '[1234567]ZaPa' """""" % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n""""""; elif isinstance(molecule, core.Molecule):; molecule = qcdb.Molecule(molecule.to_dict()). for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e = sys.exc_info()[1]; raise ValidationError(""""""Basis set '%s' not available for molecule."""""" % (basis)). return (BSET, ZSET). def _contract_bracketed_basis(basisarray):; """"""Function to reform a bracketed basis set string from a sequential series; of basis sets. Essentially the inverse of _expand_bracketed_basis(). Used to; print a nicely formatted basis set string in the results table. Parameters; ----------; basisarray : list; Basis set names, differing by zeta level, e.g. ``[""cc-pvqz"", ""cc-pv5z""]``. Returns; -------; string; A nicely formatted basis set string, e.g. ``""cc-pv[q5]z""`` for the above example. """""". if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]. pre = basisarray[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post; return basisstring. [docs]def xtpl_highest_1(functionname, zHI, valueHI, verbose=True, **kwargs):; r""""""Scheme ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:5113,Validat,ValidationError,5113,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,".match(line):; what = atom_array.match(line).group(1).split(); # Check the captures and see if this basis set is for the atom we need.; found = False; if symbol in [x.upper() for x in what]:; found = True; msg = """"""line %5d"""""" % (lineno). # Read in the next line; line = lines[lineno]; lineno += 1. # Need to do the following until we match a ""****"" which is the end of the basis set; while not separator.match(line):; # Match shell information; if shell.match(line):; what = shell.match(line); shell_type = str(what.group(1)).upper(); nprimitive = int(what.group(2)); scale = float(what.group(3)). if len(shell_type) == 1:; am = shell_to_am[shell_type[0]]. exponents = [0.0] * nprimitive; contractions = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives1.match(line); # Must match primitives1; will work on the others later; if not what:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to match an exponent with one contraction: line %d: %s"""""" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent wit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:6285,Validat,ValidationError,6285,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,1,['Validat'],['ValidationError']
Security,".match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, (unicode, str)):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (core.get_option('SCF', 'REFERENCE') in ['RHF', 'RKS']) and \; ((scf_molecule.natom() > 1) or core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:32253,Validat,ValidationError,32253,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,".match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:36232,Validat,ValidationError,36232,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,".molecule; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:1128,hash,hashlib,1128,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,1,['hash'],['hashlib']
Security,".molecule; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .constants import constants; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]; class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html:1130,hash,hashlib,1130,psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,1,['hash'],['hashlib']
Security,".molecule; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]; class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:1130,hash,hashlib,1130,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,1,['hash'],['hashlib']
Security,".molecule; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2024 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .constants import constants; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]; class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/qcdb/molecule.html:1137,hash,hashlib,1137,psi4manual/master/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/qcdb/molecule.html,1,['hash'],['hashlib']
Security,".outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen(cfour_executable.split(), bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); data = data.decode('utf-8'); if not data:; break; core.print_out(data); c4out += data; internal_p4c4_info['output'] = c4out. c4files = {}; core.print_out('\n'); for item in ['GRD', 'FCMFINAL', 'DIPOL']:; try:; with open(psioh.get_default_path() + cfour_tmpdir + '/' + item, 'r') as handle:; c4files[item] = handle.read(); core.print_out(' CFOUR scratch file %s has been read\n' % (item)); core.print_out('%s\n' % c4files[item]); internal_p4c4_info[item.lower()] = c4files[item]; except IOError:; pass; core.print_out('\n'). if molecule.name() == 'blank_molecule_psi4_yo':; qcdbmolecule = None; else:; molecule.update_geometry(); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.update_geometry(). # c4mol, if it exists, is dinky, just a clue to geometry of cfour results; psivar, c4grad, c4mol = qcdb.cfour.harvest(qcdbmolecule, c4out, **c4files). # Absorb results into psi4 data ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:8472,Validat,ValidationError,8472,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,4,['Validat'],['ValidationError']
Security,".print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159228,Validat,ValidationError,159228,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,".print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:164003,Validat,ValidationError,164003,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,".print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). optstash2 = OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if PsiMod.has_option_changed('SCF', 'BASIS_GUESS'):; cast = PsiMod.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if PsiMod.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = PsiMod.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; molecule = PsiMod.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if PsiMod.get_option('SCF','REFERENCE') != 'UHF' and PsiMod.get_option('SCF','REFERENCE') != 'UKS':; raise ValidationError('You must specify ""set reference uhf"" to use broken symmetry.'); do_broken = True; else:; do_broken = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that can't query PUREAM option directly, as it only; # reflects user changes to value, so load basis and; # read effective PUREAM setting off of it; PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')); PsiMod.set_global_option('PUREAM', PsiMod.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; molecule.set_multiplicity(3); PsiMod.print_out('\n'); banner(' Computing high-spin triplet guess '); PsiMod.print_out('\n'). # cast set-up",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:15899,Validat,ValidationError,15899,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,".qcdb.molecule; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:1128,hash,hashlib,1128,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,2,['hash'],['hashlib']
Security,".qcdb.molecule; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html:1128,hash,hashlib,1128,psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qcdb/molecule.html,1,['hash'],['hashlib']
Security,".set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables(include_d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:29408,Validat,ValidationError,29408,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,".set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); elif name in ['ccsd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); else:; raise ValidationError('Unidentified method %s' % (name)). if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:47310,Validat,ValidationError,47310,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,".set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); psi4.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); elif name in ['ccsd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); psi4.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); else:; raise ValidationError('Unidentified method %s' % (name)). if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_global_option('DERTYPE', 'FIRST'); psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); else:; raise ValidationError('Unidentified method ' % (name)). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if psi4.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:38545,Validat,ValidationError,38545,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,".set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(3)'; if (lowername == 'fno-acpf'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'ACPF'; if (lowername == 'fno-aqcc'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'AQCC'; if (lowername == 'fno-sdci'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'; if (lowername == 'fno-dci'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'. PsiMod.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level). # override symmetry for fno-cepa; if (PsiMod.get_option('FNOCC','NAT_ORBS')):; molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' FNOCC does not make use of molecular symmetry, further calculations in C1 point group.\n'). # throw an exception for open-shells; if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); scf_helper(name, **kwargs). # If the scf type is DF, then the AO integrals were never generated; if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; mints = PsiMod.MintsHelper(); mints.integrals(). if PsiMod.get_option('FNOCC','NAT_ORBS') == False:; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); PsiMod.transqt2(). # run cepa; PsiMod.fnocc(). # one-electron properties; if PsiMod.get_option('FNOCC', 'DIPMOM'):; if cepa_level == ""CEPA(1)"" or cepa_level == ""CEPA(3)"":; PsiMod.print_out(""\n""); PsiMod.print_out("" Error: one-electron properties not implemented for %s\n"" % lowername); PsiMod.print_out(""\n""); elif PsiMod.get_option('FNOCC','NAT_ORBS'):; PsiMod.print_out(""\n""); PsiMod.print_out("" Error: one-electron properties not implemented for %s\n"" % lowername); PsiMod.print_out(""\n""); else:; oeprop('DIPOLE','QUADRUPOLE','MULLIKEN_CHARGES','NO_OCCUPATIONS',title = cepa_lev",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:78026,Validat,ValidationError,78026,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,".shell_first_ao[shell_count] = ao_count; self.shell_first_basis_function[shell_count] = bf_count; shell_nprim = thisshell.nprimitive(); am = thisshell.am(); self.PYmax_nprimitive = max(shell_nprim, self.PYmax_nprimitive); self.PYmax_am = max(am, self.PYmax_am); self.shell_center[shell_count] = n; self.puream = thisshell.is_pure(); tst = ustart + atom_nprim; tsp = ustart + atom_nprim + shell_nprim; self.shells[shell_count] = GaussianShell(am, shell_nprim,; self.uoriginal_coefficients[tst:tsp],; self.ucoefficients[tst:tsp],; self.uerd_coefficients[tst:tsp],; self.uexponents[tst:tsp],; 'Pure' if self.puream else 'Cartesian',; n, xyz_ptr, bf_count); for thisbf in range(thisshell.nfunction()):; self.function_to_shell[bf_count] = shell_count; self.function_center[bf_count] = n; bf_count += 1; for thisao in range(thisshell.ncartesian()):; self.ao_to_shell[ao_count] = shell_count; ao_count += 1; atom_nprim += shell_nprim; shell_count += 1. if atom_nprim != uend - ustart:; raise ValidationError(""Problem with nprimitive in basis set construction!""). [docs] def constructor_basisset_center(self, bs, center):; """"""; * Creates a new basis set object for an atom, from an existing basis set; * bs: the basis set to copy data from; * center: the atom in bs to copy over. """"""; # Singletons; these should've been initialized by this point, but just in case; if not self.initialized_shared:; self.initialize_singletons(); self.initialized_shared = True. # First, find the shells we need, and grab the data; uexps = []; ucoefs = []; uoriginal_coefs = []; uerd_coefs = []; self.name = bs.name; self.n_shells = 0; self.n_uprimitive = 0; self.PYnao = 0; self.PYnbf = 0; for shelln in range(bs.nshell()):; shell = bs.shell(shelln); if shell.ncenter() == center:; nprim = shell.nprimitive(); for prim in range(nprim):; uexps.append(shell.exp(prim)); ucoefs.append(shell.coef(prim)); uoriginal_coefs.append(shell.original_coef(prim)); uerd_coefs.append(shell.erd_coef(prim)); self.n_uprimitive += 1; self.n_sh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:10061,Validat,ValidationError,10061,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['Validat'],['ValidationError']
Security,".strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:40573,Sanitiz,Sanitize,40573,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,4,['Sanitiz'],['Sanitize']
Security,"//ipi-code.org/). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_method(name); Replace characters in method name so that suitable for function name or Sphinx table anchor (both as-is) or HTML table link (replace underscore in returned string by dash). sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Reset the total memory",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:19452,validat,validate,19452,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['validat'],['validate']
Security,"/or user `param_tweaks`.; fctldash : str; If :py:attr:`dashparams` for :py:attr:`dashlevel` corresponds to a defined,; named, untweaked ""functional-dashlevel"" set, then that; functional. Otherwise, empty string.; description : str; Tagline for dispersion :py:attr:`dashlevel`.; dashlevel_citation : str; Literature reference for dispersion :py:attr:`dashlevel` in general,; *not necessarily* for :py:attr:`dashparams`.; dashparams_citation : str; Literature reference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""bless"" the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; `qcengine.programs.empirical_dispersion_resources.dashcoeff` itself for purposes of; validating :py:attr:`fctldash`.; engine : str; {'libdisp', ""s-dftd3"", 'dftd3', 'nl', 'mp2d', ""dftd4""}; Compute engine for dispersion. One of Psi4's internal libdisp; library, external Grimme or Beran projects, or nl.; disp : Dispersion; Only present for :py:attr:`engine` `=libdisp`. Psi4 class instance prepared; to compute dispersion.; ordered_params : list; Fixed-order list of relevant parameters for :py:attr:`dashlevel`. Matches; :rst:psivar:`DISPERSION CORRECTION ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:4556,validat,validating,4556,psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,4,['validat'],['validating']
Security,"/or user `param_tweaks`.; fctldash : str; If :py:attr:`dashparams` for :py:attr:`dashlevel` corresponds to a defined,; named, untweaked ""functional-dashlevel"" set, then that; functional. Otherwise, empty string.; description : str; Tagline for dispersion :py:attr:`dashlevel`.; dashlevel_citation : str; Literature reference for dispersion :py:attr:`dashlevel` in general,; *not necessarily* for :py:attr:`dashparams`.; dashparams_citation : str; Literature reference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""bless"" the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; `qcengine.programs.empirical_dispersion_resources.dashcoeff` itself for purposes of; validating :py:attr:`fctldash`.; engine : str; {'libdisp', 'dftd3', 'nl', 'mp2d', ""dftd4""}; Compute engine for dispersion. One of Psi4's internal libdisp; library, external Grimme or Beran projects, or nl.; disp : Dispersion; Only present for :py:attr:`engine` `=libdisp`. Psi4 class instance prepared; to compute dispersion.; ordered_params : list; Fixed-order list of relevant parameters for :py:attr:`dashlevel`. Matches; :rst:psivar:`DISPERSION CORRECTION ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:3580,validat,validating,3580,psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,2,['validat'],['validating']
Security,"/or user `param_tweaks`.; fctldash : str; If :py:attr:`dashparams` for :py:attr:`dashlevel` corresponds to a defined,; named, untweaked ""functional-dashlevel"" set, then that; functional. Otherwise, empty string.; description : str; Tagline for dispersion :py:attr:`dashlevel`.; dashlevel_citation : str; Literature reference for dispersion :py:attr:`dashlevel` in general,; *not necessarily* for :py:attr:`dashparams`.; dashparams_citation : str; Literature reference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""bless"" the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; `qcengine.programs.empirical_dispersion_resources.dashcoeff` itself for purposes of; validating :py:attr:`fctldash`.; engine : str; {'libdisp', 'dftd3', 'nl', 'mp2d'}; Compute engine for dispersion. One of Psi4's internal libdisp; library, Grimme's DFTD3 executable, or nl.; disp : Dispersion; Only present for :py:attr:`engine` `=libdisp`. Psi4 class instance prepared; to compute dispersion.; ordered_params : list; Fixed-order list of relevant parameters for :py:attr:`dashlevel`. Matches; :rst:psivar:`DISPERSION CORRECTION ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:3538,validat,validating,3538,psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['validat'],['validating']
Security,"0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]¶. right = [1.0, 0.0, 0.0]¶. save_density(filename='rho', overlap=2.0, n=[40, 40, 40], caxis=[0.0, 1.0])[source]¶. save_molecule(filename)[source]¶. set_camera(location, sky, up, right, look_at, light, light_color)[source]¶. set_color(Z, color)[source]¶. set_define(key, value)[source]¶. set_radius(Z, radius)[source]¶. set_size(width, height)[source]¶. set_view(azimuth, elevation, zoom=0.7)[source]¶. sky = [0.0, -1.0, 0.0]¶. up = [0.0, 0.75, 0.0]¶. update_geometry()[source]¶. width = 1200¶. zoom = 0.5¶. Module with utility functions for use in input files. compare_arrays(expected, computed, digits, label)[source]¶; Function to compare two numpy arrays. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. compare_csx()[source]¶; Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. compare_cubes(expected, computed, label)[source]¶; Function to compare two cube files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_integers(expected, computed, label)[source]¶; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_strings(expected, computed, label)[source]¶; Function to compare two strings. Prints util.success(); when strin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:132000,validat,validate,132000,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['validat'],['validate']
Security,"0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Vector, arg0: int) -> float. docstring. get(self: psi4.core.Vector, arg0: int, arg1: int) -> float. docstring. name; The name of the Vector. Used in printing. nirrep(self: psi4.core.Vector) → int; docstring. np; View without only one irrep. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). nph; View with irreps. print_out(self: psi4.core.Vector) → None; docstring. scale(self: psi4.core.Vector, arg0: float) → None; docstring. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, arg0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. shape; Shape of the Psi4 data object. to_array(matrix, copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data); Converts an object with a .nph accessor to a serialized dictionary. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html:6918,access,accessor,6918,psi4manual/1.1.0/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.vector.html,1,['access'],['accessor']
Security,"0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; Matrix object through the wfn as; psi4.core.Wavefunction.gradient(). Previously, cfour communicated through; psi4.core.legacy_gradient which was accessed through psi4.core.get_gradient(); Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the PSI4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documented below. psi4.driver.procrouting.interface_cfour.run_cfour(name[, keep, path])[source]¶; Function that prepares environment and input files; for a calculation calling Stanton and Gauss’s CFO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:22695,Access,Accessible,22695,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,4,['Access'],['Accessible']
Security,"0000000000000 0.00000000000000 7.28558683837122; # H 0.00000000000000 0.00000000000000 -1.12178201232889; # N 0.00000000000000 0.00000000000000 3.08339310458383; # N 0.00000000000000 0.00000000000000 -5.33865984413460. sapt = {'mol1': -0.0105313323529,; 'mol2': -0.00839486625709}. nre = {'mol1': 38.8138764635,; 'mol2': 72.3451968428}. set basis jun-cc-pvdz. for mol in ['mol1', 'mol2']:; filen = mol + '.xyz'; p4mol = Molecule.init_with_xyz(filen) # create molecule from file above; fragmentedmol = auto_fragments(molecule=p4mol) # fragment with BFS algorithm; activate(fragmentedmol) # activate returned molecule (for sapt). e = energy('sapt0') # run SAPT that requires 2 fragments; compare_values(sapt[mol], e, 5, '%s sapt ok' % mol); compare_values(nre[mol], p4mol.nuclear_repulsion_energy(), 4, '%s ok' % mol); clean() # clean scratch between loop calcs. The essential element, mass and coordinate information of the molecule is accessible; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43molecule eneyne {; 0 1; C_ene 0.000000 -0.667578 -2.124659; C_ene 0.000000 0.667578 -2.124659; H_ene@2.014 0.923621 -1.232253 -2.126185; H_ene -0.923621 -1.232253 -2.126185; H_ene -0.923621 1.232253 -2.126185; Gh(H_ene) 0.923621 1.232253 -2.126185; --; 0 1; X 9.0 9.0 9.0; C_yne 0.000000 0.000000 2.900503; C_yne 0.000000 0.000000 1.693240; H_yne 0.000000 0.000000 0.627352; H_yne 0.000000 0.000000 3.963929; }. eneyne.update_geometry(). for iat in range(eneyne.natom()):; print """"""{:4} {:4} {:12} {:8.4f} {:12.6f} {:12.6f} {:12.6f} {:12.6f}"""""".format(; eneyne.Z(iat), # atomic number; eneyne.symbol(iat), # element symbol; eneyne.label(iat), # input element label; eneyne.charge(iat), # element charge; eneyne.x(iat), # x-coordinate; eneyne.y(iat), # y-coordinate; eneyne.z(iat), # z-coordinate; eneyne.mass(iat), # mass; ). # 6.0 C C_ENE 6.0000 -0.031900 -1.218981 -3.948079 12.000000; # 6.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:20150,access,accessible,20150,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['access'],['accessible']
Security,"0: int, arg1: float) -> None. docstring. set(self: psi4.core.Vector, arg0: int, arg1: int, arg2: float) -> None. docstring. shape¶; Shape of the Psi4 data object. to_array(matrix, copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; consturcts a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:np.array or list of of np.array. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(data)¶; Converts an object with a .nph accessor to a serialized dictionary. class psi4.core.Vector3¶; Bases: object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → psi4.core.Vector3¶; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3) → float¶; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3) → float¶; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3) → None¶; Returns vector of unit length and arg1 direction. class psi4.core.VectorMatrix¶; Bases: object. append(self: List[psi::Matrix], x: psi::Matrix) → None¶; Add an item to the end of the list. count(self: List[psi::Matrix], x: psi::Matrix) → int¶; Return the number of times x appears in the list. extend(self: List[psi::Matrix], L: List[psi::Matrix]) → None¶; Extend the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:135649,access,accessor,135649,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['access'],['accessor']
Security,"0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:5247,Validat,ValidationError,5247,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nirrep())); else:; return view_data[0].shape. @property; def _np_view(self):; """"""; View without only one irrep; """"""; if self.nirrep() > 1:; raise ValidationError(""Attempted to call .np on a Psi4 data object with multiple irreps.""; ""Please use .nph for objects with irreps.""); return _get_raw_views(self)[0]. @property; def _nph_view(self):; """"""; View with irreps.; """"""; return _get_raw_views(self). @property; def _array_conversion(self):; """"""; Provides the array interface to simply classes so that np.array(core.Matrix(5, 5)) works flawlessly.; """"""; if self.nirrep() > 1:; raise ValidationError(""__array__interface__ can only be called on Psi4 data object with only one irrep!""); else:; return self.np.__array_interface__. def _np_write(self, filename=None, prefix=""""):; """"""; Writes the irreped matrix to a NumPy zipped file. Can return the packed data for saving many matrices into the same file.; """""". ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; # If returning arrays to user, we want to return copies (snapshot), not; # views of the core.Matrix's memory.; if filename is None and not v.flags['OWNDATA']:; v = np.copy(v); ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def _np_read(self, filename, prefix=""""):; """"""; Reads the data from a NumPy compress file.; """""".",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:8210,Validat,ValidationError,8210,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,"1 s8 a2 alpha6=None version=4; pfile.write('%12.6f %12.6f %12.6f %12.6f %12.6f %6d\n' %; (dashcoeff[dashlvl][func]['s6'], dashcoeff[dashlvl][func]['a1'], dashcoeff[dashlvl][func]['s8'],; dashcoeff[dashlvl][func]['a2'], 0.0, 4)); pfile.close(). # Write dftd3_geometry file that supplies geometry to dispersion calc; geomfile = './dftd3_geometry.xyz'; gfile = open(geomfile, 'w'); gfile.write(self.save_string_xyz()); gfile.close(). # Call dftd3 program; try:; dashout = subprocess.Popen(['dftd3', geomfile, '-grad'], stdout=subprocess.PIPE); except OSError:; raise ValidationError('Program dftd3 not found in path.'); out, err = dashout.communicate(); if verbosity >= 3:; print out. # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; raise ValidationError('Program dftd3 did not complete successfully.'). # Parse grad output; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for at in dfile.readlines():; dashdderiv.append([float(x.replace('D', 'E')) for x in at.split()]); dfile.close(); if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Clean up files and remove scratch directory; # os.unlink(paramfile); # os.unlink(geomfile); # os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); # try:; # shutil.rmtree(dftd3_tmpdir); # except OSError as e:; # ValidationError('Unable to remove dftd3 temporary directory %s' % e, file=sys.stderr); os.chdir(current_directory). # return -D & d(-D)/dx; return dashd, dashdderiv. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta5] » ; Module code ». © Cop",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:29914,Validat,ValidationError,29914,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"1); mints.integrals(). ref_optstash.restore(). # The DF case; if core.get_option('DETCI', 'MCSCF_TYPE') == 'DF':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). core.print_out("" Constructing Basis Sets for MCSCF...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). # The AO case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'AO':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; # retire components by v1.5; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")); core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.var",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:166221,Validat,ValidationError,166221,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"1); mints.integrals(). ref_optstash.restore(). # The DF case; if core.get_option('DETCI', 'MCSCF_TYPE') == 'DF':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). core.print_out("" Constructing Basis Sets for MCSCF...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). # The AO case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'AO':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE X"", core.get_variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.get_variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.get_variable(name.upper() + "" DIPOLE Z"")). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """"""; # initialize library; efp = core.get_active_efp(). if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:132076,Validat,ValidationError,132076,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"1); mints.integrals(). ref_optstash.restore(). # The DF case; if core.get_option('DETCI', 'MCSCF_TYPE') == 'DF':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). core.print_out("" Constructing Basis Sets for MCSCF...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). # The AO case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'AO':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE X"", core.variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.variable(name.upper() + "" DIPOLE Z"")). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule())",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:131101,Validat,ValidationError,131101,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"1); mints.integrals(). ref_optstash.restore(). # The DF case; if core.get_option('DETCI', 'MCSCF_TYPE') == 'DF':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). core.print_out("" Constructing Basis Sets for MCSCF...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). # The AO case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'AO':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:174827,Validat,ValidationError,174827,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); assert compare_values(; rgeom, ageom, ""D: concern_mol-->returned_mol geometry matches ref_mol"", atol=1.0e-4, quiet=(verbose < 2); ); assert compare_values(0.0, final_rmsd, ""D: null RMSD"", atol=1.0e-4, quiet=(verbose < 2)). return final_rmsd, hold_solution. def _plausible_atom_orderings(ref, current, rgeom, cgeom, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; -------; iterator of tuples. """"""; if sorted(ref) != sorted(current):; raise ValidationError(; """"""ref and current can't map to each other.\n"""""" + ""R: "" + str(ref) + ""\nC: "" + str(current); ). where = collections.defaultdict(list); for iuq, uq in enumerate(ref):; where[uq].append(iuq). cwhere = collections.defaultdict(list); for iuq, uq in enumerate(current):; cwhere[uq].append(iuq). connect = collections.OrderedDict(); for k in where:; connect[tuple(where[k])] = tuple(cwhere[k]). def filter_permutative(rgp, cgp):; """"""Original atom ordering generator for like subset of atoms (e.g., all carbons).; Relies on permutation. Filtering depends on similarity of structure (see `atol` parameter).; Only suitable for total system size up to about 20 atoms. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)); bnbn = [rrdistmat[first, second] for first, second in zip(rgp, rgp[1:])]; for pm in itertools.permutations(cgp):; cncn = [ccdistmat[first, second] for first, second in zip(pm, pm[1:])]; if np.allclose(bnbn, cncn, atol=1.0):; if verbose >= 1:; print(""Candidat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html:10162,Validat,ValidationError,10162,psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,3,['Validat'],['ValidationError']
Security,"1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. >>> psi4/versioner.py; Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded); undefined {master} 6100822 1.0.0.999 1.0 <-- undefined+6100822. Note 7-char git hash for the new commit, here “6100822”. ACT to bump tag in git, then bump git tag in code. Use the decided-upon tag v1.1rc1 and the observed hash “6100822” to; mint a new annotated tag, minding that “v”s are present here.; Use the observed hash to edit psi4/psi4/metadata.py and commit immediately. >>> git tag -a v1.1rc1 6100822 -m ""v1.1rc1"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 6cbc05e..fdc202e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,5 +1,5 @@; __version__ = '1.1rc1'; -__version_long = '1.1rc1+zzzzzzz'; +__version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> psi4/versioner.py; Amazing, this can't actually happen that git hash stored at git commit.; >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.1rc1"". OBSERVE current versioning state. Nothing to make note of, this is just a snapshot. >>> psi4/versioner.py; Defining development snapshot version: 1.1rc2.dev1+4e0596e (computed); 1.1rc2.dev1 {master} 4e0596e 1.0.0.999 1.0 <-- 1.1rc2.dev1+4e0596e. >>> git describe --abbrev=7 --long --always HEAD; v1.1rc1-1-g4e0596e. >>> git describe --abbrev=7 --long --dirty; v1.1rc1-1-g4e0596e. >>> git tag; v1.0; v1.1a1; v1.1rc1. >>> cat psi4/metadata.py; __version__ = '1.1rc1'; __version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> cat metadata.out.py | head -8; __version__ = '1.1rc2.dev1'; __version_branch_name = 'master'; __version_cmake = '1.0.0.999'; __version_is_clean = 'True'; __version_last_release = '1.0'; __version_long = '1.1rc2.dev1+4e0596e'; __version_prerelease = 'False'; __version_release = 'False'. >>> git log --oneline; 4e0596e Records tag for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_git.html:2961,hash,hash,2961,psi4manual/master/manage_git.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_git.html,9,['hash'],['hash']
Security,"10); if (name.lower() == 'sapt0-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif (name.lower() == 'sapt2-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif (name.lower() == 'sapt2+-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); elif (name.lower() == 'sapt2+(3)-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3-ct'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.print_out('\n'); banner('SAPT Charge Transfer'); PsiMod.print_out('\n'). # if the df_basis_sapt basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SAPT') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_SAPT', ribasis); PsiMod.print_out('No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). PsiMod.print_out('\n'); banner('Dimer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'); e_sapt = PsiMod.sapt(); CTd = PsiMod.get_variable('SAPT CT ENERGY'). PsiMod.print_out('\n'); banner('Monomer Basis SAPT'); PsiMod.print_out('\n'); PsiMod.IO.change_file_namespace(121, 'monomerAm', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerBm', 'dimer'); e_sapt = PsiMod.sapt(); CTm = PsiMod.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. PsiMod.print_out('\n\n'); PsiMod.print_out(' SAPT Charge Transfer Analysis\n'); PsiMod.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:39761,Validat,ValidationError,39761,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions used by several Python functions."""""". __all__ = [; ""all_casings"",; ""drop_duplicates"",; ""expand_psivars"",; ""format_molecule_for_input"",; ""format_options_for_input"",; ""get_psifile"",; ""getattr_ignorecase"",; ""hold_options_state"",; ""import_ignorecase"",; ""kwargs_lower"",; ""mat2arr"",; ""prepare_options_for_modules"",; ""prepare_options_for_set_options"",; ""provenance_stamp"",; ""plump_qcvar"",; ""state_to_atomicinput"",; ]. import os; import ast; import sys; import math; import pickle; import inspect; import warnings; from contextlib import contextmanager; import collections; from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Union; from types import ModuleType. import numpy as np; from qcelemental.models import AtomicInput. from psi4 import core; from psi4.metadata import __version__; from .exceptions import ValidationError; from . import p4regex. [docs]def kwargs_lower(kwargs: Dict[str, Any]) -> Dict[str, Any]:; """"""Function to rebuild and return *kwargs* dictionary sanitized. Should be; called by every function that could be called directly by the user. Parameters; ----------; kwargs; Input kwargs for any user-facing function. Returns; -------; lowered : Dict[str, Any]; Sanitized kwargs with all keys made lowercase. Also turns boolean-like; values into actual booleans. Also turns values lowercase if sensible. """"""; caseless_kwargs = {}; for key, value in kwargs.items():; lkey = key.lower(); if lkey in ['subset', 'banner', 'restart_file', 'write_orbitals']: # only kw for which case matters; lvalue = value; else:; try:; lvalue = value.lower(); except (AttributeError, KeyError):; lvalue = value. if lkey in ['irrep', 'check_bsse', 'linkage', 'bsse_type']:; caseless_kwargs[lkey] = lvalue. elif 'dertype' in lkey:; if p4regex.der0th.match(str(lvalue)):; caseless_kwargs[lkey] = 0; elif p4regex.der1st.match(str(lvalue)):; caseless_kwargs[lkey] = 1; elif p4regex.der2nd.match(str(lvalue)):; caseless_kwa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:2139,sanitiz,sanitized,2139,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,1,['sanitiz'],['sanitized']
Security,"13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-scf Gradient Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ... Irrep: 1 Size: 4 x 3. 1 2 3. 1 0.0000000 -0.0122978 0.0000000; 2 -0.0051192 0.0040993 -0.0088667; 3 -0.0051192 0.0040993 0.0088667; 4 0.0102384 0.0040993 0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; Matrix object through; psi4.get_gradient().; Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the PSI4 input file.; 1; 2energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:23206,access,accessible,23206,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['access'],['accessible']
Security,"16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path tha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:8644,Validat,ValidationError,8644,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,8,['Validat'],['ValidationError']
Security,"16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = core.get_datadir(); #nolongerpredictable psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; driver_loc = os.path.dirname(os.path.abspath(__file__)); dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath + \; ':' + driver_loc # so the databases can ""import qcdb"". sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html:8723,Validat,ValidationError,8723,psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); #nolongerpredictable psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; driver_loc = os.path.dirname(os.path.abspath(__file__)); dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath + \; ':' + driver_loc # so the databases can ""import qcdb"". sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:8712,Validat,ValidationError,8712,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name #TODO; kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name #.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath; sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:8729,Validat,ValidationError,8729,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"1]. Vector3 class in psi4.core, [1]. vector_dot() psi4.core.Matrix method, [1], [2]. vector_multiply() psi4.core.CIVector method, [1], [2]. VectorMatrix class in psi4.core, [1]. version() in module psi4.core, [1]. vibrational analysis. ; function call. output. View class in psi4.core, [1]. visualization, [1]. VMDPATH. vmfc. ; setting keywords. Vvals() psi4.core.OEProp method, [1], [2]. W. WABEI_LOWDISK (CCHBAR). Wavefunction class in psi4.core, [1]. WebMO. WFN (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (CCTRIPLES). (DETCI). (GLOBALS). (SCF). WFN_SYM (MCSCF). (PSIMRCC). WFN_TYPE (DFOCC). (OCC). with_traceback() psi4.driver.ConvergenceError method. psi4.driver.CSXError method. psi4.driver.Dftd3Error method. psi4.driver.ManagedMethodError method. psi4.driver.ParsingError method. psi4.driver.PastureRequiredError method. psi4.driver.PsiException method. psi4.driver.PsiImportError method. psi4.driver.TestComparisonError method. psi4.driver.ValidationError method. wK() psi4.core.JK method, [1], [2]. write() psi4.core.CIVector method, [1], [2]. psi4.core.FCHKWriter method, [1], [2]. psi4.core.MOWriter method, [1], [2]. psi4.core.MoldenWriter method, [1], [2]. psi4.core.NBOWriter method, [1], [2]. write_scratch_file() psi4.core.IOManager method, [1], [2]. WRITER_FILE_LABEL (GLOBALS). X. X() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. x() psi4.core.Molecule method, [1], [2]. X() psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. x_alpha() psi4.core.SuperFunctional method, [1], [2]. x_functional() psi4.core.SuperFunctional method, [1], [2]. x_omega() psi4.core.SuperFunctional method, [1], [2]. XI (CCDENSITY). XI_CONNECT (CCDENSITY). xml2dict() in module psi4.driver. xtpl_highest_1() in module psi4.driver.driver_cbs. Y. y() psi4.core.Molecule method, [1], [2]. Z. Z() psi4.core.Molecule method, [1], [2]. z() psi4.core.Mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:102621,Validat,ValidationError,102621,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['Validat'],['ValidationError']
Security,"2 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:1251,access,access,1251,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['access'],['access']
Security,"2': 6.0519}, # in psi4; 'pbe0' : {'s6': 1.000, 'a1': 0.4145, 's8': 1.2177, 'a2': 4.8593}, # in psi4; 'pbe' : {'s6': 1.000, 'a1': 0.4289, 's8': 0.7875, 'a2': 4.4407}, # in psi4; 'pw6b95' : {'s6': 1.000, 'a1': 0.2076, 's8': 0.7257, 'a2': 6.3750},; 'pwpb95' : {'s6': 0.820, 'a1': 0.0000, 's8': 0.2904, 'a2': 7.3141},; 'revpbe0' : {'s6': 1.000, 'a1': 0.4679, 's8': 1.7588, 'a2': 3.7619},; 'revpbe38' : {'s6': 1.000, 'a1': 0.4309, 's8': 1.4760, 'a2': 3.9446},; 'revpbe' : {'s6': 1.000, 'a1': 0.5238, 's8': 2.3550, 'a2': 3.5016},; 'rpw86pbe' : {'s6': 1.000, 'a1': 0.4613, 's8': 1.3845, 'a2': 4.5062},; 'tpss0' : {'s6': 1.000, 'a1': 0.3768, 's8': 1.2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:26666,Validat,ValidationError,26666,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). returnvalue = run_scf(name, **kwargs). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; PsiMod.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); PsiMod.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); PsiMod.dfmp2(); returnvalue += dfun.c_alpha() * PsiMod.get_variable('SCS-DF-MP2 CORRELATION ENERGY'). else:; PsiMod.dfmp2(); returnvalue += dfun.c_alpha() * PsiMod.get_variable('DF-MP2 CORRELATION ENERGY'). PsiMod.set_variable('DFT TOTAL ENERGY', returnvalue); PsiMod.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(); return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE']). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFEREN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:23414,Validat,ValidationError,23414,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"2, 0])):; ar = 'IR'; elif np.array_equal(Iidx, np.asarray([2, 0, 1])):; ar = 'IIR'; elif np.array_equal(Iidx, np.asarray([0, 1, 2])):; ar = 'IIIR'; elif np.array_equal(Iidx, np.asarray([2, 1, 0])):; ar = 'IL'; elif np.array_equal(Iidx, np.asarray([0, 2, 1])):; ar = 'IIL'; elif np.array_equal(Iidx, np.asarray([1, 0, 2])):; ar = 'IIIL'. # if inertial tensor has non-zero off-diagonals, this whole classification is iffy; if np.count_nonzero(it - np.diag(np.diagonal(it))):; ar = '~' + ar. return ar. [docs] def to_arrays(self, dummy=False, ghost_as_dummy=False):; """"""Exports coordinate info into NumPy arrays. Parameters; ----------; dummy : bool, optional; Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy : bool, optional; Whether or not to treat ghost atoms as dummies. Returns; -------; geom, mass, elem, elez, uniq : ndarray, ndarray, ndarray, ndarray, ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:34906,hash,hash,34906,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,1,['hash'],['hash']
Security,"2.2609, 'a2': 3.2297}, # in psi4; 'blyp' : {'s6': 1.000, 'a1': 0.4298, 's8': 2.6996, 'a2': 4.2359}, # in psi4; 'bp86' : {'s6': 1.000, 'a1': 0.3946, 's8': 3.2822, 'a2': 4.8516}, # in psi4; 'dsd-blyp' : {'s6': 0.500, 'a1': 0.000, 's8': 0.2130, 'a2': 6.0519}, # in psi4; 'pbe0' : {'s6': 1.000, 'a1': 0.4145, 's8': 1.2177, 'a2': 4.8593}, # in psi4; 'pbe' : {'s6': 1.000, 'a1': 0.4289, 's8': 0.7875, 'a2': 4.4407}, # in psi4; 'pw6b95' : {'s6': 1.000, 'a1': 0.2076, 's8': 0.7257, 'a2': 6.3750},; 'pwpb95' : {'s6': 0.820, 'a1': 0.0000, 's8': 0.2904, 'a2': 7.3141},; 'revpbe0' : {'s6': 1.000, 'a1': 0.4679, 's8': 1.7588, 'a2': 3.7619},; 'revpbe38' : {'s6': 1.000, 'a1': 0.4309, 's8': 1.4760, 'a2': 3.9446},; 'revpbe' : {'s6': 1.000, 'a1': 0.5238, 's8': 2.3550, 'a2': 3.5016},; 'rpw86pbe' : {'s6': 1.000, 'a1': 0.4613, 's8': 1.3845, 'a2': 4.5062},; 'tpss0' : {'s6': 1.000, 'a1': 0.3768, 's8': 1.2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all pa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:26401,Validat,Validate,26401,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Validat'],['Validate']
Security,"2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. a-ccsd(t) 4; CC_TYPE. CCENERGY; D. DETCI. DFMP2. FNOCC. OCC. D; D. cisd; CI_TYPE. CCENERGY. DETCI; Y. D. DFMP2. FNOCC; D. OCC. adc(2); MP_TYPE. ADCC; Y. D. BUILTIN; D. Footnotes. 1; Algorithm type selection keyword below. Values to the right: conventional CONV (here abbreviated CV), density-fitted DF, and Cholesky-decomposed CD. 2(1,2); Also available for KS reference. 3(1,2); Conditions have no default module (computationally inefficient) and can only be accessed by specifying QC_MODULE. 4; Also known as CCSD(AT), Lambda-CCSD(T), CCSD(T)_L. table of contents. Notes on Options; Notes on Psivars; Alternate Implementations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/notes_c.html:4658,access,accessed,4658,psi4manual/1.6.x/notes_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/notes_c.html,1,['access'],['accessed']
Security,"2C'); PsiMod.print_out('\n'); banner('MP2C'); PsiMod.print_out('\n'). PsiMod.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); PsiMod.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); PsiMod.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = PsiMod.sapt(). optstash.restore(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dime",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:46674,Validat,ValidationError,46674,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"2]) / 3.0; p = (A[0][0] - q) ** 2 + (A[1][1] - q) ** 2 + (A[2][2] - q) ** 2 + 2.0 * p; p = math.sqrt(p / 6.0); for i in range(3):; for j in range(3):; B[i][j] = (A[i][j] - q * B[i][j]) / p; # B = (A - q * I) / p; r = determinant(B) / 2.0. # In exact arithmetric for a symmetric matrix -1 <= r <= 1; # but computation error can leave it slightly outside this range.; if r <= -1:; phi = math.pi / 3; elif r >= 1:; phi = 0; else:; phi = math.acos(r) / 3.0. # the eigenvalues satisfy eig3 <= eig2 <= eig1; eig1 = q + 2.0 * p * math.cos(phi); eig3 = q + 2.0 * p * math.cos(phi + math.pi * (2.0 / 3.0)); eig2 = 3.0 * q - eig1 - eig3 # since trace(A) = eig1 + eig2 + eig3; return [eig1, eig2, eig3]. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print col. [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta3] » ; Module code ». © Copyright 2012, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/vecutil.html:6005,Validat,ValidationError,6005,psi4manual/4.0b3/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/vecutil.html,2,['Validat'],['ValidationError']
Security,"2]) / 3.0; p = (A[0][0] - q) ** 2 + (A[1][1] - q) ** 2 + (A[2][2] - q) ** 2 + 2.0 * p; p = math.sqrt(p / 6.0); for i in range(3):; for j in range(3):; B[i][j] = (A[i][j] - q * B[i][j]) / p; # B = (A - q * I) / p; r = determinant(B) / 2.0. # In exact arithmetric for a symmetric matrix -1 <= r <= 1; # but computation error can leave it slightly outside this range.; if r <= -1:; phi = math.pi / 3; elif r >= 1:; phi = 0; else:; phi = math.acos(r) / 3.0. # the eigenvalues satisfy eig3 <= eig2 <= eig1; eig1 = q + 2.0 * p * math.cos(phi); eig3 = q + 2.0 * p * math.cos(phi + math.pi * (2.0 / 3.0)); eig2 = 3.0 * q - eig1 - eig3 # since trace(A) = eig1 + eig2 + eig3; return [eig1, eig2, eig3]. [docs]def zero(m, n):; """""" Create zero matrix""""""; new_matrix = [[0 for row in range(n)] for col in range(m)]; return new_matrix. [docs]def show(matrix):; """""" Print out matrix""""""; for col in matrix:; print col. [docs]def mscale(matrix, d):; """"""Return *matrix* scaled by scalar *d*""""""; for i in range(len(matrix)):; for j in range(len(matrix[0])):; matrix[i][j] *= d; return matrix. [docs]def mult(matrix1, matrix2):; """""" Matrix multiplication""""""; if len(matrix1[0]) != len(matrix2):; # Check matrix dimensions; raise ValidationError('Matrices must be m*n and n*p to multiply!'). else:; # Multiply if correct dimensions; new_matrix = zero(len(matrix1), len(matrix2[0])); for i in range(len(matrix1)):; for j in range(len(matrix2[0])):; for k in range(len(matrix2)):; new_matrix[i][j] += matrix1[i][k] * matrix2[k][j]; return new_matrix. [docs]def transpose(matrix):; """"""Return matrix transpose""""""; if len(matrix[0]) != len(matrix):; # Check matrix dimensions; raise ValidationError('Matrices must be square.'). tmat = [list(i) for i in zip(*matrix)]; return tmat. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html:6005,Validat,ValidationError,6005,psi4manual/4.0b4/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/vecutil.html,2,['Validat'],['ValidationError']
Security,"2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:33190,Validat,ValidationError,33190,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"3 : axis around which to rotate, does not need to be normalized; @param bool reflect : if true, really look for Sn not Cn; @returns n. """"""; # Check all atoms. In future, make more intelligent.; max_possible = len(coord) if max_Cn_to_check == -1 else max_Cn_to_check. Cn = 1 # C1 is there for sure; for n in range(2, max_possible + 1):; rotated_mat = matrix_3d_rotation(coord, axis, 2 * math.pi / n, reflect); if equal_but_for_row_order(coord, rotated_mat, tol):; Cn = n; return Cn. [docs]def matrix_3d_rotation(mat, axis, phi, Sn):; """"""For a matrix of 3D vectors (ncol==3), rotate a set of points around an; arbitrary axis. Vectors are the rows of the matrix.; @param axis Vector3 : axis around which to rotate (need not be normalized); @param phi double : magnitude of rotation in rad; @param Sn bool : if true, then also reflect in plane through origin and perpendicular to rotation; @returns SharedMatrix with rotated points (rows). """"""; if len(mat[0]) != 3 or len(axis) != 3:; raise ValidationError(""matrix_3d_rotation: Can only rotate matrix with 3d vectors""). # Normalize rotation vector; [wx, wy, wz] = normalize(axis); cp = 1.0 - math.cos(phi). R = zero(3, 3); R[0][0] = wx * wx * cp + math.cos(phi); R[0][1] = wx * wy * cp + math.sin(phi) * wz * -1; R[0][2] = wx * wz * cp + math.sin(phi) * wy; R[1][0] = wx * wy * cp + math.sin(phi) * wz; R[1][1] = wy * wy * cp + math.cos(phi); R[1][2] = wy * wz * cp + math.sin(phi) * wx * -1; R[2][0] = wx * wz * cp + math.sin(phi) * wy * -1; R[2][1] = wy * wz * cp + math.sin(phi) * wx; R[2][2] = wz * wz * cp + math.cos(phi). # R * coord^t = R_coord^t or coord * R^t = R_coord; #Matrix rotated_coord(nrow(),3);; #rotated_coord.gemm(false, true, 1.0, *this, R, 0.0);; rotated_coord = mult(mat, transpose(R)); # print 'after C'; # show(rotated_coord). if Sn: # delta_ij - 2 a_i a_j / ||a||^2; R = identity(3); #R = zero(3, 3); R[0][0] -= 2 * wx * wx; R[1][1] -= 2 * wy * wy; R[2][2] -= 2 * wz * wz; #R[0][0] = 1 - 2 * wx * wx; #R[1][1] = 1 - 2 * wy * wy;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:93206,Validat,ValidationError,93206,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"3 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a val",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:1253,access,access,1253,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['access'],['access']
Security,"3 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:1253,access,access,1253,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['access'],['access']
Security,"3.9446},; 'revpbe' : {'s6': 1.000, 'a1': 0.5238, 's8': 2.3550, 'a2': 3.5016},; 'rpw86pbe' : {'s6': 1.000, 'a1': 0.4613, 's8': 1.3845, 'a2': 4.5062},; 'tpss0' : {'s6': 1.000, 'a1': 0.3768, 's8': 1.2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); dftd3_tmpdir = 'dftd3_' + s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:27110,Validat,ValidationError,27110,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]; def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix, core.Vector]:; """"""; Converts a `NumPy array; <https://numpy.org/doc/stable/reference/arrays.ndarray.html>`_ or list of; NumPy arrays into a |PSIfour| :class:`~psi4.core.Matrix` or; :class:`~psi4.core.Vector` (irrepped if list). Parameters; ----------; self; Matrix or Vector class.; arr; NumPy array or list of arrays to use as the data for a new; :class:`~psi4.core.Matrix` or :class:`~psi4.core.Vector`.; name; Name to give the new :class:`~psi4.core.Matrix`.; dim1; If a single dense NumPy array is given,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:2101,Validat,ValidationError,2101,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix, core.Vector]:; """"""; Converts a `NumPy array; <https://numpy.org/doc/stable/reference/arrays.ndarray.html>`_ or list of; NumPy arrays into a |PSIfour| :class:`~psi4.core.Matrix` or; :class:`~psi4.core.Vector` (irrepped if list). Parameters; ----------; self; Matrix or Vector class.; arr; NumPy array or list of arrays to use as the data for a new; :class:`~psi4.core.Matrix` or :class:`~psi4.core.Vector`.; name; Name to give the new :class:`~psi4.core.Matrix`.; dim1; If a single dense NumPy array is given, a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:2099,Validat,ValidationError,2099,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections. import numpy as np. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.qcdb import intf_dftd3; from psi4.driver.qcdb import interface_gcp as gcp. _engine_can_do = collections.OrderedDict([('libdisp', ['d1', 'd2', 'chg', 'das2009', 'das2010']),; ('dftd3', ['d2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj']),; ('nl', ['nl']),; ]) # yapf: disable. _capable_engines_for_disp = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; _capable_engines_for_disp[disp].append(eng). [docs]class EmpiricalDispersion(object):; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel: {'d1', 'd2', 'd3zero', 'd3bj', 'd3mzero', 'd3mbj', 'chg', 'das2009', 'das2010', 'nl'}; Name of dispersion correction to be applied. Resolved; from `name_hint` and/or `level_hint` into a key of; `dashparam.dashcoeff`.; dashparams : dict; Complete (number and parameter names vary by `dashlevel`); set of parameter values defining the flexible parts; of `dashlevel`. Resolved into a complet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html:1299,Validat,ValidationError,1299,psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['Validat'],['ValidationError']
Security,"4 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a val",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/numpy_helper.html:1260,access,access,1260,psi4manual/master/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/numpy_helper.html,2,['access'],['access']
Security,"4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irreped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError (""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); view = _get_raw_views(ret)[0]; view[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError (""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, inter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:4831,Validat,ValidationError,4831,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irreped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irreped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:4061,Validat,ValidationError,4061,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,5,['Validat'],['ValidationError']
Security,4.core. UHF_NOONS (SCF). UKSFunctions class in psi4.core. UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify() psi4.core.FISAPT method. unit() psi4.core.SymmetryOperation method. units. ; molecule. units qcelemental.datum.Datum attribute. units() psi4.core.Molecule method. Unnormalized psi4.core.PrimitiveType attribute. UPDATE (DETCI). update() psi4.core.DFSOMCSCF method. psi4.core.DiskSOMCSCF method. psi4.core.SOMCSCF method. update_geometry() psi4.core.Molecule method. update_orbitals() psi4.core.IntegralTransform method. UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. Va() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate_options() psi4.core.Options method. ValidationError. class in qcelemental. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. variables() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. Vb() psi4.core.CUHF method. psi4.core.HF method. ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:145569,Validat,ValidationError,145569,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['Validat'],['ValidationError']
Security,"4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.dft_funcs import functionals; from psi4.driver.procrouting.dft_funcs import build_superfunctional_from_dictionary. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html:2222,Validat,ValidationError,2222,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,1,['Validat'],['ValidationError']
Security,"4.driver.freq¶. psi4.driver.freq(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:1044,access,accesses,1044,psi4manual/1.1.0/api/psi4.driver.freq.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html,1,['access'],['accesses']
Security,"4.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); psi4.wavefunction().energy(). optstash.restore(); return psi4.get_variable('CURRENT ENERGY'). else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:35234,Validat,ValidationError,35234,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"4.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); psi4.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); psi4.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = psi4.sapt(). optstash.restore(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.fix_com(True) # This should always have been set, very dangerous bug here; molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:49011,Validat,ValidationError,49011,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"4/metadata.py. >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 5d87b55..6cbc05e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,6 +1,6 @@; -__version__ = '1.1a1'; -__version_long = '1.1a1+007a9b6'; -__version_upcoming_annotated_v_tag = '1.1a2'; +__version__ = '1.1rc1'; +__version_long = '1.1rc1+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.1rc2'. >>> git add psi4/metadata.py. >>> git commit -m ""v1.1rc1"". OBSERVE undefined version state. 1; 2; 3; 4; 5; 6; 7; 8; 9>>> git describe --abbrev=7 --long --always HEAD; v1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. >>> psi4/versioner.py; Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded); undefined {master} 6100822 1.0.0.999 1.0 <-- undefined+6100822. Note 7-char git hash for the new commit, here “6100822”. ACT to bump tag in git, then bump git tag in code. Use the decided-upon tag v1.1rc1 and the observed hash “6100822” to; mint a new annotated tag, minding that “v”s are present here.; Use the observed hash to edit psi4/psi4/metadata.py and commit immediately. 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18>>> git tag -a v1.1rc1 6100822 -m ""v1.1rc1"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 6cbc05e..fdc202e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,5 +1,5 @@; __version__ = '1.1rc1'; -__version_long = '1.1rc1+zzzzzzz'; +__version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> psi4/versioner.py; Amazing, this can't actually happen that git hash stored at git commit.; >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.1rc1"". OBSERVE current versioning state. Nothing to make note of, this is just a snapshot. 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34>>> psi4/versioner.py; Defining development snapshot vers",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/manage_git-1.html:2487,hash,hash,2487,psi4manual/1.1.0/manage_git-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/manage_git-1.html,6,['hash'],['hash']
Security,"4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:30420,Validat,ValidationError,30420,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n"");; core.print_out("" "" + banner.center(58));. scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(scf_wfn). # The wfn from_file routine adds the npy suffix if needed, but we add it here so that; # we can use os.path.isfile to query whether the file exists before attempting to read; read_filename = scf_wfn.get_scratch_filename(180) + '.npy'; if ((core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename)):; old_wfn = core.Wavefunction.from_file(read_filename). Ca_occ = old_wfn.Ca_subset(""SO"", ""OCC""); Cb_occ = old_wfn.Cb_subset(""SO"", ""OCC""). if old_wfn.molecule().schoenflies_symbol() != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if old_wfn.basisset().name() == scf_wfn.basisset().name():; core.print_out(f"" Reading orbitals from file {read_filename}, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out(f"" Reading orbitals from file {read_filename}, projecting to new basis.\n\n""); core.print_out("" Computing basis projection from %s to %s\n\n"" % (old_wfn.basisset().name(), scf_wfn.basisset().name())). pCa = scf_wfn.basis_projection(Ca_occ, old_wfn.nalphapi(), old_wfn.basisset(), scf_wfn.basisset()); pCb = scf_wfn.basis_projection(Cb_occ, old_wfn.nbetapi(), old_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Strip off headers to only get R, RO, U, CU; old_ref = old_wfn.name().replace(""KS"", """").replace(""HF"", """"); new_ref = scf_wfn.name().replace(""KS"", """").replace(""HF"", """"); if old_ref != new_ref:; scf_wfn.reset_occ_ = True. elif (core.get_option('SCF', 'GUESS') == 'READ') and not os.pat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:44677,Validat,ValidationError,44677,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"5"").replace(""3"",""4"").replace(""2"",""3"").replace(""1"",""2""); else:; bn_gz = basisname.group('zeta'); # filter out commas and be forgiving of e.g., t5q or 3q; zetas = [z for z in zeta_values if (z in bn_gz or str(zeta_values.index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" % (basisstring, zeta_val2sym[zeta_sym2val[b] - 1])); # reassemble def2-svp* properly instead of def2-dzvp*; if def2_basis.match(basisname.group('pre')) and b == ""d"":; BSET.append(basisname.group('pre') + ""s"" + basisname.group('post')[1:]); # reassemble pc-n basis sets properly; elif pc_basis.match(basisname.group('pre')):; BSET.append(basisname.group('pre') + ""{0:d}"".format(zeta_sym2val[b] - 1)); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(""""""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]'"""""" % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n"""""". for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e=sys.exc_info()[1]; raise ValidationError(""""""Basis set '%s' not available for molecule."""""" % (basis)). return (BSET, ZSET). def _contract_bracketed_basis(basisarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets *basisarray* (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]).; Used to print a nicely formatted basis set string in the results table. """"""; if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]. pre = basisarray[1][",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:4170,Validat,ValidationError,4170,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"59}, # in psi4; 'bp86' : {'s6': 1.000, 'a1': 0.3946, 's8': 3.2822, 'a2': 4.8516}, # in psi4; 'dsd-blyp' : {'s6': 0.500, 'a1': 0.000, 's8': 0.2130, 'a2': 6.0519}, # in psi4; 'pbe0' : {'s6': 1.000, 'a1': 0.4145, 's8': 1.2177, 'a2': 4.8593}, # in psi4; 'pbe' : {'s6': 1.000, 'a1': 0.4289, 's8': 0.7875, 'a2': 4.4407}, # in psi4; 'pw6b95' : {'s6': 1.000, 'a1': 0.2076, 's8': 0.7257, 'a2': 6.3750},; 'pwpb95' : {'s6': 0.820, 'a1': 0.0000, 's8': 0.2904, 'a2': 7.3141},; 'revpbe0' : {'s6': 1.000, 'a1': 0.4679, 's8': 1.7588, 'a2': 3.7619},; 'revpbe38' : {'s6': 1.000, 'a1': 0.4309, 's8': 1.4760, 'a2': 3.9446},; 'revpbe' : {'s6': 1.000, 'a1': 0.5238, 's8': 2.3550, 'a2': 3.5016},; 'rpw86pbe' : {'s6': 1.000, 'a1': 0.4613, 's8': 1.3845, 'a2': 4.5062},; 'tpss0' : {'s6': 1.000, 'a1': 0.3768, 's8': 1.2576, 'a2': 4.5865},; 'tpss' : {'s6': 1.000, 'a1': 0.4535, 's8': 1.9435, 'a2': 4.4752},; }; }. # Validate arguments; dashlvl = dashlvl.lower(); if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:26491,Validat,ValidationError,26491,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:36718,Validat,ValidationError,36718,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"7582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array var",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:30987,Validat,ValidationError,30987,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"8 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Karton SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Karton SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Karton 2-point power from SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_Karton_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_helgaker_3(functionname, zLO, valueLO, zMD, valueMD, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 3.0; """""". if (type(valueLO) != type(valueMD)) or (type(valueMD) != type(valueHI)):; raise ValidationError(""scf_xtpl_helgaker_3: Inputs must be of the same datatype! (%s, %s, %s)""; % (type(valueLO), type(valueMD), type(valueHI))). if isinstance(valueLO, float):. ratio = (valueHI - valueMD) / (valueMD - valueLO); alpha = -1 * math.log(ratio); beta = (valueHI - valueMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); value = valueHI - beta * math.exp(-1 * alpha * zHI). if verbose:; # Output string with extrap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:13694,Validat,ValidationError,13694,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; # print(""about to generate displacements""); displacements = core.fd_geoms_1_0(moleculeclone); # print(displacements); ndisp = len(displacements); # print(""generated d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:38823,Validat,ValidationError,38823,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; # print(""about to generate displacements""); displacements = core.fd_geoms_1_0(moleculeclone); # print(displacements); ndisp = len(displacements); # print(""generated d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:37650,Validat,ValidationError,37650,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; psi4.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; psi4.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(moleculeclone); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:36419,Validat,ValidationError,36419,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"89)90033-7 .; Additional one-electron integrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. Parameters; ----------; wfn; Set of molecule, basis, orbitals from which to generate FCIDUMP file.; fname; Name of the integrals file, defaults to INTDUMP.; oe_ints; List of additional one-electron integrals to save to file. So far only; EIGENVALUES is a valid option. Raises; ------; ValidationError; When SCF wavefunction is not RHF. Examples; --------. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_irrep ^= h. core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '&FCI\n'; header += 'NORB={:d},\n'.format(nbf); header += 'NELEC={:d},\n'.format(nelectron); header += 'MS2={:d},\n'.format(wfn.nalpha() - wfn.nbeta()); header += 'UHF=.{}.,\n'.format(not wfn.same_a_b_orbs()).upper(); orbsym = ''; for h in range(active_mopi.n()):; for n in range(f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html:2909,Validat,ValidationError,2909,psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fcidump.html,4,['Validat'],['ValidationError']
Security,"8f' % (item[0], item[1], item[2])). #coord.rotate(self.Cexchflip); geom2 = mult(geom, self.Cexchflip); geom = geom2; # print ""ExchFlip""; # for item in geom:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). geom2 = []; for at in range(coord.natom()):; geom2.append(geom[self.Catommap[at]]); coord.set_geometry(geom2); geom = geom2; # print ""AtomMap""; # for item in geom:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). #coord.rotate(transpose(self.Protate)); geom2 = mult(geom, transpose(self.Protate)); geom = geom2; # print ""P4 Rotate""; # for item in geom:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). geom2 = []; for item in geom:; geom2.append(add(item, self.Pshift)); geom = geom2; # print ""P4 Shift""; # for item in geom:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). Pgeom = self.Pmol.geometry(); Cgeom = geom; Nat = len(geom); if not all([all([abs(Cgeom[at][ax] - Pgeom[at][ax]) < COORD_ZERO for ax in range(3)]) for at in range(Nat)]):; raise ValidationError(""""""Geometries unreconcilable between QC programs:\n P4 %s\n C4 %s"""""" % (Pgeom, Cgeom)); return geom. [docs] def transform_gradient(self, arr):; """"""Applies to *arr* the transformation appropriate to bring a; gradient in *molChangeable* orientation into *molPermanent*; orientation. In particular, applies a rotation to place it; in the inertial frame, a column exchange and phasing to place; it in the axis system, a row exchange to place it in the atom; ordering, and a rotation to remove it from the inertial frame. """"""; arr = mult(arr, self.Crotate); # print ""Rotate""; # for item in arr:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). arr = mult(arr, self.Cexchflip); # print ""ExchFlip""; # for item in arr:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). arr2 = []; for at in range(len(arr)):; arr2.append(arr[self.Catommap[at]]); arr = arr2; # print ""AtomMap""; # for item in arr:; # print(' %16.8f %16.8f %16.8f' % (item[0],",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html:12529,Validat,ValidationError,12529,psi4manual/1.0.0/_modules/qcdb/orient.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html,1,['Validat'],['ValidationError']
Security,": [; ""driver"",; ""method""; ]; }; }; }. Fields:. basis (str); bsse_type (List[psi4.driver.driver_nbody.BsseEnum]); driver (qcelemental.models.common_models.DriverEnum); embedding_charges (Dict[int, List[float]]); keywords (Dict[str, Any]); max_nbody (int); method (str); molecule (Any); nbodies_per_mc_level (List[List[Union[int, Literal['supersystem']]]]); nfragments (int); quiet (bool); return_total_data (Optional[bool]); task_list (Dict[str, Union[psi4.driver.task_base.AtomicComputer, psi4.driver.driver_cbs.CompositeComputer, psi4.driver.driver_findif.FiniteDifferenceComputer]]). Validators:. set_bsse_type » bsse_type; set_embedding_charges » embedding_charges; set_max_nbody » max_nbody; set_molecule » molecule; set_nfragments » nfragments; set_return_total_data » return_total_data. field basis: str = '(auto)'¶. field bsse_type: List[BsseEnum] = [<BsseEnum.cp: 'cp'>]¶; Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. Validated by:. set_bsse_type. field driver: DriverEnum [Required]¶; The computation driver; i.e., energy, gradient, hessian. field embedding_charges: Dict[int, List[float]] = {}¶; Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. Validated by:. set_embedding_charges. field keywords: Dict[str, Any] = {}¶; The computation keywords/options. field max_nbody: int = -1¶; Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments. Validated by:. set_max_nbody. field method: str = '(auto)'¶. field molecule: Any [Required]¶; The target molecule, if not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:12588,Validat,Validated,12588,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,1,['Validat'],['Validated']
Security,": psi::Molecule) → None¶; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int¶; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False)¶; Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector]) – Pointers to which Psi4 core class should be used in the construction.; copy (bool) – Copy the data if True, return a view otherwise; dense (bool) – Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector]) – Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {‘matrix’, ‘vector’}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix) → float¶; Returns the trace of the matrix. transform(*args, **kwargs)¶; Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix) → psi4.core.Matrix¶; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix) → None¶; Transpose the matrix in-place. static triplet(A, B, C, transA, transB, transC)¶; Multiply three matrices together. Deprecated since version 1.4: Use psi4.core.triplet() instead. vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix) → float¶; Returns th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:16757,access,accessor,16757,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,4,['access'],['accessor']
Security,": str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:37169,Validat,ValidationError,37169,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,":8.4f}"".format(final_rmsd)). # sanity checks; assert compare_values(; _pseudo_nre(cuniq, cgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE uncorrupted"",; atol=1.0e-4,; quiet=(verbose < 2),; ). if mols_align is True:; assert compare_values(; _pseudo_nre(runiq, rgeom),; _pseudo_nre(auniq, ageom),; ""D: concern_mol-->returned_mol pNRE matches ref_mol"",; atol=1.0e-4,; quiet=(verbose < 2),; ); assert compare_values(; rgeom, ageom, ""D: concern_mol-->returned_mol geometry matches ref_mol"", atol=1.0e-4, quiet=(verbose < 2); ); assert compare_values(0.0, final_rmsd, ""D: null RMSD"", atol=1.0e-4, quiet=(verbose < 2)). return final_rmsd, hold_solution. def _plausible_atom_orderings(ref, current, rgeom, cgeom, algorithm=""hungarian_uno"", verbose=1, uno_cutoff=1.0e-3):; r"""""". Parameters; ----------; ref : list; Hashes encoding distinguishable non-coord characteristics of reference; molecule. Namely, atomic symbol, mass, basis sets?.; current : list; Hashes encoding distinguishable non-coord characteristics of trial; molecule. Namely, atomic symbol, mass, basis sets?. Returns; -------; iterator of tuples. """"""; if sorted(ref) != sorted(current):; raise ValidationError(; """"""ref and current can't map to each other.\n"""""" + ""R: "" + str(ref) + ""\nC: "" + str(current); ). where = collections.defaultdict(list); for iuq, uq in enumerate(ref):; where[uq].append(iuq). cwhere = collections.defaultdict(list); for iuq, uq in enumerate(current):; cwhere[uq].append(iuq). connect = collections.OrderedDict(); for k in where:; connect[tuple(where[k])] = tuple(cwhere[k]). def filter_permutative(rgp, cgp):; """"""Original atom ordering generator for like subset of atoms (e.g., all carbons).; Relies on permutation. Filtering depends on similarity of structure (see `atol` parameter).; Only suitable for total system size up to about 20 atoms. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)); bnbn = [rrdistmat[first, second] for first, second in zip(rgp, rgp[1:])]; fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html:9957,Hash,Hashes,9957,psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,3,['Hash'],['Hashes']
Security,":; # if self.type == 'STR': ; # print 'foo', self.name, self.arg; 		if (self.type == 'STR' or 'STR_ARRAY' or 'DATA') and \; 				(self.arg == '' or self.arg == None): # empty string; 			nargs=-1 # flags as empty for Fortran code; 		else: ; 			nargs=len(self.arg); 			tmp=''; 			for i in self.arg:; 				tmp=tmp+str(i)+'\n'; 		s=""%s %s %d %s\n"" % (self.type, self.name, nargs, self.isset); 		return s+tmp. [docs]class Getkw:; 	""""""Unified interface to sections and keywords.; 	Implements a path stack.; 	""""""; 	def __init__(self, top):; 		self.top=top; 		self.stack=[self.top]; 		self.cur=self.stack[0]. [docs]	def get_active_section(self):; 		return self.cur. [docs]	def getkw(self, path):; 		return self.cur.getkw(path). [docs]	def get_keyword(self, path):; 		retur=self.cur.get_keyword(path); 		return retur. [docs]	def setkw(self, path):; 		return self.cur.setkw(path). [docs]	def find_sect(self, path):; 		return self.cur.find_sect(path). [docs]	def sanitize(self, templ):; 		return self.cur.sanitize(templ). [docs]	def run_callbacks(self, templ):; 		return self.cur.run_callbacks(templ). [docs]	def push_sect(self, path):; 		k=self.cur.find_sect(path); 		if k is None:; 			return None; 		self.stack.append(k); 		self.cur=self.stack[-1]; 		return self.cur. [docs]	def pop_sect(self):; 		try:; 			del self.stack[-1]; 		except:; 			return None; 		self.cur=self.stack[-1]; 		return self.cur. [docs]	def get_topsect(self):; 		return self.top. [docs]class GetkwParser:; 	""""""Implements a class to do the actual parsing of input files and store; 	the results in Sections and Keywords. The parseFile() method returns a; 	Getkw object.; 	""""""; 	bnf=None; 	caseless=False; 	yes=re.compile(r'(1|yes|true|on)$',re.I); 	no=re.compile(r'(0|no|false|off)$',re.I). 	def __init__(self,templ=None):; 		self.top=Section('toplevel'); 		self.stack=[self.top]; 		self.cur=self.stack[0]; 		self.templ=templ; 		self.strg=None; 		self.loc=None; 		if templ is not None:; 			self.path=[self.templ]; 		else:; 			self.path=None; 	",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/pcmgetkw.html:12299,sanitiz,sanitize,12299,psi4manual/4.0b5/_modules/pcmgetkw.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pcmgetkw.html,1,['sanitiz'],['sanitize']
Security,":; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += [f'delta{x}_wfn' for x in range(2, 6)]; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; """""" A helper function that parses a ``""method/basis""`` input string; into separate method and basis components. Also handles delta corrections. Parameters; ----------; method_name : str; A ``""method/basis""`` style string defining the calculation. Returns; -------; tuple; Tuple in the ``(method_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(r""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:63657,Validat,ValidationError,63657,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,":; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). dertype = min(dertype, derivatives[ptype]). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:3632,validat,validation,3632,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['validat'],['validation']
Security,":; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """""". optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF', 'SCF_TYPE']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if ((core.get_option('SCF', 'SCF_TYPE') == 'DF') and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwargs); else:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; if (core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV'):; mints = core.MintsHelper(ref_wfn.basisset()); mints.set_print(1); mints.integrals(). ref_optstash.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:124470,Validat,ValidationError,124470,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,":; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = defaultdict(lambda: defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. [docs] def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else psi_bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(), self.tagline). for i in range(self.natom()):; [x, y, z] = self.atoms[i].compute(); text += '%4s %17.12f %17.12f %17.12f\n' % (("""" if self.Z(i) else 'Bq') + self.symbol(i), \; x * factor, y * factor, z * factor); return text; pass. # if symm print M2OUT ""nosym\nnoorient\n"";; # print DIOUT ""angstrom\ngeometry={\n"";. [docs] def auto_fragments(self):; """"""Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. """"""; if self.nfragments() != 1:; pri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:25560,Validat,ValidationError,25560,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,":; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and not do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and not do_delta2:; pass; elif do_scf and do_corl and do_delta and do_delta2:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:63159,Validat,ValidationError,63159,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,:; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn)). if 'delta2_wfn_lesser' in kwargs:; cbs_delta2_wfn_lesser = kwargs['delta2_wfn_lesser'].lower(); else:; cbs_delta2_wfn_lesser = 'mp2'; if not (cbs_delta2_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA2 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta2_wfn_lesser)). # Establish method for third delta correction energy; if 'delta3_wfn' in kwargs:; do_delta3 = 1; cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); if not (cbs_delta3_wfn in VARH.keys()):; raise ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:72025,Validat,ValidationError,72025,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,":`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:79825,access,accesses,79825,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['access'],['accesses']
Security,":`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Pointers to which Psi4 core class should be used in the construction.; copy : bool; Copy the data if True, return a view otherwise; dense : bool; Converts irreped Psi4 objects to diagonally blocked dense arrays. Returns a list of arrays otherwise. Returns; -------; array : np.array or list of of np.array; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.Matrix(3, 3); >>> data._to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. ret = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return ret. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinstance(matrix, core.Matrix):; ret_type = '2D'; else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % type(matrix)). dim1 = []; dim2 = []; for h in ret:; # Ignore zero dim irreps; if 0 in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1, arr in zip(dim1, ret):; if d1 == 0: continue; dense_ret[start: start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, ret):; if d1 == 0: continue. dense_ret[start1: start1 + d1, start2: start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. def _build_view(matrix):; """"""; Builds a view of the vector or matrix; """"""; views = _to_array(matrix, copy=False, dense=False); if matrix.nirrep() > 1:; return tuple(views); else:; return views. def get_view(self):; if hasattr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:7378,Validat,ValidationError,7378,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,":class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.Validatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:39475,Validat,ValidationError,39475,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,":class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.Validati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:37403,Validat,ValidationError,37403,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,":math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are not available. Frequencies will proceed through; finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce (someday) if name is function; if hasattr(name, '__call__'):; raise ValidationError(""Frequency: Cannot use custom function""). lowername = name.lower(). old_global_basis = None; if ""/"" in lowername:; if (""+"" in lowername) or (""["" in lowername) or (lowername.count('/') > 1):; raise ValidationError(""Frequency: Cannot extrapolate or delta correct frequencies yet.""); else:; old_global_basis = psi4.get_global_option(""BASIS""); lowername, new_basis = lowername.split('/'); psi4.set_global_option('BASIS', new_basis). if kwargs.get('bsse_type', None) is not None:; raise ValdiationError(""Frequency: Does not currently support 'bsse_type' arguements""). return_wfn = kwargs.pop('return_wfn', False). # are we in sow/reap mode?; freq_mode = kwargs.get('mode', 'continuous').lower(); if freq_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:82139,Validat,ValidationError,82139,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"; """""" A helper function that parses a ``""method/basis""`` input string; into separate method and basis components. Also handles delta corrections. Parameters; ----------; method_name; A ``""method/basis""`` style string defining the calculation. Returns; -------; tuple; Tuple in the ``(method_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(r""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are exp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:39170,Validat,ValidationError,39170,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['Validat'],['ValidationError']
Security,"; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername) or re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); els",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:32997,Validat,ValidationError,32997,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"; # qcdb.BasisSet; self.basis = basis; # numerical value for reaction; self.value = float(value); # energy unit attached to value, defaults to kcal/mol; self.units = units; # publication citation of value; self.citation = citation; # digital object identifier for publication (maybe this should be doi of datum, not of pub?); self.doi = doi; # addl comments; self.comment = comment. @classmethod; [docs] def library_modelchem(cls, dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, doi=None,; comment=None):; """"""Constructor when method and basis are strings corresponding to; qcdb.Method and qcdb.BasisSet already defined in methods and bases. """"""; # computational method; try:; tmp_method = methods[method.upper()]; except KeyError as e:; raise ValidationError(""""""Invalid ReactionDatum method %s: %s"""""" % (method, e)); # computational basis set; try:; tmp_basis = bases[basis.lower()]; except KeyError as e:; raise ValidationError(""""""Invalid ReactionDatum basis %s: %s"""""" % (basis, e)); # publication; if citation is None:; tmp_pub = citation; else:; try:; tmp_pub = pubs[citation.lower()]; except KeyError as e:; raise ValidationError(""""""Invalid ReactionDatum publication %s: %s"""""" % (citation, e)); return cls(dbse, rxn, tmp_method, mode, tmp_basis, value, units, citation=tmp_pub, doi=doi, comment=comment). def __str__(self):; text = ''; text += """""" ==> ReactionDatum <==\n\n""""""; text += """""" Database reaction: %s\n"""""" % (self.dbrxn); text += """""" Method: %s\n"""""" % (self.method.fullname); text += """""" Mode: %s\n"""""" % (self.mode); text += """""" Basis: %s\n"""""" % (self.basis.fullname); text += """""" Value: %f [%s]\n"""""" % (self.value, self.units); text += """""" Citation: %s %s\n"""""" % (self.citation.name, self.citation.doi); text += """""" DOI: %s\n"""""" % (self.doi); text += """""" Comment: %s\n"""""" % (self.comment); text += """"""\n""""""; return text. [docs]class Subset(object):; """"""Affiliated qcdb.Reaction-s. """""". def __init__(self, name, hrxn, tagl=None, axis=None):; # identifier; self.n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:10948,Validat,ValidationError,10948,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"; #; """"""Module with a *procedures* dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; import os; import re; import sys; import json; import shutil. import numpy as np. from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *. # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". if ptype not in ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:2050,Validat,ValidationError,2050,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"; A=elea[at],; Z=elez[at],; E=elem[at],; mass=mass[at],; real=real[at],; label=elbl[at],; speclabel=speclabel,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose,; ); for at in range(nat); ]; ); else:; A = Z = E = mass = real = label = []; return {; ""elea"": np.array(A, dtype=int),; ""elez"": np.array(Z, dtype=int),; ""elem"": np.array(E),; ""mass"": np.array(mass, dtype=float),; ""real"": np.array(real, dtype=bool),; ""elbl"": np.array(label),; }. def validate_and_fill_fragments(nat, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None):; """"""Check consistency of fragment specifiers wrt type and length. For; charge & multiplicity, scientific defaults are not computed or applied;; rather, missing slots are filled with `None` for later processing. """"""; if fragment_separators is None:; if fragment_charges is None and fragment_multiplicities is None:; frs = [] # np.array([], dtype=int) # if empty, needs to be both ndarray and int; frc = [None]; frm = [None]; else:; raise ValidationError(; """"""Fragment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None el",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:20550,Validat,ValidationError,20550,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76950,Validat,ValidationError,76950,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"; GDMA manual.; If more advanced usage is desired, which is not is permitted by the options; listed below, the user may provide their own data file containing keywords to; control the GDMA code. Simply place the data file in the directory PSI4; is called from, and provide the file name as the datafile argument to the; gdma() routine. For example, if GDMA data file is called; control.dma, the GDMA code is called as follows:; 1; 2grad, wfn = gradient('mp2', return_wfn=True); gdma(wfn, datafile='control.dma'). An FCHK file will be generated for the GDMA code to read; this file will have; the prefix given by WRITER_FILE_LABEL (if set), or else by the name; of the output file plus the name of the current molecule, and the suffix will; be ‘.fchk’. This FCHK file name should be passed to the ‘File’ keyword in the; DGMA data file, to ensure that the GDMA code reads the correct wavefunction; information.; After running, two matrices of results can be accessed:; 1; 2dma_results = get_array_variable('DMA DISTRIBUTED MULTIPOLES'); tot_results = get_array_variable('DMA TOTAL MULTIPOLES'). The first contains distributed multipoles, in units given by; GDMA_MULTIPOLE_UNITS, with the row index corresponding to the site and; the column index referencing the multipole component. Both indices are zero; based, and the \(Q^l_m\) components of the multipoles are ordered as; \(Q^0_0, Q^1_0, Q^1_{1c}, Q^1_{1s}, Q^2_0, Q^2_{1c}, Q^2_{1s}, Q^2_{2c},; Q^2_{2s}, \ldots\) The second matrix returned has a single row, whose columns; are the total multipoles, translated to GDMA_ORIGIN, and summed. psi4.gdma(wfn)[source]¶; Function to use wavefunction information in wfn and, if specified,; additional commands in filename to run GDMA analysis. New in version 0.6. Returns:None. Parameters:; wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate DMA analysis; datafile (string) – optional control file (see GDMA manual) to peform more complicated DMA; analyses. If this option is use",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/gdma-1.html:2697,access,accessed,2697,psi4manual/1.1.0/gdma-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/gdma-1.html,6,['access'],['accessed']
Security,"; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix) → int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self: psi4.core.Matrix) → float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix) → psi4.core.Matrix; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix) → None; Transpose the matrix in-place. static triplet(A, B, C, transA, transB, transC). vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix) → float; Returns the vector dot product of this with rhs. zero(self: psi4.core.Matrix) → None; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix) → None; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix) → None; Zero the lower triangle. zero_upper(self: psi4.core.Matrix) → None; Zer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:26144,access,accessor,26144,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,1,['access'],['accessor']
Security,"; a path to the location of scratch files. -t <subset>, --test <subset>¶; Runs pytest tests. If pytest-xdist installed, parallel with -n. -v, --verbose¶; Print the Psithon to Python translation of the input file. -V, --version¶; Print version information.; # stable release; >>> psi4 --version; 1.3.2. # development snapshot between 1.3 and 1.4; >>> psi4 --version; 1.4a2.dev525. Environment Variables¶; These environment variables will influence PSI4‘s behavior. CONDA_PREFIX¶; Set when a conda environment is activated. Note that if PSI4 has been; built against any library in CONDA_PREFIX, the path has been baked into the; program, so any available dependencies are liable to been loaded from the environment. HOST¶; Set when a conda environment with conda compilers is activated. Used; when compatibly building PSI4 from source against conda; dependencies. MKL_NUM_THREADS¶; Number of threads to use by operations with Intel threaded BLAS libraries. OMP_NESTED¶; Do access nested DGEMM in OpenMP sections in DFMP2 for multi-socket; platforms. This is very low-level access to OpenMP functions for; experienced programmers. Users should leave this variable unset or set; to False. OMP_NUM_THREADS¶; Number of threads to use by modules with OpenMP threading. PATH¶; Path for interfaced executables. Note; While once configuring PSI4 through PSIPATH was preferred; to modifying this environment variable, now PATH is preferred for; executables to accommodate QCEngine. To run Kállay’s MRCC program; (see MRCC), the dmrcc executable must be in PATH.; Likewise to run Grimme’s dftd3 program (see dftd3), the; dftd3 executable must be in PATH. PSI_SCRATCH¶; Directory where scratch files are written. Overrides settings in ~/.psi4rc.; It is very important to ensure that PSI4 is writing its scratch files; to a disk drive physically attached to the computer running the computation.; If it is not, it will significantly slow down the program and the network.; Modify PSI_SCRATCH through normal Linux sh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external.html:20879,access,access,20879,psi4manual/master/external.html,https://psicode.org,https://psicode.org/psi4manual/master/external.html,9,['access'],['access']
Security,"; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; psi4.print_out('\n'); psi4.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); psi4.print_out(' BSSE Treatment: %s\n' % (bsse)); psi4.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); psi4.print_out(' Compute Total Energy: %s\n' % (do_total)); psi4.print_out(' External Field: %s\n' % (has_external)); if (external):; psi4.print_out(' External Field Monomers: '); for k in external_indices:; psi4.print_out('%-3d ' % (k)); psi4.print_out('\n'); psi4.print_out('\n'). # Run the total molecule, if required; energies_full = {",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:6393,Validat,ValidationError,6393,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"; actives += """"""core.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""core.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""core.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\ncore.set_memory_bytes(%s)\n\n"""""" % (core.get_memory()); for chgdopt in core.get_global_option_list():; if core.has_global_option_changed(chgdopt):; chgdoptval = core.get_global_option(chgdopt); #chgdoptval = core.get_option(chgdopt); if isinstance(chgdoptval, (str, bytes)):; commands += """"""core.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""core.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; pass; #raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'. if symmetry_override:; commands += """"""molecule.reset_point_group('c1')\n""""""; commands += """"""molecule.fix_orientation(True)\n""""""; commands += """"""molecule.fix_com(True)\n""""""; commands += """"""molecule.update_geometry()\n"""""". if (openshell_override) and (molecule.multiplicity() != 1):; if user_reference == 'RHF':; commands += """"""core.set_global_option('REFERENCE', 'UHF')\n""""""; elif user_reference == 'RKS':; commands += """"""core.set_global_option('REFERENCE', 'UKS')\n"""""". commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects resul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:19584,Validat,ValidationError,19584,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"; alpha = -1 * np.log(np.abs(ratio)); beta = top / (np.exp(-1 * alpha * zMD) * (ratio - 1)); np_value = valueHI.copy(); np_value[nonzero_mask] -= beta * np.exp(-1 * alpha * zHI); np_value[~nonzero_mask] = 0.0. # Build and set from numpy routines; value = core.Matrix(*valueHI.shape); value_view = np.asarray(value); value_view[:] = np_value; return value. else:; raise ValidationError(""scf_xtpl_helgaker_3: datatype is not recognized '%s'."" % type(valueLO)). #def corl_xtpl_helgaker_2(functionname, valueSCF, zLO, valueLO, zHI, valueHI, verbose=True):; [docs]def corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson, Chem. Phys. Lett. 286 (1998) 243-252. .. math:: E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if isinstance(valueLO, float):; value = (valueHI * zHI ** 3 - valueLO * zLO ** 3) / (zHI ** 3 - zLO ** 3); beta = (valueHI - valueLO) / (zHI ** (-3) - zLO ** (-3)). # final = valueSCF + value; final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = """"""\n\n ==> Helgaker 2-point correlated extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); # cbsscheme += """""" HI-zeta (%1s) SCF Energy: % 16.12f\n"""""" % (str(zHI), valueSCF); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); # cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n"""""" % beta; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; #cbsscheme += """""" LO-zeta (%s) Correlation Energy: % 16.12f\n"""""" % (str(zLO), valueLO); #cbsscheme += """""" HI-zeta (%s) Correlation Energy: % 16.12f\n"""""" % (str(zHI), ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:10598,Validat,ValidationError,10598,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"; axis1 = 2; else:; axis1 = 1; result = [0.0, 0.0, 0.0]; # do the pi/2 rotation in the plane; result[axis0] = d[axis1]; result[axis1] = -1.0 * d[axis0]; result = normalize(result); return result. else:; # normalize the cross product and return the result; result = scale(result, 1.0 / math.sqrt(resultdotresult)); return result. [docs]def determinant(mat):; """"""Given 3x3 matrix *mat*, compute the determinat. """"""; if len(mat) != 3 or len(mat[0]) != 3 or len(mat[1]) != 3 or len(mat[2]) != 3:; raise ValidationError('determinant() only defined for arrays of dimension 3x3\n'). det = mat[0][0] * mat[1][1] * mat[2][2] - mat[0][2] * mat[1][1] * mat[2][0] + \; mat[0][1] * mat[1][2] * mat[2][0] - mat[0][1] * mat[1][0] * mat[2][2] + \; mat[0][2] * mat[1][0] * mat[2][1] - mat[0][0] * mat[1][2] * mat[2][1]; return det. [docs]def diagonalize3x3symmat(A):; """"""Given an real symmetric 3x3 matrix A, compute the eigenvalues. """"""; if len(A) != 3 or len(A[0]) != 3 or len(A[1]) != 3 or len(A[2]) != 3:; raise ValidationError('diagonalize3x3symmat() only defined for arrays of dimension 3x3\n'). B = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # I is the identity matrix; p = A[0][1] * A[0][1] + A[0][2] * A[0][2] + A[1][2] * A[1][2]; if p == 0:; # A is diagonal; eig1 = A[0][0]; eig2 = A[1][1]; eig3 = A[2][2]; else:; q = (A[0][0] + A[1][1] + A[2][2]) / 3.0; p = (A[0][0] - q) ** 2 + (A[1][1] - q) ** 2 + (A[2][2] - q) ** 2 + 2.0 * p; p = math.sqrt(p / 6.0); for i in range(3):; for j in range(3):; B[i][j] = (A[i][j] - q * B[i][j]) / p; # B = (A - q * I) / p; r = determinant(B) / 2.0. # In exact arithmetric for a symmetric matrix -1 <= r <= 1; # but computation error can leave it slightly outside this range.; if r <= -1:; phi = math.pi / 3; elif r >= 1:; phi = 0; else:; phi = math.acos(r) / 3.0. # the eigenvalues satisfy eig3 <= eig2 <= eig1; eig1 = q + 2.0 * p * math.cos(phi); eig3 = q + 2.0 * p * math.cos(phi + math.pi * (2.0 / 3.0)); eig2 = 3.0 * q - eig1 - eig3 # since trace(A) = eig1 + eig2 + eig3; return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/vecutil.html:4467,Validat,ValidationError,4467,psi4manual/4.0b3/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/vecutil.html,2,['Validat'],['ValidationError']
Security,"; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; """""" A helper function that parses a ``""method/basis""`` input string; into separate method and basis components. Also handles delta corrections. Parameters; ----------; method_name : str; A ``""method/basis""`` style string defining the calculation. Returns; -------; tuple; Tuple in the ``(method_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based wrapper of the CBS function. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:62099,Validat,ValidationError,62099,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; from __future__ import print_function; from __future__ import absolute_import; import sys; import re; import math; import os; import shutil. # Import driver helpers; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import p4util; # from psi4.driver.inputparser import parse_options_block. from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *; # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". if ptype not in ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:2122,Validat,ValidationError,2122,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"; core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0l, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Left Endpoint', **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; E_HOMO = max(E_a, E_b); E_HOMOl = E_HOMO; core.IO.change_file_namespace(180, ""ot"", ""neutral""). # Cation; core.IO.change_file_namespace(180, ""cation"", ""ot""); molecule.set_molecular_charge(charge1); molecule.set_multiplicity(mult1); core.set_global_option(""DOCC"", [Nb1]); core.set_global_option(""SOCC"", [Na1 - Nb1]); E1l = driver.energy('scf', dft_functional=name, molecule=molecule,; banner='IP Fitting SCF: Cation, Left Endpoint', **kwargs); core.IO.change_file_namespace(180, ""ot"", ""cation""). IPl = E1l - E0l; kIPl = -E_HOMOl; delta_l = IPl - kIPl. if IPl < kIPl:; raise ValidationError(""""""\n***IP Fitting Error: Left Omega limit should have kIP < IP: {} !< {}"""""".format(kIPl, IPl)). omegas.append(omega_l); types.append('Left Limit'); E0s.append(E0l); E1s.append(E1l); IPs.append(IPl); kIPs.append(kIPl). converged = False; repeat_l = 0; repeat_r = 0; for step in range(maxiter):. # Regula Falsi (modified); if repeat_l > 1:; delta_l /= 2.0; if repeat_r > 1:; delta_r /= 2.0; omega = - (omega_r - omega_l) / (delta_r - delta_l) * delta_l + omega_l; core.set_local_option('SCF', 'DFT_OMEGA', omega). # Neutral; core.IO.change_file_namespace(180, ""neutral"", ""ot""); molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); core.set_global_option(""DOCC"", [Nb]); core.set_global_option(""SOCC"", [Na - Nb]); E0, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Omega = {:11.3E}'.format(omega), **kwargs); eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Nb == 0:; E_HOMO = eps_a.np[int(Na - 1)]; else:; E_a = eps_a.np[int(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:20218,Validat,ValidationError,20218,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,4,['Validat'],['ValidationError']
Security,"; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:64109,Validat,ValidationError,64109,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['Validat'],['ValidationError']
Security,"; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; try:; getattr(database, 'BIND_' + db_benchmark); except AttributeError:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)); else:; BIND = getattr(database, 'BIND_' + db_benchmark). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; try:; getattr(database, db_subset); except AttributeError:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; HRXN = getattr(database, db_subset); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:35450,Validat,ValidationError,35450,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"; del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; dtl = docs_table_link(""dummy"", ""ccenergy""). optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for CCENERGY energy through `run_bccd`. See Capabilities Table at {dtl}""). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:95092,Validat,ValidationError,95092,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != mol.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), mol.natom())). # Prepare results for Psi4; if isP4regime and dertype != 0:; core.set_variable('DISPERSION CORRECTION ENERGY', dashd); psi_dashdderiv = core.Matrix.from_list(dashdderiv). # Print program output to file if verbose; if not verbose and isP4regime:; verbose = True if core.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> DFTD3 Output <==\n'; text += out.decode('utf-8'); if dertype != 0:; with open(derivfile, 'r') as handle:; text += handle.read().replace('D', 'E'); text += '\n'; if isP4regime:; core.print_out(text); else:; print(text). # Clean up files and remove scratch directory; os.unlink(paramfile1); os.unlink(paramfile2); os.unlink(geomfile); if dertype != 0:; os.unlink(derivfile); if defmoved is True:; os.rename(defaultfile + '_hide', defaultfile). os.chdir('..'); try:; shutil.rmtree(dftd3_tmpdir); except OSError as e:; ValidationError('Unable to remove dftd3 temporary directory %s' % e); os.chdir(current_directory). # return -D & d(-D)/dx; if dertype == -1:; return dashd, dashdderiv; elif dertype == 0:; return dashd; elif dertype == 1:; return psi_dashdderiv. try:; # Attach method to libmints psi4.Molecule class; core.Molecule.run_dftd3 = run_dftd3; except (NameError, AttributeError):; # But don't worry if that doesn't work b/c; # it'll get attached to qcdb.Molecule class; pass. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.2.1;  · . PSI4. Module code. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:10430,Validat,ValidationError,10430,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.qcdb.molecule. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html:67261,Validat,ValidationError,67261,psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:4227,Validat,ValidationError,4227,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); os.chdir(psioh.get_default_path()); dftd3_tmpdir = 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.dftd3.' + str(random.randi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:8313,Validat,ValidationError,8313,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]. # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Setup unique scratch directory and move in; current_directory = os.getcwd(); psioh = psi4.IOManager.shared_object(); psio = psi4.IO.shared_object(); os.chdir(psioh.get_default_path()); dftd3_tmpdir = 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.dftd3.' + str(random.randint(0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:9148,Validat,ValidationError,9148,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Validat'],['ValidationError']
Security,"; elif np.array_equal(Iidx, np.asarray([0, 1, 2])):; ar = 'IIIR'; elif np.array_equal(Iidx, np.asarray([2, 1, 0])):; ar = 'IL'; elif np.array_equal(Iidx, np.asarray([0, 2, 1])):; ar = 'IIL'; elif np.array_equal(Iidx, np.asarray([1, 0, 2])):; ar = 'IIIL'. # if inertial tensor has non-zero off-diagonals, this whole classification is iffy; if np.count_nonzero(it - np.diag(np.diagonal(it))):; ar = '~' + ar. return ar. [docs]; def to_arrays(self, dummy: bool = False, ghost_as_dummy: bool = False) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:; """"""Exports coordinate info into NumPy arrays. Parameters; ----------; dummy; Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy; Whether or not to treat ghost atoms as dummies. Returns; -------; geom, mass, elem, elez, uniq : numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:35123,hash,hash,35123,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,3,['hash'],['hash']
Security,"; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_for_psi4(self):; """"""Returns a string of Molecule formatted for psi4.; Includes fragments and reorienting, if specified. >>> print H2OH2O.save_string_for_psi4(); 6; 0 1; O -1.55100700 -0.11452000 0.00000000; H -1.93425900 0.76250300 0.00000000; H -0.59967700 0.04071200 0.00000000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:3053,Validat,ValidationError,3053,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,2,['Validat'],['ValidationError']
Security,"; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_xyz(self, save_ghosts=True):; """"""Save a string for a XYZ-style file. >>> H2OH2O.save_string_xyz(); 6; -2 3 water_dimer; O -1.551007000000 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.3506250",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:3936,Validat,ValidationError,3936,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"; else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Molecule::get_anchor_atom: Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. """"""; geom = []; for at in range(self.natom()):; geom.append([self.x(at), self.y(at), self.z(at)]); return geom. [docs] def full_geometry(self):; """"""Returns the full (dummies included) geometry in Bohr as a N X 3 array. >>> print H2OH2O.full_geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [0.0, 0.0, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.706",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:39036,Validat,ValidationError,39036,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"; for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4,; 5]). This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Allows; out-of-order zeta specification (e.g., [qtd]) and numeral for number; (e.g., [23]) but not skipped zetas (e.g., [dq]) or zetas outside [2,; 8] or non-Dunning sets or non-findable .gbs sets. """"""; BSET = []; ZSET = []; legit_compound_basis = re.compile(r'^(?P<pre>.*cc-.*)\[(?P<zeta>[dtq2345678,]*)\](?P<post>.*z)$', re.IGNORECASE). if legit_compound_basis.match(basisstring):; basisname = legit_compound_basis.match(basisstring); # filter out commas and be forgiving of e.g., t5q or 3q; bn_gz = basisname.group('zeta'); zetas = [z for z in zeta_values if (z in bn_gz or str(zeta_values.index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" % (basisstring, b)); BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(""""""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z'."""""" % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n"""""". for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound, e:; raise ValidationError(""""""Basis set '%s' not available for molecule."""""" % (basis)). return (BSET, ZSET). def _contract_bracketed_basis(basisarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets *basisarray* (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]).; Used to print a nicely formatted basis set string in the results table. """"""; if len(basisarray) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:2784,Validat,ValidationError,2784,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"; for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4,; 5]). This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Allows; out-of-order zeta specification (e.g., [qtd]) and numeral for number; (e.g., [23]) but not skipped zetas (e.g., [dq]) or zetas outside [2,; 8] or non-Dunning sets or non-findable .gbs sets. """"""; BSET = []; ZSET = []; legit_compound_basis = re.compile(r'^(?P<pre>.*cc-.*)\[(?P<zeta>[dtq2345678,]*)\](?P<post>.*z)$', re.IGNORECASE). if legit_compound_basis.match(basisstring):; basisname = legit_compound_basis.match(basisstring); # filter out commas and be forgiving of e.g., t5q or 3q; bn_gz = basisname.group('zeta'); zetas = [z for z in zeta_values if (z in bn_gz or str(zeta_values.index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" % (basisstring, b)); BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(""""""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z'."""""" % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n"""""". for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e=sys.exc_info()[1]; raise ValidationError(""""""Basis set '%s' not available for molecule."""""" % (basis)). return (BSET, ZSET). def _contract_bracketed_basis(basisarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets *basisarray* (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]).; Used to print a nicely formatted basis set string in the results table. """"""; i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:3006,Validat,ValidationError,3006,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"; grad.print_atom_vector(); ref_wfn.set_print(old_print). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). # Clearly, add some logic when the reach of this fn expands; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:81955,Validat,ValidationError,81955,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"; grad.print_atom_vector(); ref_wfn.set_print(old_print). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). # Clearly, add some logic when the reach of this fn expands; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF; ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; core.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:82035,Validat,ValidationError,82035,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop, oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT']:; mints = core.MintsHelper(wfn.basisset()); if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(wfn.molecule(),; ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"",; core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); mints.set_basisset('BASIS_RELATIVISTIC', rel_bas). mints.set_print(1); mints.integrals(). def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = core.get_global_option('SCF_TYPE'); supp_jk_type = ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if sc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:2929,Validat,ValidationError,2929,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['Validat'],['ValidationError']
Security,"; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; scf_helper(name, **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). e_dfmp2 = PsiMod.dfmp2(); e_scs_dfmp2 = PsiMod.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; run_mcscf(name, **kwargs); PsiMod.psimrcc(); return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). PsiMod.psimrcc(); retur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:42067,Validat,ValidationError,42067,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"; if not atomSym in el2z:; raise ValidationError('Molecule::create_molecule_from_string: Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; atomMass = el2mass[atomSym] if atomm.group('mass') is None else float(atomm.group('mass')); charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:19342,Validat,ValidationError,19342,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"; mtol=mtol,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). def _raw_to_string(self, dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12):; """"""Format a string representation of QM molecule."""""". molrec = self.to_dict(np_out=True); smol = molparse.to_string(molrec,; dtype=dtype,; units=units,; atom_format=atom_format,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. @staticmethod; def contiguize_from_fragment_pattern(frag_pattern,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; verbose=1,; throw_reorder=False):; """"""Take (nat, ?) array-like arrays and return with atoms arranged by (nfr, ?) `frag_pattern`."""""". vsplt = np.cumsum([len(fr) for fr in frag_pattern]); nat = vsplt[-1]; fragment_separators = vsplt[:-1]. do_reorder = False; if not np.array_equal(np.sort(np.concatenate(frag_pattern)), np.arange(nat)):; raise ValidationError(""""""Fragmentation pattern skips atoms: {}"""""".format(frag_pattern)). if not np.array_equal(np.concatenate(frag_pattern), np.arange(nat)):; print(""""""Warning: Psi4 is reordering atoms to accommodate non-contiguous fragments""""""); do_reorder = True. if do_reorder and throw_reorder:; raise ValueError(""""""Error: Psi4 would need to reorder atoms to accommodate non-contiguous fragments""""""). def reorder(arr):; assert nat == len(arr), """"""wrong number of atoms in array""""""; return np.concatenate([np.array(arr)[fr] for fr in frag_pattern], axis=0). if geom is not None:; ncgeom = np.array(geom).reshape(-1, 3); assert nat == ncgeom.shape[0], """"""dropped atoms!""""""; geom = np.vstack([ncgeom[fr] for fr in frag_pattern]); geom = geom.reshape((-1)). if elea is not None:; elea = reorder(elea); if elez is not None:; elez = reorder(elez); if elem is not None:; elem = reorder(elem); if mass is not None:; mass = reorder(mass); if real is not None:; real = reorder(real); if elbl is not None:; elbl = reorder(elbl). retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:43266,Validat,ValidationError,43266,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"; p4util.banner(name.upper()); psi4.print_out('\n'); e_sapt = psi4.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); psi4.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); psi4.set_local_option('SCF', 'SAPT', '2-mon",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:53964,Validat,ValidationError,53964,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that ; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:23607,access,access,23607,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['access'],['access']
Security,"; raise ValidationError(""Invalid molecule geometry units: {}"".format(units)). if molinit[""units""] == ""Bohr"":; iutau = 1.0; elif molinit[""units""] == ""Angstrom"":; iutau = 1.0 / constants.bohr2angstroms. if input_units_to_au is not None:; if abs(input_units_to_au - iutau) < 0.05:; iutau = input_units_to_au; else:; raise ValidationError(; """"""No big perturbations to physical constants! {} !~= {}"""""".format(iutau, input_units_to_au); ). if always_return_iutau or input_units_to_au is not None:; molinit[""input_units_to_au""] = iutau. return molinit. def validate_and_fill_frame(extern, fix_com=None, fix_orientation=None, fix_symmetry=None):. if fix_com is True:; com = True; elif fix_com is False:; if extern:; raise ValidationError(""Invalid fix_com ({}) with extern ({})"".format(fix_com, extern)); else:; com = False; elif fix_com is None:; com = extern; else:; raise ValidationError(""Invalid fix_com: {}"".format(fix_com)). if fix_orientation is True:; orient = True; elif fix_orientation is False:; if extern:; raise ValidationError(""Invalid fix_orientation ({}) with extern ({})"".format(fix_orientation, extern)); else:; orient = False; elif fix_orientation is None:; orient = extern; else:; raise ValidationError(""Invalid fix_orientation: {}"".format(fix_orientation)). symm = None; if extern:; if fix_symmetry is None:; symm = ""c1""; elif fix_symmetry.lower() == ""c1"":; symm = ""c1""; else:; raise ValidationError(""Invalid (non-C1) fix_symmetry ({}) with extern ({})"".format(fix_symmetry, extern)); else:; if fix_symmetry is not None:; symm = fix_symmetry.lower(). molinit = {}; molinit[""fix_com""] = com; molinit[""fix_orientation""] = orient; if symm:; molinit[""fix_symmetry""] = symm. return molinit. def validate_and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:15424,Validat,ValidationError,15424,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"; raise ValidationError('Unidentified method ' % (name)). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if core.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:49393,Validat,ValidationError,49393,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"; raise ValidationError('Unidentified method ' % (name)). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if psi4.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_local_option('DFOCC', 'OEPROP', 'TRUE'); psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); psi4.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); psi4.set_local_option('DFOCC', 'QCHF', 'TRUE'); psi4.set_local_option('DFOCC', 'E_CONVERGENCE', 8). psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); psi4.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); psi4.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:40184,Validat,ValidationError,40184,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif kind not in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:114272,Validat,ValidationError,114272,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ValidationError(""adcc can only deal with a single irrep.""); kwargs[""n_states""] = n_roots[0]. if core.get_option(""ADC"", ""NUM_GUESSES"") > 0:; kwargs[""n_guesses""] = core.get_option(""ADC"", ""NUM_GUESSES""); if core.get_option(""ADC"", ""MAX_NUM_VECS"") > 0:; kwargs[""max_subspace""] = core.get_option(""ADC"", ""MAX_NUM_VECS""). kind = core.get_option(""ADC"", ""KIND"").lower(); if isinstance(ref_wfn, core.UHF):; if not core.has_option_changed(""ADC"", ""KIND""):; kind = ""any""; elif not kind in [""any"", ""spin_flip""]:; raise ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif not kind in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:111987,Validat,ValidationError,111987,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"", core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; from .proc_data import mrcc_methods. # level is a dictionary of settings to be passed to core.mrcc; try:; level = mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:161236,Validat,ValidationError,161236,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"; scf_wfn.reset_occ_ = True. elif (core.get_option('SCF', 'GUESS') == 'READ') and not os.path.isfile(read_filename):; core.print_out("" Unable to find file 180, defaulting to SAD guess.\n""); core.set_local_option('SCF', 'GUESS', 'SAD'); sad_basis_list = core.BasisSet.build(scf_wfn.molecule(), ""ORBITAL"",; core.get_global_option(""BASIS""),; puream=scf_wfn.basisset().has_puream(),; return_atomlist=True); scf_wfn.set_sad_basissets(sad_basis_list). if (""DF"" in core.get_option(""SCF"", ""SAD_SCF_TYPE"")):; sad_fitting_list = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=scf_wfn.basisset().has_puream(),; return_atomlist=True); scf_wfn.set_sad_fitting_basissets(sad_fitting_list). if cast:; core.print_out(""\n Computing basis projection from %s to %s\n\n"" % (ref_wfn.basisset().name(), base_wfn.basisset().name())); if ref_wfn.basisset().n_ecp_core() != base_wfn.basisset().n_ecp_core():; raise ValidationError(""Projecting from basis ({}) with ({}) ECP electrons to basis ({}) with ({}) ECP electrons will be a disaster. Select a compatible cast-up basis with `set guess_basis YOUR_BASIS_HERE`."".format(; ref_wfn.basisset().name(), ref_wfn.basisset().n_ecp_core(), base_wfn.basisset().name(), base_wfn.basisset().n_ecp_core())). pCa = ref_wfn.basis_projection(ref_wfn.Ca(), ref_wfn.nalphapi(), ref_wfn.basisset(), scf_wfn.basisset()); pCb = ref_wfn.basis_projection(ref_wfn.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute dftd3; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule()); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:38144,Validat,ValidationError,38144,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"; self.center_to_nshell = None; # What's the first shell on each center?; self.center_to_shell = None. # The flattened lists of unique exponents; self.uexponents = None; # The flattened lists of unique contraction coefficients (normalized); self.ucoefficients = None; # The flattened lists of unique contraction coefficients (as provided by the user); self.uoriginal_coefficients = None; # The flattened lists of ERD normalized contraction coefficients; self.uerd_coefficients = None; # The flattened list of Cartesian coordinates for each atom; self.xyz = None. # Divert to constructor functions; if len(args) == 0:; self.constructor_zero_ao_basis(); elif len(args) == 2 and \; isinstance(args[0], BasisSet) and \; isinstance(args[1], int):; self.constructor_basisset_center(*args); elif len(args) == 3 and \; isinstance(args[0], basestring) and \; isinstance(args[1], Molecule) and \; isinstance(args[2], OrderedDict):; self.constructor_role_mol_shellmap(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def initialize_singletons(self):; """"""Initialize singleton values that are shared by all basis set objects.""""""; # Populate the exp_ao arrays; for l in range(self.LIBINT_MAX_AM):; for i in range(l + 1):; x = l - i; for j in range(i + 1):; y = i - j; z = j; self.exp_ao[l].append([x, y, z]). [docs] def constructor_zero_ao_basis(self):; """"""Constructs a zero AO basis set"""""". if not self.initialized_shared:; self.initialize_singletons(); self.initialized_shared = True. # Add a dummy atom at the origin, to hold this basis function; self.molecule = Molecule(); self.molecule.add_atom(0, 0.0, 0.0, 0.0); # Fill with data representing a single S function, at the origin, with 0 exponent; self.n_uprimitive = 1; self.n_shells = 1; self.PYnprimitive = 1; self.PYnao = 1; self.PYnbf = 1; self.uerd_coefficients = [1.0]; self.n_prim_per_shell = [1]; self.uexponents = [0.0]; self.ucoefficient",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:3772,Validat,ValidationError,3772,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['Validat'],['ValidationError']
Security,"; text += ""%10.7f \n"" % (self.d[1][2]); text += "" 3 ""; text += ""%10.7f "" % (self.d[2][0]); text += ""%10.7f "" % (self.d[2][1]); text += ""%10.7f \n"" % (self.d[2][2]); text += ""bits_ = %d\n"" % (self.bits). if out is None:; return text; else:; with open(out, mode='w') as handle:; handle.write(text). [docs]class SymRep(object):; """"""The SymRep class provides an n dimensional matrix representation of a; symmetry operation, such as a rotation or reflection. The trace of a; SymRep can be used as the character for that symmetry operation. d is; hardwired to 5x5 since the H irrep in Ih is 5 dimensional. """""". def __init__(self, *args):; """"""Constructor"""""". # order of representation; self.n = 0; # matrix representation; self.d = zero(5, 5). # Divert to constructor functions; if len(args) == 1 and \; isinstance(args[0], int):; self.constructor_order(*args); elif len(args) == 1 and \; isinstance(args[0], SymmetryOperation):; self.constructor_symmetryoperation(*args); else:; raise ValidationError('SymRep::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_order(self, i):; """"""Initialize order only. """"""; self.n = i; self.zero(). [docs] def constructor_symmetryoperation(self, so):; """"""Initialize from 3x3 SymmetryOperation. """"""; self.n = 3; self.zero(); for i in range(3):; for j in range(3):; self.d[i][j] = so[i][j]. [docs] def SymmetryOperation(self):; """"""Cast SymRep to SymmetryOperation. """"""; if self.n != 3:; raise ValidationError(""SymRep::operator SymmetryOperation(): trying to cast to symop when n != 3""). so = SymmetryOperation(); for i in range(3):; for j in range(3):; so[i][j] = self.d[i][j]; return so. # <<< Simple Methods for Basic SymRep Information >>>. [docs] def set_dim(self, i):; """"""Set the dimension of d""""""; self.n = i. def __getitem__(self, i, j=None):; """"""Returns the (i,j)th element of the transformation matrix; or the i'th row of the transformation matrix if *j* is None. """"""; if j is None:; ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:10414,Validat,ValidationError,10414,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:13638,Validat,ValidationError,13638,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,8,['Validat'],['ValidationError']
Security,"; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:13752,Validat,ValidationError,13752,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,3,['Validat'],['ValidationError']
Security,";  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . ccsd; CC_TYPE. CCENERGY; D;  ;  ; D;  ;  ; D;  ;  ; D;  ;  ; D;  ;  ; D;  ;  . DETCI; Y;  ;  ;  ;  ;  ; Y;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC; Y; D; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ; Y; Y;  ;  ;  ;  ;  ;  ;  ; D;  ;  ;  ;  ;  ;  ;  . ccsd(t); CC_TYPE. CCENERGY; D;  ;  ; D;  ;  ; D;  ;  ; D;  ;  ; D;  ;  ;  ;  ;  . DETCI;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC; Y; D; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ; Y; Y;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . ccsd(at); CC_TYPE. CCENERGY; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DETCI;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ; D; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . cisd; CI_TYPE. CCENERGY;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DETCI; Y;  ;  ;  ;  ;  ; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . DFMP2;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . FNOCC; D;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . OCC;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  ;  . Footnotes. [1]Algorithm type selection keyword below. Values to the right: conventional CONV (here abbreviated CV), density-fitted DF, and Cholesky-decomposed CD. [2](1, 2) Also available for KS reference. [3](1, 2) Conditions have no default module (computationally inefficient) and can only be accessed by specifying QC_MODULE. table of contents. Notes on Options; Alternate Implementations. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/notes_c-1.html:5963,access,accessed,5963,psi4manual/1.1.0/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/notes_c-1.html,2,['access'],['accessed']
Security,";   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. validator set_bsse_type  »  bsse_type[source]¶. validator set_embedding_charges  »  embedding_charges[source]¶. validator set_max_nbody  »  max_nbody[source]¶. validator set_molecule  »  molecule[source]¶. validator set_nfragments  »  nfragments[source]¶. validator set_return_total_data  »  return_total_data[source]¶. table of contents. Basis Set Superposition Corrections; nbody(); API; BsseEnum; BsseEnum.cp; BsseEnum.nocp; BsseEnum.vmfc. ManyBodyComputer; ManyBodyComputer.basis; ManyBodyComputer.bsse_type; ManyBodyComputer.driver; ManyBodyComputer.embedding_charges; ManyBodyComputer.keywords; ManyBodyComputer.max_nbody; ManyBodyComputer.method; ManyBodyComputer.molecule; ManyBodyComputer.nbodies_per_mc_level; ManyBodyComputer.nfragments; ManyBodyComputer.quiet; ManyBodyComputer.return_total_data; ManyBodyComputer.task_list; ManyBodyComputer.build_tasks(); ManyBodyComputer.compute(); ManyBodyComputer.get_psi_results(); ManyBodyComputer.get_results(); ManyBodyComputer.plan(); ManyBodyComputer.prepare_results(); ManyBodyComputer.set_bsse_type; ManyBodyComputer.set_embedding_charges; ManyBodyComputer.set_max_nbody; ManyBodyComputer.set_molecule; ManyBodyComputer.set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:35118,validat,validator,35118,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,3,['validat'],['validator']
Security,"<< Methods for Construction >>>. [docs] def constructor_schoenflies(self, cpg):; """"""This constructor takes the Schoenflies symbol of a point group; as input. """"""; self.symb = cpg; # Check the symbol coming in; self.PYbits = PointGroup.full_name_to_bits(cpg); if self.PYbits is None:; raise ValidationError('CharacterTable: Invalid point group name: %s\n' % (cpg)); self.common_init(). [docs] def constructor_bits(self, bits):; """"""This constructor takes the bitswise representation of a point; group as input. """"""; self.PYbits = bits; self.symb = PointGroup.bits_to_basic_name(bits); self.common_init(). [docs] def common_init(self):; """"""First parse the point group symbol, this will give us the; order of the point group(g), the type of point group (pg), the; order of the principle rotation axis (nt), and the number of; irreps (nirrep). """"""; if len(self.symb) == 0:; raise ValidationError('CharacterTable::CharacterTable: null point group'); if self.make_table() < 0:; raise ValidationError('CharacterTable::CharacterTable: could not make table'). # CharacterTable(const CharacterTable&);; #CharacterTable::CharacterTable(const CharacterTable& ct); # : nt(0), pg(PointGroups::C1), nirrep_(0), gamma_(0), symop(0), _inv(0), symb(0),; # bits_(0); #{; # *this = ct;; #}; #; #; # CharacterTable& operator=(const CharacterTable&);; #CharacterTable&; #CharacterTable::operator=(const CharacterTable& ct); #{; # nt=ct.nt; pg=ct.pg; nirrep_=ct.nirrep_;; #; # symb = ct.symb;; #; # if (gamma_) delete[] gamma_; gamma_=0;; # if (ct.gamma_) {; # gamma_ = new IrreducibleRepresentation[nirrep_];; # for (int i=0; i < nirrep_; i++) {; # gamma_[i].init();; # gamma_[i] = ct.gamma_[i];; # }; # }; #; # if (symop); # delete[] symop;; # symop=0;; #; # if (ct.symop) {; # symop = new SymmetryOperation[nirrep_];; # for (int i=0; i < nirrep_; i++) {; # symop[i] = ct.symop[i];; # }; # }; #; # if (_inv); # delete[] _inv;; # _inv=0;; #; # if (ct._inv) {; # _inv = new int[nirrep_];; # memcpy(_inv,ct._inv,sizeof(int)* n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:22264,Validat,ValidationError,22264,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ... Irrep: 1 Size: 4 x 3. 1 2 3. 1 0.0000000 -0.0122978 0.0000000; 2 -0.0051192 0.0040993 -0.0088667; 3 -0.0051192 0.0040993 0.0088667; 4 0.0102384 0.0040993 0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; Matrix object through the wfn as; psi4.core.Wavefunction.gradient(). Previously, cfour communicated through; psi4.core.legacy_gradient which was accessed through psi4.core.get_gradient(); Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the PSI4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function docu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:22543,access,accessible,22543,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,4,['access'],['accessible']
Security,"= """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables). return e_mp25. # A direct translation of a plugin input file into a function call. Function calls are the only; # way to call plugins in sow/reap mode for db(), opt(), etc. This isn't best practices; # but is an example of what to do for a more complicated procedure where different options ; # are set for different qc steps.; [docs]def run_plugin_omega(name, **kwargs):; r""""""Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish's omega plugin. >>> energy('plugin_omega'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). plugfile = PsiMod.Process.environment[""PSIDATADIR""] + ""/../tests/plugin_omega/plugin_omega.so""; PsiMod.plugin_load(""%s"" % (plugfile)). PsiMod.set_global_option('BASIS', 'AUG-CC-PVDZ'); PsiMod.set_global_option('DF_BASIS_SCF', 'AUG-CC-PVDZ-RI'); PsiMod.set_global_option('REFERENCE', 'UHF'); PsiMod.set_global_option('SCF_TYPE', 'DF'); energy('scf', **kwargs). PsiMod.set_global_option('dft_functional', 'wB97'); PsiMod.set_global_option('dft_order_spherical', 25); PsiMod.set_global_option('dft_num_radial', 35); PsiMod.set_global_option('omega_procedure', 'ip'); PsiMod.set_global_option('maxiter', 50); PsiMod.set_global_option('d_convergence', 5); PsiMod.set_global_option('e_convergence', 7); PsiMod.plugin(""plugin_omega.so""). return PsiMod.get_variable('SCF TOTAL ENERGY'). # Integration with driver routines; proced",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:4378,access,access,4378,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,1,['access'],['access']
Security,"= ''; actives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); #chgdoptval = PsiMod.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""PsiMod.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:40690,Validat,ValidationError,40690,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"= 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; core.print_out(instructions). # write sow/reap instructions",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:15388,Validat,ValidationError,15388,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,3,['Validat'],['ValidationError']
Security,"= 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); core.print_out(instructions). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. core.print_out('\n'); p4util.banner(' Database {} Computation: Reagent {} \n {}'.format(db_name, rgt, TAGL[rgt])); core.print_out('\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:15080,Validat,ValidationError,15080,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,7,['Validat'],['ValidationError']
Security,"= 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap instructions",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:15268,Validat,ValidationError,15268,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"= 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". # TODO: split options into mixable (qc_module=ccenergy/"""") or non-mixable (freeze_core=true/false). metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""tr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:17582,Validat,Validated,17582,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['Validat'],['Validated']
Security,"= 1 and xtpl_type in [""scf"", ""corl""]:; return ""xtpl_highest_1""; elif xtpl_type == ""scf"":; if nbasis == 2:; return ""scf_xtpl_helgaker_2""; elif nbasis == 3:; return ""scf_xtpl_helgaker_3""; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:17508,Validat,Validated,17508,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['Validated']
Security,"= 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:19435,Validat,ValidationError,19435,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"= 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:12204,Validat,ValidationError,12204,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,11,['Validat'],['ValidationError']
Security,"= 5:; self.d[2][2] = -1.0; self.d[3][3] = -1.0. [docs] def c2_x(self):; """"""Set equal to C2 about the x axis. """"""; self.i(); if self.n == 2 or self.n == 3 or self.n == 4:; self.d[0][0] = 1.0; if self.n == 4:; self.d[3][3] = 1.0; elif self.n == 5:; self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[4][4] = 1.0. [docs] def c2_y(self):; """"""Set equal to C2 about the y axis. """"""; self.i(); if self.n == 2 or self.n == 3 or self.n == 4:; self.d[1][1] = 1.0; if self.n == 4:; self.d[2][2] = 1.0; elif self.n == 5:; self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[3][3] = 1.0. [docs] def c2_z(self):; """"""Set equal to C2 about the z axis. """"""; self.i(); if self.n == 2 or self.n == 3 or self.n == 4:; self.d[1][1] = 1.0; if self.n == 4:; self.d[2][2] = 1.0; elif self.n == 5:; self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[3][3] = 1.0. # <<< Methods for Operations >>>. [docs] def operate(self, r):; """"""This operates on this with r (i.e. return r * this). """"""; if r.n != self.n:; raise ValidationError(""SymRep::operate(): dimensions don't match""). ret = SymRep(self.n); for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += r[i][k] * self.d[k][j]; ret[i][j] = t; return ret. [docs] def transform(self, r):; """"""This performs the transform r * this * r~. """"""; if r.n != self.n:; raise ValidationError(""SymRep::operate(): dimensions don't match""). foo = SymRep(n); # foo = r * d; for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += r[i][k] * d[k][j]; foo[i][j] = t. ret = SymRep(n); # ret = (r*d)*r~ = foo*r~; for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += foo[i][k] * r[j][k]; ret[i][j] = t. return ret. [docs] def rotation(self, theta):; """"""Set equal to a clockwise rotation by 2pi/n or theta degrees. """"""; if isinstance(theta, int):; theta = 2.0 * math.pi if theta == 0 else 2.0 * math.pi / theta. ctheta = math.cos(theta); stheta = math.sin(theta); c2theta = math.cos(2 * theta); s2theta = math.si",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:13763,Validat,ValidationError,13763,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"= False:; psi4.opt_clean(). optstash.restore(). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :ref:`Matrix<sec:psimod_Matrix>` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:ref:`Matrix<sec:psimod_Matrix>`, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, psi4.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Hessian: Cannot specify bsse_type for hessian yet.""). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. if gradient_type != 'conventional':; raise ValidationError(""Hessian: Does not yet support more advanced input or custom functions.""). lowername = name.lower(). # Check if this is a CBS extrapolation; if ""/"" in lowername:; return driver_cbs._cbs_gufunc('hessian', lowername, **kwargs). return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:62618,Validat,ValidationError,62618,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"= _np_write; core.Vector.np_read = classmethod(_np_read); core.Vector.to_serial = _to_serial; core.Vector.from_serial = classmethod(_from_serial); core.Vector.__iter__ = _irrep_access; core.Vector.__getitem__ = _irrep_access. ### CIVector properties. @property; def _civec_view(self):; """"""; Returns a view of the CIVector's buffer; """"""; return np.asarray(self). core.CIVector.np = _civec_view. ### Dimension properties. @classmethod; def _dimension_from_list(; self,; dims: Union[Tuple[int], List[int], np.ndarray, core.Dimension],; name=""New Dimension"",; ) -> core.Dimension:; """"""; Builds a Dimension object from a Python list or tuple. If a :class:`~psi4.core.Dimension` object is passed, a copy will be returned. Parameters; ----------; dims; Iterable of integers defining irrep dimensions.; name; Name for new instance. """"""; if isinstance(dims, (tuple, list, np.ndarray)):; irreps = len(dims); elif isinstance(dims, core.Dimension):; irreps = dims.n(); else:; raise ValidationError(""Dimension from list: Type '%s' not understood"" % type(dims)). ret = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(self: core.Dimension) -> Tuple[int]:; """"""Serializes :class:`~psi4.core.Dimension` to a tuple."""""". if isinstance(self, (tuple, list)):; return tuple(self). irreps = self.n(); ret = []; for i in range(irreps):; ret.append(self[i]); return tuple(ret). def _dimension_iter(dim) -> Iterator[int]:; """"""; Provides an iterator class for the Dimension object. Example; -------; >>> dim = psi4.core.Dimension(...); >>> list(dim). """"""; for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. # General functions for NumPy array manipulation. [docs]; def block_diagonal_array(*args: List[np.ndarray]) -> np.ndarray:; """"""; Convert square NumPy array to a single block diagonal array. Mimic of SciPy's :",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:16441,Validat,ValidationError,16441,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,"= classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial). # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.to_array = _to_array; core.Vector.shape = _np_shape; core.Vector.np = _np_view; core.Vector.nph = _nph_view; core.Vector.__array_interface__ = _array_conversion; core.Vector.np_write = _np_write; core.Vector.np_read = classmethod(_np_read); core.Vector.to_serial = _to_serial; core.Vector.from_serial = classmethod(_from_serial). ### CIVector properties. @property; def _civec_view(self):; ""Returns a view of the CIVector's buffer""; return np.asarray(self). core.CIVector.np = _civec_view. ### Dimension properties. @classmethod; def _dimension_from_list(self, dims, name=""New Dimension""):; """"""; Builds a core.Dimension object from a python list or tuple. If a dimension; object is passed a copy will be returned.; """""". if isinstance(dims, (tuple, list, np.ndarray)):; irreps = len(dims); elif isinstance(dims, core.Dimension):; irreps = dims.n(); else:; raise ValidationError(""Dimension from list: Type '%s' not understood"" % type(dims)). ret = core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(dim):; """"""; Converts a core.Dimension object to a tuple.; """""". if isinstance(dim, (tuple, list)):; return tuple(dim). irreps = dim.n(); ret = []; for i in range(irreps):; ret.append(dim[i]); return tuple(ret). def _dimension_iter(dim):; """"""; Provides an iterator class for the Dimension object. Allows:; dim = psi4.core.Dimension(...); list(dim); """""". for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. Module code. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:13615,Validat,ValidationError,13615,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"= core.get_option(""SCF"", ""D_CONVERGENCE""). return (abs(e_delta) < e_conv and d_rms < d_conv). def _validate_damping():; """"""Sanity-checks DAMPING control options. Raises; ------; ValidationError; If any of |scf__damping_percentage|, |scf__damping_convergence|; don't play well together. Returns; -------; bool; Whether DAMPING is enabled during scf. """"""; # Q: I changed the enabled criterion get_option <-- has_option_changed; enabled = (core.get_option('SCF', 'DAMPING_PERCENTAGE') > 0.0); if enabled:; parameter = core.get_option('SCF', ""DAMPING_PERCENTAGE""); if parameter < 0.0 or parameter > 100.0:; raise ValidationError('SCF DAMPING_PERCENTAGE ({}) must be between 0 and 100'.format(parameter)). stop = core.get_option('SCF', 'DAMPING_CONVERGENCE'); if stop < 0.0:; raise ValidationError('SCF DAMPING_CONVERGENCE ({}) must be > 0'.format(stop)). return enabled. def _validate_diis():; """"""Sanity-checks DIIS control options. Raises; ------; ValidationError; If any of |scf__diis|, |scf__diis_start|,; |scf__diis_min_vecs|, |scf__diis_max_vecs| don't play well together. Returns; -------; bool; Whether DIIS is enabled during scf. """"""; enabled = bool(core.get_option('SCF', 'DIIS')); if enabled:; start = core.get_option('SCF', 'DIIS_START'); if start < 1:; raise ValidationError('SCF DIIS_START ({}) must be at least 1'.format(start)). minvecs = core.get_option('SCF', 'DIIS_MIN_VECS'); if minvecs < 1:; raise ValidationError('SCF DIIS_MIN_VECS ({}) must be at least 1'.format(minvecs)). maxvecs = core.get_option('SCF', 'DIIS_MAX_VECS'); if maxvecs < minvecs:; raise ValidationError(; 'SCF DIIS_MAX_VECS ({}) must be at least DIIS_MIN_VECS ({})'.format(maxvecs, minvecs)). return enabled. def _validate_frac():; """"""Sanity-checks FRAC control options. Raises; ------; ValidationError; If any of |scf__frac_start| don't play well together. Returns; -------; bool; Whether FRAC is enabled during scf. """"""; enabled = (core.get_option('SCF', 'FRAC_START') != 0); if enabled:; if enabled < 0:; raise Va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:23613,Validat,ValidationError,23613,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"= database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_global_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:31445,Validat,ValidationError,31445,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"= str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). run_scf('RHF', **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). PsiMod.dfmp2grad(); e_dfmp2 = PsiMod.get_variable('DF-MP2 ENERGY'); e_scs_dfmp2 = PsiMod.get_variable('SCS-DF-MP2 ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2'):; return e_dfmp2. [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; lowername = name.lower(). optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if (lowername == 'ccsd'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD'); PsiMod.set_local_option('CCSORT', 'WFN', 'CCSD'); PsiMod.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif (lowername == 'ccsd(t)'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); PsiMod.set_local_option('CCSORT', 'WFN', 'CCSD_T'); PsiMod.set_local_option('CCENERGY', 'WF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:11993,Validat,ValidationError,11993,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(cls):; if not hasattr(cls, 'frequency_analysis'):; return None. vibinfo = cls.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). def _core_wavefunction_legacy_frequencies(cls):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.legacy_frequencies` (accessing c-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.legacy_frequencies(). def _core_wavefunction_set_frequencies(cls, val):; """"""; .. deprecated:: 1.4. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_frequencies` (accessing c-side member data) instead of `psi4.core.Wavefunction.frequency_analysis` (py-side member data) is deprecated, and in 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_legacy_frequencies(val). core.Wavefunction.frequencies = _core_wavefunction_frequencies; core.Wavefunction.legacy_frequencies = _core_wavefunction_legacy_frequencies; core.Wavefunction.set_frequencies = _core_wavefunction_set_frequencies. def _core_wavefunction_X(cls):; warnings.warn(; ""Using `psi4.core.Wavefunction.X` instead of `psi4.core.Wavefunction.lagrangian` is deprecated, and in 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.lagrangian(). core.Wavefunction.X = _core_wavefunction_X. ## Psi4 v1.3 Export Deprecations. def _core_get_gradient():; """"""; .. deprecated:: 1.2. """"""; warnings.warn(; ""Using `psi4.core.get_gradient` (only used internally for C++ optking; deprecated silently in 1.2) is deprecated, and in 1.5 (or whenever Py optking is adopted) it ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:36202,access,accessing,36202,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,2,['access'],['accessing']
Security,"=================================================================================+; | scf | Hartree--Fock (HF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce (someday) if name is function; if hasattr(name, '__call__'):; raise ValidationError(""Frequency: Cannot use custom function""). lowername = name.lower(). old_global_basis = None; if ""/"" in lowername:; if (""+"" in lowername) or (""["" in lowername) or (lowername.count('/') > 1):; raise ValidationError(""Frequency: Cannot extrapolate or delta correct frequencies yet.""); else:; old_global_basis = core.get_global_option(""BASIS""); lowername, new_basis = lowername.split('/'); core.set_global_option('BASIS', new_basis). if kwargs.get('bsse_type', None) is not None:; raise ValdiationError(""Frequency: Does not currently support 'bsse_type' arguements""). return_wfn = kwargs.pop('return_wfn', False). # are we in sow/reap mode?; freq_mode = kwargs.get('mode', 'continuous').lower(); if freq_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:84641,Validat,ValidationError,84641,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are feezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone().",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:57417,Validat,ValidationError,57417,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Function to reset the total memory allocation. Takes memory value; *inputval* as type int, float, or str; int and float are taken literally; as bytes to be set, string taken as a unit-containing value (e.g., 30 mb); which is case-insensitive. Set *execute* to False to interpret *inputval*; without setting in Psi4 core. :returns: *memory_amount* Number of bytes of memory set. :raises: :py:class:`psi4.ValidationError` when <500MiB or disallowed type or misformatted. :examples:. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. >>> # Good examples; >>> psi4.set_memory(800000000) # 800000000; >>> psi4.set_memory(2004088624.9) # 2004088624; >>> psi4.set_memory(1.0e9) # 1000000000; >>> psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html:3921,Validat,ValidationError,3921,psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,3,['Validat'],['ValidationError']
Security,">> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). interactive¶. run()[source]¶. pubchem¶. class PubChemObj(cid, mf, iupac)[source]¶. getCartesian()[source]¶; Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. getMoleculeString()[source]¶; Function to obtain a molecule string through; getCartesian() or fail. getSDF()[source]¶; Function to return the SDF (structure-data file) of the PubChem object. getXYZFile()[source]¶; Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. name()[source]¶; Function to return the IUPAC name of the PubChem object. getPubChemResults(name)[source]¶; Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. inputparser¶; Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. bad_option_syntax(line)[source]¶; Function to report bad syntax to screen and output file. basname(name)[source]¶; Imitates BasisSet.make_filename() without the gbs extension. check_parentheses_and_brackets(input_string, exit_on_error)[source]¶; Function to check that all parenthesis and brackets; in input_string are paired. On that condition, exit_on_error =1,; otherwise 0. parse_multiline_array(input_list)[source]¶; Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. process_basis_block(matchobj)[source]¶; Function to process match of basis name? { ... }. process_cfour_command(matchobj)[source]¶; Function to process match of cfour name? { ... }. process_external_command(matchobj)[source]¶; Function to process match of external name? { ... }. process_extract_command(matchobj)[source]¶; Function to process match of extract_subsets. process_from_file_command(matchobj)[source]¶; Function that pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:4698,access,access,4698,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['access'],['access']
Security,">>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:29785,Validat,ValidationError,29785,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,">>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['df-scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['df-mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'df-mp2corl': 'DF-MP2 CORRELATION ENERGY'}; VARH['cc2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'cc2corl': 'CC2 CORRELATION ENERGY'}; VARH['ccsd'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY',; 'ccsdcorl': 'CCSD CORRELATION ENERGY'}; VARH['bccd'] = { 'scf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:58969,Validat,ValidationError,58969,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,">>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['mp2'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY'}; VARH['mp2.5'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp3'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATION ENERGY', ; 'mp2.5corl': 'MP2.5 CORRELATION ENERGY', ; 'mp3corl': 'MP3 CORRELATION ENERGY'}; VARH['mp4(sdq)'] = { 'scftot': 'SCF TOTAL ENERGY',; 'mp2corl': 'MP2 CORRELATIO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:60377,Validat,ValidationError,60377,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,">>> print asdf.dbdict; XXXX. dbse = None¶; internal name of database collection; >>> print asdf.dbse; 'DB4'. export_pandas(modelchem=[], benchmark='default', sset='default', modelchemlabels=None, failoninc=True)[source]¶; modelchem is array of model chemistries, if modelchem is empty, get only benchmark; is benchmark needed?. fancy_mcs(latex=False)[source]¶. get_hrgt(sset='default', actv='default')[source]¶. get_hrxn(sset='default')[source]¶. get_missing_reactions(modelchem, sset='default')[source]¶; Returns a dictionary (keys self.dbse and all component; WrappedDatabase.dbse) of two elements, the first being the number; of reactions sset should contain and the second being a list of; the reaction names (dbrxn) not available for modelchem. Absence; of benchmark not considered. get_reactions(modelchem, sset='default', benchmark='default', failoninc=True)[source]¶; Collects the reactions present in sset from each WrappedDatabase,; checks that modelchem and benchmark ReactionDatum are present; (fails if failoninc True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; modelchem, the modelchem key needed to access benchmark, and; the Reaction object. integer_reactions()[source]¶; Returns boolean of whether reaction names need to be cast to integer. load_qcdata_byproject(project, pythonpath=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; standard location for project :module dbse_project and function; load_project. Module search path can be prepended with pythonpath. load_qcdata_hdf5_trusted(project, path=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. load_qcdata_hrxn_byproject(project, path=None)[source]¶. load_saptdata_frombfdb(sset='default', pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True)[source]¶; This",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:32688,access,access,32688,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,4,['access'],['access']
Security,"A helper function that parses a ``""method/basis""`` input string; into separate method and basis components. Also handles delta corrections. Parameters; ----------; method_name : str; A ``""method/basis""`` style string defining the calculation. Returns; -------; tuple; Tuple in the ``(method_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based wrapper of the CBS function. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:62374,Validat,ValidationError,62374,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"A helper function that parses a ``""method/basis""`` input string; into separate method and basis components. Also handles delta corrections. Parameters; ----------; method_name : str; A ``""method/basis""`` style string defining the calculation. Returns; -------; tuple; Tuple in the ``(method_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(r""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:63932,Validat,ValidationError,63932,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"AL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:98829,Validat,ValidationError,98829,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"ANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for FCHK files."""""". import re; from typing import Union. import numpy as np; from psi4.driver.p4util.testing import compare_strings, compare_arrays, compare_values, compare_integers; from psi4 import core; from .exceptions import ValidationError. __all__ = [; ""compare_fchkfiles"",; ""compare_moldenfiles"",; ]. def _consume_fchk_section(input_list, index):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. def _fchkfile_to_string(fname: str) -> str:; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]; def compare_fchkfiles(expected: str, computed: str, atol_exponent: Union[int, float], label: str):; """"""Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html:1751,Validat,ValidationError,1751,psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/fchk.html,1,['Validat'],['ValidationError']
Security,"ANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for FCHK files."""""". import re; from typing import Union. import numpy as np; from psi4.driver.p4util.testing import compare_strings, compare_arrays, compare_values, compare_integers; from psi4 import core; from .exceptions import ValidationError. __all__ = [; ""compare_fchkfiles"",; ""compare_moldenfiles"",; ]. def _consume_fchk_section(input_list, index):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. def _fchkfile_to_string(fname: str) -> str:; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]def compare_fchkfiles(expected: str, computed: str, atol_exponent: Union[int, float], label: str):; """"""Comparison function for output data in FCHK (formatted checkpoint) file; format. Compares many fields including number of electrons, highest angular; momentum, basis set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html:1749,Validat,ValidationError,1749,psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/fchk.html,1,['Validat'],['ValidationError']
Security,APT method. unit() psi4.core.SymmetryOperation method. units. ; molecule. units qcelemental.datum.Datum attribute. units() psi4.core.Molecule method. Unnormalized psi4.core.PrimitiveType attribute. UPDATE (DETCI). update() psi4.core.DFSOMCSCF method. psi4.core.DiskSOMCSCF method. psi4.core.SOMCSCF method. update_density() psi4.core.ERI method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. update_forward_refs() psi4.driver.AtomicComputer class method. update_geometry() psi4.core.Molecule method. update_orbitals() psi4.core.IntegralTransform method. UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. Va() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate() psi4.driver.AtomicComputer class method. validate_diis() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. validate_options() psi4.core.Options method. ValidationError. class in qcelemental. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. variables() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:153262,validat,validate,153262,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['validat'],['validate']
Security,"AS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:175828,Validat,ValidationError,175828,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"ASE); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Skip the second line. # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Coordinates in Molecule must be bohr.; if fileUnits == 'Angstrom':; fileX /= psi_bohr2angstroms; fileY /= psi_bohr2angstroms; fileZ /= psi_bohr2angstroms. # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Molecule::init_with_xyz: Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(0); instance.fragment_multiplicities.append(1); # Set the units to bohr since we did the conversion above, if needed.; instance.PYunits = 'Bohr'; instance.input_units_to_au = 1.0. instance.update_geometry(); return instance. [docs] def clone(self):; """"""Returns new, independent Molecule object. >>> dimer = H2OH2O.clone(). """"""; return copy.deepcopy(self). # <<< Methods for Printing >>>. [docs] de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:24543,Validat,ValidationError,24543,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"ATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.core.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; # elif der2nd.match(str(dertype)):; # raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]; # else:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html:3122,Validat,ValidationError,3122,psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,2,['Validat'],['ValidationError']
Security,"BSVec method, [1], [2]. psi4.core.VectorMatrix method, [1], [2]. apply_denominator() psi4.core.Matrix method, [1], [2]. approx_solve() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. AQCCCORRELATIONENERGY. AQCCDIPOLEX. AQCCDIPOLEY. AQCCDIPOLEZ. AQCCQUADRUPOLEXX. AQCCQUADRUPOLEXY. AQCCQUADRUPOLEXZ. AQCCQUADRUPOLEYY. AQCCQUADRUPOLEYZ. AQCCQUADRUPOLEZZ. AQCCTOTALENERGY. arbitrary-order coupled-cluster theory. ; CI. arbitrary-order perturbation theory. ; CI. architectures. args psi4.driver.ConvergenceError attribute. psi4.driver.CSXError attribute. psi4.driver.Dftd3Error attribute. psi4.driver.ManagedMethodError attribute. psi4.driver.OptimizationConvergenceError attribute. psi4.driver.ParsingError attribute. psi4.driver.PastureRequiredError attribute. psi4.driver.PsiException attribute. psi4.driver.PsiImportError attribute. psi4.driver.SCFConvergenceError attribute. psi4.driver.TestComparisonError attribute. psi4.driver.ValidationError attribute. array_interface() psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. array_to_matrix() in module psi4.driver.p4util.numpy_helper. array_variable() in module psi4.core, [1]. psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. array_variables() in module psi4.core, [1]. psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. arrays() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:7782,Validat,ValidationError,7782,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['Validat'],['ValidationError']
Security,"C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if (psi4.get_option('SCF', 'REFERENCE') == 'ROHF') and \; ((name in ['ccsd(t)', 'ccsd(at)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; psi4.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if psi4.get_global_option('RUN_CCTRANSORT'):; psi4.cctransort(ref_wfn); else:; psi4.transqt2(ref_wfn); psi4.ccsort(). ccwfn = psi4.ccenergy(ref_wfn). if name == 'ccsd(at)':; psi4.cchbar(ref_wfn); psi4.cclambda(ref_wfn). optstash.restore(); return ccwfn. [docs]def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). psi4.set_global_option('DERTYPE', 'FIRST'). if psi4.get_global_option('FREEZE_CORE') == 'TRUE':; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'ccsd':; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; psi4.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); psi4.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). user_ref = psi4.get_option('CCENERGY', 'REFERENCE'); if user_ref != 'UHF':; raise ValidationError('Reference %s for CCSD(T) gradients is not available.' % user_ref). psi4.cchbar(ccwfn); psi4.cclambda(ccwfn); psi4.ccdensity(ccwfn). derivobj = psi4.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad). optstash.restore(); return ccwfn. [docs]def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'DELETE_TEI'],; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; psi4.set_local",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:54944,Validat,ValidationError,54944,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"CC','COMPUTE_MP4_TRIPLES', True); psi4.set_local_option('FNOCC','COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC','NAT_ORBS', True); elif (lowername == 'mp4(sdq)'):; psi4.set_local_option('FNOCC','RUN_MP4', True); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES', False); psi4.set_local_option('FNOCC','COMPUTE_TRIPLES', False); elif (lowername == 'fno-mp4(sdq)'):; psi4.set_local_option('FNOCC','RUN_MP4', True); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES', False); psi4.set_local_option('FNOCC','COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC','NAT_ORBS', True); elif (lowername == 'fnocc-mp') and (level == 3):; psi4.set_local_option('FNOCC','RUN_MP3', True); elif (lowername == 'fnocc-mp') and (level == 4):; psi4.set_local_option('FNOCC','RUN_MP4', True); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES', True); psi4.set_local_option('FNOCC','COMPUTE_TRIPLES', True). # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). # scf; scf_helper(name,**kwargs). # if the scf type is df/cd, then the ao integrals were never written to disk.; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; # do we generate 4-index eri's with 3-index ones, or do we want conventional eri's?; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; mints = psi4.MintsHelper(); mints.integrals(). # if this is not cim or FNO-CC, run transqt2. otherwise, libtrans will be used; if psi4.get_option('FNOCC','NAT_ORBS') == False and psi4.get_option('FNOCC','RUN_MP2') == False:; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); psi4.transqt2(). # run ccsd; psi4.fnocc(). # set current correlation energy and total energy. only need to treat mpn here.; if (lowername == 'fnocc-mp') and (level == 3):; emp3 = psi4.get_variable(""MP3 TOTAL ENERGY""); cemp3 = psi4.get_variable(""MP3 CORRELATI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:69735,Validat,ValidationError,69735,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"CC. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. cbs-parser; mtd/basis syntax examples. options1; check all variety of options parsing. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in tab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:15631,Access,Accesses,15631,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['Access'],['Accesses']
Security,"CE'); mtd_type = core.get_global_option('SCF_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only scf. if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError(['select_scf_gradient', name, 'SCF_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:3439,validat,validation,3439,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['validat'],['validation']
Security,"CF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """""". optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF', 'SCF_TYPE']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if ((core.get_option('SCF', 'SCF_TYPE') == 'DF') and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:124241,Validat,ValidationError,124241,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"CF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n"");; if banner:; core.print_out("" "" + banner.center(58));; if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58));; ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(ref_wfn). # Compute dftd3; if hasattr(ref_wfn, ""_disp_functor""):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variable(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # broken clean-up; if do_broken:; raise ValidationError(""Broken Symmetry computations are temporarily disabled.""); scf_molecule.set_multiplicity(1); core.set_local_option('SCF', 'GUESS', 'READ'); core.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); core.print_out('\n'). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). optstash2.restore(). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n"");; core.print_out("" "" + banner.center(58));. scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(scf_wfn). # The wfn from_file routine adds the npy s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:43160,Validat,ValidationError,43160,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"CF'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE']). core.set_local_option('FNOCC', 'DFCC', True); core.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); elif type_val == 'DF':; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''); # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_option('SCF', 'SCF_TYPE') not in ['CD', 'DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:114181,Validat,ValidationError,114181,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"CF'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE']). psi4.set_local_option('FNOCC', 'DFCC', True); psi4.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). def set_cholesky_from(mtd_type):; type_val = psi4.get_global_option(mtd_type); if type_val == 'CD':; psi4.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'CD'); psi4.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); elif type_val == 'DF':; if psi4.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; psi4.set_local_option('FNOCC', 'DF_BASIS_CC', ''); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if psi4.get_option('SCF', 'SCF_TYPE') not in ['CD', 'DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:98615,Validat,ValidationError,98615,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"CF). threading. TIKHONOW_MAX (PSIMRCC). TIKHONOW_OMEGA (DCFT). (PSIMRCC). TIKHONOW_TRIPLES (PSIMRCC). TILE_SZ (SCF). TPDM (DCFT). (DETCI). TPDM_ABCD_TYPE (OMP3). TPDM_ADD_REF (TRANSQT). TPDM_FILE (TRANSQT). TPDM_PRINT (DETCI). transition state; . geometry optimization. translate() LibmintsMolecule method. transpose() in module qcdb.vecutil. TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TURN_ON_ACTV (MCSCF). TWO-ELECTRONENERGY. type() CartesianEntry method. NumberValue method. VariableValue method. ZMatrixEntry method. U. UNCP-CORRECTED2-BODYINTERACTIONENERGY. unique() LibmintsMolecule method. units; . molecule. UNITS (GLOBALS). units() LibmintsMolecule method. UPDATE (DETCI). update_geometry() LibmintsMolecule method. USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). useful() in module qcdb.dbproc. util module. V. VAL_EX_LEVEL (DETCI). valid_atom_map() LibmintsMolecule method. validate_bracketed_basis() in module wrappers. validate_scheme_args() in module wrappers. ValidationError, [1]. variable_to_string() NumberValue method. VariableValue method. VariableValue class in qcdb.libmintscoordentry. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). VECS_WRITE (DETCI). W. WABEI_LOWDISK (CCHBAR). WFN (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CCTRIPLES). (CIS). (CLAG). (DETCI). (GLOBALS). (LMP2). (MP2). (SCF). (TRANSQT). (TRANSQT2). WFN_SYM (MCSCF). (PSIMRCC). wrappers module. X. x() LibmintsMolecule method. XI (CCDENSITY). XI_CONNECT (CCDENSITY). xyz() LibmintsMolecule method. Y. y() LibmintsMolecule method. Z. Z() CoordEntry method. z() LibmintsMolecule method. Z() LibmintsMolecule method. ZAPTnCORRELATIONENERGY. ZAPTnTOTALENERGY. zero() in module qcdb.vecutil. ZERO_INTERNAL_AMPS (PSIMRCC). ZETA (CCDENSITY). (CCLAMBDA). ZMatrixEntry class in qcdb.libmintscoordentry. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/genindex.html:43158,Validat,ValidationError,43158,psi4manual/4.0b3/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/genindex.html,1,['Validat'],['ValidationError']
Security,"CF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). optstash.restore(). [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""The \""properties\"" keyword is required with the property() function.""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if (n_invalid > 0):; print(""The following properties are not currently supported: %s"" % invalid). if (n_excited > 0 and (name.lower() != 'eom-ccsd' and name.lower() != 'eom-cc2')):; raise ValidationError(""Excited state CC properties require EOM-CC2 or EOM-CCSD.""). if ((name.lower() == 'eom-ccsd' or name.lower() == 'eom-cc2') and n_response > 0):; raise ValidationError(""Cannot (yet) compute response properties for excited states.""). if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""Computing both density- and response-based properties.""). if (name.lower() == 'ccsd'):; PsiMod.set_global_option('WFN', 'CCSD'); run_ccenergy('ccsd', **kwargs); PsiMod.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'cc2'):; PsiMod.set_global_option('WFN', 'CC2'); run_ccenergy('cc2', **kwargs); PsiMod.set_global_option('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:26949,Validat,ValidationError,26949,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); dertype = 1. optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError('No analytic derivatives for SCF_TYPE CD.'). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:32276,Validat,ValidationError,32276,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from *self* ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:40925,Validat,ValidationError,40925,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from *self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:38854,Validat,ValidationError,38854,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Programming: Using the Core Libraries. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/proc_py-1.html:6812,access,access,6812,psi4manual/1.1.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/proc_py-1.html,2,['access'],['access']
Security,"D) together provide; the methods described on this page, they are controlled through one; QC_MODULE value OCC. Without set qc_module occ,; these methods may default to implementations in other modules based on efficiency considerations.; Starting in v1.4, MP2.5 and MP3 default to the density-fit algorithm. Set MP_TYPE to CONV to get previous behavior.; Publications resulting from the use of the non-OO CC codes should cite the following publications:. MP2 [Bozkaya:2011:omp2], [Bozkaya:2013:omp2grad], and [Bozkaya:2014:dfomp2grad]; MP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], [Bozkaya:2013:omp3grad], [Bozkaya:2016:dfomp3], and [Bozkaya:2018:dfomp3grad]; MP2.5 [Bozkaya:2011:omp3], [Bozkaya:2016:dfomp3], and [Bozkaya:2018:dfomp3grad]; REMP [Behnle:2019:REMP], [Behnle:2022:OREMP]; LCCD [Bozkaya:2013:ocepa] and [Bozkaya:2016:dfolccd]; CCD [Bozkaya:2020:dfoccd]; CCSD [Bozkaya:2016:dfccsdgrad]; CCSD(T) [Bozkaya:2017:dfccsdtgrad]; CCSD(AT) [Bozkaya:2016:dfccsdat]. Non-OO theoretical methods accessible through OCC/DFOCC¶. name; calls method; plain; FNO. mp2; second-order MP perturbation theory; E/G; n/a. mp2.5; average of MP2 and MP3; E/G. mp3; third-order MP perturbation theory; E/G. remp2; second-order retaining-the-excitation-degree MP hybrid PT; E. lccd; linear coupled cluster doubles; E/G. ccd; coupled cluster doubles; E/G. ccsd; coupled cluster singles and doubles; E/G. ccsd(t); coupled cluster singles and doubles with perturbative triples; E/G. a-ccsd(t); CCSD with asymmetric perturbative triples; E. Detailed non-orbital-optimized capabilities of the OCC module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[5] ↓ →; FREEZE_CORE[6]→. QC_MODULE=OCC Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[7]; energy(); gradient()[7]; energy(); gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:19225,access,accessible,19225,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['access'],['accessible']
Security,"D. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. mom-h2o-4; MOM excitation from LUMO HOMO+4. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. scf-response3; UHF Dipole Polarizability Test. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. sapt10; usapt example with empty beta due to frozen core. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cc51; EOM-CC3/cc-pVTZ on H2O. opt7; Various c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:4618,validat,validate,4618,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"DAMPING_CONVERGENCE ({}) must be > 0'.format(stop)). return enabled. def _validate_diis():; """"""Sanity-checks DIIS control options. Raises; ------; ValidationError; If any of |scf__diis|, |scf__diis_start|,; |scf__diis_min_vecs|, |scf__diis_max_vecs| don't play well together. Returns; -------; bool; Whether DIIS is enabled during scf. """"""; enabled = bool(core.get_option('SCF', 'DIIS')); if enabled:; start = core.get_option('SCF', 'DIIS_START'); if start < 1:; raise ValidationError('SCF DIIS_START ({}) must be at least 1'.format(start)). minvecs = core.get_option('SCF', 'DIIS_MIN_VECS'); if minvecs < 1:; raise ValidationError('SCF DIIS_MIN_VECS ({}) must be at least 1'.format(minvecs)). maxvecs = core.get_option('SCF', 'DIIS_MAX_VECS'); if maxvecs < minvecs:; raise ValidationError(; 'SCF DIIS_MAX_VECS ({}) must be at least DIIS_MIN_VECS ({})'.format(maxvecs, minvecs)). return enabled. def _validate_frac():; """"""Sanity-checks FRAC control options. Raises; ------; ValidationError; If any of |scf__frac_start| don't play well together. Returns; -------; bool; Whether FRAC is enabled during scf. """"""; enabled = (core.get_option('SCF', 'FRAC_START') != 0); if enabled:; if enabled < 0:; raise ValidationError('SCF FRAC_START ({}) must be at least 1'.format(enabled)). return enabled. def _validate_MOM():; """"""Sanity-checks MOM control options. Raises; ------; ValidationError; If any of |scf__mom_start|, |scf__mom_occ| don't play well together. Returns; -------; bool; Whether excited-state MOM (not just the plain stabilizing MOM) is enabled during scf. """"""; enabled = (core.get_option('SCF', ""MOM_START"") != 0 and len(core.get_option('SCF', ""MOM_OCC"")) > 0); if enabled:; start = core.get_option('SCF', ""MOM_START""); if enabled < 0:; raise ValidationError('SCF MOM_START ({}) must be at least 1'.format(start)). return enabled. def _validate_soscf():; """"""Sanity-checks SOSCF control options. Raises; ------; ValidationError; If any of |scf__soscf|, |scf__soscf_start_convergence|,; |scf__so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:24440,Validat,ValidationError,24440,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""a-ccsd(t)"": {""wfn_type"": ""DF-CCSD(AT)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC energy""). # throw exception for CONV (approximately). run reference defaulting logic; set_cholesky_from(method_algorithm_type(name).now). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:65148,Validat,ValidationError,65148,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"DFOCC — Level shift to aid convergence. Type: double; Default: 0.02. LEVEL_SHIFT (MCSCF)¶MCSCF — Level shift to aid convergence. Type: double; Default: 0.0. LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 0.02. LEVEL_SHIFT (SCF)¶SCF — Do use a level shift?. Type: double; Default: 0.0. LEVEL_SHIFT_CUTOFF (SCF)¶SCF — DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. LINEAR (CCRESPONSE)¶CCRESPONSE — Do Bartlett size-extensive linear model?. Type: boolean; Default: false. LINEQ_SOLVER (DFOCC)¶DFOCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINK_INTS_TOLERANCE (SCF)¶SCF — The screening tolerance used for ERI/Density sparsity in the LinK algorithm. Type: conv double; Default: 1.0e-12. LITERAL_CFOUR (GLOBALS)¶GLOBALS — Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. LOCAL (CCENERGY)¶CCENERGY — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCEOM)¶CCEOM — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCLAMBDA)¶CCLAMBDA — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCRESPONSE)¶CCRESPONSE — Do simulate local correlation?. Type: boolean; Default: false. LOCAL_CONVERGENCE (DLPNO)¶DLPNO — Convergence criteria for the Foster-Boys orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_CONVERGENCE (FISAPT)¶FISAPT — Relative convergence in orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_CONVERGENCE (SCF)¶SCF — The convergence on the orbital localization procedure. Type: conv double; Default: 1e-12. LOCAL_CPHF_CUTOFF (CCENERGY)¶CCENERGY — Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:159554,Access,Access,159554,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,4,['Access'],['Access']
Security,"DFOCC', 'WFN_TYPE', 'DF-OMP2'); type_val = set_cholesky_from('MP2_TYPE'); elif name in ['mp2.5', 'omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); type_val = set_cholesky_from('MP_TYPE'); elif name in ['mp3', 'omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); type_val = set_cholesky_from('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); type_val = set_cholesky_from('CC_TYPE'). elif name == 'ccd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'ccsd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'ccsd(at)':; core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(AT)'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'dfocc':; pass; else:; raise ValidationError('Unidentified method %s' % (name)). # conventional vs. optimized orbitals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'ccsd(at)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:45905,Validat,ValidationError,45905,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"DFT. """"""; if name == 'cphf':; core.set_global_option('MODULE', 'RCPHF'); if name == 'cis':; core.set_global_option('MODULE', 'RCIS'); if name == 'tdhf':; core.set_global_option('MODULE', 'RTDHF'); if name == 'cpks':; core.set_global_option('MODULE', 'RCPKS'); if name == 'tda':; core.set_global_option('MODULE', 'RTDA'); if name == 'tddft':; core.set_global_option('MODULE', 'RTDDFT'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). libfock_wfn = core.libfock(ref_wfn); libfock_wfn.compute_energy(); return libfock_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']) # yes, this really must be global, not local to SCF. # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:66284,Validat,ValidationError,66284,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"DFT. """"""; if name == 'cphf':; core.set_global_option('MODULE', 'RCPHF'); if name == 'cis':; core.set_global_option('MODULE', 'RCIS'); if name == 'tdhf':; core.set_global_option('MODULE', 'RTDHF'); if name == 'cpks':; core.set_global_option('MODULE', 'RCPKS'); if name == 'tda':; core.set_global_option('MODULE', 'RTDA'); if name == 'tddft':; core.set_global_option('MODULE', 'RTDDFT'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). libfock_wfn = core.libfock(ref_wfn); libfock_wfn.compute_energy(); return libfock_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']) # yes, this really must be global, not local to SCF. # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if core.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:62483,Validat,ValidationError,62483,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"",; core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = core.variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:113375,Validat,ValidationError,113375,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"DO_THIRD_ORDER', True); elif (name.lower() == 'sapt2+(ccd)-ct'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+(3)(ccd)-ct'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', False); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+3(ccd)-ct'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', True); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); psi4.print_out('\n'); p4util.banner('SAPT Charge Transfer'); psi4.print_out('\n'). # if the df_basis_sapt basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SAPT') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_SAPT', ribasis); psi4.print_out(' No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). psi4.print_out('\n'); p4util.banner('Dimer Basis SAPT'); psi4.print_out('\n'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = psi4.sapt(); CTd = psi4.get_variable('SAPT CT ENERGY'). psi4.print_out('\n'); p4util.banner('Monomer Basis SAPT'); psi4.print_out('\n'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = psi4.sapt(); CTm = psi4.get_variable('SAPT CT ENERGY'); CT = CTd - CTm. psi4.print_out('\n\n'); psi4.print_out(' SAPT Charge Transfer Analysis\n'); psi4.print_out(' -----------------------------------------------------------------------------\n'); line1 = ' SAPT Induction (Dimer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTd * 1000.0, CTd * p4const.psi_hartree2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:57746,Validat,ValidationError,57746,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"Datum for %s to database %s with reactions %s."""""" %; (dbse + '-' + str(rxn), self.dbse, self.hrxn.keys())); label = '-'.join([method, mode, basis]); if overwrite or (label not in self.hrxn[rxnname].data):; self.hrxn[rxnname].data[label] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxnname,; method=method, mode=mode, basis=basis,; value=value, units=units,; comment=comment, citation=citation); else:; raise ValidationError(""""""ReactionDatum %s already present in Database."""""" % (label)); else:; raise ValidationError(""""""Inconsistent to add ReactionDatum for %s to database %s."""""" %; (dbse + '-' + str(rxn), self.dbse)). [docs] def add_Subset(self, name, func):; """"""Define a new subset labeled *name* by providing a function; *func* that filters *self.hrxn*. """"""; sname = name.lower().split('\n'); label = sname.pop(0); tagl = sname[0].strip() if sname else None; try:; filtered = func(self); lsslist = [rxn for rxn in self.sset['default'].keys() if rxn in filtered]; except TypeError as e:; raise ValidationError(""""""Function %s did not return list: %s."""""" % (func.__name__, str(e))); if len(lsslist) == 0:; print(""""""WrappedDatabase %s: Subset %s NOT formed: empty"""""" % (self.dbse, label)); return. self.sset[label] = OrderedDict(); for rxn in lsslist:; self.sset[label][rxn] = self.hrxn[rxn]; self.oss[label] = Subset(name=label,; hrxn=self.sset[label].keys(),; tagl=tagl); print(""""""WrappedDatabase %s: Subset %s formed: %d"""""" % (self.dbse, label, len(self.sset[label].keys()))). [docs] def compute_errors(self, modelchem, benchmark='default', sset='default', failoninc=True, verbose=False):; """"""For full database or subset *sset*, computes raw reaction; errors between *modelchem* and *benchmark* model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless *failoninc* set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. """"""; if isinstance(sset, basestring):; # sset is normal subset name 'MX' corresponding ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:31141,Validat,ValidationError,31141,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"E'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccsd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccsd(t)']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); else:; raise ValidationError('Unidentified method %s' % (name)). if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd', 'ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); if corl_type not in [""DF"", ""CD""]:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC""""""). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:60900,Validat,ValidationError,60900,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"E', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = sapt_dimer.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = sapt_dimer.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, 1); monomerB.set_name('monomerB'); sapt_dimer.update_geometry(); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = core.get_option('SCF', 'SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'); core.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.set_global_option('DF_INTS_IO', 'LOAD'). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'); core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF (Dimer Basis)'); core.print_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:101170,Validat,ValidationError,101170,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"E']). oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa', 'roa_tensor']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(""""""CC property name %s not recognized"""""" % name.upper()). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:72859,Validat,ValidationError,72859,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"E']). oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa', 'roa_tensor']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); psi4.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); psi4.set_global_option('WFN', this_name); else:; raise ValidationError(""""""CC property name %s not recognized"""""" % name.upper()). # Need cchbar for everything; psi4.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; psi4.set_global_option('WFN', 'EOM_CCSD'); psi4.set_global_option('DERT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:60201,Validat,ValidationError,60201,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"EL (GLOBALS)>` . :examples:. >>> # [1] DMA analysis from MP2 wavefunction. N.B. gradient must be requested to generate MP2 density.; >>> grad, wfn = gradient('mp2', return_wfn=True); >>> gdma(wfn). """"""; # Start by writing a G* checkpoint file, for the GDMA code to read in; fw = core.FCHKWriter(wfn); molname = wfn.molecule().name(); prefix = core.get_writer_file_prefix(molname); fchkfile = prefix + '.fchk'; fw.write(fchkfile). if datafile:; commands = datafile; else:; if wfn.reference_wavefunction():; densname = ""CC""; else:; densname = ""SCF""; commands = 'psi4_dma_datafile.dma'; radii = core.get_option('GDMA', 'GDMA_RADIUS'); origin = core.get_option('GDMA', 'GDMA_ORIGIN'); with open(commands, 'w') as f:; f.write(""File %s Density %s\n"" % (fchkfile, densname)); f.write(""Angstrom\n""); f.write(""%s\n"" % core.get_option('GDMA', 'GDMA_MULTIPOLE_UNITS')); f.write(""Multipoles\n""); if origin:; try:; f.write(""Origin %f %f %f\n"" % (float(origin[0]), float(origin[1]), float(origin[2]))); except IndexError:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % core.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.write(""Limit %d\n"" % core.get_option('GDMA', 'GDMA_LIMIT')); f.write(""Start\n""); f.write(""Finish\n""). # from outside the Psi4 ecosystem; from qcelemental.util import which_import; if not which_import(""gdma"", return_bool=True):; raise ModuleNotFoundError('Python module gdma not found. Solve by installing it: `conda install -c conda-forge gdma` or recompile with `-DENABLE_gdma`'); import gdma. min_version = ""2.3.3""; from qcelemental.util import parse_version; if parse_version(gdma.__version__) < parse_version(min_version):; raise ModuleNotFoundError(f""GDMA version {min_version} is required at least. Version {gdma.__version__} was found.""). core.prepare_options_for_module(""GDMA""). gof = core.get_output_file(); gdma.run_gdma(gof, commands); core.set_output",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:95059,Validat,ValidationError,95059,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"EL (GLOBALS)>` . :examples:. >>> # [1] DMA analysis from MP2 wavefunction. N.B. gradient must be requested to generate MP2 density.; >>> grad, wfn = gradient('mp2', return_wfn=True); >>> gdma(wfn). """"""; # Start by writing a G* checkpoint file, for the GDMA code to read in; fw = core.FCHKWriter(wfn); molname = wfn.molecule().name(); prefix = core.get_writer_file_prefix(molname); fchkfile = prefix + '.fchk'; fw.write(fchkfile). if datafile:; commands = datafile; else:; if wfn.reference_wavefunction():; densname = ""CC""; else:; densname = ""SCF""; commands = 'psi4_dma_datafile.dma'; radii = core.get_option('GDMA', 'GDMA_RADIUS'); origin = core.get_option('GDMA', 'GDMA_ORIGIN'); with open(commands, 'w') as f:; f.write(""File %s Density %s\n"" % (fchkfile, densname)); f.write(""Angstrom\n""); f.write(""%s\n"" % core.get_option('GDMA', 'GDMA_MULTIPOLE_UNITS')); f.write(""Multipoles\n""); if origin:; try:; f.write(""Origin %f %f %f\n"" % (float(origin[0]), float(origin[1]), float(origin[2]))); except IndexError:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % core.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.write(""Limit %d\n"" % core.get_option('GDMA', 'GDMA_LIMIT')); f.write(""Start\n""); f.write(""Finish\n""); core.run_gdma(wfn, commands). os.remove(fchkfile); # If we generated the DMA control file, we should clean up here; if not datafile:; os.remove(commands). [docs]; def fchk(wfn: core.Wavefunction, filename: str, *, debug: bool = False, strict_label: bool = True):; """"""Function to write wavefunction information in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Ga",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:94409,Validat,ValidationError,94409,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"EL (GLOBALS)>` . :examples:. >>> # [1] DMA analysis from MP2 wavefunction. N.B. gradient must be requested to generate MP2 density.; >>> grad, wfn = gradient('mp2', return_wfn=True); >>> gdma(wfn). """"""; # Start by writing a G* checkpoint file, for the GDMA code to read in; fw = core.FCHKWriter(wfn); molname = wfn.molecule().name(); prefix = core.get_writer_file_prefix(molname); fchkfile = prefix + '.fchk'; fw.write(fchkfile). if datafile:; commands = datafile; else:; if wfn.reference_wavefunction():; densname = ""CC""; else:; densname = ""SCF""; commands = 'psi4_dma_datafile.dma'; radii = core.get_option('GDMA', 'GDMA_RADIUS'); origin = core.get_option('GDMA', 'GDMA_ORIGIN'); with open(commands, 'w') as f:; f.write(""File %s Density %s\n"" % (fchkfile, densname)); f.write(""Angstrom\n""); f.write(""%s\n"" % core.get_option('GDMA', 'GDMA_MULTIPOLE_UNITS')); f.write(""Multipoles\n""); if origin:; try:; f.write(""Origin %f %f %f\n"" % (float(origin[0]), float(origin[1]), float(origin[2]))); except IndexError:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % core.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.write(""Limit %d\n"" % core.get_option('GDMA', 'GDMA_LIMIT')); f.write(""Start\n""); f.write(""Finish\n""); core.run_gdma(wfn, commands). os.remove(fchkfile); # If we generated the DMA control file, we should clean up here; if not datafile:; os.remove(commands). [docs]def fchk(wfn: core.Wavefunction, filename: str, *, debug: bool = False, strict_label: bool = True):; """"""Function to write wavefunction information in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaus",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:86256,Validat,ValidationError,86256,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"ENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; dtl = docs_table_link(""dummy"", ""ccenergy""). optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for CCENERGY energy through `run_bccd`. See Capabilities Table at {dtl}""). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:95227,Validat,ValidationError,95227,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"ERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error message ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html:1742,Validat,ValidationError,1742,psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,1,['Validat'],['ValidationError']
Security,"ERENCE') == 'UKS':; PsiMod.set_local_option('SCF', 'REFERENCE', 'UHF'); else:; pass; elif lowername == 'rhf':; PsiMod.set_local_option('SCF', 'REFERENCE', 'RHF'); elif lowername == 'uhf':; PsiMod.set_local_option('SCF', 'REFERENCE', 'UHF'); elif lowername == 'rohf':; PsiMod.set_local_option('SCF', 'REFERENCE', 'ROHF'); elif lowername == 'rscf':; if (len(PsiMod.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'RHF'); elif lowername == 'uscf':; if (len(PsiMod.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'UHF'); elif lowername == 'roscf':; if (len(PsiMod.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'ROHF'). scf_helper(name, **kwargs). optstash.restore(). [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """"""; optstash = OptionsState(; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). if (PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF' or PsiMod.get_option('SCF', 'SCF_TYPE') == 'DIRECT'):. # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationEr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:12298,Validat,ValidationError,12298,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"ERENCE') == 'UKS':; PsiMod.set_local_option('SCF', 'REFERENCE', 'UHF'); else:; pass; elif lowername == 'rhf':; PsiMod.set_local_option('SCF', 'REFERENCE', 'RHF'); elif lowername == 'uhf':; PsiMod.set_local_option('SCF', 'REFERENCE', 'UHF'); elif lowername == 'rohf':; PsiMod.set_local_option('SCF', 'REFERENCE', 'ROHF'); elif lowername == 'rscf':; if (len(PsiMod.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'RHF'); elif lowername == 'uscf':; if (len(PsiMod.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'UHF'); elif lowername == 'roscf':; if (len(PsiMod.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'ROHF'); ; if 'brokensymmetry' in kwargs:; molecule = PsiMod.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if PsiMod.get_option('SCF','REFERENCE') != 'UHF' and lowername != 'UHF':; raise ValidationError('You must specify ""set reference uhf"" to use broken symmetry.'); molecule.set_multiplicity(3); PsiMod.print_out(""\n\n\tComputing high-spin triplet guess\n\n""); scf_helper(name, **kwargs); molecule.set_multiplicity(1); PsiMod.set_local_option('SCF', 'GUESS', 'READ'); PsiMod.print_out(""\n\n\tComputing broken symmetry solution from high-spin triplet guess\n\n""); ; returnvalue = scf_helper(name, **kwargs); ; optstash.restore(); return returnvalue. [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """"""; optstash = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:3489,Validat,ValidationError,3489,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"ERGY'). PsiMod.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; PsiMod.set_variable('DFT TOTAL ENERGY', returnvalue); PsiMod.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). user_ref = PsiMod.get_option('DETCI', 'REFERENCE'); if (user_ref != 'RHF') or (user_ref != 'ROHF'):; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if (name.lower() == 'zapt'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); PsiMod.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; PsiMod.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:37833,Validat,ValidationError,37833,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int Q); Accessing integrals; Derivative Integrals; Changes to External Potential Engines; New Operators Available; Shell Pairs; One Electron Integral Algorithm Overview. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Integrals in PSI4. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/prog_integrals.html:19030,Access,Accessing,19030,psi4manual/1.8.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/prog_integrals.html,1,['Access'],['Accessing']
Security,"Electron Integral Algorithm Overview¶; The following table summarizes which implementation is used; for each type of one electron integral in PSI4. Algorithms used for One Electron Integrals¶. Integral; Class; Implementation; Comment. Three-Center Overlap; ThreeCenterOverlapInt; Libint2; using libint2::Operator::delta for 4-center integrals. Angular Momentum; AngularMomentumInt; M-D. Dipole; DipoleInt; Libint2; no derivatives supported. Electric Field; ElectricFieldInt; Libint2; using first derivative of libint2::Operator::nuclear. Coulomb Potential; ElectrostaticInt; Libint2; evaluated for a single origin and unity charge. Kinetic; KineticInt; Libint2. Multipole Potential; MultipolePotentialInt; M-D; arbitrary order derivative of 1/R supported. Multipole Moments; MultipoleInt; M-D; arbitrary order multipoles supported, including nuclear gradients. Nabla Operator; NablaInt; Libint2; using first derivative of libint2::Operator::overlap. Overlap; OverlapInt; Libint2. Nuclear Coulomb Potential; PotentialInt; Libint2; assumes nuclear centers/charges as the potential. PCM Potential; PCMPotentialInt; Libint2; parallelized over charge points. Quadrupole; QuadrupoleInt; Libint2. Traceless Quadrupole; TracelessQuadrupoleInt; Libint2. Relativistic Potential; RelPotentialInt; Libint2. table of contents. Integrals in PSI4; Introduction; The older style; The new syntax; Sieving; Buffer address; Density Screening; Shell blocking; Permutational symmetry; Using bra-ket symmetry; Instantiating integral objects. One Electron Integrals in PSI4; Calling compute_shell(int P, int Q); Accessing integrals; Derivative Integrals; Changes to External Potential Engines; New Operators Available; Shell Pairs; One Electron Integral Algorithm Overview. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Integrals in PSI4. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/prog_integrals.html:19030,Access,Accessing,19030,psi4manual/1.9.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/prog_integrals.html,1,['Access'],['Accessing']
Security,EmpericalDispersion; energy; energy; fchk; fchk; fcidump; fcidump; fcidump_from_file; fcidump_from_file; filter_comments; filter_comments; find_approximate_string_matches; find_approximate_string_matches; freq; freq; frequencies; frequencies; frequency; frequency; gdma; gdma; geometry; geometry; get_memory; get_memory; getFromDict; gradient; gradient; hessian; hessian; join_path; join_path; levenshtein; levenshtein; ManagedMethodError; molden; molden; driver.molecule_from_arrays; driver.molecule_from_arrays; driver.molecule_from_schema; driver.molecule_from_schema; driver.molecule_from_string; driver.molecule_from_string; molecule_get_attr; molecule_get_attr; molecule_set_attr; molecule_set_attr; oeprop; oeprop; opt; opt; OptimizationConvergenceError; optimize; optimize; ParsingError; PastureRequiredError; pcm_helper; pcm_helper; print_stderr; print_stderr; print_stdout; print_stdout; process_input; process_input; process_pubchem_command; process_pubchem_command; prop; prop; properties; properties; PsiException; PsiImportError; QMMM; sanitize_name; sanitize_name; scf_helper; scf_helper; scf_wavefunction_factory; scf_wavefunction_factory; set_memory; set_memory; set_module_options; set_module_options; set_options; set_options; success; success; Table; TestComparisonError; ValidationError; vibanal_wfn; vibanal_wfn; write_eigenvalues; write_eigenvalues; xml2dict; xml2dict. Appendices; Appendices. /autodir_options_c; ; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:423879,Validat,ValidationError,423879,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['Validat'],['ValidationError']
Security,EmpericalDispersion; energy; energy; fchk; fchk; fcidump; fcidump; fcidump_from_file; fcidump_from_file; filter_comments; filter_comments; find_approximate_string_matches; find_approximate_string_matches; freq; freq; frequencies; frequencies; frequency; frequency; gdma; gdma; geometry; geometry; get_memory; get_memory; getFromDict; gradient; gradient; hessian; hessian; join_path; join_path; levenshtein; levenshtein; ManagedMethodError; molden; molden; driver.molecule_from_arrays; driver.molecule_from_arrays; driver.molecule_from_schema; driver.molecule_from_schema; driver.molecule_from_string; driver.molecule_from_string; molecule_get_attr; molecule_get_attr; molecule_set_attr; molecule_set_attr; oeprop; oeprop; opt; opt; OptimizationConvergenceError; optimize; optimize; ParsingError; PastureRequiredError; pcm_helper; pcm_helper; print_stderr; print_stderr; print_stdout; print_stdout; process_input; process_input; process_pubchem_command; process_pubchem_command; prop; prop; properties; properties; PsiException; PsiImportError; QMMM; sanitize_name; sanitize_name; scf_helper; scf_helper; scf_wavefunction_factory; scf_wavefunction_factory; set_memory; set_memory; set_module_options; set_module_options; set_options; set_options; success; success; Table; TestComparisonError; ValidationError; vibanal_wfn; vibanal_wfn; write_eigenvalues; write_eigenvalues; xml2dict; xml2dict. Appendices; Appendices. autodir_options_c; ; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:381384,Validat,ValidationError,381384,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['Validat'],['ValidationError']
Security,"F option read in DFMP2; PsiMod.set_global_option('SCF_TYPE', 'DF'). if not PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 gradients need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). PsiMod.print_out('\n'); banner('DFMP2'); PsiMod.print_out('\n'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). PsiMod.dfmp2grad(); e_dfmp2 = PsiMod.get_variable('MP2 TOTAL ENERGY'); e_scs_dfmp2 = PsiMod.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-DFMP2') or (name.upper() == 'SCS-DF-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:20599,Validat,ValidationError,20599,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"F', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:32670,Validat,ValidationError,32670,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"F', 'DF_BASIS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:43011,Validat,ValidationError,43011,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"F', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). # Clearly, add some logic when the reach of this fn expands; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerica",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:82788,Validat,ValidationError,82788,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"F', 'SCF_TYPE', 'DF'). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf(name, **kwargs); returnvalue = PsiMod.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; PsiMod.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); PsiMod.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); PsiMod.dfmp2(); vdh = dfun.c_alpha() * PsiMod.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; PsiMod.dfmp2(); vdh = dfun.c_alpha() * PsiMod.get_variable('MP2 CORRELATION ENERGY'). PsiMod.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; PsiMod.set_variable('DFT TOTAL ENERGY', returnvalue); PsiMod.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:36447,Validat,ValidationError,36447,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"F-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC gradient""). # throw exception for CONV (approximately); if (corl_type := method_algorithm_type(name).now) not in [""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for DFOCC gradient. See Capabilities Table at {dtl}""). proc_util.check_disk_df(name.upper(), optstash). # throw exception for SCF_TYPE; if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:68023,Validat,ValidationError,68023,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"F.initialize_jk = initialize_jk; core.HF.iterations = scf_iterate; core.HF.compute_energy = scf_compute_energy; core.HF.finalize_energy = scf_finalize_energy; core.HF.print_energies = scf_print_energies. def _converged(e_delta, d_rms, e_conv=None, d_conv=None):; if e_conv is None:; e_conv = core.get_option(""SCF"", ""E_CONVERGENCE""); if d_conv is None:; d_conv = core.get_option(""SCF"", ""D_CONVERGENCE""). return (abs(e_delta) < e_conv and d_rms < d_conv). def _validate_damping():; """"""Sanity-checks DAMPING control options. Raises; ------; ValidationError; If any of |scf__damping_percentage|, |scf__damping_convergence|; don't play well together. Returns; -------; bool; Whether DAMPING is enabled during scf. """"""; # Q: I changed the enabled criterion get_option <-- has_option_changed; enabled = (core.get_option('SCF', 'DAMPING_PERCENTAGE') > 0.0); if enabled:; parameter = core.get_option('SCF', ""DAMPING_PERCENTAGE""); if parameter < 0.0 or parameter > 100.0:; raise ValidationError('SCF DAMPING_PERCENTAGE ({}) must be between 0 and 100'.format(parameter)). stop = core.get_option('SCF', 'DAMPING_CONVERGENCE'); if stop < 0.0:; raise ValidationError('SCF DAMPING_CONVERGENCE ({}) must be > 0'.format(stop)). return enabled. def _validate_diis():; """"""Sanity-checks DIIS control options. Raises; ------; ValidationError; If any of |scf__diis|, |scf__diis_start|,; |scf__diis_min_vecs|, |scf__diis_max_vecs| don't play well together. Returns; -------; bool; Whether DIIS is enabled during scf. """"""; enabled = bool(core.get_option('SCF', 'DIIS')); if enabled:; start = core.get_option('SCF', 'DIIS_START'); if start < 1:; raise ValidationError('SCF DIIS_START ({}) must be at least 1'.format(start)). minvecs = core.get_option('SCF', 'DIIS_MIN_VECS'); if minvecs < 1:; raise ValidationError('SCF DIIS_MIN_VECS ({}) must be at least 1'.format(minvecs)). maxvecs = core.get_option('SCF', 'DIIS_MAX_VECS'); if maxvecs < minvecs:; raise ValidationError(; 'SCF DIIS_MAX_VECS ({}) must be at least DIIS_MIN_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:23277,Validat,ValidationError,23277,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,F/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:32882,Validat,ValidationError,32882,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; modul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:1799,Validat,ValidationError,1799,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). core.set_local_option('FNOCC', 'DFCC', True); core.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_global_option('SCF_TYPE') not in ['CD', 'DISK_DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenfl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:119611,Validat,ValidationError,119611,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"FT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'ROHF'). scf_helper(name, **kwargs). optstash.restore(). [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """"""; optstash = OptionsState(; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). if (PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF' or PsiMod.get_option('SCF', 'SCF_TYPE') == 'DIRECT'):. # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\n No DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). PsiMod.scfgrad(). else:; PsiMod.deriv(). optstash.restore(). [docs]def run_libfock(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. """"""; if (name.lower() == 'cphf'):; PsiMod.set_global_option('MODULE', 'RCPHF'); if (name.lower() == 'cis'):; PsiMod.set_global_option('MODULE', 'RCIS'); if (name.lower() == 'tdhf'):; PsiMod.set_global_option('MODULE', 'RTDHF'); if (name.lower() == 'cpks'):; PsiMod.set_global_option('MODULE', 'RCPKS'); if (name.lower() == 'tda'):; PsiMod.set_global_option('MODULE', 'RTDA'); if (name.lower() == 'tddft'):; PsiMod.set_global_option('MODULE', 'RTDDFT'). PsiMod.libfock(). [docs]def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; return PsiMod.mcscf(). [docs]def scf_helper(name, **kwargs)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:13283,Validat,ValidationError,13283,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:128317,Validat,ValidationError,128317,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn); else:; scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:122760,Validat,ValidationError,122760,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). reference = core.get_option('SCF', 'REFERENCE'); if core.get_global_option('CC_TYPE') != ""CONV"":; raise ValidationError(""""""CEPA methods from FNOCC module require 'cc_type conv'.""""""). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:162173,Validat,ValidationError,162173,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). reference = core.get_option('SCF', 'REFERENCE'); if core.get_global_option('CC_TYPE') != ""CONV"":; raise ValidationError(""""""CEPA methods from FNOCC module require 'cc_type conv'.""""""). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:170784,Validat,ValidationError,170784,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; psi4.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; psi4.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). psi4.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; psi4.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). fnocc_wfn = psi4.fnocc(ref_wfn). # one-electron properties; if psi4.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; psi4.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif psi4.get_option('FNOCC', 'NAT_ORBS'):; psi4.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). optstash.restore(); return fnocc_wfn. [docs]def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multire",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:106498,Validat,ValidationError,106498,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:7218,Validat,ValidationError,7218,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"False, size='small') # comment for quick nolabel, whiteback; axt.xaxis.set_tick_params(width=0, length=0); axt.yaxis.set_tick_params(width=0, length=0); #axt.set_title('%s' % (title), fontsize=16, verticalalignment='bottom'); #axt.text(10.0, -1.5, title, horizontalalignment='center', fontsize=16). # nill spacing between 20x20 heatmaps; plt.subplots_adjust(hspace=0.001, wspace=0.001). index = 1; for aa1 in aa:; for aa2 in aa:; cb = composition_tile(err, aa1, aa2). ax = matplotlib.axes.Subplot(fig, len(aa), len(aa), index); fig.add_subplot(ax); heatmap = ax.pcolor(cb, vmin=-xlimit, vmax=xlimit, cmap=plt.cm.PRGn); ax.set_xticks([]); ax.set_yticks([]); index += 1. #plt.title(title); axt.axvline(x=4.8, linewidth=5, color='k'); axt.axvline(x=8.75, linewidth=5, color='k'); axt.axvline(x=11.6, linewidth=5, color='k'); axt.axhline(y=4.8, linewidth=5, color='k'); axt.axhline(y=8.75, linewidth=5, color='k'); axt.axhline(y=11.6, linewidth=5, color='k'); axt.set_zorder(100). # save and show; pltuid = title + '_' + hashlib.sha1(title + str(xlimit)).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='iowa_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); #plt.savefig(savefile, transparent=False, format=ext, bbox_inches='tight') # for quick nolabel, whiteback; files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. [docs]def liliowa(mcdat, title='', xlimit=2.0, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with a heatmap representation of *mcdat*. """"""; import numpy as np; import hashlib; import matplotlib; import matplotlib.pyplot as plt. # handle for frame, overall axis; fig, axt = plt.subplots(figsize=(1, 1)). axt.set_xticks([]); axt.set_yticks([]); axt.invert_yaxis(); axt.xaxis.set_tick_params(width=0, length=0); axt.yaxis.set_tick_params(width=0, length=0); axt.set_a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:32845,hash,hashlib,32845,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,"Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:; return_wfn (bool) – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. Return type:; Union[float, Matrix, Tuple[Union[float, Matrix], Wavefunction]]. Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. get_results(client=None)[source]¶; Return results as FiniteDifference",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/freq.html:9547,Validat,Validated,9547,psi4manual/1.7.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/freq.html,1,['Validat'],['Validated']
Security,"Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (qcportal.FractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None) – . Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/freq.html:9549,Validat,Validated,9549,psi4manual/1.8.x/freq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/freq.html,2,['Validat'],['Validated']
Security,"Findifrec"",; ""default"": {},; ""type"": ""object""; },; ""method"": {; ""title"": ""Method"",; ""type"": ""string""; }; },; ""required"": [; ""driver"",; ""method""; ],; ""definitions"": {; ""DriverEnum"": {; ""title"": ""DriverEnum"",; ""description"": ""Allowed computation driver values."",; ""enum"": [; ""energy"",; ""gradient"",; ""hessian"",; ""properties""; ],; ""type"": ""string""; },; ""BaseComputer"": {; ""title"": ""BaseComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {}; }; }; }. Fields:. driver (qcelemental.models.common_models.DriverEnum); findifrec (Dict[str, Any]); metameta (Dict[str, Any]); method (str); molecule (Any); task_list (Dict[str, psi4.driver.task_base.BaseComputer]). Validators:. set_driver » driver; set_molecule » molecule. field driver: DriverEnum [Required]¶. Validated by:. set_driver. field findifrec: Dict[str, Any] = {}¶. field metameta: Dict[str, Any] = {}¶. field method: str [Required]¶. field molecule: Any = None¶. Validated by:. set_molecule. field task_list: Dict[str, BaseComputer] = {}¶. computer¶; alias of AtomicComputer. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶; Run each job in task list. Parameters:; client (qcportal.FractalClient | None). get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None). Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[sou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:9556,Validat,Validated,9556,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,1,['Validat'],['Validated']
Security,"G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs; i_m; An iterator containing tuples. Each tuple has the index of a salc in; salc_list and the number of steps (positive or negative) to displace; the salc at that index.; step_size; The size of a single ""step,"" i.e., the stencil siz",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:4842,Validat,ValidationError,4842,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,1,['Validat'],['ValidationError']
Security,"GA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/opt-1.html:7383,access,accesses,7383,psi4manual/4.0b3/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html,2,['access'],['accesses']
Security,"GE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" %; (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:11447,Validat,ValidationError,11447,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,2,['Validat'],['ValidationError']
Security,"GE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (fileAtom)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2mass[fileAtom], el2z[fileAtom]). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)); except IndexError:; raise ValidationError(""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:8749,Validat,ValidationError,8749,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,2,['Validat'],['ValidationError']
Security,"GE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.match(text[4 + i]):. fileX = float(xyzM.match(text[4 + i]).group(1)); fileY = float(xyzM.match(text[4 + i]).group(2)); fileZ = float(xyzM.match(text[4 + i]).group(3)); fileAtom = xyzM.match(text[4 + i]).group(4).upper(). # Check that the atom symbol is valid; z = qcel.periodictable.to_Z(fileAtom). # Add it to the molecule.; instance.add_atom(z, fileX, fileY, fileZ, fileAtom, qcel.periodictable.to_mass(fileAtom), z). else:; raise ValidationError(""Molecule::init_with_mol2: Malformed atom information line %d."" % (i + 5)). except IndexError:; raise ValidationError(; ""Molecule::init_with_mol2: Expected atom in file at line %d.\n%s"" % (i + 5, text[i + 4])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.frag",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:8083,Validat,ValidationError,8083,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,16,['Validat'],['ValidationError']
Security,"H """"; before adding more paths to it. Finally, PSI_SCRATCH should point to a fast,; local disk for temporary file storage. The next step is then to actually run the computation:; /psi/install/directory/bin/psi4 -i input.in -o input.out. And then to clean up the scratch directories previously created:; foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. Note again that the specific commands for your PBS system may differ. Refer; to your system administrator. Command Line Options¶; Psi4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.; The set of three commands below are completely equivalent, while the fourth is,; perhaps, the most common usage.; >>> psi4; >>> psi4 -i input.dat -o output.dat; >>> psi4 input.dat output.dat. >>> psi4 descriptive_filename.in descriptive_filename.out. Command-line arguments to Psi4 can be accessed through psi4 --help. -a, --append¶; Append results to output file. Default: Truncate first. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -h, --help¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. -l <name>, --psidatadir <name>¶; Mainly for use by developers, this overrides the value of; PSIDATADIR and specifies the path to the Psi data; library (psi4/share). -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename (subtracting; any ”.in” or ”.dat” suffix) plus ”.out”. -p <prefix>, --prefi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:13628,access,accessed,13628,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['access'],['accessed']
Security,"H Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings). (First line; for C shell; second line for bash.); setenv PSI_SCRATCH /scratch/user; export PSI_SCRATCH=/scratch/user. The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MKL (Note that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:4815,access,accessible,4815,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,6,['access'],['accessible']
Security,"H to Cartesians and unmasswt. assemble_gradient_from_energies(); ---------------------------------; assemble_dipder_from_dipoles(); ------------------------------. * form DD, G, H from lower derivative points. * place as many of DD, G, H as available onto reference entry. * pull qcvars off reference job; * from reference job, set add'l mol, DD, G, H as available; * form model, including detailed dict at atomicresult.extras[""findif_record""]. * convert result to psi4.core.Matrix. _findif_schema_to_wfn(); -----------------------; * build wfn from findif mol and basis (if singular) and module (if singular); * push qcvars to P::e and wfn. gradient_write(); ----------------; * write .grad file if requested. hessian_write(); ---------------; * write .hess file if requested. * return dd/g/h and wfn. """""". import copy; import logging; from functools import partial; from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union, TYPE_CHECKING. import numpy as np; from pydantic import Field, validator; from qcelemental.models import DriverEnum, AtomicResult; from qcelemental import constants. from psi4 import core; from psi4.driver import p4util, pp, qcdb, nppp10; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). # CONVENTIONS:; # n_ at the start of a variable name is short for ""number of.""; # _pi at the end of a variable name is short for ""per irrep.""; # h is the index of an irrep. def _displace_cart(mass: np.ndarray, geom: np.ndarray, salc_list: core.CdSalcList, i_m: Iterator[Tuple], step_size: float) -> Tuple[np.ndarray, str]:; """"""Displace a geometry along the specified displacement SALCs. Parameters; ----------; mass; (nat, ) masses [u] of atoms of the molecule (const).; geom; (nat, 3) reference geometry [a0] of the molecule (const).; salc_list; A list of Cartesian displacement SALCs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:4624,validat,validator,4624,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,1,['validat'],['validator']
Security,"H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Hessian: Cannot specify bsse_type for hessian yet.""). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. if gradient_type != 'conventional':; raise ValidationError(""Hessian: Does not yet support more advanced input or custom functions.""). lowername = name.lower(). # Check if this is a CBS extrapolation; if ""/"" in lowername:; return driver_cbs._cbs_gufunc('hessian', lowername, **kwargs). return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:65328,Validat,ValidationError,65328,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Hessian: Cannot specify bsse_type for hessian yet.""). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. if gradient_type != 'conventional':; raise ValidationError(""Hessian: Does not yet support more advanced input or custom functions.""). lowername = name.lower(). # Check if this is a CBS extrapolation; if ""/"" in lowername:; return driver_cbs._cbs_gufunc('hessian', lowername, **kwargs). return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['FINDIF', 'FD_PROJECT'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:68100,Validat,ValidationError,68100,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Hessian: Cannot specify bsse_type for hessian yet.""). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = 'conventional'. if gradient_type != 'conventional':; raise ValidationError(""Hessian: Does not yet support more advanced input or custom functions.""). lowername = name.lower(). # Check if this is a CBS extrapolation; if ""/"" in lowername:; return driver_cbs._cbs_gufunc('hessian', lowername, **kwargs). return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); dertype = 2. # Prevent methods that do not have associated energies; if lowername in energy_only_methods:; raise ValidationError(""hessian('%s') does not have an associated hessian"" % name). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:63491,Validat,ValidationError,63491,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"H2 if None. Allows; out-of-order zeta specification (e.g., [qtd]) and numeral for number; (e.g., [23]) but not skipped zetas (e.g., [dq]) or zetas outside [2,; 8] or non-Dunning sets or non-findable .gbs sets. """"""; BSET = []; ZSET = []; legit_compound_basis = re.compile(r'^(?P<pre>.*cc-.*)\[(?P<zeta>[dtq2345678,]*)\](?P<post>.*z)$', re.IGNORECASE). if legit_compound_basis.match(basisstring):; basisname = legit_compound_basis.match(basisstring); # filter out commas and be forgiving of e.g., t5q or 3q; bn_gz = basisname.group('zeta'); zetas = [z for z in zeta_values if (z in bn_gz or str(zeta_values.index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" % (basisstring, b)); BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(""""""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z'."""""" % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n"""""". for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound, e:; raise ValidationError(""""""Basis set '%s' not available for molecule."""""" % (basis)). return (BSET, ZSET). def _contract_bracketed_basis(basisarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets *basisarray* (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]).; Used to print a nicely formatted basis set string in the results table. """"""; if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in xrange(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]. pre = basisarray[0][:zetaindx]; post = basisarray[0][zetaindx + 1:]; basisstring ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:3049,Validat,ValidationError,3049,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"H2 if None. Allows; out-of-order zeta specification (e.g., [qtd]) and numeral for number; (e.g., [23]) but not skipped zetas (e.g., [dq]) or zetas outside [2,; 8] or non-Dunning sets or non-findable .gbs sets. """"""; BSET = []; ZSET = []; legit_compound_basis = re.compile(r'^(?P<pre>.*cc-.*)\[(?P<zeta>[dtq2345678,]*)\](?P<post>.*z)$', re.IGNORECASE). if legit_compound_basis.match(basisstring):; basisname = legit_compound_basis.match(basisstring); # filter out commas and be forgiving of e.g., t5q or 3q; bn_gz = basisname.group('zeta'); zetas = [z for z in zeta_values if (z in bn_gz or str(zeta_values.index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" % (basisstring, b)); BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(""""""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z'."""""" % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n"""""". for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e=sys.exc_info()[1]; raise ValidationError(""""""Basis set '%s' not available for molecule."""""" % (basis)). return (BSET, ZSET). def _contract_bracketed_basis(basisarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets *basisarray* (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]).; Used to print a nicely formatted basis set string in the results table. """"""; if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]. pre = basisarray[0][:zetaindx]; post = basisarray[0][zetaindx + ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:3271,Validat,ValidationError,3271,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"HANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. Only used by untested distributed CC response machinery. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. # PsiImportError ceased to be used by v1.1. Class removed by v1.7; # class PsiImportError(PsiException):. [docs]; class TestComparisonError(PsiException):; """"""Error called when a :func:`~psi4.compare_values` or other comparison; function fails. Error mes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:1748,Validat,ValidationError,1748,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,1,['Validat'],['ValidationError']
Security,"HF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:70534,Validat,ValidationError,70534,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"HF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft1-alt; DFT Functional Test. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and tri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:4510,Access,Accesses,4510,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['Access'],['Accesses']
Security,"HIRD_ORDER', True). # if the df_basis_sapt basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SAPT') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_SAPT', ribasis); PsiMod.print_out('No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'); e_sapt = PsiMod.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:36507,Validat,ValidationError,36507,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"Hess = None. if 'DIPOL' in largs:; dipolDip = harvest_DIPOL(largs['DIPOL']); else:; dipolDip = None. # Reconcile the coordinate information: several cases; # Case p4Mol GRD Check consistency Apply orientation? ReturnMol (1-19-2014); # sp with mol thru cfour {} None None outMol N.C. outMol; # opt with mol thru cfour {} None grdMol outMol && grdMol N.C. grdMol; # sp with mol thru molecule {} p4Mol None p4Mol && outMol p4Mol <-- outMol p4Mol (same as input arg); # opt with mol thru molecule {} p4Mol grdMol p4Mol && outMol && grdMol p4Mol <-- grdMol p4Mol (same as input arg). if outMol:; if grdMol:; if abs(outMol.nuclear_repulsion_energy() - grdMol.nuclear_repulsion_energy()) > 1.0e-3:; raise ValidationError(""""""Cfour outfile (NRE: %f) inconsistent with Cfour GRD (NRE: %f)."""""" % \; (outMol.nuclear_repulsion_energy(), grdMol.nuclear_repulsion_energy())); if p4Mol:; if abs(outMol.nuclear_repulsion_energy() - p4Mol.nuclear_repulsion_energy()) > 1.0e-3:; raise ValidationError(""""""Cfour outfile (NRE: %f) inconsistent with Psi4 input (NRE: %f)."""""" % \; (outMol.nuclear_repulsion_energy(), p4Mol.nuclear_repulsion_energy())); else:; raise ValidationError(""""""No coordinate information extracted from Cfour output.""""""). # print ' <<< [1] P4-MOL >>>'; # if p4Mol:; # p4Mol.print_out_in_bohr(); # print ' <<< [2] C4-OUT-MOL >>>'; # if outMol:; # outMol.print_out_in_bohr(); # print ' <<< [3] C4-GRD-MOL >>>'; # if grdMol:; # grdMol.print_out_in_bohr(). # Set up array reorientation object; if p4Mol and grdMol:; p4c4 = OrientMols(p4Mol, grdMol); oriCoord = p4c4.transform_coordinates2(grdMol); oriGrad = p4c4.transform_gradient(grdGrad); oriDip = None if dipolDip is None else p4c4.transform_vector(dipolDip); elif p4Mol and outMol:; p4c4 = OrientMols(p4Mol, outMol); oriCoord = p4c4.transform_coordinates2(outMol); oriGrad = None; oriDip = None if dipolDip is None else p4c4.transform_vector(dipolDip); elif outMol:; oriCoord = None; oriGrad = None; oriDip = None if dipolDip is None else dipolDip. # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html:21950,Validat,ValidationError,21950,psi4manual/1.0.0/_modules/qcdb/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/cfour.html,1,['Validat'],['ValidationError']
Security,"ING !!!!!\n"" +; ""\t\tThe built-in ADC(2) method may give incorrect results if\n""; ""\t\tmultiple roots are requested, due to an error in the Davidson solver,\n""; ""\t\tand is no longer maintained. It is slated for removal in Psi4 1.7.\n""; ""\t\tUse of the Psi interface to `adcc` instead is strongly recommended.\n""). core.print_out(error_msg). wfn = core.adc(ref_wfn). core.print_out(error_msg). return wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < 0:; kwargs[""conv_tol""] = max(100 * scf_accuracy, 1e-6); else:; kwargs[""conv_tol""] = core.get_option(""ADC"", ""R_CONVERGENCE""). n_roots = core.get_option('ADC', 'ROOTS_PER_IRREP'); if len(n_roots) > 1:; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:113275,Validat,ValidationError,113275,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"IS_GUESS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, (unicode, str)):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(""""""Stability analysis root following is only available for UHF""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If GUESS is auto guess what it should be; if core.get_option('S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:32126,Validat,ValidationError,32126,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath; sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'); user_reference = psi4.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:9841,Validat,ValidationError,9841,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"If False, interpret elbl as only the user/tagging; extension to nucleus label, e.g. _mine or 4 in the previous examples.; missing_enabled_return (str) – {‘minimal’, ‘none’, ‘error’}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out (bool) – When True, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use False to get a json-able version. Returns. molrec (dict) – Molecule dictionary spec follows. Its principles are; (1) contents are fully validated and defaulted - no error; checking necessary,; (2) contents may be mildly redundant - atomic numbers and; element symbols present,; (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,; (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present.; (5) apart from some mild optional fields, _all_ fields will; be present (corollary of “fully validated and defaulted”) - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec.; (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name (str, optional) – Label for molecule; should be valid Python identifier.; units ({‘Angstrom’, ‘Bohr’}) – Units for geom.; input_units_to_au (float, optional) – If units=’Angstrom’, overrides consumer’s value for [A]–>[a0] conversion.; fix_com (bool) – Whether translation of geom is allowed or disallowed.; fix_orientation (bool) – Whether rotation of geom is allowed or disallowed.; fix_symmetry (str, optional) – Maximal point group symmet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:7388,validat,validated,7388,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,5,['validat'],['validated']
Security,"KFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc51; EOM-CC3/cc-pVTZ on H2O. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. nbo; Generation of NBO file. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. pywrap-freq-e-sow",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:36147,Access,Accesses,36147,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['Access'],['Accesses']
Security,"L ENERGY'); e_scs_dfmp2 = psi4.get_variable('SCS-MP2 TOTAL ENERGY'). optstash.restore(). if (name.upper() == 'SCS-MP2'):; return e_scs_dfmp2; elif (name.upper() == 'DF-MP2') or (name.upper() == 'DFMP2') or (name.upper() == 'MP2'):; return e_dfmp2. [docs]def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if (name.lower() == 'eom-ccsd'):; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); run_ccenergy('ccsd', **kwargs); elif (name.lower() == 'eom-cc2'):. user_ref = psi4.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for EOM-CC2 is not available.' % user_ref). psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CC2'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CC2'); run_ccenergy('cc2', **kwargs); elif (name.lower() == 'eom-cc3'):; psi4.set_local_option('TRANSQT2', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCSORT', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCENERGY', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCHBAR', 'WFN', 'EOM_CC3'); psi4.set_local_option('CCEOM', 'WFN', 'EOM_CC3'); run_ccenergy('cc3', **kwargs). psi4.cchbar(); psi4.cceom(). optstash.restore(). [docs]def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; optstash = p4util.OptionsState(; ['CCDENSITY', 'XI'],; ['CCDENSITY', 'ZETA'],; ['CCLAMBDA', 'ZETA'],; ['DE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:35154,Validat,ValidationError,35154,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"L')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'RHF'); elif lowername == 'uscf':; if (len(PsiMod.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'UHF'); elif lowername == 'roscf':; if (len(PsiMod.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or PsiMod.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; raise ValidationError('ROHF reference for DFT is not available.'); else:; PsiMod.set_local_option('SCF', 'REFERENCE', 'ROHF'); ; if 'brokensymmetry' in kwargs:; molecule = PsiMod.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if PsiMod.get_option('SCF','REFERENCE') != 'UHF' and lowername != 'UHF':; raise ValidationError('You must specify ""set reference uhf"" to use broken symmetry.'); molecule.set_multiplicity(3); PsiMod.print_out(""\n\n\tComputing high-spin triplet guess\n\n""); scf_helper(name, **kwargs); molecule.set_multiplicity(1); PsiMod.set_local_option('SCF', 'GUESS', 'READ'); PsiMod.print_out(""\n\n\tComputing broken symmetry solution from high-spin triplet guess\n\n""); ; returnvalue = scf_helper(name, **kwargs); ; optstash.restore(); return returnvalue. [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """"""; optstash = OptionsState(; ['DF_BASIS_SCF']). returnvalue = run_scf(name, **kwargs). if (PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF'):. # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:3878,Validat,ValidationError,3878,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"LE_LABEL (GLOBALS)>` . :examples:. >>> # [1] DMA analysis from MP2 wavefunction. N.B. gradient must be requested to generate MP2 density.; >>> grad, wfn = gradient('mp2', return_wfn=True); >>> gdma(wfn). """"""; # Start by writing a G* checkpoint file, for the GDMA code to read in; fw = core.FCHKWriter(wfn); molname = wfn.molecule().name(); prefix = core.get_writer_file_prefix(molname); fchkfile = prefix + '.fchk'; fw.write(fchkfile). if datafile:; commands = datafile; else:; if wfn.reference_wavefunction():; densname = ""CC""; else:; densname = ""SCF""; commands = 'psi4_dma_datafile.dma'; radii = core.get_option('GDMA', 'GDMA_RADIUS'); origin = core.get_option('GDMA', 'GDMA_ORIGIN'); with open(commands, 'w') as f:; f.write(""File %s Density %s\n"" % (fchkfile, densname)); f.write(""Angstrom\n""); f.write(""%s\n"" % core.get_option('GDMA', 'GDMA_MULTIPOLE_UNITS')); f.write(""Multipoles\n""); if origin:; try:; f.write(""Origin %f %f %f\n"" % (float(origin[0]), float(origin[1]), float(origin[2]))); except:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % core.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.write(""Limit %d\n"" % core.get_option('GDMA', 'GDMA_LIMIT')); f.write(""Start\n""); f.write(""Finish\n""); core.run_gdma(wfn, commands). os.remove(fchkfile); # If we generated the DMA control file, we should clean up here; if not datafile:; os.remove(commands). [docs]def fchk(wfn: core.Wavefunction, filename: str, *, debug: bool = False, strict_label: bool = True):; """"""Function to write wavefunction information in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate fchk file. :param filename: destination file name for FCHK file. :param debug: returns a dictionary to aid with debugging. :param strict_label: If true set a density label compliant with what Gaussian w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:93050,Validat,ValidationError,93050,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"L_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_MAXITER', False); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_occ(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; # Stash these options so we can reload them at computation end.; optstash = p4util.OptionsState(; ['OCC', 'SPIN_SCALE_TYPE'],; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE']). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCS"", },; ""scs(n)-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSN"", },; ""scs-mp2-vdw"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSVDW"",},; ""sos-mp2"": ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:73545,Validat,ValidationError,73545,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"Label)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:19567,Validat,ValidationError,19567,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = core.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; core.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.procrouting.interface_cfour. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/procrouting/interface_cfour.html:17453,Validat,ValidationError,17453,psi4manual/master/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/procrouting/interface_cfour.html,1,['Validat'],['ValidationError']
Security,"Lori A. Burns; Section author: Lori A. Burns. psi4.driver.wrapper_database.database(name, db_name[, func, mode, cp, rlxd, symm, zpe, benchmark, tabulate, subset])[source]¶; Function to access the molecule objects and reference energies of; popular chemical databases. Aliases:db(). Returns:(float) Mean absolute deviation of the database in kcal/mol. PSI variables:. db_name DATABASE MEAN SIGNED DEVIATION; db_name DATABASE MEAN ABSOLUTE DEVIATION; db_name DATABASE ROOT-MEAN-SQUARE DEVIATION; Python dictionaries of results accessible as DB_RGT and DB_RXN. Note; It is very easy to make a database from a collection of xyz files; using the script psi4/share/scripts/ixyz2database.py.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – \(\Rightarrow\) energy \(\Leftarrow\) || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; key",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/db-1.html:1100,access,access,1100,psi4manual/1.1.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/db-1.html,6,['access'],['access']
Security,"MP2.5 cc-pVDZ gradient for the H2O molecule. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. scf6; Tests RHF/ROHF/UHF SCF gradients. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. mints15; check SP basis Fortran exponent parsing. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. extern4; External potential calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to validate the gradient on the charges. cdoremp-energy1; Cholesky decomposed OO-REMP/cc-pVDZ energy for the H2O molecule. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mbis-6; MBIS calculation on H2O. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-ste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:42192,validat,validate,42192,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set (pre-Spring 2021)¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replaceme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/manage_release-1.html:11837,hash,hash,11837,psi4manual/1.5.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/manage_release-1.html,5,['hash'],['hash']
Security,"Mod.get_option('DF_BASIS_MP2'); #user_df_basis_cc = PsiMod.get_option('DF_BASIS_CC'); #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_global_option('WFN'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:66479,Validat,ValidationError,66479,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"N FROM qcel.molparse.from_arrays(domain={})"".format(domain.upper())); pprint.pprint(molinit). if not np_out:; molinit = unnp(molinit). return molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:12940,Validat,ValidationError,12940,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"NCE. For a; list of applicable keywords, see source of; qcdb.cfour.muster_psi4options().; Consult Functionality for information on what Cfour; functionality is accessible through PSI4. PSI4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a PSI4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into PSI4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the PSI4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in PSI4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a PSI4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:3695,access,accessible,3695,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['access'],['accessible']
Security,"NDIF', 'HESSIAN_WRITE'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(""""""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:66422,Validat,ValidationError,66422,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"NDIF', 'HESSIAN_WRITE'],; ). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. dertype = _find_derivative_type('hessian', lowername, kwargs.pop('freq_dertype', kwargs.pop('dertype', None))). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference freq run in one job or files farmed out; freq_mode = kwargs.pop('mode', 'continuous').lower(); if freq_mode == 'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0. # Does an analytic procedure exist for the requested method?; if dertype == 2:; psi4.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; psi4.set_variable('CURRENT ENERGY', wfn.energy()). if return_wfn:; return (wfn.hessia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:64585,Validat,ValidationError,64585,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"NERGY', core.variable('SCS-MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; core.set_variable('CURRENT ENERGY', core.variable('MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.variable('MP2 CORRELATION ENERGY')). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:94096,Validat,ValidationError,94096,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"NV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_wavefunction_factory(name, ref_wfn, reference):; """"""Builds the correct wavefunction from the provided information; """""". if core.has_option_changed(""SCF"", ""DFT_DISPERSION_PARAMETERS""):; modified_disp_params = core.get_option(""SCF"", ""DFT_DISPERSION_PARAMETERS""); else:; modified_disp_params = None. # Figure out functional; superfunc, disp_type = dft_funcs.build_superfunctional(name, (reference in [""RKS"", ""RHF""])). # Build the wavefunction; core.prepare_options_for_module(""SCF""); if reference in [""RHF"", ""RKS""]:; wfn = core.RHF(ref_wfn, superfunc); elif reference == ""ROHF"":; wfn = core.ROHF(ref_wfn, superfunc); elif reference in [""UHF"", ""UKS""]:; wfn = core.UHF(ref_wfn, superfunc); elif reference == ""CUHF"":; wfn = core.CUHF(ref_wfn, superfunc); else:; raise V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:25825,access,access,25825,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['access'],['access']
Security,"NV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_wavefunction_factory(name, ref_wfn, reference, **kwargs):; """"""Builds the correct (R/U/RO/CU HF/KS) wavefunction from the; provided information, sets relevant auxiliary basis sets on it,; and prepares any empirical dispersion. """"""; if core.has_option_changed(""SCF"", ""DFT_DISPERSION_PARAMETERS""):; modified_disp_params = core.get_option(""SCF"", ""DFT_DISPERSION_PARAMETERS""); else:; modified_disp_params = None. # Figure out functional; superfunc, disp_type = dft.build_superfunctional(name, (reference in [""RKS"", ""RHF""])). # Build the wavefunction; core.prepare_options_for_module(""SCF""); if reference in [""RHF"", ""RKS""]:; wfn = core.RHF(ref_wfn, superfunc); elif reference == ""ROHF"":; wfn = core.ROHF(ref_wfn, superfunc); elif reference in [""UHF"", ""UKS""]:; wfn = cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:25747,access,access,25747,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['access'],['access']
Security,"NV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_wavefunction_factory(reference, ref_wfn, functional=None):; """"""Builds the correct wavefunction from the provided information; """""". if core.has_option_changed(""SCF"", ""DFT_DISPERSION_PARAMETERS""):; modified_disp_params = core.get_option(""SCF"", ""DFT_DISPERSION_PARAMETERS""); else:; modified_disp_params = None. # Figure out functional; if functional is None:; superfunc, disp_type = dft_functional.build_superfunctional(core.get_option(""SCF"", ""DFT_FUNCTIONAL"")); elif isinstance(functional, core.SuperFunctional):; superfunc = functional; disp_type = False; elif isinstance(functional, (str, unicode)):; superfunc, disp_type = dft_functional.build_superfunctional(functional); else:; raise ValidationError(""Functional %s is not understood"" % str(functional)). # Buil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:25683,access,access,25683,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['access'],['access']
Security,"NV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited state energy; call and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only adcc/adc. # TODO Actually one should do selection on a couple of other options here; # as well, e.g. adcc supports frozen-core and frozen-virtual,; # spin-specific states or spin-flip methods.; # But as far as I (mfherbst) know the BUILTIN ADC routine only supports; # singlet states and without freezing some core or some virtual orbitals. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'ADCC' and extras.addons(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:29312,access,access,29312,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['access'],['access']
Security,"NV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited state energy; call and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only adcc/adc. # TODO Actually one should do selection on a couple of other options here; # as well, e.g. adcc supports frozen-core and frozen-virtual,; # spin-specific states or spin-flip methods.; # But as far as I (mfherbst) know the BUILTIN ADC routine only supports; # singlet states and without freezing some core or some virtual orbitals. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in {'ADCC', ''} and extras.a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:30152,access,access,30152,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['access'],['access']
Security,"None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. molecule = ref_wfn.molecule(). # The DF case; if psi4.get_option('DETCI', 'MCSCF_TYPE') == 'DF':. # Do NOT set global options in general, this is a bit of a hack; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'). # The non-DF case; else:; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). # Second-order SCF requires non-symmetric density matrix support; if psi4.get_option('DETCI', 'MCSCF_SO'):; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = psi4.detci(ref_wfn). # We always would like to print a little dipole information; oeprop = psi4.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); psi4.set_variable(""CURRENT DIPOLE X"", psi4.get_variable(name.upper() + "" DIPOLE X"")); psi4.set_variable(""CURRENT DIPOLE Y"", psi4.get_variable(name.upper() + "" DIPOLE Y"")); psi4.set_variable(""CURRENT DIPOLE Z"", psi4.get_variable(name.upper() + "" DIPOLE Z"")). optstash.restore(); return ciwfn. [docs]def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """"""; # initialize library; efp = psi4.get_active_efp(). if efp.nfragments() == 0:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # set options; psi4.set_global_option('QMEFP', False) # apt to go haywire if set locally to efp; psi4.efp_set_options(). efp.print_out(); returnvalue = efp.compute(); return returnvalue. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:109508,Validat,ValidationError,109508,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"None¶; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str¶; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]¶; Exports coordinate info into NumPy arrays. Parameters:; dummy (bool, optional) – Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool, optional) – Whether or not to treat ghost atoms as dummies. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]¶; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]¶; Serializes instance into dictionary according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12)[source]¶; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule) → str¶; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html:35170,hash,hash,35170,psi4manual/1.3.2/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.molecule.html,3,['hash'],['hash']
Security,"Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs] def build_tasks(self, mb_computer: SubTaskComputers, mc_level_idx: int, **kwargs: Dict[str, Any]) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model che",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:34810,validat,validator,34810,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"O density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. Command Line Options¶; PSI4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.; The set of three commands below are completely equivalent, while the fourth is,; perhaps, the most common usage.; psi4; psi4 -i input.dat -o output.dat; psi4 input.dat output.dat. psi4 descriptive_filename.in descriptive_filename.out. Command-line arguments to PSI4 can be accessed through psi4 --help. -a, --append¶; Append results to output file. Default: Truncate first. -h, --help¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: output.dat. -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -p <prefix>, --prefix <prefix>¶; Prefix for psi files. Default: psi. -v, --verbose¶; Print a lot of information. -d, --debug¶; Flush the outfile at every fprintf. Default: true iff --with-debug. -V, --ve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:8552,access,accessed,8552,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,4,['access'],['accessed']
Security,"O density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. Command Line Options¶; PSI4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.; The set of three commands below are completely equivalent, while the fourth is,; perhaps, the most common usage.; psi4; psi4 -i input.dat -o output.dat; psi4 input.dat output.dat. psi4 descriptive_filename.in descriptive_filename.out. Command-line arguments to PSI4 can be accessed through psi4 --help. -a, --append¶; Append results to output file. Default: Truncate first. -h, --help¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename (subtracting; any ”.in” or ”.dat” suffix) plus ”.out”. -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). --new-plugin <name>¶; Creates a new directory <name> with files for writing a; new plugin. An additional argument specifies a template; to use, for example: --new-plugin name +mointegrals.; See Sec. Plugins: Adding New Functionality to PSI4 for available templates. -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:8666,access,accessed,8666,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,4,['access'],['accessed']
Security,"O), eLO); cbsscheme += """""" MD-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zMD), eMD); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); PsiMod.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_2(**largs):; r""""""Extrapolation scheme for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 2):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zLO = NEED['LO']['f_zeta']. # LAB TODO add ability to pass alternate parameter values in. # Return extrapolated energy; alpha = 1.63; beta = (eHI - eLO) / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:83132,Validat,ValidationError,83132,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). nbo; Generation of NBO file. cc54; CCSD dipole with user-specified basis set. scf-guess-read3; Test if the the guess read in the same basis converges. scf-upcast-custom-basis; test scf castup with custom basis sets. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. fci-dipole; 6-31G H2O Test FCI Energy Point. mints6; Patch of a glycine with a methyl ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:22077,validat,validate,22077,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"O; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. ## Aliases ##; complete_basis_set = cbs. def _cbs_wrapper_methods(**kwargs):; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]. cbs_methods = []; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:65564,Validat,ValidationError,65564,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"OCC', 'SPIN_SCALE_TYPE', 'SOS'); elif name == 'custom-scs-omp3':; core.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'CUSTOM'). elif name == 'lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'); elif name == 'custom-scs-lccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'FALSE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'CUSTOM'). elif name == 'olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'); elif name == 'custom-scs-olccd':; core.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); core.set_local_option('OCC', 'ORB_OPT', 'TRUE'); core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'CUSTOM'). else:; raise ValidationError(""""""Invalid method %s"""""" % name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conven",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:71490,Validat,ValidationError,71490,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"OLCCD cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. mbis-6; MBIS calculation on H2O. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cbs-parser; mtd/basis syntax examples. scf-occ; force occupations in scf. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. mints9",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:28705,validat,validate,28705,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['validat'],['validate']
Security,"OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if PsiMod.has_option_changed('SCF', 'BASIS_GUESS'):; cast = PsiMod.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if PsiMod.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = PsiMod.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; molecule = PsiMod.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if PsiMod.get_option('SCF','REFERENCE') != 'UHF' and PsiMod.get_option('SCF','REFERENCE') != 'UKS':; raise ValidationError('You must specify ""set reference uhf"" to use broken symmetry.'); do_broken = True; else:; do_broken = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that can't query PUREAM option directly, as it only; # reflects user changes to value, so load basis and; # read effective PUREAM setting off of it; PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')); PsiMod.set_global_option('PUREAM', PsiMod.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; molecule.set_multiplicity(3); PsiMod.print_out('\n'); banner(' Computing high-spin triplet guess '); PsiMod.print_out('\n'). # cast set-up; if (cast):. if yes.match(str(cast)):; guessbasis = '3-21G'; else:; guessbasis = cast. if (castdf):; if yes.match(str(castdf)):; guessbasisdf = corresponding_jkfit(guessba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:16064,Validat,ValidationError,16064,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"P is used; os.environ['NO_STOP_MESSAGE'] = '1'. # Obtain user's OMP_NUM_THREADS so that we don't blow it away.; omp_num_threads_found = 'OMP_NUM_THREADS' in os.environ; if omp_num_threads_found == True:; omp_num_threads_user = os.environ['OMP_NUM_THREADS']. # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if psi4.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = str(psi4.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); p4out.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; if psi4.outfile_name() == 'stdout':; sys.stdout.write(data); else:; p4out.write(data); p4out.flush(); c4out += data. # try:; # if psi4.outfile_name() == 'stdout':; # retcode = subprocess.call('dmrcc', shell=True, env=lenv); # else:; # retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + psi4.outfile_name(), shell=True, env=lenv); #; # if retcode < 0:; # print('MRCC was terminated by signal %d' % -retcode, file=sys.stderr); # exit(1); # elif retcode > 0:; # print('MRCC errored %d' % retcode, file=sys.stderr); # exit(1); #; # except OSError as e:; # print('Execution failed: %s' % e, file=sys.stderr); # exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if psi4.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; ene = 0.0; for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:94939,Validat,ValidationError,94939,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"PCT-Data>; """""" % int(ticket); if ticket:; # Wait 10 seconds...; print(""\tPubChem result not available yet, will try again in 10 seconds...""); time.sleep(10); # ...and ask for an update on the progress; server_response = urlopen(url, statusrequest).read(); xml = ET.fromstring(server_response); #print(server_response); else:; # We can't find a ticket number, or a download location. Bail.; raise ValidationError(""""""PubChem: download error""""""); return self.dataSDF. [docs] def name(self):; """"""Function to return the IUPAC name of the PubChem object.""""""; return self.iupac. [docs] def getCartesian(self):; """"""Function to return a string of the atom symbol and XYZ; coordinates of the PubChem object. """"""; try:; sdfText = self.getSDF(); except Exception as e:; raise e. # Find; # NA NB CONSTANT; # 14 13 0 0 0 0 0 0 0999 V2000; m = re.search(r'^\s*(\d+)\s+(?:\d+\s+){8}V2000$', sdfText, re.MULTILINE); self.natom = 0; if (m):; self.natom = int(m.group(1)). if self.natom == 0:; raise ValidationError(""PubChem: Cannot find the number of atoms. 3D data doesn't appear\n"" +; ""to be available for %s.\n"" % self.iupac). lines = re.split('\n', sdfText). # 3.7320 -0.2500 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0; NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; atom_re = re.compile(r'^\s*' + NUMBER + r'\s+' + NUMBER + r'\s+' + NUMBER + r'\s*(\w+)(?:\s+\d+){12}'). molecule_string = ""PubchemInput\n"". atom_count = 0; for line in lines:; if (not line or line.isspace()):; continue. atom_match = atom_re.match(line); if atom_match:; x = float(atom_match.group(1)); y = float(atom_match.group(2)); z = float(atom_match.group(3)); sym = atom_match.group(4). atom_count = atom_count + 1. molecule_string += ""%s %10.6f %10.6f %10.6f\n"" % (sym, x, y, z). if (atom_count == self.natom):; break. return molecule_string. [docs] def getXYZFile(self):; """"""Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. """"""; try:; temp = sel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html:5908,Validat,ValidationError,5908,psi4manual/1.0.0/_modules/pubchem.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/pubchem.html,1,['Validat'],['ValidationError']
Security,"PI helpers for PSIthon `{...}` syntax.; Also, many Python extensions to core classes:. - core (variable-related, gradient, python option),; - Wavefunction (variable-related, freq, Lagrangian, constructor, scratch file, serialization),; - Matrix (doublet, triplet),; - BasisSet (constructor); - JK (constructor); - VBase (grid); - OEProp (avail prop); - ERISieve (constructor); """""". __all__ = [; ""basis_helper"",; ""pcm_helper"",; ""plump_qcvar"",; ""set_options"",; ""set_module_options"",; ""temp_circular_import_blocker"", # retire ASAP; ]. import os; import re; import sys; import math; import uuid; import warnings; from collections import Counter; from itertools import product; from pathlib import Path; from tempfile import NamedTemporaryFile; from typing import Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel; from psi4 import core; from psi4 import extras; from psi4.driver import qcdb. from . import optproc; from .exceptions import TestComparisonError, ValidationError, UpgradeHelper. ## Python basis helps. @staticmethod; def _pybuild_basis(; mol: core.Molecule,; key: Optional[str] = None,; target: Optional[Union[str, Callable]] = None,; fitrole: str = ""ORBITAL"",; other: Optional[Union[str, Callable]] = None,; puream: int = -1,; return_atomlist: bool = False,; *,; quiet: bool = False,; ) -> Union[core.BasisSet, List[core.BasisSet]]:; """"""Build a primary or auxiliary basis set. Parameters; ----------; mol; Molecule for which to build the basis set instance.; key; {'BASIS', 'ORBITAL', 'DF_BASIS_SCF', 'DF_BASIS_MP2', 'DF_BASIS_CC', 'BASIS_RELATIVISTIC', 'DF_BASIS_SAD'}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ``""ORBITAL""`` or ``""BASIS""``.; target; Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:2161,Validat,ValidationError,2161,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""File to. """"""; from __future__ import absolute_import; from __future__ import print_function; import sys; import os; import glob; import ast. [docs]def useful():; print(""in qcdb.useful()""); return 'qcdb successfully accessed'. [docs]def drop_duplicates(seq):; """"""Function that given an array or array of arrays *seq*, returns an; array without any duplicate entries. There is no guarantee of which; duplicate entry is dropped. """"""; noDupes = []; seq2 = sum(seq, []); [noDupes.append(i) for i in seq2 if not noDupes.count(i)]; return noDupes. [docs]def dictify_database_docstrings():; """""". """"""; db_path = os.path.dirname(__file__) + '/../databases'. DSD = {}; module_choices = []; for module in glob.glob(db_path + '/*.py'):; filename = os.path.split(module)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.replace(lst[0], '|', ''); DSD[base",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html:1193,access,accessed,1193,psi4manual/1.0.0/_modules/qcdb/dbproc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbproc.html,1,['access'],['accessed']
Security,"PointGroups['C2Y'], PointGroups['C2X']]; d2h = [PointGroups['D2h']]; d2 = [PointGroups['D2']]; ci = [PointGroups['Ci']]; c1 = [PointGroups['C1']]. if bits in cs:; sim = cs; elif bits in c2v:; sim = c2v; elif bits in c2h:; sim = c2h; elif bits in c2:; sim = c2; elif bits in d2h:; sim = d2h; elif bits in ci:; sim = ci; elif bits in c1:; sim = c1; elif bits in d2:; sim = d2; else:; raise ValidationError('PointGroups::similar: Should not have reached here.'). return sim, len(sim). [docs]class SymmetryOperation(object):; """"""The SymmetryOperation class provides a 3 by 3 matrix; representation of a symmetry operation, such as a rotation or reflection. """""". def __init__(self, *args):; """"""Constructor"""""". # matrix representation; self.d = zero(3, 3); # bits representation; self.bits = 0. # Divert to constructor functions; if len(args) == 0:; pass; elif len(args) == 1 and \; isinstance(args[0], SymmetryOperation):; self.constructor_symmetryoperation(*args); else:; raise ValidationError('SymmetryOperation::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. [docs] def constructor_symmetryoperation(self, so):; self.bits = so.bits; self.d = [row[:] for row in so.d]. # <<< Simple Methods for Basic SymmetryOperation Information >>>. [docs] def bit(self):; """"""Get the bit value.""""""; return self.bits. def __getitem__(self, i, j=None):; """"""Returns the (i,j)th element of the transformation matrix; or the i'th row of the transformation matrix if *j* is None. """"""; if j is None:; return self.d[i]; else:; return self.d[i][j]. [docs] def trace(self):; """"""returns the trace of the transformation matrix""""""; return self.d[0][0] + self.d[1][1] + self.d[2][2]. # <<< Methods for Symmetry Operations >>>. [docs] def zero(self):; """"""zero out the symop""""""; self.d = zero(3, 3). [docs] def unit(self):; """"""Set equal to a unit matrix""""""; self.zero(); self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[2][2] = 1.0. [docs] def E(self):; """"""Set equal to E""""""; sel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:4691,Validat,ValidationError,4691,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"Psi4 keyword: BASIS,; DF_BASIS_SCF, etc.). Fails utterly if a basis has not been set for; role for every atom in mol, unless deffit is set (JFIT,; JKFIT, or RIFIT), whereupon empty atoms are assigned to role; from the BasisFamily. This function is significantly; re-worked from its libmints analog. constructor_basisset_center(bs, center)[source]¶. Creates a new basis set object for an atom, from an existing basis set; bs: the basis set to copy data from; center: the atom in bs to copy over. constructor_role_mol_shellmap(role, mol, shell_map)[source]¶; The most commonly used constructor. Extracts basis set name for role; from each atom of mol, looks up basis and role entries in the; shell_map dictionary, retrieves the GaussianShell objects and returns; the BasisSet. constructor_zero_ao_basis()[source]¶; Constructs a zero AO basis set. exp_ao = [[], [], [], [], [], []]¶. export_for_libmints(role)[source]¶; From complete BasisSet object, returns array where; triplets of elements are each unique atom label, the hash; of the string shells entry in gbs format and the; shells entry in gbs format for that label. This packaging is; intended for return to libmints BasisSet::pyconstruct for; instantiation of a libmints BasisSet clone of self. function_to_center(i)[source]¶; Given a function what is its atomic center; * @param i Function number; * @return The atomic center for the i’th function. function_to_shell(i)[source]¶; Given a function number what shell does it correspond to. get_ao_sorted_list()[source]¶; Returns the vector of sorted shell list. Defunct. get_ao_sorted_shell(i)[source]¶; Returns the value of the sorted shell list. Defunct. has_puream()[source]¶; Spherical harmonics?; * @return true if using spherical harmonics. initialize_singletons()[source]¶; Initialize singleton values that are shared by all basis set objects. initialized_shared = False¶. l = 5¶. static make_filename(name)[source]¶; Converts basis set name to a compatible filename.; * @param basisname ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:60564,hash,hash,60564,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['hash'],['hash']
Security,"Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""create_plugin"",; ""sanitize_name"",; ]. import os; import sys; from pathlib import Path. from psi4 import core; from psi4.driver.util import tty. [docs]def sanitize_name(name: str) -> str:; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", ""bitand"", ""bitor"",; ""bool"", ""break"", ""case"", ""catch"", ""char"", ""char16_t"", ""char32_t"",; ""class"", ""compl"", ""concept"", ""const"", ""constexpr"", ""const_cast"",; ""continue"", ""decltype"", ""default"", ""delete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""req",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html:1521,sanitiz,sanitized,1521,psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/pluginutil.html,1,['sanitiz'],['sanitized']
Security,"Python, PSI4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:9442,access,accessed,9442,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['access'],['accessed']
Security,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign. The geometry; specification supports delayed initialization of variable, which permits; potential energy scans. As an example, we can scan both the angle and bond; length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:22863,access,access,22863,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,4,['access'],['access']
Security,"QZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_set is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H1 R; H1 R2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(102,106,2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; ta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:25728,access,access,25728,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['access'],['access']
Security,"Q_SOLVER (DFOCC); DFOCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINEQ_SOLVER (OCC); OCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINESEARCH_STATIC_MAX (OPTKING); OPTKING — If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.100. LINESEARCH_STATIC_MIN (OPTKING); OPTKING — If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.001. LINESEARCH_STATIC_N (OPTKING); OPTKING — If doing a static line search, scan this many points. Type: integer; Default: 8. LITERAL_CFOUR (GLOBALS); GLOBALS — Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. LOCAL (CCENERGY); CCENERGY — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCEOM); CCEOM — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCLAMBDA); CCLAMBDA — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCRESPONSE); CCRESPONSE — Do simulate local correlation?. Type: boolean; Default: false. LOCAL (CCSORT); CCSORT — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CONVERGENCE (FISAPT); FISAPT — Relative convergence in orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_CONVERGENCE (SCF); SCF — The convergence on the orbital localization procedure. Type: conv double; Default: 1e-12. LOCAL_CORE_CUTOFF (CCSORT); CCSORT — Local core cutoff value. Type: double; Default: 0.05. LOCAL_CPHF_CUTOFF (CCENERGY); CCENERGY — Cutoff valu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:146066,Access,Access,146066,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['Access'],['Access']
Security,"Q_SOLVER (DFOCC); DFOCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINEQ_SOLVER (OCC); OCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINESEARCH_STATIC_MAX (OPTKING); OPTKING — If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.100. LINESEARCH_STATIC_MIN (OPTKING); OPTKING — If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.001. LINESEARCH_STATIC_N (OPTKING); OPTKING — If doing a static line search, scan this many points. Type: integer; Default: 8. LITERAL_CFOUR (GLOBALS); GLOBALS — Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. LOCAL (CCENERGY); CCENERGY — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCEOM); CCEOM — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCLAMBDA); CCLAMBDA — Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL (CCRESPONSE); CCRESPONSE — Do simulate local correlation?. Type: boolean; Default: false. LOCAL_CONVERGENCE (FISAPT); FISAPT — Relative convergence in orbital localization. Type: conv double; Default: 1.0e-12. LOCAL_CONVERGENCE (SCF); SCF — The convergence on the orbital localization procedure. Type: conv double; Default: 1e-12. LOCAL_CPHF_CUTOFF (CCENERGY); CCENERGY — Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_CPHF_CUTOFF (CCLAMBDA); CCLAMBDA — Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:146587,Access,Access,146587,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['Access'],['Access']
Security,"R PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import print_function; from __future__ import absolute_import; from __future__ import division; import re; import math; import sys; import numpy as np. from psi4 import core. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver import driver_util; from psi4.driver import constants. from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list. zeta_values = ['d', 't', 'q', '5', '6', '7', '8']; zeta_val2sym = {k + 2: v for k, v in zip(range(7), zeta_values)}; zeta_sym2val = {v: k for k, v in zeta_val2sym.items()}. def _expand_bracketed_basis(basisstring, molecule=None):; r""""""Function to transform and validate basis series specification; *basisstring* for cbs(). A basis set with no paired square brackets is; passed through with zeta level 0 (e.g., '6-31+G(d,p)' is returned as; [6-31+G(d,p)] and [0]). A basis set with square brackets is checked; for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4,; 5]). This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Allows; out-of-order zeta specification (e.g., [qtd]) and numeral for number; (e.g., [23]) but not skipped zetas (e.g., [dq]) or zetas outside [2,; 8] or non-Dunning sets or non-findable .gbs sets. """"""; BSET = []; ZSET = []; legit_compound_basis = re.compile(r'^(?P<pre>.*cc-.*)\[(?P<zeta>[dtq2345678,]*)\](?P<post>.*z)$', re.IGNORECASE). if legit_compound_basis.match(basisstring):; basisname = legit_compound_basis.match(basisstring); # filter out commas and be forgiv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:1779,validat,validate,1779,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validate']
Security,"R PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import print_function; from __future__ import absolute_import; from __future__ import division; import re; import sys; import math. import numpy as np. from psi4 import core; from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver import driver_util; from psi4.driver import constants; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list. zeta_values = ['d', 't', 'q', '5', '6', '7', '8']; zeta_val2sym = {k + 2: v for k, v in zip(range(7), zeta_values)}; zeta_sym2val = {v: k for k, v in zeta_val2sym.items()}. def _expand_bracketed_basis(basisstring, molecule=None):; r""""""Function to transform and validate basis series specification; *basisstring* for cbs(). A basis set with no paired square brackets is; passed through with zeta level 0 (e.g., '6-31+G(d,p)' is returned as; [6-31+G(d,p)] and [0]). A basis set with square brackets is checked; for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4,; 5]). This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Allows; out-of-order zeta specification (e.g., [qtd]) and numeral for number; (e.g., [23]) but not skipped zetas (e.g., [dq]) or zetas outside [2,; 8] or non-Dunning or non-Ahlrichs or non-Jensen sets or ; non-findable .gbs sets. """"""; BSET = []; ZSET = []; legit_compound_basis = re.compile(r'^(?P<pre>.*cc-.*|def2-|.*pcs+eg-)\[(?P<zeta>[dtq2345678,s1]*)\](?P<post>.*z.*|)$', re.IGNORECASE); pc_basis = re.compile(r'.*pcs+eg-$', re.IGNORECASE); def2_basis = re.compile(r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:1781,validat,validate,1781,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validate']
Security,"RELATION ENERGY'). psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). user_ref = psi4.get_option('DETCI', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'ROHF'):; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if (name.lower() == 'zapt'):; psi4.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); psi4.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; psi4.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; psi4.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; psi4.set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:40148,Validat,ValidationError,40148,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"RENCE') != 'RHF'):; raise ValidationError('ADC requires reference RHF'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return PsiMod.adc(). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf(name, **kwargs); returnvalue = PsiMod.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; PsiMod.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); PsiMod.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); PsiMod.dfmp2(); vdh = dfun.c_alpha() * PsiMod.get_variable('SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:35740,Validat,ValidationError,35740,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"RH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # ... resume correlation logic; if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:40464,Validat,ValidationError,40464,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3; Default: FALSE. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. INTEGRAL_PACKAGE¶. Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT, SIMINT; Default: LIBINT. LITERAL_CFOUR¶. Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. MOLDEN_WITH_VIRTUAL¶. Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MP2_TYPE¶. Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE¶. Algorithm to use for MPn ( \(n>2\) ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. NUM_FROZEN_DOCC¶. The number of core orbitals to freeze in later correlated computations. This trumps FREEZE_CORE. Type: integer; Default: 0. NUM_FROZEN_UOCC¶. The number of virtual orbitals to freeze in later correlated computations. Type: integer; Default: 0. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PRINT¶. The amount of information to print to the output file. 1 prints basic information, and higher levels print more informat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__globals-1.html:4234,Access,Access,4234,psi4manual/1.3.2/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__globals-1.html,2,['Access'],['Access']
Security,"ReapOrders. return inputString. [docs]def vpt2_reaprun_files(item, linkage, isSowReap, isC4notP4, isC4fully, zmat, outdir, scrdir, c4scrdir, lowername, kwargs):; """"""Provided with the particular displacement number *item* and the; associated *zmat* file with geometry and *linkage*, returns the; FJOBARC contents. Depending on the mode settings of *isC4notP4*,; *isSowReap*, and *isC4fully*, either runs (using *lowername* and; *kwargs*) or reaps contents. *outdir* is where psi4 was invoked,; *scrdir* is the psi4 scratch directory, and *c4scrdir* is Cfour; scratch directory within. """"""; os.chdir(outdir) # current_directory; # Extract qcdb.Molecule at findif orientation; zmmol = qcdb.cfour.harvest_zmat(zmat). # Cfour S/R Direct for gradients; if isC4fully:; with open('VPT2-' + item + '.fja', 'r') as handle:; fjobarc = handle.read(). # Cfour for gradients; elif isC4notP4:. # S/R: Reap results from output file; if isSowReap:; isOk, msg, results = reap_job_validate(outdir, 'VPT2', item, linkage,; ['CURRENT ENERGY', 'CURRENT DIPOLE', 'CURRENT GRADIENT', 'CURRENT MOLECULE']); if not isOk:; raise ValidationError(msg). fje = results['CURRENT ENERGY']; fjgrd = results['CURRENT GRADIENT']; fjdip = [item / p4const.psi_dipmom_au2debye for item in results['CURRENT DIPOLE']]; c4mol = qcdb.Molecule(results['CURRENT MOLECULE']); c4mol.update_geometry(). # C: Run the job and collect results; else:; # Prepare Cfour skeleton calc directory; os.chdir(scrdir + c4scrdir) # psi_scratch/cfour; if os.path.exists('scr.' + item):; shutil.rmtree('scr.' + item); os.mkdir('scr.' + item); os.chdir('scr.' + item) # psi_scratch/cfour/scr.000-004; with open('ZMAT', 'w') as handle:; handle.write(zmat); shutil.copy2('../harm/GENBAS', 'GENBAS'). #os.chdir(scrdir + '/scr.' + item); #run_cfour_module('xja2fja'); #with open('FJOBARC', 'r') as handle:; # fjobarc = handle.read(). # Run Cfour calc using ZMAT & GENBAS in scratch, outdir redirects to outfile; os.chdir(outdir) # current_directory; psi4.get_active_mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:20796,Validat,ValidationError,20796,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,1,['Validat'],['ValidationError']
Security,"Return. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xtpl_helgaker_2():; pass. def _expand_bracketed_basis(basisstring: str, molecule: Union[""qcdb.Molecule"", core.Molecule] = None) -> Tuple[List[str], List[int]]:; """"""Function to transform and validate basis series specification for cbs(). Parameters; ----------; basisstring; A string containing the basis sets to be expanded.; A basis set with no paired square brackets is passed through; with zeta level 0 (e.g., ``'6-31+G(d,p)'`` is returned as; ``([""6-31+G(d,p)""], [0])``). A basis set with square brackets is checked; for sensible sequence and returned as separate basis sets; (e.g., ``'cc-pV[Q5]Z'` is returned as ``([""cc-pVQZ"", ""cc-pV5Z""], [4, 5])``).; Allows out-of-order zeta specification (e.g., ``[qtd]``) and numeral for; number (e.g., ``[23]``). Does not allow skipped zetas (e.g., ``[dq]``), zetas; outside the [2,8] range, non-Dunning, non-Ahlrichs, or non-Jensen sets,; or non-findable .gbs sets.; molecule; This function checks that the basis is valid by trying to build; the qcdb.BasisSet object for *molecule* or for H2 if None. Returns; -------; tuple; Tuple in the ``([basis set names], [basis set zetas])`` format. """"""; BSET = []; ZSET = []; legit_compo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:6653,validat,validate,6653,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validate']
Security,"Run with Tamm-Dancoff approximation (TDA), uses random-phase approximation (RPA) when false. Type: boolean; Default: false. TDSCF_R_CONVERGENCE¶. Convergence threshold for the norm of the residual vector. If unset, default based on D_CONVERGENCE. Type: conv double; Default: 1e-4. TDSCF_MAXITER¶. Maximum number of TDSCF solver iterations. Type: integer; Default: 60. TDSCF_GUESS¶. Guess type, only ‘denominators’ currently supported. Type: string; Default: DENOMINATORS. TDSCF_PRINT¶. Verbosity level in TDSCF. Type: integer; Default: 1. TDSCF_COEFF_CUTOFF¶. Cutoff for printing excitations and de-excitations icontributing to each excited state. Type: double; Default: 0.1. TDSCF_TDM_PRINT¶. Which transition dipole moments to print out: - E_TDM_LEN : electric transition dipole moments, length representation - E_TDM_VEL : electric transition dipole moments, velocity representation - M_TDM : magnetic transition dipole moments. Type: array; Default: No Default. PsiAPI usage¶; The TDSCF functionality is also accessible from PsiAPI. The example calculation shown above can be carried out as follows:; import psi4. from psi4.driver.procrouting.response.scf_response import tdscf_excitations. psi4.core.set_output_file(""h2o2.out""). h2o2 = psi4.geometry(""""""0 1; O 0.000000 0.695000 -0.092486; O -0.000000 -0.695000 -0.092486; H -0.388142 0.895249 0.739888; H 0.388142 -0.895249 0.739888; symmetry c1; """""", name=""H2O2""). psi4.set_options({; 'save_jk': True,; }). e, wfn = psi4.energy(""HF/cc-pvdz"", return_wfn=True, molecule=h2o2); res = tdscf_excitations(wfn, states=10). Plotting one-photon absorption and electronic circular dichroism spectra¶; Excitation energies and corresponding spectroscopic observables can be used to; produce spectra for one-photon absorption (OPA) and electronic circular; dichroism (ECD) with phenomenological line broadening.; PSI4 provides the spectrum function for this purpose implementing the; recommendations of Rizzo et al. [Rizzo2011-to].; This function will not pl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/tdscf.html:10385,access,accessible,10385,psi4manual/1.6.x/tdscf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/tdscf.html,1,['access'],['accessible']
Security,"S loaded from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = core.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; core.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; psi4.driver.procrouting.interface_cfour. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html:17160,Validat,ValidationError,17160,psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,1,['Validat'],['ValidationError']
Security,"S') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). fnocc_wfn = psi4.fnocc(ref_wfn). # one-electron properties; if psi4.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; psi4.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif psi4.get_option('FNOCC', 'NAT_ORBS'):; psi4.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). optstash.restore(); return fnocc_wfn. [docs]def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """""". optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF', 'SCF_TYPE']; ). user_ref = psi4.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; psi4.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; psi4.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. molecule = ref_wfn.molecule(). # The DF case; if psi4.get_option('DETCI', 'MCSCF_TYPE') == 'DF':. # Do NOT set global options in general, this is a bit of a hack; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'). # The non-DF case; else:; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). # Second-order SCF requires non-symmetric density matrix support; if psi4.get_option('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:107727,Validat,ValidationError,107727,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"S', '', '', '', finalenergy, ''); tables += table_delimit. #print tables; psi4.print_out(tables). # Restore molecule and options; #psi4.set_local_option('SCF', ""WFN"", user_wfn) # TODO refuses to set global option WFN - rejects SCF as option; psi4.set_global_option('BASIS', user_basis). psi4.set_global_option('WFN', user_wfn); if not b_user_wfn:; psi4.revoke_global_option_changed('WFN'). psi4.set_global_option('WRITER_FILE_LABEL', user_writer_file_label). psi4.set_variable('CBS REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CBS TOTAL ENERGY', finalenergy); psi4.set_variable('CURRENT REFERENCE ENERGY', GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT CORRELATION ENERGY', finalenergy - GRAND_NEED[0]['d_energy']); psi4.set_variable('CURRENT ENERGY', finalenergy); return finalenergy. # Transform and validate basis sets from 'cc-pV[Q5]Z' into [cc-pVQZ, cc-pV5Z] and [4, 5]; [docs]def validate_bracketed_basis(basisstring):; r""""""Function to transform and validate basis sets for cbs(). A basis set with no; paired square brackets is passed through with zeta level 0 (e.g., '6-31+G(d,p)'; is returned as [6-31+G(d,p)] and [0]). A basis set with square brackets is; checked for sensible sequence and Dunning-ness and returned as separate basis; sets (e.g., 'cc-pV[Q5]Z' is returned as [cc-pVQZ, cc-pV5Z] and [4, 5]). Note; that this function has no communication with the basis set library to check; if the basis actually exists. Used by :py:func:`~wrappers.complete_basis_set`. """"""; ZETA = ['d', 't', 'q', '5', '6']; BSET = []; ZSET = []; if re.match(r'.*cc-.*\[.*\].*z$', basisstring, flags=re.IGNORECASE):; basispattern = re.compile(r'^(.*)\[(.*)\](.*)$'); basisname = basispattern.match(basisstring); for b in basisname.group(2):; if b not in ZETA:; raise ValidationError('Basis set \'%s\' has invalid zeta level \'%s\'.' % (basisstring, b)); if len(ZSET) != 0:; if (int(ZSET[len(ZSE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:90347,validat,validate,90347,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['validat'],['validate']
Security,S). MCSCF. theory. MCSCF TOTAL ENERGY. mcscf() (in module psi4.core). MCSCF_ALGORITHM (DETCI). MCSCF_CI_CLEANUP (DETCI). MCSCF_DIIS_ERROR_TYPE (DETCI). MCSCF_DIIS_FREQ (DETCI). MCSCF_DIIS_MAX_VECS (DETCI). MCSCF_DIIS_START (DETCI). MCSCF_DPD_CLEANUP (DETCI). MCSCF_E_CONVERGENCE (DETCI). MCSCF_GUESS (DETCI). MCSCF_MAX_ROT (DETCI). MCSCF_MAXITER (DETCI). mcscf_object() (psi4.core.CIWavefunction method). MCSCF_R_CONVERGENCE (DETCI). MCSCF_ROTATE (DETCI). MCSCF_SO_START_E (DETCI). MCSCF_SO_START_GRAD (DETCI). MCSCF_TYPE (DETCI). mdi_run() (in module psi4.driver). MemDFJK (class in psi4.core). memory. memory_estimate() (psi4.core.JK method). message (psi4.driver.ConvergenceError attribute). (psi4.driver.ManagedMethodError attribute). (psi4.driver.MissingMethodError attribute). (psi4.driver.OptimizationConvergenceError attribute). (psi4.driver.SCFConvergenceError attribute). (psi4.driver.TDSCFConvergenceError attribute). (psi4.driver.TestComparisonError attribute). (psi4.driver.ValidationError attribute). message_box() (in module psi4.driver). (in module psi4.driver.p4util). meta_cutoff() (psi4.core.Functional method). metadata (psi4.driver.driver_cbs.CompositeComputer attribute). metameta (psi4.driver.driver_cbs.CompositeComputer attribute). (psi4.driver.driver_findif.FiniteDifferenceComputer attribute). method (psi4.driver.AtomicComputer attribute). (psi4.driver.driver_cbs.CompositeComputer attribute). (psi4.driver.driver_findif.FiniteDifferenceComputer attribute). (psi4.driver.driver_nbody.ManyBodyComputer attribute). method alias. ; adding new. metric() (psi4.core.FDDS_Dispersion method). metric_inv() (psi4.core.FDDS_Dispersion method). MIN_CCD_DIISVECS (SAPT). MINAO_BASIS (FISAPT). MintsHelper (class in psi4.core). mintshelper() (psi4.core.CUHF method). (psi4.core.RHF method). (psi4.core.ROHF method). (psi4.core.UHF method). (psi4.core.Wavefunction method). MissingMethodError. MIXED (DETCI). MIXED4 (DETCI). Mk-MRCC. MKL_NUM_THREADS. MO_DIIS_NUM_VECS (DFOCC). mo_elec_d,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:75800,Validat,ValidationError,75800,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['Validat'],['ValidationError']
Security,"SA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import absolute_import; import re; import os; import math; import warnings; import pickle; import copy; import collections; import p4const; from driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:2251,access,accessible,2251,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['access'],['accessible']
Security,"SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CON",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:10758,access,access,10758,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['access'],['access']
Security,"SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:10161,access,access,10161,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,2,['access'],['access']
Security,"SCF"", ""ORBITALS_WRITE"", filename); elif _chkfile is True:; write_checkpoint_file = True. # Continuum solvation needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM"") or core.get_option(""SCF"", ""DDX""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM or DDX continuum solvation does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE""):; c1_molecule = scf_molecule.clone(); if getattr(scf_molecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_cartesian.clone(); c1_molecule.set_geometry(c1_molecule._initial_cartesian); c1_molecule.reset_point_group(""c1""); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); else:; raise ValidationError(""Set no_com/no_reorient/symmetry c1 by hand for PE on non-Cartesian molecules.""). scf_molecule = c1_molecule; core.print_out("""""" PE does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); core.print_out("""""" PE geometry must align with POTFILE keyword: """"""; """"""resetting coordinates with fixed origin and orientation.\n""""""). # SCF Banner data; banner = kwargs.pop('banner', None); bannername = name. # Did we pass in a DFT functional?; dft_func = kwargs.pop('dft_functional', None); if dft_func is not None:; if name.lower() != ""scf"":; raise ValidationError(""dft_functional was supplied to SCF, but method name was not SCF ('%s')"" % name); name = dft_func; bannername = name; if isinstance(name, dict):; bannername = name.get(""name"", ""custom functional""). # Setup the timer; if do_timer:; core.tstart(). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:47150,Validat,ValidationError,47150,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"SCS-MP2 CORRELATION ENERGY'). else:; PsiMod.dfmp2(); vdh = dfun.c_alpha() * PsiMod.get_variable('MP2 CORRELATION ENERGY'). PsiMod.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; PsiMod.set_variable('DFT TOTAL ENERGY', returnvalue); PsiMod.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf_gradient(name, **kwargs). optstash.restore(). [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). user_ref = PsiMod.get_option('DETCI', 'REFERENCE'); if (user_ref != 'RHF') or (user_ref != 'ROHF'):; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if (name.lower() == 'zapt'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); PsiMod.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_local_option('DETCI', 'MA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:37738,Validat,ValidationError,37738,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"SE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2019 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys. import numpy as np. from psi4 import core; from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr : array or list of arrays; Numpy array or list of arrays to use a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:1176,Validat,ValidationError,1176,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"SIS_SCF"", scf_aux_basis). # The AO case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'AO':; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.set_oeprop(oeprop); core.set_variable(""CURRENT DIPOLE X"", core.get_variable(name.upper() + "" DIPOLE X"")); core.set_variable(""CURRENT DIPOLE Y"", core.get_variable(name.upper() + "" DIPOLE Y"")); core.set_variable(""CURRENT DIPOLE Z"", core.get_variable(name.upper() + "" DIPOLE Z"")). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """"""; # initialize library; efp = core.get_active_efp(). if efp.nfragments() == 0:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # set options; core.set_global_option('QMEFP', False) # apt to go haywire if set locally to efp; core.efp_set_options(). efp.print_out(); returnvalue = efp.compute(); return returnvalue. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. Module code. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:127409,Validat,ValidationError,127409,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"SS'):; castdf = core.get_option('SCF', 'DF_BASIS_GUESS'); if p4util.yes.match(str(castdf)):; castdf = True; elif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_local_option('SCF', 'SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, (unicode, str)):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if core.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if cast and do_broken:; raise ValidationError(""""""Detected options to both cast and perform a broken symmetry computation""""""). # broken set-up; if do_broken:; raise ValidationError(""""""Broken symmetry computations are not currently enabled.""""""); scf_molecule.set_multiplicity(3); core.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); core.print_out('\n'). # If we force c1 copy the active molecule; if use_c1:; scf_molecule.update_geometry(); if scf_molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); sc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:31232,Validat,ValidationError,31232,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"SSCF/6-31G** energy point. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cubeprop; RHF orbitals and density for water. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-level-shift-uhf; SCF level shift on a UHF computation. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. cbs-parser; mtd/basis syntax examples. options1; check all variety of options parsing. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to on",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:14393,validat,validate,14393,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"SSE treatment. Contents:; ``'all'``: dict of int: set; Set containing full list of computations required; ``'cp'``: dict of int: set; Set containing list of computations required for CP procedure; ``'nocp'``: dict of int: set; Set containing list of computations required for non-CP procedure; ``'vmfc_compute'``: dict of int: set; Set containing list of computations required for VMFC procedure; ``'vmfc_levels'``: dict of int: set; Set containing list of levels required for VMFC procedure; """"""; # What levels do we need?; nbody_range = range(1, metadata['max_nbody'] + 1); fragment_range = range(1, metadata['max_frag'] + 1). cp_compute_list = {x:set() for x in nbody_range}; nocp_compute_list = {x:set() for x in nbody_range}; vmfc_compute_list = {x:set() for x in nbody_range}; vmfc_level_list = {x:set() for x in nbody_range} # Need to sum something slightly different. # Verify proper passing of bsse_type_list; bsse_type_remainder = set(metadata['bsse_type_list']) - {'cp', 'nocp', 'vmfc'}; if bsse_type_remainder:; raise ValidationError(""""""Unrecognized BSSE type(s): %s; Possible values are 'cp', 'nocp', and 'vmfc'."""""" % ', '.join(str(i) for i in bsse_type_remainder)). # Build up compute sets; if 'cp' in metadata['bsse_type_list']:; # Everything is in dimer basis; basis_tuple = tuple(fragment_range); for nbody in nbody_range:; for x in itertools.combinations(fragment_range, nbody):; cp_compute_list[nbody].add( (x, basis_tuple) ). if 'nocp' in metadata['bsse_type_list']:; # Everything in monomer basis; for nbody in nbody_range:; for x in itertools.combinations(fragment_range, nbody):; nocp_compute_list[nbody].add( (x, x) ). if 'vmfc' in metadata['bsse_type_list']:; # Like a CP for all combinations of pairs or greater; for nbody in nbody_range:; for cp_combos in itertools.combinations(fragment_range, nbody):; basis_tuple = tuple(cp_combos); for interior_nbody in nbody_range:; for x in itertools.combinations(cp_combos, interior_nbody):; combo_tuple = (x, basis_tuple); vmfc_com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:11046,Validat,ValidationError,11046,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"S_BUFFER']['value'] = 512; options['QCHEM']['QCHEM_MAX_SCF_CYCLES']['value'] = 200. options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; options['QCHEM']['QCHEM_SYMMETRY']['value'] = False; options['QCHEM']['QCHEM_INTEGRALS_BUFFER']['value'] = 512. return text, options. [docs]def muster_modelchem(name, dertype):; """"""Transform calculation method *name* and derivative level *dertype*; into options for cfour. While deliberately requested pieces,; generally |cfour__cfour_deriv_level| and |cfour__cfour_calc_level|,; are set to complain if contradicted ('clobber' set to True), other; 'recommended' settings, like |cfour__cfour_cc_program|, can be; countermanded by keywords in input file ('clobber' set to False).; Occasionally, want these pieces to actually overcome keywords in; input file ('superclobber' set to True). """"""; text = ''; lowername = name.lower(); options = defaultdict(lambda: defaultdict(dict)). if dertype == 0:; options['QCHEM']['QCHEM_JOBTYPE']['value'] = 'SP'; # text += """"""energy('""""""; else:; raise ValidationError(""""""Requested Psi4 dertype %d is not available."""""" % (dertype)). if lowername == 'wb97x-v':; options['QCHEM']['QCHEM_EXCHANGE']['value'] = 'omegaB97X-V'. # text += """"""mp2')\n\n""""""; #; # elif lowername == 'df-mp2':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['MP2']['MP2_TYPE']['value'] = 'df'; # text += """"""mp2')\n\n""""""; #; # elif lowername == 'sapt0':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # text += """"""sapt0')\n\n""""""; #; # elif lowername == 'sapt2+':; # options['GLOBALS']['FREEZE_CORE']['value'] = True; # options['SCF']['SCF_TYPE']['value'] = 'df'; # options['SAPT']['NAT_ORBS_T2']['value'] = True; # options['SAPT']['NAT_ORBS_T3']['value'] = True; # options['SAPT']['NAT_ORBS_V4']['value'] = True; # options['SAPT']['OCC_TOLERANCE']['value'] = 1.0e-6; # text += """"""sapt2+')\n\n""""""; #; # elif lowername == 'sapt2+(3)':; # options[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:12057,Validat,ValidationError,12057,psi4manual/1.0.0/_modules/qcdb/qchem.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html,1,['Validat'],['ValidationError']
Security,"See class field. Maximum number of bodies to include in the many-body treatment.""; embedding_charges : bool; Whether embedding charges are present. Used to NaN the output printing rather than print bad numbers.; molecule : psi4.core.Molecule; See class field. Used to count atoms in fragments.; nbodies_per_mc_level: List[List[Union[int, Literal[""supersystem""]]]]; See class field. Distribution of active n-body levels among model chemistry levels.; Formerly nbody_list; bsse_type : List[BsseEnum]; See class field. Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned.; Note that this is the only arg that gets RESET. Happens for supersystem ""nbody"". Returns; -------; results; Dictionary of all N-body results. See contents at ManyBodyComputer.prepare_results docstring. """"""; # which level are we assembling?; mc_level_labels = {int(i.split(""_"")[0]) for i in component_results.keys()}. if len(mc_level_labels) != 1:; raise ValidationError(f""Something's wrong - this fn handles single-level (e.g., 1- & 2-body w/mp2) not multi-level (e.g., 1-body w/hf & 2-body w/mp2) assembly: len({mc_level_labels}) != 1""). # get the range of nbodies for this level; # * modelchem level label (mc_level_lbl) used in qcvars and dict keys is 1-indexed counterpart to 0-indexed modelchem level position (mc_level_idx) used to navigate self.nbodies_per_mc_level; mc_level_lbl = list(mc_level_labels)[0]; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl - 1]; if nbodies[0] == 'supersystem':; # range for supersystem sub-components; nbodies = metadata['nbodies_per_mc_level'][mc_level_lbl]; metadata['bsse_type'] = ['nocp']. # regenerate per-bsse required calcs list; compute_dict = build_nbody_compute_list(; metadata['bsse_type'], nbodies, metadata['nfragments'], metadata[""return_total_data""], verbose=0; ). # Build size and slices dictionaries; fragment_size_dict = {}; fragment_slice_dict = {}; iat = 0; for ifr in range(1, metadata[""nfragments""] +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:22195,Validat,ValidationError,22195,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,5,['Validat'],['ValidationError']
Security,"Slater radii. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-reference; MP2 with a PBE0 reference computation. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. linK-1; RHF Linear Exchange Algorithm test for water. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. mp2-h; check that methods can act on single atom. linK-2; RKS Linear Exchange Algorithm test for benzene. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. fsapt-ext-abc2; FSAPT with external charge on dimer. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dft-jk; DFT JK on-disk test. fd-freq-gradient; SCF STO-3G finite-differences",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:28235,Access,Accesses,28235,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['Access'],['Accesses']
Security,"SourceForge. Find-the-code Quiz¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base.; Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,; and optimization for a variety of processor architectures (except; Mac, which is least common denominator), I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself.; I’m on Linux or Mac or Windows with Ubuntu Bash Shell.; I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility; I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4.; In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub; I want to develop using PSI4 infrastructure and libraries, not; on them; I think a plugin might do.; I’ve got a PSI4 compilation. Use it, then consult plugins; I’d rather not compile PSI4 or I don’t have compilers —; Goto Binary-Package then consult; plugins through conda. I really like parentheses and/or DBOC, so I want Psi3. —; Goto Psi3-from-SourceForge. Binary Installer¶. Get Initially; Just go to http://www.psicode.org/downloads.html and follow the; instructions there. Build; Not applicable as binary is pre-built. Get Updates directions; >>> conda update psi4. Contribute Back; Not applicable as not un",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_obtaining-1.html:1658,access,access,1658,psi4manual/1.3.2/build_obtaining-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_obtaining-1.html,2,['access'],['access']
Security,"Space method, [1], [2]. VirOnly psi4.core.IntegralTransform.FrozenOrbitals attribute, [1]. visualization, [1]. VMDPATH. vmfc. ; setting keywords. vv10_b() psi4.core.SuperFunctional method, [1], [2]. vv10_c() psi4.core.SuperFunctional method, [1], [2]. Vvals() psi4.core.OEProp method, [1], [2]. W. w() psi4.core.BlockOPoints method, [1], [2]. WABEI_LOWDISK (CCHBAR). Wavefunction class in psi4.core, [1]. WebMO. WFN (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (CCTRIPLES). (DETCI). (GLOBALS). (SCF). WFN_SYM (MCSCF). (PSIMRCC). WFN_TYPE (DFOCC). (OCC). with_traceback() psi4.driver.ConvergenceError method. psi4.driver.CSXError method. psi4.driver.Dftd3Error method. psi4.driver.ManagedMethodError method. psi4.driver.OptimizationConvergenceError method. psi4.driver.ParsingError method. psi4.driver.PastureRequiredError method. psi4.driver.PsiException method. psi4.driver.PsiImportError method. psi4.driver.TestComparisonError method. psi4.driver.ValidationError method. wK() psi4.core.JK method, [1], [2]. write() psi4.core.CIVector method, [1], [2]. psi4.core.FCHKWriter method, [1], [2]. psi4.core.MOWriter method, [1], [2]. psi4.core.MoldenWriter method, [1], [2]. psi4.core.NBOWriter method, [1], [2]. write_eigenvalues() in module psi4.driver. write_scratch_file() psi4.core.IOManager method, [1], [2]. WRITER_FILE_LABEL (GLOBALS). X. x() psi4.core.BlockOPoints method, [1], [2]. X() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. x() psi4.core.Molecule method, [1], [2]. X() psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. x_alpha() psi4.core.SuperFunctional method, [1], [2]. x_beta() psi4.core.SuperFunctional method, [1], [2]. x_functional() psi4.core.SuperFunctional method, [1], [2]. x_functionals() psi4.core.SuperFunctional method, [1], [2]. x_omega() psi4.core.SuperFunctional method",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:127455,Validat,ValidationError,127455,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['Validat'],['ValidationError']
Security,"Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; core.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if db_mode == 'sow':; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer archite",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:16252,access,accessed,16252,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,3,['access'],['accessed']
Security,"Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; psi4.print_out(instructions). # write sow/reap instructions and index of calcs to output file and reap input file; if db_mode == 'sow':; instructions = """"""\n The database sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructions += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructions += """""" has produced a number of input files (%s-*.in) for individual database members\n"""""" % (dbse); instructions += """""" and a single input file (%s-master.in) with a database(mode='reap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer archite",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:16132,access,accessed,16132,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['access'],['accessed']
Security,"T is required.'). PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'). e_sapt = PsiMod.infsapt(wfn_dimer,wfn_monomerA,wfn_monomerB). molecule.reset_point_group(user_pg); molecule.update_geometry(). PsiMod.set_global_option('DF_INTS_IO', df_ints_io). optstash.restore(); return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; Psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:58188,Validat,ValidationError,58188,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"T2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', True); psi4.set_local_option('SAPT', 'DO_CCD_DISP', False); elif (name.lower() == 'sapt2+(ccd)'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+(3)(ccd)'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', False); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+3(ccd)'):; psi4.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); psi4.set_local_option('SAPT', 'DO_THIRD_ORDER', True); psi4.set_local_option('SAPT', 'DO_CCD_DISP', True). # if the df_basis_sapt basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_SAPT') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_SAPT', ribasis); psi4.print_out(' No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). psi4.print_out('\n'); p4util.banner(name.upper()); psi4.print_out('\n'); e_sapt = psi4.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = psi4.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires req",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:52908,Validat,ValidationError,52908,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"TD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Establish treatment for delta3 correction energy; cbs_delta3_scheme = highest_1; if 'delta3_scheme' in kwargs:; cbs_delta3_scheme = kwargs['delta3_scheme']. # Establish treatment for delta4 correction energy; cbs_delta4_scheme = highest_1; if 'delta4_scheme' in kwargs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:77247,Validat,ValidationError,77247,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"TH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:131663,Validat,ValidationError,131663,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"THOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import sys. import numpy as np. from psi4 import core; from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr : array or list of arrays; Numpy array or list of arrays to use as the data for a new core.Matrix; name : str; Name to give the new core.Matrix; dim1 : list, tuple, or core.Dimension (optional); If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 :; Same as dim1 only if using a psi4.core.Dimension object. Returns; -------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:1686,Validat,ValidationError,1686,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"TION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:127191,Validat,ValidationError,127191,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['Validat'],['ValidationError']
Security,"TP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce (someday) if name is function; if hasattr(name, '__call__'):; raise ValidationError(""Frequency: Cannot use custom function""). lowername = name.lower(). old_global_basis = None; if ""/"" in lowername:; if (""+"" in lowername) or (""["" in lowername) or (lowername.count('/') > 1):; raise ValidationError(""Frequency: Cannot extrapolate or delta correct frequencies yet.""); else:; old_global_basis = core.get_global_option(""BASIS""); lowername, new_basis = lowername.split('/'); core.set_global_option('BASIS', new_basis). if kwargs.get('bsse_type', None) is not None:; raise ValdiationError(""Frequency: Does not currently support 'bsse_type' arguements""). return_wfn = kwargs.pop('return_wfn', False). # are we in sow/reap mode?; freq_mode = kwargs.get('mode', 'continuous').lower(); if freq_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(lowername, return_wfn=True, molecule=molecule, **kwargs). # S/R: Quit after getting new displacements; if freq_mode == 'sow':; return 0.0. wfn.frequencies().print_out(); core.thermo(wfn, wfn.frequencies()). for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). # Reset old global basis if needed; if not old_global_basis is None:; core.set_global_option(""BASIS"", old_global_basis). if return_wfn:; return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def gdma(wfn, datafile=""""):; """"""Function to use wavefunction information in *wfn* and, if specified,; additional commands in *filename* to run GDMA analysis. .. include:: ../autod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:85406,Validat,ValidationError,85406,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"TP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce (someday) if name is function; if hasattr(name, '__call__'):; raise ValidationError(""Frequency: Cannot use custom function""). lowername = name.lower(). old_global_basis = None; if ""/"" in lowername:; if (""+"" in lowername) or (""["" in lowername) or (lowername.count('/') > 1):; raise ValidationError(""Frequency: Cannot extrapolate or delta correct frequencies yet.""); else:; old_global_basis = psi4.get_global_option(""BASIS""); lowername, new_basis = lowername.split('/'); psi4.set_global_option('BASIS', new_basis). if kwargs.get('bsse_type', None) is not None:; raise ValdiationError(""Frequency: Does not currently support 'bsse_type' arguements""). return_wfn = kwargs.pop('return_wfn', False). # are we in sow/reap mode?; freq_mode = kwargs.get('mode', 'continuous').lower(); if freq_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(lowername, return_wfn=True, molecule=molecule, **kwargs). # S/R: Quit after getting new displacements; if freq_mode == 'sow':; return 0.0. wfn.frequencies().print_out(); psi4.thermo(wfn, wfn.frequencies()). for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). # Reset old global basis if needed; if not old_global_basis is None:; psi4.set_global_option(""BASIS"", old_global_basis). if return_wfn:; return (psi4.get_variable('CURRENT ENERGY'), wfn); else:; return psi4.get_variable('CURRENT ENERGY'). [docs]def gdma(wfn, datafile=""""):; """"""Function to use wavefunction information in *wfn* and, if specified,; additional commands in *filename* to run GDMA analysis. .. versionadded:: 0.6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:82904,Validat,ValidationError,82904,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"TY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('SCF_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only scf. if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:1737,Validat,ValidationError,1737,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"TYPE'); elif name == 'ccsd(at)':; core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(AT)'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'dfocc':; pass; else:; raise ValidationError('Unidentified method %s' % (name)). # conventional vs. optimized orbitals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'ccsd(at)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:46640,Validat,ValidationError,46640,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). run_scf(name, **kwargs). optstash.restore(). [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = p4util.drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""The \""properties\"" keyword is required with the property() function.""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if (n_invalid > 0):; print(""The following properties are not currently supported: %s"" % invalid). if (n_excited > 0 and (name.lower() != 'eom-ccsd' and name.lower() != 'eom-cc2')):; raise ValidationError(""Excited state CC properties require EOM-CC2 or EOM-CCSD.""). if ((name.lower() == 'eom-ccsd' or name.lower() == 'eom-cc2') and n_response > 0):; raise ValidationError(""Cannot (yet) compute response properties for excited states.""). if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""Computing both density- and response-based properties.""). if (name.lower() == 'ccsd'):; psi4.set_global_option('WFN', 'CCSD'); run_ccenergy('ccsd', **kwargs); psi4.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'cc2'):; psi4.set_global_option('WFN', 'CC2'); run_ccenergy('cc2', **kwargs); psi4.set_global_option('WFN', 'C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:29289,Validat,ValidationError,29289,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""AtomicComputer"",; ""BaseComputer"",; ""EnergyGradientHessianWfnReturn"",; ]. import abc; import copy; import logging; import pprint; from typing import Any, Dict, Optional, Tuple, Union, TYPE_CHECKING. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator; import qcelemental as qcel; from qcelemental.models import DriverEnum, AtomicInput, AtomicResult; from qcelemental.models.results import AtomicResultProtocols; qcel.models.molecule.GEOMETRY_NOISE = 13 # need more precision in geometries for high-res findif; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). EnergyGradientHessianWfnReturn = Union[float, core.Matrix, Tuple[Union[float, core.Matrix], core.Wavefunction]]. [docs]; class BaseComputer(qcel.models.ProtoModel):; """"""Base class for ""computers"" that plan, run, and process QC tasks."""""". [docs]; @abc.abstractmethod; def compute(self):; pass. [docs]; @abc.abstractmethod; def plan(self):; pass. class Config(qcel.models.ProtoModel.Config):; extra = ""allow""; allow_mutation = True. [docs]; class AtomicComputer(BaseComputer):; """"""Computer for analytic single-geometry computations."""""". molecule: Any = Field(..., descr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:1349,validat,validator,1349,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html,2,['validat'],['validator']
Security,"True returns the total data (energy/gradient/etc) of the system,; otherwise returns interaction data.; """""". # Initialize dictionaries for easy data passing; metadata, component_results, nbody_results = {}, {}, {}. # Parse some kwargs; kwargs = p4util.kwargs_lower(kwargs); metadata['ptype'] = kwargs.pop('ptype', None); metadata['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', False); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); metadata['max_frag'] = metadata['molecule'].nfragments(); if metadata['max_nbody'] == -1:; metadata['max_nbody'] = metadata['molecule'].nfragments(); else:; metadata['max_nbody'] = min(metadata['max_nbody'], metadata['max_frag']). # Flip this off for now, needs more testing; # If we are doing CP lets save them integrals; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # # Set to save RI integrals for repeated full-basis computations; # ri_ints_io = core.get_global_option('DF_INTS_IO'). # # inquire if above at all applies to dfmp2 or just scf; # core.set_global_optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:6275,Validat,ValidationError,6275,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"UPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(""""""CC property name %s not recognized"""""" % name.upper()). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; core.set_global_option('DERTYPE', 'RESPONSE'); core.cclambda(ccwfn); for prop in response:; core.set_global_option('PROPERTY', prop); core.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_globa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:78824,Validat,ValidationError,78824,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"URRENT CORRELATION ENERGY"",cemp4); elif (lowername == 'fnocc-mp') and (level == 4):; emp4 = psi4.get_variable(""MP4 TOTAL ENERGY""); cemp4 = psi4.get_variable(""MP4 CORRELATION ENERGY""); psi4.set_variable(""CURRENT ENERGY"",emp4); psi4.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore options; optstash.restore(). return psi4.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). psi4.set_local_option('FNOCC','RUN_CEPA', True); psi4.set_local_option('FNOCC','USE_DF_INTS', False). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise ValidationError(""Error: %s not implemented\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa_level = 'CEPA(0)'; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-cepa(1)'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(1)'; if (lowername == 'fno-cepa(3)'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(3)'; if (lowername == 'fno-acpf'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'ACPF'; if (lowername == 'fno-aqcc'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'AQCC'; if (lowername == 'fno-sdci'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'; if (lowername == 'fno-dci'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'. psi4.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level). # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; ra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:72745,Validat,ValidationError,72745,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"User-Defined Basis Sets. PSI Variables¶; To harness the power of Python, Psi4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:8729,access,accessed,8729,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['access'],['accessed']
Security,"VE/trove into GRAND_NEED/cbsrec. _contract_scheme_orders(); -------------------------; * prepare arguments for xtpl fns based on desired E/D/G/H quantity. * form extrapolated values for all available E/D/G/H quantities; * return structure of extrapolated values and filled-in GRAND_NEED/cbsrec. _summary_table(); ----------------; * build string table of cbs results. * form cbs qcvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:5053,validat,validator,5053,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validator']
Security,"VERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:93768,Validat,ValidationError,93768,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,7,['Validat'],['ValidationError']
Security,"VWN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/opt-1.html:6762,access,accesses,6762,psi4manual/4.0b5/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/opt-1.html,2,['access'],['accesses']
Security,"ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to match an exponent with one contraction: line %d: %s"""""" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions[p] = contraction. # We have a full shell, push it to the basis set; shell_list.append(ShellInfo(am, contractions, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')). elif len(shell_type) == 2:; # This is to handle instances of SP, PD, DF, FG, ...; am1 = shell_to_am[shell_type[0]]; am2 = shell_to_am[shell_type[1]]. exponents = [0.0] * nprimitive; contractions1 = [0.0] * nprimitive; contractions2 = [0.0] * nprimitive. for p in range(nprimitive):; line = lines[lineno]; lineno += 1; line = line.replace('D', 'e', 2); line = line.replace('d', 'e', 2). what = primitives2.match(line); # Must match primitivies2; if not what:; raise ValidationError(""Gaussian94BasisSetParser::parse: Unable to match an exponent with two contractions: line %d: %s"" % (lineno, line)); exponent = float(what.group(1)); contraction = float(what.group(2)). # Scale the contraction and save the information; contraction *= scale; exponents[p] = exponent; contractions1[p] = contraction. # Do the other contraction; contraction = float(what.group(3)). # Scale the contraction and save the information; contraction *= scale; contractions2[p] = contraction. shell_list.append(ShellInfo(am1, contractions1, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); shell_list.append(ShellInfo(am2, contractions2, exponents,; gaussian_type, 0, center, 0, 'Unnormalized')); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Unable to parse basis sets with spd, or higher grouping""""""); else:; raise ValidationError(""""""Gaussian94BasisSetParser::parse: Expected shell information, but got: line %d: %s"""""" % (lineno, line)); line = lines[lineno]; lineno += 1. break. if not found:; #raise BasisSetN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:7238,Validat,ValidationError,7238,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,1,['Validat'],['ValidationError']
Security,"ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the pass",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:115748,Validat,ValidationError,115748,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif kind not in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calcul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:119481,Validat,ValidationError,119481,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"ValidationError(""For UHF references the only valid values for 'KIND' are ""; ""'SPIN_FLIP' or 'ANY' and not '{}."".format(kind.upper())); elif not kind in [""singlet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and not ""cvs"" in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; try:; adcc.set_n_threads(core.get_num_threads()); except AttributeError:; # Before adcc 0.13.3:; adcc.thread_pool.reinit(core.get_num_threads(), core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:113463,Validat,ValidationError,113463,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']) # yes, this really must be global, not local to SCF. # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:66361,Validat,ValidationError,66361,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,ValidationError('Requested DELTA3 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn)). if 'delta3_wfn_lesser' in kwargs:; cbs_delta3_wfn_lesser = kwargs['delta3_wfn_lesser'].lower(); else:; cbs_delta3_wfn_lesser = 'mp2'; if not (cbs_delta3_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA3 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta3_wfn_lesser)). # Establish method for fourth delta correction energy; if 'delta4_wfn' in kwargs:; do_delta4 = 1; cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); if not (cbs_delta4_wfn in VARH.keys()):; raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)). if 'delta4_wfn_lesser' in kwargs:; cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); else:; cbs_delta4_wfn_lesser = 'mp2'; if not (cbs_delta4_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)). # Establish method for fifth delta correction energy; if 'delta5_wfn' in kwargs:; do_delta5 = 1; cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); if not (cbs_delta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and n,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:73332,Validat,ValidationError,73332,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"Variables)). [docs]class CoordEntry(object):; """"""Class to store all the attributes associated with an atom, not the; larger Molecule. Specialized into CartesianEntry and ZMatrixEntry. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label="""", basis=None, shells=None):; """"""Constructor""""""; # Order in full atomic list; self.PYentry_number = entry_number; # Whether the coordinates have been computed; self.computed = False; # Actual cartesian coordinates of the atom; self.coordinates = [None, None, None]; # Atomic number of the atom; self.PYZ = Z; # Charge of the atom (SAD-related); self.PYcharge = charge; # Mass of the atom; self.PYmass = mass; # Label of the atom minus any extra info (H1 => H); self.PYsymbol = symbol; # Original label from the molecule from the input file (H1); self.PYlabel = label; # Is this a ghost atom?; self.ghosted = False; # Different types of basis sets that can be assigned to this atom.; self.PYbasissets = basis if basis is not None else OrderedDict(); # Hash of one-atom BasisSet attached to this atom; self.PYshells = shells if shells is not None else OrderedDict(). @staticmethod; [docs] def r(a1, a2):; """"""Computes the distance between two sets of coordinates""""""; if len(a1) != 3 or len(a2) != 3:; raise ValidationError('ERROR: r() only defined for Vector3\n'); return distance(a1, a2). @staticmethod; [docs] def a(a1, a2, a3):; """"""Computes the angle (in rad.) between three sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3:; raise ValidationError('ERROR: a() only defined for Vector3\n'); eBA = sub(a2, a1); eBC = sub(a2, a3); eBA = normalize(eBA); eBC = normalize(eBC); costheta = dot(eBA, eBC). if costheta > 1.0 - 1.0E-14:; costheta = 1.0; if costheta < 1.0E-14 - 1.0:; costheta = -1.0; return math.acos(costheta). @staticmethod; [docs] def d(a1, a2, a3, a4):; """"""Computes the dihedral (in rad.) between four sets of coordinates.""""""; if len(a1) != 3 or len(a2) != 3 or len(a3) != 3 or len(a4) != 3:; raise ValidationErr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:6334,Hash,Hash,6334,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['Hash'],['Hash']
Security,"View with irreps. shape; Shape of the Psi4 data object. Methods Summary. array_interface(self). dim(self, h); Returns the dimensions of the vector per irrep h. from_array(arr[, name, dim1, dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_list(x). from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get_block(self, slice); Get a vector block. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. print_out(self); Prints the vector to the output file. scale(self, sc); Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set_block(self, slice, block); Set a vector block. to_array([copy, dense]); Converts a Psi4 Matrix or Vector to a numpy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Attributes Documentation. name¶; The name of the Vector. Used in printing. np¶; View without only one irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. array_interface(self: psi4.core.Vector) → list¶. dim(self: psi4.core.Vector, h: int) → int¶; Returns the dimensions of the vector per irrep h. classmethod from_array(arr, name='New Matrix', dim1=None, dim2=None)¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters:; arr (array or list of arrays) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (list, tuple, or core.Dimension (optional)) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 – Same as dim1 only if using a p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vector.html:1308,access,accessor,1308,psi4manual/1.2.1/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vector.html,1,['access'],['accessor']
Security,"WN3 (RPA) LSDA Functional. s_x; Slater LSDA Exchange. vwn3rpa_c; VWN3 (RPA) LSDA Correlation. vwn3_c; VWN3 LSDA Correlation. vwn5rpa_c; VWN5 (RPA) LSDA Correlation. vwn5_c; VWN5 LSDA Correlation. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/opt-1.html:6763,access,accesses,6763,psi4manual/4.0b4/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html,2,['access'],['accesses']
Security,"Watkins?; Just trying to kill some bugs sir!; -Starship Troopers""""""). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (occs[k], energies[k], potentials[k], convs[k])). optstash.restore(); return E. [docs]def frac_nuke(name: Union[str, Callable], **kwargs) -> Dict[float, float]:; """"""Pull all the electrons out, one at a time""""""; optstash = p4util.OptionsState(; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; [""SCF"", ""FRAC_START""],; [""SCF"", ""FRAC_RENORMALIZE""],; # NYI [""SCF"", ""FRAC_LOAD""],; [""SCF"", ""FRAC_OCC""],; [""SCF"", ""FRAC_VAL""],; [""SCF"", ""FRAC_DIIS""]). kwargs = p4util.kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molecular_charge() != 0:; raise ValidationError(""""""frac_nuke requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `frac_nuke` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # By default, we start the frac procedure on the 25th iteration; # when not reading a previous guess; frac_start = kwargs.get('frac_start', 25). # By default, we occupy by tenths of electrons; foccs = kwargs.get('foccs', [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]). # By default, HOMO and LUMO are both in alpha; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). charge = charge0; mult = mult0. # By default, nuke all the electrons; Nmin = 0; if 'nmax' in kwargs:; Nmin = N - int(kwargs['nmax'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:9770,Validat,ValidationError,9770,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,1,['Validat'],['ValidationError']
Security,"X (PSIMRCC). TIKHONOW_OMEGA (DCFT). (PSIMRCC). TIKHONOW_TRIPLES (PSIMRCC). TILE_SZ (SCF). TPDM (DCFT). (DETCI). TPDM_ABCD_TYPE (OCC). TPDM_ADD_REF (TRANSQT). TPDM_FILE (TRANSQT). TPDM_PRINT (DETCI). transition state; . geometry optimization. translate() LibmintsMolecule method. transpose() in module qcdb.vecutil. TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_LOW_MEMORY (FNOCC). TURN_ON_ACTV (MCSCF). TWO-ELECTRONENERGY. type() CartesianEntry method. NumberValue method. VariableValue method. ZMatrixEntry method. U. UNCP-CORRECTED2-BODYINTERACTIONENERGY. unique() LibmintsMolecule method. units; . molecule. UNITS (GLOBALS). units() LibmintsMolecule method. UPDATE (DETCI). update_geometry() LibmintsMolecule method. USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). useful() in module qcdb.dbproc. util module. V. VAL_EX_LEVEL (DETCI). valid_atom_map() LibmintsMolecule method. validate_bracketed_basis() in module wrappers. validate_scheme_args() in module wrappers. ValidationError, [1]. variable_to_string() NumberValue method. VariableValue method. VariableValue class in qcdb.libmintscoordentry. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). VECS_WRITE (DETCI). visualization. W. WABEI_LOWDISK (CCHBAR). WebMO. WFN (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CCTRIPLES). (CIS). (CLAG). (DETCI). (GLOBALS). (LMP2). (SCF). (TRANSQT). (TRANSQT2). WFN_SYM (MCSCF). (PSIMRCC). WFN_TYPE (OCC). wrappers module. WRITER_FILE_LABEL (GLOBALS). X. x() LibmintsMolecule method. XI (CCDENSITY). XI_CONNECT (CCDENSITY). xyz() LibmintsMolecule method. Y. y() LibmintsMolecule method. Z. Z() CoordEntry method. LibmintsMolecule method. z() LibmintsMolecule method. ZAPTnCORRELATIONENERGY. ZAPTnTOTALENERGY. zero() in module qcdb.vecutil. ZERO_INTERNAL_AMPS (PSIMRCC). ZETA (CCDENSITY). (CCLAMBDA). ZMatrixEntry class in qcdb.libmintscoordentry. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:45383,Validat,ValidationError,45383,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['Validat'],['ValidationError']
Security,"X. """"""; if isinstance(valueHI, float):. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI). core.print_out(cbsscheme). return valueHI. elif isinstance(valueHI, (core.Matrix, core.Vector)):. if verbose > 2:; core.print_out("""""" HI-zeta (%s) Total Energy:\n"""""" % (str(zHI))); valueHI.print_out(). return valueHI. [docs]def scf_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme using exponential form for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Halkier, Helgaker, Jorgensen, Klopper, & Olsen, Chem. Phys. Lett. 302 (1999) 437-446,; DOI: 10.1016/S0009-2614(99)00179-7. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}, \alpha = 1.63. """""". if type(valueLO) != type(valueHI):; raise ValidationError(""scf_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 1.63. beta_division = 1 / (math.exp(-1 * alpha * zLO) * (math.exp(-1 * alpha) - 1)); beta_mult = math.exp(-1 * alpha * zHI). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:6528,Validat,ValidationError,6528,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"YPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). # Clearly, add some logic when the reach of this fn expands; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF; ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; core.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerica",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:83083,Validat,ValidationError,83083,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adc_deprecated(*args, **kwargs):; warnings.warn(""The method 'adc' has been deprecated, please use 'adc2' instead.""; ""The method key 'adc' will be removed Psi4 1.6."", DeprecationWarning); return select_adc2(*args, **kwargs). def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). return core.adc(ref_wfn). def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.backends import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:110040,Validat,ValidationError,110040,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adc_deprecated(*args, **kwargs):; warnings.warn(""The method 'adc' has been deprecated, please use 'adc2' instead.""; ""The method key 'adc' will be removed Psi4 1.6."", DeprecationWarning); return select_adc2(*args, **kwargs). def run_adc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). warnings.warn(""Using built-in `adc` module instead of add-on `adcc` interface is deprecated due ""; ""to certain wrong results, and as soon as 1.7, it will stop working."", category=FutureWarning). error_msg = (""\n\t\t\t\t!!!!! WARNING !!!!!\n"" +; ""\t\tThe built-in ADC(2) method may give incorrect results if\n""; ""\t\tmultiple roots are requested, due to an error in the Davidson solver,\n""; ""\t\tand is no longer maintained. It is slated for removal in Psi4 1.7.\n""; ""\t\tUse of the Psi interface to `adcc` instead is strongly recommended.\n""). core.print_out(error_msg). wfn = core.adc(ref_wfn). core.print_out(error_msg). return wfn. def run_adcc(name, **kwargs):; """"""Pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:111714,Validat,ValidationError,111714,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, (str, bytes)):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:14242,Validat,ValidationError,14242,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,8,['Validat'],['ValidationError']
Security,"[ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. Warning; The following will lead to reference errors: view =; psi4.Matrix(3, 3).np. Here, the Python garbage collection deletes the Matrix; object, the view then points to deleted data resulting in the view effectively; reading random data. As a general rule, never assign the .nph or .np; accessors. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; 1; 2; 3; 4; 5; 6; 7; 8>>> dim = psi4.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None)[source]¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters:; arr (array or list of arrays) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (list, tuple, or core.Dimension (optional)) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 – Same as dim1 only if using a Psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/numpy-1.html:2808,access,accessor,2808,psi4manual/1.1.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/numpy-1.html,2,['access'],['accessor']
Security,"['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). core.set_local_option('FNOCC', 'DFCC', True); core.set_local_option('FNOCC', 'RUN_CEPA', False). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""""""Error: {name} requires 'reference rhf'.""""""). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_global_option('SCF_TYPE') not in ['CD', 'DISK_DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenfl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:153333,Validat,ValidationError,153333,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); try:; database = __import__(db_name); except ImportError:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:30008,Validat,ValidationError,30008,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"['return_wfn'] = kwargs.pop('return_wfn', False); metadata['return_total_data'] = kwargs.pop('return_total_data', None); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['embedding_charges'] = kwargs.get('embedding_charges', False); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). if metadata['return_total_data'] is None:; if metadata['ptype'] in ['gradient', 'hessian']:; metadata['return_total_data'] = True; else:; metadata['return_total_data'] = False. # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); if metadata['molecule'].nfragments() == 1:; raise ValidationError(""N-Body requires active molecule to have more than 1 fragment.""); metadata['max_frag'] = metadata['molecule'].nfragments(); if metadata['max_nbody'] == -1:; metadata['max_nbody'] = metadata['molecule'].nfragments(); else:; metadata['max_nbody'] = min(metadata['max_nbody'], metadata['max_frag']). # Flip this off for now, needs more testing; # If we are doing CP lets save them integrals; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # # Set to save RI integrals for repeated full-basis computations; # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:8378,Validat,ValidationError,8378,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['Validat'],['ValidationError']
Security,"[0]. if sum(active_mask) == 0:; break. # Update p; z_vec = preconditioner(r_vec, active_mask); for x in active:; beta = r_vec[x].vector_dot(z_vec[x]) / rz_old[x]; p_vec[x].scale(beta); p_vec[x].axpy(1.0, z_vec[x]). if printlvl:; core.print_out("" -----------------------------------------------------\n""). return x_vec, r_vec. [docs]class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs] def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs] def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del sel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:6600,Validat,ValidationError,6600,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,1,['Validat'],['ValidationError']
Security,"[]; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = p4util.drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""The \""properties\"" keyword is required with the property() function.""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if (n_invalid > 0):; print(""The following properties are not currently supported: %s"" % invalid). if (n_excited > 0 and (name.lower() != 'eom-ccsd' and name.lower() != 'eom-cc2')):; raise ValidationError(""Excited state CC properties require EOM-CC2 or EOM-CCSD.""). if ((name.lower() == 'eom-ccsd' or name.lower() == 'eom-cc2') and n_response > 0):; raise ValidationError(""Cannot (yet) compute response properties for excited states.""). if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""Computing both density- and response-based properties.""). if (name.lower() == 'ccsd'):; psi4.set_global_option('WFN', 'CCSD'); run_ccenergy('ccsd', **kwargs); psi4.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'cc2'):; psi4.set_global_option('WFN', 'CC2'); run_ccenergy('cc2', **kwargs); psi4.set_global_option('WFN', 'CC2'); elif (name.lower() == 'eom-ccsd'):; psi4.set_global_option('WFN', 'EOM_CCSD'); run_ccenergy('eom-ccsd', **kwargs); psi4.set_global_option('WFN', 'EOM_CCSD'); elif (name.lower() == 'eom-cc2'):; psi4.set_global_option('WFN', 'EOM_CC2'); run_ccenergy('eom-cc2', **kwargs); psi4.set_global_option('WFN', 'EOM_CC2'). # Need cchbar for everything; psi4.cchbar(). # Need ccdensity at this point only for density-based props; if (n_one > 0 or n_two > 0):; if (name.lower() == 'eom-ccsd'):; psi4.set_global_option('WFN', 'EOM_CCSD'); psi4.set_globa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:29849,Validat,ValidationError,29849,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.driver.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.driver_cbs_helper. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:22090,Validat,ValidationError,22090,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa_level = 'CEPA(0)'; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-cepa(1)'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(1)'; if (lowername == 'fno-cepa(3)'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(3)'; if (lowername == 'fno-acpf'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'ACPF'; if (lowername == 'fno-aqcc'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'AQCC'; if (lowername == 'fno-sdci'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'; if (lowername == 'fno-dci'):; psi4.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'. psi4.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level). # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""Error: %s requires \""reference rhf\""."" % lowername). psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; mints = psi4.MintsHelper(); mints.integrals(). if psi4.get_option('FNOCC','NAT_ORBS') == False:; if psi4.get_option('FNOCC', 'USE_DF_INTS') == False:; psi4.set_local_option('TRANSQT2', 'WFN', 'CCSD'); psi4.transqt2(). # run cepa; psi4.fnocc(). # one-electron properties; if psi4.get_option('FNOCC', 'DIPMOM'):; if cepa_level == ""CEPA(1)"" or cepa_level == ""CEPA(3)"":; psi4.print_out(""\n""); psi4.print_out("" Error: one-electron properties not implemented for %s\n"" % lowername); psi4.print_out(""\n""); elif psi4.get_option('FNOCC','NAT_ORBS'):; psi4.print_out(""\n""); psi4.print_out("" Error: one-electron properties not implemented f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:73785,Validat,ValidationError,73785,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_for_psi4(self):; """"""Returns a string of Mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:2844,Validat,ValidationError,2844,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,2,['Validat'],['ValidationError']
Security,"\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline = xyz2.match(text[1]).group(3).strip(); else:; instance.tagline = text[1].strip(). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzN.match(text[2 + i]):. fileAtom = xyzN.match(text[2 + i]).group(1).upper(); fileX = float(xyzN.match(text[2 + i]).group(2)); fileY = float(xyzN.match(text[2 + i]).group(3)); fileZ = float(xyzN.match(text[2 + i]).group(4)). # Check that the atom symbol is valid; if not fileAtom in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). # Add it to the molecule.; instance.add_atom(el2z[fileAtom], fileX, fileY, fileZ, fileAtom, el2masses[fileAtom]). else:; raise ValidationError(""Molecule::init_with_xyz: Malformed atom information line %d."" % (i + 3)); except IndexError:; raise ValidationError(""Molecule::init_with_xyz: Expected atom in file at line %d.\n%s"" % (i + 3, text[i + 2])). # We need to make 1 fragment with all atoms; instance.fragments.append([0, fileNatom - 1]); instance.fragment_types.append('Real'); instance.fragment_charges.append(instance.molecular_charge()); instance.fragment_multiplicities.append(instance.multiplicity()); # Set the units properly; instance.PYunits = fileUnits; if fileUnits == 'Bohr':; instance.input_units_to_au = 1.0; elif fileUnits == 'Angstrom':; instance.input_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. [docs] def save_string_xyz(self, save_ghosts=True):; """"""Save a str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:3727,Validat,ValidationError,3727,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"] * len(ZETA); BSET = []. for lvl in needarray.iteritems():; BSET.append(lvl[1]['f_basis']). if (len(BSET) == 1):; basisstring = BSET[0]; else:; indx = 0; while indx < len(BSET[0]):; if (BSET[0][indx] != BSET[1][indx]):; zetaindx = indx; indx += 1; for basis in BSET:; ZSET[ZETA[basis[zetaindx]] - 2] = basis[zetaindx]. pre = BSET[0][:zetaindx]; post = BSET[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post. return basisstring. [docs]def highest_1(**largs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) == 0):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; if (wfnname == 'scf'):; portion = 'tot'; else:; portion = 'corl'; NEED = {'HI': dict(zip(f_fields, [wfnname, portion, BSET[len(ZSET) - 1], ZSET[len(ZSET) - 1], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; # Compute extrapolated energy; energypiece = NEED['HI']['f_energy']. # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); if (NEED['HI']['f_wfn'] == 'scf'):; cbsscheme += """""" HI-zeta (%s) Total Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); else:; cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(NEED['HI']['f_zeta']), energypiece); PsiMod.print_out(cbsscheme). return energypiece. # Solution equation in LaTeX: $E_{corl}^{\infty} = \frac{E_{corl}^{X} X^3 - E_{corl}^{X-1} (X-1)^3}{X^3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:77740,Validat,ValidationError,77740,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"] def label(self):; """"""The atom label.""""""; return self.PYlabel. [docs] def entry_number(self):; """"""The order in which this appears in the full atom list.""""""; return self.PYentry_number. [docs] def set_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basissets(self):; """"""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coord",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:10570,hash,hash,10570,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['hash'],['hash']
Security,"] for atoms.; real (ndarray of bool) – (nat, ) Real/ghostedness for atoms.; elbl (ndarray of str) – (nat, ) Label with any tagging information from element spec.; fragment_separators (list of int) – (nfr - 1, ) list of atom indices at which to split geom into fragments.; fragment_charges (list of float) – (nfr, ) list of charge allocated to each fragment.; fragment_multiplicities (list of int) – (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge (float) – total charge on system.; molecular_multiplicity (int) – total multiplicity on system.; comment (str, optional) – Additional comment for molecule.; provenance (dict of str) – Accumulated history of molecule, with fields “creator”, “version”, “routine”.; connectivity (list of tuples of int, optional) – (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples; EFP extension (this + units is minimal); fragment_files (list of str) – (nfr, ) lowercased names of efp meat fragment files.; hint_types ({‘xyzabc’, ‘points’}) – (nfr, ) type of fragment orientation hint.; geom_hints (list of lists of float) – (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment.; QMVZ extension (geom_unsettled replaces geom); geom_unsettled (list of lists of str) – (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables (list of pairs) – (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; qcelemental.ValidationError – For most anything wrong. class qcelemental.ValidationError(msg)[source]¶; Error called for problems with syntax input file. Prints; error message msg to standard output stream. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .  · ; 1.4;  · . PSI4. External API Objects. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external_apis-1.html:10322,Validat,ValidationError,10322,psi4manual/1.4.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external_apis-1.html,4,['Validat'],['ValidationError']
Security,"] for atoms.; real (ndarray of bool) – (nat, ) Real/ghostedness for atoms.; elbl (ndarray of str) – (nat, ) Label with any tagging information from element spec.; fragment_separators (list of int) – (nfr - 1, ) list of atom indices at which to split geom into fragments.; fragment_charges (list of float) – (nfr, ) list of charge allocated to each fragment.; fragment_multiplicities (list of int) – (nfr, ) list of multiplicity allocated to each fragment.; molecular_charge (float) – total charge on system.; molecular_multiplicity (int) – total multiplicity on system.; comment (str, optional) – Additional comment for molecule.; provenance (dict of str) – Accumulated history of molecule, with fields “creator”, “version”, “routine”.; connectivity (list of tuples of int, optional) – (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples; EFP extension (this + units is minimal); fragment_files (list of str) – (nfr, ) lowercased names of efp meat fragment files.; hint_types ({‘xyzabc’, ‘points’}) – (nfr, ) type of fragment orientation hint.; geom_hints (list of lists of float) – (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment.; QMVZ extension (geom_unsettled replaces geom); geom_unsettled (list of lists of str) – (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables (list of pairs) – (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; qcelemental.ValidationError – For most anything wrong. class qcelemental.ValidationError(msg)[source]¶; Error called for problems with syntax input file. Prints; error message msg to standard output stream. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .  · ; 1.5;  · . PSI4. External API Objects. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/external_apis-1.html:10322,Validat,ValidationError,10322,psi4manual/1.5.0/external_apis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/external_apis-1.html,4,['Validat'],['ValidationError']
Security,"]) == 3:; self.constructor_schoenflies_origin(*args); elif len(args) == 2 and \; isinstance(args[0], int) and \; len(args[1]) == 3:; self.constructor_bits_origin(*args); else:; raise ValidationError('BasisSet::constructor: Inappropriate configuration of constructor arguments'). # <<< Methods for Construction >>>. # libmints: These 2 constructors do not work right now.; [docs] def constructor_schoenflies(self, s):; """"""This constructor takes a string containing the Schoenflies; symbol of the point group as its only argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = [0.0, 0.0, 0.0]. [docs] def constructor_schoenflies_origin(self, s, origin):; """"""Like the above, but this constructor also takes a point of; origin as an argument. """"""; self.PYbits = self.full_name_to_bits(s); if self.PYbits is None:; raise ValidationError('PointGroup: Unknown point group name provided.'); self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = origin. [docs] def constructor_bits(self, bits):; """"""Using the bitwise representation constructor the point group; object. """"""; self.PYbits = bits; self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = [0.0, 0.0, 0.0]. [docs] def constructor_bits_origin(self, bits, origin):; """"""Using the bitwise representation constructor the point group; object. """"""; self.PYbits = bits; self.symb = self.bits_to_basic_name(self.PYbits); self.PYorigin = origin. # <<< Simple Methods for Basic PointGroup Information >>>. [docs] def symbol(self):; """"""Returns the Schoenflies symbol for this point group.""""""; return self.symb. [docs] def set_symbol(self, sym):; """"""Sets (or resets) the Schoenflies symbol.""""""; self.symb = sym if (len(sym) > 0) else 'c1'. [docs] def origin(self):; """"""Returns the origin of the symmetry frame.""""""; return self.PYorigin. [docs] def bits(self):; """"""Returns the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:39813,Validat,ValidationError,39813,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"], psi4.core.Matrix]) → None¶; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.iteration_energies; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbital_gradient(); HF.compute_spin_contamination(); HF.cphf_Hx(); HF.cphf_converged(); HF.cphf_solve(); HF.damping_update(); HF.diis(); HF.finalize(); HF.finalize_energy(); HF.find_occupation(); HF.form_C(); HF.form_D(); HF.form_F(); HF.form_FDSmSDF(); HF.form_G(); HF.form_H(); HF.form_Shalf(); HF.form_V(); HF.form_initial_C(); HF.form_initial_F(); HF.frac_renormalize(); HF.functional(); HF.get_energies(); HF.guess()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:11282,Validat,ValidationError,11282,psi4manual/1.9.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html,1,['Validat'],['ValidationError']
Security,"], psi4.core.Matrix]) → None¶; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str) → List[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbital_gradient(); HF.compute_spin_contamination(); HF.cphf_Hx(); HF.cphf_converged(); HF.cphf_solve(); HF.damping_update(); HF.diis(); HF.finalize(); HF.finalize_energy(); HF.find_occupation(); HF.form_C(); HF.form_D(); HF.form_F(); HF.form_FDSmSDF(); HF.form_G(); HF.form_H(); HF.form_Shalf(); HF.form_V(); HF.form_initial_C(); HF.form_initial_F(); HF.frac_renormalize(); HF.functional(); HF.get_energies(); HF.guess(); HF.guess_Ca(); HF.gue",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html:11236,Validat,ValidationError,11236,psi4manual/1.8.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.HF.html,1,['Validat'],['ValidationError']
Security,"], psi4.core.Matrix]) → None¶; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK) → None¶; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: list[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: list[psi4.core.BasisSet]) → None¶; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int) → int¶; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF) → bool¶; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: list[psi4.core.Matrix], arg1: bool, arg2: str) → list[psi4.core.Matrix]¶; Two-electron Hessian-vector products. validate_diis()¶; Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError – If any of DIIS options don’t play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.iteration_energies; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbital_gradient(); HF.compute_spin_contamination(); HF.cphf_Hx(); HF.cphf_converged(); HF.cphf_solve(); HF.damping_update(); HF.diis(); HF.finalize(); HF.finalize_energy(); HF.find_occupation(); HF.form_C(); HF.form_D(); HF.form_F(); HF.form_FDSmSDF(); HF.form_G(); HF.form_H(); HF.form_Shalf(); HF.form_V(); HF.form_initial_C(); HF.form_initial_F(); HF.frac_renormalize(); HF.functional(); HF.get_energies(); HF.guess()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.HF.html:11289,Validat,ValidationError,11289,psi4manual/master/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.HF.html,1,['Validat'],['ValidationError']
Security,"],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if core.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['mp2.5', 'omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['mp3', 'omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); elif name in ['ccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); elif name in ['ccsd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); else:; raise ValidationError('Unidentified method %s' % (name)). if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; purea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:46594,Validat,ValidationError,46594,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if psi4.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2', 'omp2']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['mp2.5', 'omp2.5']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['mp3', 'omp3']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['lccd', 'olccd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); elif name in ['ccd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); psi4.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); elif name in ['ccsd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); psi4.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); else:; raise ValidationError('Unidentified method %s' % (name)). if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_global_option('DERTYPE', 'FIRST'); psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def ru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:37829,Validat,ValidationError,37829,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"],; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.qcdb.molecule. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html:67214,Validat,ValidationError,67214,psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"]. # <<< Changeable (Cfour) >>>. # Molecule; self.Cmol = molChangeable; # Vector to shift Cmol to center of mass; self.Cshift = []; # Matrix to rotate Cmol to inertial frame; self.Crotate = []; # Matrix to rotate Cmol to axis representation of Pmol; self.Cexchflip = []; # Vector to map Cmol to atom ordering of Pmol; self.Catommap = []. try:; if ((self.Pmol.nallatom() == self.Cmol.nallatom()) and \; (abs(self.Pmol.nuclear_repulsion_energy() - self.Cmol.nuclear_repulsion_energy()) < 1.0e-3)):; self.create_orientation_from_molecules(self.Pmol, self.Cmol); else:; print('qcdb.orient.__init__ debug info'); self.Pmol.print_out(); print('natom', self.Pmol.natom(), 'NRE', self.Pmol.nuclear_repulsion_energy(), 'rotor', self.Pmol.rotor_type()); self.Cmol.print_out(); print('natom', self.Cmol.natom(), 'NRE', self.Cmol.nuclear_repulsion_energy(), 'rotor', self.Cmol.rotor_type()); raise ValidationError(""""""OrientMols Molecule arguments differ fatally.""""""); except AttributeError:; raise ValidationError(""""""OrientMols must be instantiated with two qcdb.Molecule objects.""""""). def __str__(self):; text = """""" ==> qcdb OrientMols <==\n\n""""""; text += """""" natom: %d\n\n"""""" % (self.Pmol.natom()); text += """""" PNRE: %16.8f\n"""""" % (self.Pmol.nuclear_repulsion_energy()); text += """""" Pshift: %s\n"""""" % (self.Pshift); text += """""" Protate: %s\n"""""" % (self.Protate); text += """"""\n CNRE: %16.8f\n"""""" % (self.Cmol.nuclear_repulsion_energy()); text += """""" Cshift: %s\n"""""" % (self.Cshift); text += """""" Crotate: %s\n"""""" % (self.Crotate); text += """""" Cexchflip: %s\n"""""" % (self.Cexchflip); text += """""" Catommap: %s\n"""""" % (self.Catommap); return text. [docs] def create_orientation_from_molecules(self, Pmol, Cmol):; """"""Finds the shift, rotation, axis exchange, axis inversion,; and atom remapping necessary to bring the geometry of *Cmol*; into coincidence with the geometry of *Pmol*. *Pmol* and *Cmol*; must be :py:class:`qcdb.Molecule` and represent the same; geometry. Presently catches some errors of orientation th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html:3360,Validat,ValidationError,3360,psi4manual/1.0.0/_modules/qcdb/orient.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html,1,['Validat'],['ValidationError']
Security,"]. if sum(active_mask) == 0:; break. # Update p; z_vec = preconditioner(r_vec, active_mask); for x in active:; beta = r_vec[x].vector_dot(z_vec[x]) / rz_old[x]; p_vec[x].scale(beta); p_vec[x].axpy(1.0, z_vec[x]). if printlvl:; core.print_out("" -----------------------------------------------------\n""). return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:6606,Validat,ValidationError,6606,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,3,['Validat'],['ValidationError']
Security,"].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; elif len(BSTC) > 2:; raise ValidationError(""""""Cannot extrapolate correlation with %d basis sets. Use highest 2."""""" % (len(BSTC))); else:; cbs_corl_scheme = xtpl_highe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:46462,Validat,ValidationError,46462,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:37961,Validat,ValidationError,37961,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"]['DFT_RADIAL_POINTS']['value'] = 100; text += """"""wpbe')\n\n"""""". elif lowername == 'ccsd-polarizability':; options['GLOBALS']['FREEZE_CORE']['value'] = True; text = """"""property('ccsd', properties=['polarizability'])\n\n"""""". elif lowername == 'mrccsdt(q)':; options['SCF']['SCF_TYPE']['value'] = 'pk'; options['GLOBALS']['FREEZE_CORE']['value'] = True; options['GLOBALS']['NAT_ORBS']['value'] = True # needed by mrcc but not recognized by mrcc; options['FNOCC']['OCC_TOLERANCE']['value'] = 6; text += """"""mrccsdt(q)')\n\n"""""". elif lowername == 'c4-ccsdt(q)':; options['CFOUR']['CFOUR_SCF_CONV']['value'] = 11; options['CFOUR']['CFOUR_CC_CONV']['value'] = 10; options['CFOUR']['CFOUR_FROZEN_CORE']['value'] = True; text += """"""c4-ccsdt(q)')\n\n"""""". elif lowername == 'df-m05-2x':; options['SCF']['SCF_TYPE']['value'] = 'df'; options['SCF']['DFT_SPHERICAL_POINTS']['value'] = 302; options['SCF']['DFT_RADIAL_POINTS']['value'] = 100; text += """"""m05-2x')\n\n"""""". else:; raise ValidationError(""""""Requested Psi4 computational methods %d is not available."""""" % (lowername)). # # Set clobbering; # if 'CFOUR_DERIV_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_DERIV_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_DERIV_LEVEL']['superclobber'] = True; # if 'CFOUR_CALC_LEVEL' in options['CFOUR']:; # options['CFOUR']['CFOUR_CALC_LEVEL']['clobber'] = True; # options['CFOUR']['CFOUR_CALC_LEVEL']['superclobber'] = True; # if 'CFOUR_CC_PROGRAM' in options['CFOUR']:; # options['CFOUR']['CFOUR_CC_PROGRAM']['clobber'] = False. return text, options. procedures = {; 'energy': {; 'df-b97-d3' : muster_modelchem,; 'df-wb97x-d' : muster_modelchem,; 'df-b3lyp-d3' : muster_modelchem,; 'mp2' : muster_modelchem,; 'df-mp2' : muster_modelchem,; 'sapt0' : muster_modelchem,; 'sapt2+' : muster_modelchem,; 'sapt2+(3)' : muster_modelchem,; 'sapt2+3(ccd)' : muster_modelchem,; 'mrccsdt(q)' : muster_modelchem,; 'c4-ccsdt(q)' : muster_modelchem,; 'ccsd-polarizability' : muster_modelchem,; 'dfdf-b2plyp-d3': muste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html:9941,Validat,ValidationError,9941,psi4manual/1.0.0/_modules/qcdb/psi4.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/psi4.html,1,['Validat'],['ValidationError']
Security,"_BASIS_SAPT is required.'). PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'). e_sapt = PsiMod.dftsapt(wfn_dimer,wfn_monomerA,wfn_monomerB). molecule.reset_point_group(user_pg); molecule.update_geometry(). PsiMod.set_global_option('DF_INTS_IO', df_ints_io). optstash.restore(); return e_sapt. [docs]def run_infsapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a INF-SAPT0 calculation of any level. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); if (sapt_basis == 'di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:54782,Validat,ValidationError,54782,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"_CC2'); else:; raise ValidationError(""Unknown excited-state CC wave function.""); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.set_global_option('ONEPDM', 'TRUE'); PsiMod.cceom(); PsiMod.cclambda(); PsiMod.ccdensity(). PsiMod.set_global_option('WFN', 'SCF'); PsiMod.revoke_global_option_changed('WFN'); PsiMod.set_global_option('DERTYPE', 'NONE'); PsiMod.revoke_global_option_changed('DERTYPE'). [docs]def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). PsiMod.set_global_option('ONEPDM', 'TRUE'); PsiMod.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; #PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF') # insufficient b/c SCF option read in DFMP2; PsiMod.set_global_option('SCF_TYPE', 'DF'). if not PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 properties need DF-SCF reference, for now.'). if 'restart_file' in kwargs:; restartfile = kwargs.pop('restart_file'); # Rename the checkpoint file to be consistent with psi4's file system; psioh = PsiMod.IOManager.shared_object(); psio = PsiMod.IO.shared_object(); filepath = psioh.get_file_path(32); namespace = psio.get_default_namespace(); pid = str(os.getpid()); prefix = 'psi'; targetfile = filepath + prefix + '.' + pid + '.' + namespace + '.32'; if(PsiMod.me() == 0):; shutil.copy(restartfile, targetfile); else:; # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). scf_helper(name, **kwargs). PsiMod.print_out('\n'); bann",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:30372,Validat,ValidationError,30372,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). return optstash. [docs]def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES',; 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES',; 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI',; 'NO_OCCUPATIONS']. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)); . [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'CD', 'PK', 'DIRECT']:; mints = psi4.MintsHelper(wfn.basisset()); mints.set_print(1); mints.integrals(). [docs]def check_non_symmetric_jk_density(name):; """"""; Ensure non-symmetric density matrices are supported for the selected JK routine.; """"""; scf_type = psi4.get_option('SCF', 'SCF_TYPE'); supp_jk_type = ['DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html:3628,Validat,ValidationnError,3628,psi4manual/1.0.0/_modules/procedures/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html,1,['Validat'],['ValidationnError']
Security,_SPHERICAL_POINTS (GLOBALS). MCSCF. theory. MCSCF TOTAL ENERGY. mcscf() in module psi4.core. MCSCF_ALGORITHM (DETCI). MCSCF_CI_CLEANUP (DETCI). MCSCF_DIIS_ERROR_TYPE (DETCI). MCSCF_DIIS_FREQ (DETCI). MCSCF_DIIS_MAX_VECS (DETCI). MCSCF_DIIS_START (DETCI). MCSCF_DPD_CLEANUP (DETCI). MCSCF_E_CONVERGENCE (DETCI). MCSCF_GUESS (DETCI). MCSCF_MAX_ROT (DETCI). MCSCF_MAXITER (DETCI). mcscf_object() psi4.core.CIWavefunction method. MCSCF_R_CONVERGENCE (DETCI). MCSCF_ROTATE (DETCI). MCSCF_SO_START_E (DETCI). MCSCF_SO_START_GRAD (DETCI). MCSCF_TYPE (DETCI). mdi_run() in module psi4.driver. MemDFJK class in psi4.core. memory. memory_estimate() psi4.core.JK method. message psi4.driver.ConvergenceError attribute. psi4.driver.ManagedMethodError attribute. psi4.driver.MissingMethodError attribute. psi4.driver.OptimizationConvergenceError attribute. psi4.driver.SCFConvergenceError attribute. psi4.driver.TDSCFConvergenceError attribute. psi4.driver.TestComparisonError attribute. psi4.driver.ValidationError attribute. message_box() in module psi4.driver. in module psi4.driver.p4util. meta_cutoff() psi4.core.Functional method. metadata psi4.driver.driver_cbs.CompositeComputer attribute. metameta psi4.driver.driver_cbs.CompositeComputer attribute. psi4.driver.driver_findif.FiniteDifferenceComputer attribute. method psi4.driver.AtomicComputer attribute. psi4.driver.driver_cbs.CompositeComputer attribute. psi4.driver.driver_findif.FiniteDifferenceComputer attribute. psi4.driver.driver_nbody.ManyBodyComputer attribute. method alias. ; adding new. metric() psi4.core.FDDS_Dispersion method. metric_inv() psi4.core.FDDS_Dispersion method. MIN_CCD_DIISVECS (SAPT). MINAO_BASIS (FISAPT). MintsHelper class in psi4.core. mintshelper() psi4.core.CUHF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. MissingMethodError. MIXED (DETCI). MIXED4 (DETCI). Mk-MRCC. MKL_NUM_THREADS. MO_DIIS_NUM_VECS (DFOCC). mo_elec_dip_deriv1() psi4.core.MintsHelper me,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:72224,Validat,ValidationError,72224,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['Validat'],['ValidationError']
Security,"__init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vector_dot(e2); B[num1, num2] = B[num2, num1] = val. # Build residual vector; resid = np.zeros(diis_count + 1); resid[-1] = 1. # Solve pulay equations. # Yea, yea this is unstable make it stable; iszero = np.any(np.diag(B)[:-1] <= 0.0); if iszero:; S = np.ones((diis_count + 1)); else:; S = np.diag(B).copy(); S[:-1] **= -0.5; S[-1] = 1. # Then we gotta do a custom inverse; B *= S[:, None] * S; invB = core.Matrix.from_array(B); invB.power(-1.0, 1.e-12). ci =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:7368,Validat,ValidationError,7368,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,3,['Validat'],['ValidationError']
Security,"__version__ = '1.1rc1'; __version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> cat metadata.out.py | head -8; __version__ = '1.1rc2.dev1'; __version_branch_name = 'master'; __version_cmake = '1.0.0.999'; __version_is_clean = 'True'; __version_last_release = '1.0'; __version_long = '1.1rc2.dev1+4e0596e'; __version_prerelease = 'False'; __version_release = 'False'. >>> git log --oneline; 4e0596e Records tag for v1.1rc1; 6100822 v1.1rc1; cbee32b Fixes pcmsolver/scf for py3. Moves source for libefp upstream. ACT to inform remote of bump. Temporarily disengage “Include administrators” on protected master branch. >>> git push origin master; >>> git push origin v1.1rc1. Now https://github.com/psi4/psi4/releases says v1.1rc1 & 6100822. How to create and remove an annotated Git tag on a remote¶; PSI4 versioning only works with annotated tags, not lightweight; tags as are created with the GitHub interface. Create annotated tag:; >>> git tag -a v1.1a1 <git hash if not current> -m ""v1.1a1""; >>> git push origin v1.1a1. Delete tag:; >>> git tag -d v1.1a1; >>> git push origin :refs/tags/v1.1a1. Pull tags:; >>> git fetch <remote> 'refs/tags/*:refs/tags/*'. What Psi4 version is running¶. Psithon / from the executable:; >>> psi4 --version; 1.1rc2.dev17. PsiAPI / from the library:; >>> python -c ""import psi4; print(psi4.__version__)""; 1.1rc2.dev17. Output file header gives info like the print_header() below.; Function print_header() returns a summary of citation, version, and; git information about PSI4. Function version_formatter() can; return version and git information in any desired format string.; >>> import psi4; >>> psi4.print_header(). -----------------------------------------------------------------------; Psi4: An Open-Source Ab Initio Electronic Structure Package; Psi4 1.1rc2.dev17. Git: Rev {condadoc} c852257 dirty. R. M. Parrish, L. A. Burns, D. G. A. Smith, A. C. Simmonett,; A. E. DePrince III, E. G. Hohenstein, U. Bozkaya, A. Yu. Sokolov,; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_git.html:4497,hash,hash,4497,psi4manual/master/manage_git.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_git.html,9,['hash'],['hash']
Security,"__writer_file_label| . :examples:. >>> # [1] DMA analysis from MP2 wavefunction. N.B. gradient must be requested to generate MP2 density.; >>> grad, wfn = gradient('mp2', return_wfn=True); >>> gdma(wfn). """"""; # Start by writing a G* checkpoint file, for the GDMA code to read in; fw = core.FCHKWriter(wfn); molname = wfn.molecule().name(); prefix = core.get_writer_file_prefix(molname); fchkfile = prefix + '.fchk'; fw.write(fchkfile). if datafile:; commands = datafile; else:; if wfn.reference_wavefunction():; densname = ""CC""; else:; densname = ""SCF""; commands = 'psi4_dma_datafile.dma'; radii = core.get_option('GDMA', 'GDMA_RADIUS'); origin = core.get_option('GDMA', 'GDMA_ORIGIN'); with open(commands, 'w') as f:; f.write(""File %s Density %s\n"" % (fchkfile, densname)); f.write(""Angstrom\n""); f.write(""%s\n"" % core.get_option('GDMA', 'GDMA_MULTIPOLE_UNITS')); f.write(""Multipoles\n""); if origin:; try:; f.write(""Origin %f %f %f\n"" % (float(origin[0]), float(origin[1]), float(origin[2]))); except:; raise ValidationError(""The GDMA origin array should contain three entries: x, y, and z.""); f.write(""Switch %f\n"" % core.get_option('GDMA', 'GDMA_SWITCH')); if radii:; f.write(""Radius %s\n"" % "" "".join([str(r) for r in radii])); f.write(""Limit %d\n"" % core.get_option('GDMA', 'GDMA_LIMIT')); f.write(""Start\n""); f.write(""Finish\n""); core.run_gdma(wfn, commands). os.remove(fchkfile); # If we generated the DMA control file, we should clean up here; if not datafile:; os.remove(commands). [docs]def fchk(wfn, filename):; """"""Function to write wavefunction information in *wfn* to *filename* in; Gaussian FCHK format. .. versionadded:: 0.6. :returns: None. :type filename: string; :param filename: destination file name for FCHK file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate fchk file. Notes; -----; * A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; * The allowed heade",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:80103,Validat,ValidationError,80103,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:41171,Validat,ValidationError,41171,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.ha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:39100,Validat,ValidationError,39100,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compare two cube files. compare_fcidumps(expected, computed, label); Function to compare two FCIDUMP files. compare_integers(expected, computed, label); Function to compare two integers. compare_matrices(expected, computed, digits, …); Function to compare two matrices. compare_strings(expected, computed, label); Function to compare two strings. compare_values(expected, computed, digits, label); Function to compare two values. compare_vectors(expected, computed, digits, …); Function to compare two vectors. copy_file_from_scratch(filename, prefix, …); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, …); Function to move file into scratch with correct naming convention. create_plugin(name, template); Generate plugin in directory with sanitized name based upon template. csx2endict(); Grabs the CSX file as a dictionary, encodes translation of PSI variables to XML blocks, gathers all available energies from CSX file into returned dictionary. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:258947,sanitiz,sanitized,258947,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['sanitiz'],['sanitized']
Security,"_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); else:; raise ValidationError('Unidentified method ' % (name)). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if core.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:48437,Validat,ValidationError,48437,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish list of valid basis sets for third delta correction energy; if do_delta3:; if 'delta3_basis' in kwargs:; BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); else:; raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')). # Establish list of valid basis sets for fourth delta correction energy; if do_delta4:; if 'delta4_basis' in kwargs:; BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); else:; raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')). # Establish list of valid basis sets for fifth delta correction energy; if do_delta5:; if 'delta5_basis' in kwargs:; BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); else:; raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:76355,Validat,ValidationError,76355,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec cbsbanners. # Call schemes for each portion of total energy to 'place order",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:64923,Validat,ValidationError,64923,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); cbs_scf_scheme = highest_1; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; cbs_corl_scheme = highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; cbs_delta_scheme = highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; cbs_delta2_scheme = highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""PsiMod.print_out('\\n')\n""""""; cbsbanners += """"""banner(' CBS Setup ')\n""""""; cbsbanners += """"""PsiMod.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orde",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:66023,Validat,ValidationError,66023,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); #user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); #user_df_basis_cc = PsiMod.get_option('DF_BASIS_CC'); #user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); #user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'); b_user_wfn = PsiMod.has_global_option_changed('WFN'); user_wfn = PsiMod.get_global_option('WFN'). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # Establish method for correlation energy; if 'name' in kwargs:; if (lowername == 'scf') or (lowername == 'df-scf'):; pass; else:; do_corl = 1; cbs_corl_wfn = kwargs['name'].lower(); if 'corl_wfn' in kwargs:; do_corl = 1; cbs_corl_wfn = kwargs['corl_wfn'].lower(); if do_corl:; if not (cbs_corl_wfn in VARH.keys()):; raise ValidationError('Requested CORL method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_corl_wfn)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = 1; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if not (cbs_delta_wfn in VARH.keys()):; raise ValidationError('Requested DELTA method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn)). if 'delta_wfn_lesser' in kwargs:; cbs_delta_wfn_lesser = kwargs['delta_wfn_lesser'].lower(); else:; cbs_delta_wfn_lesser = 'mp2'; if not (cbs_delta_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = 1; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if not (cbs_delta2_wfn in VARH.keys()):; raise ValidationError('Requested DELTA2 method \'%s\' is not recognized. Add it",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:62990,Validat,ValidationError,62990,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"_basisset(self, name, role='BASIS'):; """"""Set the basis for this atom; * @param type Keyword from input file, basis, ri_basis, etc.; * @param name Value from input file. """"""; self.PYbasissets[role] = name. [docs] def basisset(self, role='BASIS'):; """"""Returns the basis name for the provided type.; * @param type Keyword from input file.; * @returns the value from input. """"""; try:; return self.PYbasissets[role]; except ValueError:; raise ValidationError('CoordEntry::basisset: Basisset not set for %s and type of %s' % \; (self.PYlabel, role)). [docs] def basissets(self):; """"""Returns basisset to atom map""""""; return self.PYbasissets. [docs] def set_shell(self, bshash, key='BASIS'):; """"""Set the hash for this atom; * @param key Keyword from input file, basis, ri_basis, etc.; * @param bshash hash string of one-atom BasisSet. """"""; self.PYshells[key] = bshash. [docs] def shell(self, key='BASIS'):; """"""Returns the hash for the provided type.; * @param type Keyword from input file.; * @returns the hash string for basis. """"""; try:; return self.PYshells[key]; except (ValueError, KeyError):; raise ValidationError('CoordEntry::shells: Shells not set for %s and type of %s' % \; (self.PYlabel, key)). [docs] def shells(self):; """"""Returns shells sets to atom map""""""; return self.PYshells. [docs] def everything(self):; print('\nCoordEntry\n Entry Number = %d\n Computed = %s\n Z = %d\n Charge = %f\n Mass = %f\n Symbol = %s\n Label = %s\n Ghosted = %s\n Coordinates = %s\n Basissets = %s\n\n Shells = %s\n\n' %; (self.entry_number(), self.is_computed(), self.Z(), self.charge(),; self.mass(), self.symbol(), self.label(), self.is_ghosted(),; self.coordinates, self.PYbasissets, self.PYshells)). [docs]class CartesianEntry(CoordEntry):; """"""Class to hold all information about an atom, including its; coordinate specification as three Cartesians. """""". def __init__(self, entry_number, Z, charge, mass, symbol, label, x, y, z, basis=None, shells=None):; CoordEntry.__init__(self, entry_number, Z, charge, ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html:10775,hash,hash,10775,psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintscoordentry.html,1,['hash'],['hash']
Security,"_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and input.yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:18795,Validat,ValidationError,18795,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the difference and; # (2) return the from_arrays filled-in values; # * from.arrays is expecting speclabel ""Co_userlbl"" for elbl, but we're; # sending ""_userlbl"", hence speclabel=False; # * from.arrays sets difference provenance than input mol; forgive = ['elea', 'provenance']. # * from_arrays and comparison lines below are quite unnecessary to; # to_dict, but is included as a check. in practice, only fills in mass; # numbers and heals user chgmult.; try:; validated_molrec = qcel.molparse.from_arrays(speclabel=False, verbose=0, domain='qm', **molrec); except qcel.ValidationError as err:; # * this can legitimately happen if total chg or mult has been set; # independently b/c fragment chg/mult not reset. so try again.; print(; """"""Following warning is harmless if you've altered chgmult through `set_molecular_change` or `set_multiplicity`. Such alterations are an expert feature. Specifying in the original molecule string is preferred. Nonphysical masses may also trigger the warning.""""""; ); molrec['fragment_charges'] = [None] * len(fragments); molrec['fragment_multiplicities'] = [None] * len(fragments); validated_molrec = qcel.molparse.from_arrays(speclabel=False, nonphysical=True, verbose=0, domain='qm', **molrec); forgive.append('fragment_charges'); forgive.append('fragment_multiplicities'); compare_molrecs(validated_molrec, molrec, 'to_dict', atol=1.e-6, forgive=forgive, verbose=0). # from_arrays overwrites provenance; validated_molrec['provenance'] = copy.deepcopy(molrec['provenance']). if not np_out:; validated_molrec = qcel.util.unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html:49724,Validat,ValidationError,49724,psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/molecule.html,7,['Validat'],['ValidationError']
Security,"_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the difference and; # (2) return the from_arrays filled-in values; # * from.arrays is expecting speclabel ""Co_userlbl"" for elbl, but we're; # sending ""_userlbl"", hence speclabel=False; # * from.arrays sets difference provenance than input mol; forgive = ['elea', 'provenance']. # * from_arrays and comparison lines below are quite unnecessary to; # to_dict, but is included as a check. in practice, only fills in mass; # numbers and heals user chgmult.; try:; validated_molrec = qcel.molparse.from_arrays(speclabel=False, verbose=0, domain='qm', **molrec); except qcel.ValidationError as err:; # * this can legitimately happen if total chg or mult has been set; # independently b/c fragment chg/mult not reset. so try again.; print(; """"""Following warning is harmless if you've altered chgmult through `set_molecular_change` or `set_multiplicity`. Such alterations are an expert feature. Specifying in the original molecule string is preferred.""""""; ); molrec['fragment_charges'] = [None] * len(fragments); molrec['fragment_multiplicities'] = [None] * len(fragments); validated_molrec = qcel.molparse.from_arrays(speclabel=False, verbose=0, domain='qm', **molrec); forgive.append('fragment_charges'); forgive.append('fragment_multiplicities'); compare_molrecs(validated_molrec, molrec, 6, 'to_dict', forgive=forgive, verbose=0). # from_arrays overwrites provenance; validated_molrec['provenance'] = copy.deepcopy(molrec['provenance']). if not np_out:; validated_molrec = qcel.util.unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, molrec, verbose=1):. mol = cls(); mol._internal_from_dict(molrec=molrec, verbos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:46274,Validat,ValidationError,46274,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"_compound_basis.match(basisstring):; basisname = legit_compound_basis.match(basisstring); # filter out commas and be forgiving of e.g., t5q or 3q; bn_gz = basisname.group('zeta'); zetas = [z for z in zeta_values if (z in bn_gz or str(zeta_values.index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" % (basisstring, b)); BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(""""""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z'."""""" % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n"""""". for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound, e:; raise ValidationError(""""""Basis set '%s' not available for molecule."""""" % (basis)). return (BSET, ZSET). def _contract_bracketed_basis(basisarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets *basisarray* (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]).; Used to print a nicely formatted basis set string in the results table. """"""; if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in xrange(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]. pre = basisarray[0][:zetaindx]; post = basisarray[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post; return basisstring. [docs]def xtpl_highest_1(functionname, zHI, valueHI, verbose=True):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~driver_cbs.complete_basis_set`. .. math:: E_{total}^X = E_{total}^X. """"""; if isinstance(valu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:3404,Validat,ValidationError,3404,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method for third delta correction energy; # if 'delta3_wfn' in kwargs:; # do_delta3 = True; # cbs_delta3_wfn = kwargs['delta3_wfn'].lower(); # if cbs_delta3_wfn not in VARH.keys():; # raise ValidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:31963,Validat,ValidationError,31963,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"_data (bool, Optional) – When True, returns the total data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying return_total_data = True may carry out more computations than return_total_data = False.; quiet (bool, Default: False) – Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.; task_list (Dict[Union[, , ]], Default: {}) – ; extra_data (Any) – . Return type; None. build_tasks(mb_computer, mc_level_idx, **kwargs)[source]¶; Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type mb_computer with model chemistry level specified in kwargs and n-body levels accessed through mc_level_idx. Parameters. mb_computer (Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]) – Class of TaskComputers to instantiate and add to self.task_list. Usually AtomicComputer but may be other when wrappers are layered.; mc_level_idx (int) – Position in field self.nbodies_per_mc_level used to obtain nbodies, the list of n-body; levels (e.g., [1] or [1, 2] or [“supersystem”]) to which the modelchem specified in kwargs applies.; That is, nbodies = self.nbodies_per_mc_level[mc_level_idx].; Note the natural 1-indexing of nbodies _contents_, so [1] covers one-body contributions.; The corresponding user label is the 1-indexed counterpart, mc_level_lbl = mc_level_idx + 1; Formerly nlevel as in nbody = self.nbody_list[nbody_level=nlevel].; kwargs (Dict[str, Any]) – Other arguments for initializing mb_computer. In particular, specifies model chemistry. Returns; Number of new tasks planned by this call.; Formerly, didn’t in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/nbody.html:6604,access,accessed,6604,psi4manual/1.6.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/nbody.html,1,['access'],['accessed']
Security,"_default_namespace('monomerA'); PsiMod.print_out('\n'); banner('Monomer A HF'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs); wfn_monomerA = PsiMod.wavefunction(). activate(monomerB); if (ri == 'DF' and sapt_basis == 'dimer'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); wfn_monomerB = PsiMod.wavefunction(). if (ri == 'DF' and sapt_basis == 'dimer'):; PsiMod.IO.change_file_namespace(97, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'). # if the df_basis_sapt basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SAPT') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_SAPT', ribasis); PsiMod.print_out(' No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'). e_sapt = PsiMod.dftsapt(wfn_dimer,wfn_monomerA,wfn_monomerB). molecule.reset_point_group(user_pg); molecule.update_geometry(). PsiMod.set_global_option('DF_INTS_IO', df_ints_io). optstash.restore(); return e_sapt. [docs]def run_infsapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a INF-SAPT0 calculation of any level. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (PsiMod.g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:53759,Validat,ValidationError,53759,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"_default_namespace('monomerA'); PsiMod.print_out('\n'); banner('Monomer A HF'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs); wfn_monomerA = PsiMod.wavefunction(). activate(monomerB); if (ri == 'DF' and sapt_basis == 'dimer'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); wfn_monomerB = PsiMod.wavefunction(). if (ri == 'DF' and sapt_basis == 'dimer'):; PsiMod.IO.change_file_namespace(97, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'). # if the df_basis_sapt basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SAPT') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_SAPT', ribasis); PsiMod.print_out(' No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'). e_sapt = PsiMod.infsapt(wfn_dimer,wfn_monomerA,wfn_monomerB). molecule.reset_point_group(user_pg); molecule.update_geometry(). PsiMod.set_global_option('DF_INTS_IO', df_ints_io). optstash.restore(); return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:57155,Validat,ValidationError,57155,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"_density(root_title + "" ALPHA""); oe.set_Da_so(Da); if not ccwfn.same_a_b_dens():; Db = ccwfn.get_density(root_title + "" BETA""); oe.set_Db_so(Db); oe.compute(). core.set_global_option('WFN', 'SCF'); core.revoke_global_option_changed('WFN'); core.set_global_option('DERTYPE', 'NONE'); core.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). core.set_global_option('ONEPDM', 'TRUE'); core.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:104581,Validat,ValidationError,104581,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"_diis_start|,; |scf__diis_min_vecs|, |scf__diis_max_vecs| don't play well together. Returns; -------; bool; Whether DIIS is enabled during scf. """"""; enabled = bool(core.get_option('SCF', 'DIIS')); if enabled:; start = core.get_option('SCF', 'DIIS_START'); if start < 1:; raise ValidationError('SCF DIIS_START ({}) must be at least 1'.format(start)). minvecs = core.get_option('SCF', 'DIIS_MIN_VECS'); if minvecs < 1:; raise ValidationError('SCF DIIS_MIN_VECS ({}) must be at least 1'.format(minvecs)). maxvecs = core.get_option('SCF', 'DIIS_MAX_VECS'); if maxvecs < minvecs:; raise ValidationError(; 'SCF DIIS_MAX_VECS ({}) must be at least DIIS_MIN_VECS ({})'.format(maxvecs, minvecs)). return enabled. def _validate_frac():; """"""Sanity-checks FRAC control options. Raises; ------; ValidationError; If any of |scf__frac_start| don't play well together. Returns; -------; bool; Whether FRAC is enabled during scf. """"""; enabled = (core.get_option('SCF', 'FRAC_START') != 0); if enabled:; if enabled < 0:; raise ValidationError('SCF FRAC_START ({}) must be at least 1'.format(enabled)). return enabled. def _validate_MOM():; """"""Sanity-checks MOM control options. Raises; ------; ValidationError; If any of |scf__mom_start|, |scf__mom_occ| don't play well together. Returns; -------; bool; Whether excited-state MOM (not just the plain stabilizing MOM) is enabled during scf. """"""; enabled = (core.get_option('SCF', ""MOM_START"") != 0 and len(core.get_option('SCF', ""MOM_OCC"")) > 0); if enabled:; start = core.get_option('SCF', ""MOM_START""); if enabled < 0:; raise ValidationError('SCF MOM_START ({}) must be at least 1'.format(start)). return enabled. def _validate_soscf():; """"""Sanity-checks SOSCF control options. Raises; ------; ValidationError; If any of |scf__soscf|, |scf__soscf_start_convergence|,; |scf__soscf_min_iter|, |scf__soscf_max_iter| don't play well together. Returns; -------; bool; Whether SOSCF is enabled during scf. """"""; enabled = core.get_option('SCF', 'SOSCF'); if enabled:; start ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:24667,Validat,ValidationError,24667,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:20179,validat,validate,20179,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['validat'],['validate']
Security,"_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * psi_bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose-1); if not do_resort:; compare_integers(True, np.allclose(solution.rotation.T, perturbation.rotation), 'rotations transpose', verbose=verbose-1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose-1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .interface_dftd3 import run_dftd3 as _dftd3_qcdb_yo; Molecule.run_dftd3 = _dftd3_qcdb_yo; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol2 = _parker_xyz2mol_yo; from .parker import bond_profile as _parker_bondprofile_yo; Molecule.bond_profile = _parker_bondprofile_yo; from .interface_gcp import run_gcp as _gcp_qcdb_yo; Molecule.run_gcp = _gcp_qcdb_yo. Molecule.to_arrays = Molecule._raw_to_arrays; Molecule.to_dict = Molecule._raw_to_dict; Molecule.BFS = Molecule._raw_BFS; Molecule.B787 = Molecule._raw_B787; Molecule.scramble = Molecule._raw_scramble; Molecule.to_string = Molecule._raw_to_string; Molecule.to_schema = Molecule._raw_to_schema. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:64081,Validat,ValidationError,64081,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if (name.lower() == 'sapt0'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif (name.lower() == 'sapt2'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif (name.lower() == 'sapt2+'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); elif (name.lower() == 'sapt2+(3)'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); elif (name.lower() == 'sapt2+3'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True). # if the df_basis_sapt basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SAPT') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_SAPT', ribasis); PsiMod.print_out('No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'); e_sapt = PsiMod.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). return e_sapt. [docs]def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:35901,Validat,ValidationError,35901,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); elif (name.lower() == 'sapt2+(ccd)'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); PsiMod.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+(3)(ccd)'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', False); PsiMod.set_local_option('SAPT', 'DO_CCD_DISP', True); elif (name.lower() == 'sapt2+3(ccd)'):; PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); PsiMod.set_local_option('SAPT', 'DO_THIRD_ORDER', True); PsiMod.set_local_option('SAPT', 'DO_CCD_DISP', True). # if the df_basis_sapt basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SAPT') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_SAPT', ribasis); PsiMod.print_out(' No DF_BASIS_SAPT auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_SAPT is required.'). PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'); e_sapt = PsiMod.sapt(). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_dftsapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFT-SAPT calculation of any level. """"""; optstash = OptionsState(; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not PsiMod.has_option_changed('SCF', 'SCF_TYPE'):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'). molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(); if user_pg != 'c1':; PsiMod.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'). if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:50454,Validat,ValidationError,50454,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name.lower():; dfun = ssuper. if dfun.is_c_hybrid():. # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; psi4.dfmp2(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(). [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:38785,Validat,ValidationError,38785,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners). try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; optstash.restore(); return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies); ; # The last item in the list is the reference energy, return it; optstash.restore(); return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:40099,Validat,ValidationError,40099,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners). try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:31656,Validat,ValidationError,31656,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval, execute=True):; """"""Function to reset the total memory allocation. Takes memory value; *inputval* as type int, float, or str; int and float are taken literally; as bytes to be set, string taken as a unit-containing value (e.g., 30 mb); which is case-insensitive. Set *execute* to False to interpret *inputval*; without setting in Psi4 core. :returns: *memory_amount* (float) Number of bytes of memory set. :raises: ValidationError when <500MiB or disallowed type or misformatted. :examples:. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. >>> # Good examples; >>> psi4.set_memory(800000000) # 800000000; >>> psi4.set_memory(2004088624.9) # 2004088624; >>> psi4.set_memory(1.0e9) # 1000000000; >>> psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html:3467,Validat,ValidationError,3467,psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,2,['Validat'],['ValidationError']
Security,"_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS',['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and; ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]def set_memory(inputval, execute=True):; """"""Function to reset the total memory allocation. Takes memory value; *inputval* as type int, float, or str; int and float are taken literally; as bytes to be set, string taken as a unit-containing value (e.g., 30 mb); which is case-insensitive. Set *execute* to False to interpret *inputval*; without setting in Psi4 core. :returns: *memory_amount* (float) Number of bytes of memory set. :raises: ValidationError when <500MiB or disallowed type or misformatted. :examples:. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. :good examples:. 800000000 # 800000000; 2004088624.9 # 2004088624; 1.0e9 # 1000000000; '600 mb' # 600000000; '600.0 MiB' # 629145600; '.6 Gb' # 600000000; ' 100000000kB ' # 100000000000; '2 eb' # 2000000000000000000. :bad examples:. {} # odd type; '' # no info; ""8 dimms"" # unacceptable units; ""1e5 gb"" # string w/ exponent; ""5e5"" # string w/o units; 2000 # mem too small; -5e5 # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:3465,Validat,ValidationError,3465,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"_puream(),; return_atomlist=True); wfn.set_sad_basissets(sad_basis_list). if (""DF"" in core.get_option(""SCF"", ""SAD_SCF_TYPE"")):; # We need to force this to spherical regardless of any user or other demands.; optstash = p4util.OptionsState(['PUREAM']); core.set_global_option('PUREAM', True); sad_fitting_list = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=True,; return_atomlist=True); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if core.get_option(""SCF"", ""GUESS"") == ""SAPGAU"":; # Populate sapgau basis; sapgau = core.BasisSet.build(wfn.molecule(), ""SAPGAU_BASIS"", core.get_global_option(""SAPGAU_BASIS"")); wfn.set_basisset(""SAPGAU"", sapgau). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs:; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:42725,Validat,ValidationError,42725,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. def _core_has_variable(key):; return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls, key):; return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key):; if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return core.array_variable(key); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls, key):; if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return cls.array_variable(key); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key, val):; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(val)); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). def _core_wavefunction_set_variable(cls, key, val):; if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:18848,Validat,ValidationError,18848,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"_reactions(modelchem, sset='default', benchmark='default', failoninc=True)[source]¶; Collects the reactions present in sset from each WrappedDatabase,; checks that modelchem and benchmark ReactionDatum are present; (fails if failoninc True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; modelchem, the modelchem key needed to access benchmark, and; the Reaction object. integer_reactions()[source]¶; Returns boolean of whether reaction names need to be cast to integer. load_qcdata_byproject(project, pythonpath=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; standard location for project :module dbse_project and function; load_project. Module search path can be prepended with pythonpath. load_qcdata_hdf5_trusted(project, path=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. load_qcdata_hrxn_byproject(project, path=None)[source]¶. load_saptdata_frombfdb(sset='default', pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True)[source]¶; This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. load_subsets(modname='subsetgenerator', pythonpath=None)[source]¶; For each component database, loads subsets from all functions; in module modname. Default modname usues standard generators. mcs = None¶; assembly pattern for transspecies modelchems; >>> print asdf.mcs.keys(); XXXX. plot_all_flats(modelchem=None, sset='default', xlimit=4.0, failoninc=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Generate pieces for inclusion into tables. Supply list of; modelchemistries to plot from modelchem, otherwise defaults to; all those available. Can modify subset sset and plotting; range xlimit.; >>> asdf.plot_all_flats(sset='tt-5min', xlimit=4.0). plot_axis(axis, modelchem, benchmark",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:33379,validat,validated,33379,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['validat'],['validated']
Security,"_split_tag(i); 				pname=pname+i; 				try:; 					s=s[name]; 				except:; 					str='Invalid section: ' + pname; 					raise AttributeError, str; 				else:; 					pname=pname+'.'; 			pname=pname+path[-1:][0]; 			i=path[-1:][0]; 			k=s[tag].kw; 		if k.has_key(i):; 			return k[i]; 		str='No such key: ' + pname; 		raise AttributeError, str. [docs]	def getkw(self, path):; 		kw=self.get_keyword(path); 		return kw.arg. [docs]	def setkw(self, name, arg):; 		if self.kw.has_key(name):; 			self.kw[name].setkw(arg); 		else:; 			print 'Error: invalid kw: ', name. [docs]	def fetch_sect(self, name):; 		(key, tag)=self._split_tag(name); 		if self.sect.has_key(key):; 			if self.sect[key].has_key(tag):; 				return self.sect[key][tag]; 		return None. [docs]	def get_keys(self):; 		return self.kw. [docs]	def get_sects(self):; 		return self.sect. [docs]	def status(self):; 		return self.isset; 	; [docs]	def set_status(self, set):; 		if set:; 			self.isset=True; 		else:; 			self.isset=False. [docs]	def sanitize(self, templ):; 		self.equalize(templ); 		self.xvalidate(templ). 	# add missing keys; [docs]	def equalize(self, templ):; 		for i in templ.kw:; 			if not self.kw.has_key(i):; 				self.kw[i]=deepcopy(templ.kw[i]); 		for i in templ.sect:; 			if not self.sect.has_key(i):; 				self.sect[i]={None : deepcopy(templ.sect[i][None])}; 			for tag in self.sect[i]:; 				self.sect[i][tag].equalize(templ.sect[i][None]). [docs]	def run_callbacks(self, templ):; 		if templ.callback is not None:; 			templ.callback(self); 		for i in templ.kw:; 			cb=templ.kw[i]; 			if cb.callback is not None:; 				cb.callback(self.kw[i]); 		for i in templ.sect:; 			for tag in self.sect[i]:; 				self.sect[i][tag].run_callbacks(templ.sect[i][None]). #verify!; [docs]	def sanity_check(self,path=None):; 		dlm=''; 		if path is None:; 			path=''; 		else:; 			path=path+dlm+self.name; 			dlm='.'; 		if self.req and not self.isset:; 			print '>>> Required section not set: %s \n' % (path); 			sys.exit(0); 		for i in self.kw:; 			i.sanit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/pcmgetkw.html:4992,sanitiz,sanitize,4992,psi4manual/4.0b5/_modules/pcmgetkw.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/pcmgetkw.html,1,['sanitiz'],['sanitize']
Security,"_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options) → None¶; print the global, cross-module options. print_module_options(self: psi4.core.Options) → None¶; print global and local options prepared for current module. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. table of contents. Options; Options; Options.add_array(); Options.add_bool(); Options.add_int(); Options.add_str(); Options.add_str_i(); Options.get_bool(); Options.get_current_module(); Options.get_double(); Options.get_int(); Options.get_int_vector(); Options.get_str(); Options.print_global_options(); Options.print_module_options(); Options.read_globals(); Options.set_array(); Options.set_bool(); Options.set_current_module(); Options.set_double(); Options.set_int(); Options.set_read_globals(); Options.set_str(); Options.set_str_i(); Options.validate_options(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; Options. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Options.html:3457,validat,validate,3457,psi4manual/master/api/psi4.core.Options.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Options.html,1,['validat'],['validate']
Security,"_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name))); PsiMod.print_out(""\n""). # write index of calcs to output file; if (db_mode.lower() == 'continuous'):; instructions = """"""\n The database single-job procedure has been selected through mode='continuous'.\n""""""; instructions += """""" Calculations for the reagents will proceed in the order below and will be followed\n""""""; instructions += """""" by summary results for the database.\n\n""""""; for rgt in HSYS:; instructions += """""" %-s\n"""""" % (rgt); instructions += """"""\n Alternatively, a farming-out of the database calculations may be accessed through\n""""""; instructions += """""" the database wrapper option mode='sow'/'reap'.\n\n""""""; PsiMod.print_out(instructions). # write sow/reap instructions",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:36404,Validat,ValidationError,36404,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"_unit = self.units if units is None else units; factor = constants.conversion_factor(self.units, to_unit). if isinstance(self.data, Decimal):; return factor * float(self.data); else:; return factor * self.data. def print_variables(qcvars: Dict[str, ""Datum""]) -> str:; r""""""Form a printable representation of qcvariables. Parameters; ----------; qcvars; Group of Datum objects to print. Returns; -------; str; Printable string representation of label, data, and unit in Datum-s. """"""; text = [""\n Variable Map:"", "" ----------------------------------------------------------------------------""]. if len(qcvars) == 0:; text.append("" (none)""); return ""\n"".join(text). largest_key = max(len(k) for k in qcvars) + 2 # for quotation marks; largest_characteristic = 8; for k, v in qcvars.items():; try:; exp = int(str(v.data).split(""E"")[1]); except IndexError:; pass; else:; largest_characteristic = max(exp, largest_characteristic). for k, qca in sorted(qcvars.items()):; # if k != qca.lbl:; # raise ValidationError('Huh? {} != {}'.format(k, qca.label)). if isinstance(qca.data, np.ndarray):; data = np.array_str(qca.data, max_line_width=120, precision=8, suppress_small=True); data = ""\n"".join("" "" + ln for ln in data.splitlines()); text.append(; """""" {:{keywidth}} => {:{width}} [{}]"""""".format(; '""' + k + '""', """", qca.units, keywidth=largest_key, width=largest_characteristic + 14; ); ); text.append(data); elif isinstance(qca.data, Decimal):; text.append(; """""" {:{keywidth}} => {:{width}} [{}]"""""".format(; '""' + k + '""', qca.data, qca.units, keywidth=largest_key, width=largest_characteristic + 14; ); ); elif not qca.numeric:; text.append(; """""" {:{keywidth}} => {:>{width}} [{}]"""""".format(; '""' + k + '""', str(qca.data), qca.units, keywidth=largest_key, width=largest_characteristic + 14; ); ); else:; text.append(; """""" {:{keywidth}} => {:{width}.{prec}f} [{}]"""""".format(; '""' + k + '""', qca.data, qca.units, keywidth=largest_key, width=largest_characteristic + 14, prec=12; ); ). text.append(""""); return ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html:3576,Validat,ValidationError,3576,psi4manual/1.4.0/_modules/qcelemental/datum.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/datum.html,3,['Validat'],['ValidationError']
Security,"_variable('SCS-MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.get_variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; core.set_variable('CURRENT ENERGY', core.get_variable('MP2 TOTAL ENERGY')); core.set_variable('CURRENT CORRELATION ENERGY', core.get_variable('MP2 CORRELATION ENERGY')). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:95054,Validat,ValidationError,95054,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"_wfn', False); ptype = kwargs.pop('ptype', None); return_total_data = kwargs.pop('return_total_data', False); molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); core.clean_variables(). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % ptype). # Figure out BSSE types; do_cp = False; do_nocp = False; do_vmfc = False; return_method = False. # Must be passed bsse_type; bsse_type_list = kwargs.pop('bsse_type'); if bsse_type_list is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(bsse_type_list, list):; bsse_type_list = [bsse_type_list]. for num, btype in enumerate(bsse_type_list):; if btype.lower() == 'cp':; do_cp = True; if (num == 0): return_method = 'cp'; elif btype.lower() == 'nocp':; do_nocp = True; if (num == 0): return_method = 'nocp'; elif btype.lower() == 'vmfc':; do_vmfc = True; if (num == 0): return_method = 'vmfc'; else:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). max_nbody = kwargs.get('max_nbody', -1); max_frag = molecule.nfragments(); if max_nbody == -1:; max_nbody = molecule.nfragments(); else:; max_nbody = min(max_nbody, max_frag). # What levels do we need?; nbody_range = range(1, max_nbody + 1); fragment_range = range(1, max_frag + 1). # Flip this off for now, needs more testing; # If we are doing CP lets save them integrals; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # # Set to save RI integrals for repeated full-basis computations; # ri_ints_io = core.get_global_option('DF_INTS_IO'). # # inquire if above at all applies to dfmp2 or just scf; # core.set_global_option('DF_INTS_IO', 'SAVE'); # psioh = core.IOManager.shared_object(); # psioh.set_specific_retention(97, True). bsse_str = bsse_type_list[0]; if len(bsse_type_list) >1:; bsse_str = str(bsse_type_list); core.print_out(""\n\n""); core.print_out("" ===> N-Body Interaction Abacus <=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html:6571,Validat,ValidationError,6571,psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"_wfn', False); ptype = kwargs.pop('ptype', None); return_total_data = kwargs.pop('return_total_data', False); molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); psi4.clean_variables(). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % ptype). # Figure out BSSE types; do_cp = False; do_nocp = False; do_vmfc = False; return_method = False. # Must be passed bsse_type; bsse_type_list = kwargs.pop('bsse_type'); if bsse_type_list is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(bsse_type_list, list):; bsse_type_list = [bsse_type_list]. for num, btype in enumerate(bsse_type_list):; if btype.lower() == 'cp':; do_cp = True; if (num == 0): return_method = 'cp'; elif btype.lower() == 'nocp':; do_nocp = True; if (num == 0): return_method = 'nocp'; elif btype.lower() == 'vmfc':; do_vmfc = True; if (num == 0): return_method = 'vmfc'; else:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). max_nbody = kwargs.get('max_nbody', -1); max_frag = molecule.nfragments(); if max_nbody == -1:; max_nbody = molecule.nfragments(); else:; max_nbody = min(max_nbody, max_frag). # What levels do we need?; nbody_range = range(1, max_nbody + 1); fragment_range = range(1, max_frag + 1). # Flip this off for now, needs more testing; # If we are doing CP lets save them integrals; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # # Set to save RI integrals for repeated full-basis computations; # ri_ints_io = psi4.get_global_option('DF_INTS_IO'). # # inquire if above at all applies to dfmp2 or just scf; # psi4.set_global_option('DF_INTS_IO', 'SAVE'); # psioh = psi4.IOManager.shared_object(); # psioh.set_specific_retention(97, True). bsse_str = bsse_type_list[0]; if len(bsse_type_list) >1:; bsse_str = str(bsse_type_list); psi4.print_out(""\n\n""); psi4.print_out("" ===> N-Body Interaction Abacus <=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:6438,Validat,ValidationError,6438,psi4manual/1.0.0/_modules/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; """"""Requested lesser %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn_lo""])). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""core.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup: %s ' % label)\n""""""; cbsbanners += """"""core.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_alpha'; ]; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian', 'f_options']; GRAND_NEED = []; MODELCHEM = []. NEED = _expand_scheme_orders(metadata[0][""scheme""], metadata[0][""basis""][0], metadata[0][""basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:47059,Validat,ValidationError,47059,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; """"""Requested lesser %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn_lo""])). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Setup{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_alpha'; ]; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian', 'f_options']; GRAND_NEED = []; MODELCHEM = []. NEED = _expand_scheme_orders(metadata[0][""scheme""], metadata[0][""basis""][0], metadata[0][""basis""][1],; metadata[0][""wfn""], metadata[0][""options""],",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:48666,Validat,ValidationError,48666,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"_ylim([vmin - vbuf, vmax + vbuf]); plt.legend(fontsize='x-small', frameon=False); ax2.set_ylim([emin - ebuf, emax + ebuf]). # save and show; pltuid = title + '_' + hashlib.sha1(title).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='valerr_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close() # give this a try; return files_saved. [docs]def disthist(data, title='', xtitle='', xmin=None, xmax=None,; me=None, stde=None, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Saves a plot with name *saveas* with a histogram representation; of the reaction errors in *data*. Also plots a gaussian distribution; with mean *me* and standard deviation *stde*. Plot has x-range; *xmin* to *xmax*, x-axis label *xtitle* and overall title *title*. """"""; import hashlib; import numpy as np; import matplotlib.pyplot as plt. def gaussianpdf(u, v, x):; """"""*u* is mean, *v* is variance, *x* is value, returns probability""""""; return 1.0 / np.sqrt(2.0 * np.pi * v) * np.exp(-pow(x - u, 2) / 2.0 / v). me = me if me is not None else np.mean(data); stde = stde if stde is not None else np.std(data, ddof=1); evenerr = max(abs(me - 4.0 * stde), abs(me + 4.0 * stde)); xmin = xmin if xmin is not None else -1 * evenerr; xmax = xmax if xmax is not None else evenerr. dx = (xmax - xmin) / 40.; nx = int(round((xmax - xmin) / dx)) + 1; pdfx = []; pdfy = []; for i in xrange(nx):; ix = xmin + i * dx; pdfx.append(ix); pdfy.append(gaussianpdf(me, pow(stde, 2), ix)). fig, ax1 = plt.subplots(figsize=(16, 6)); plt.axvline(0.0, color='#cccc00'); ax1.set_xlim(xmin, xmax); ax1.hist(data, bins=30, range=(xmin, xmax), color='#2d4065', alpha=0.7); ax1.set_xlabel(xtitle); ax1.set_ylabel('Count'). ax2 = ax1.twinx(); ax2.fill(pdfx, pdfy, color='k', alpha=0.2); ax2.set_ylabel('Probability Density').",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:11644,hash,hashlib,11644,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,"_{ptype}""], store dict of `task_list key = return_{ptype}` for all in task_list or results kwarg. ptype=e/g/h; always for ptype=energy, as available for higher derivatives when driver=g/h. * form nbody qcvars and properties, inc'l number, current e/g/h as available; * pull results (incl dicts!) into qcvars; * form model, including copy of class with mols converted to qcsk at atomicresult.extras[""component_results""]. * collect ManyBody-flavored AtomicResult from self.get_results(); * build wfn from nbody mol and basis (always def2-svp); * push qcvars to P::e and wfn. push various internal dicts to qcvars, too; * convert result to psi4.core.Matrix (non-energy) and set g/h on wfn; * return e/g/h and wfn. """""". __all__ = [; ""BsseEnum"",; ""ManyBodyComputer"",; ""nbody"",; ]. import copy; import itertools; import math; from typing import Any, Callable, Dict, List, Literal, Optional, Sequence, Set, Tuple, Union, TYPE_CHECKING; from ast import literal_eval; from enum import Enum. from pydantic import Field, validator. import pprint; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from qcelemental.models import DriverEnum, AtomicResult. from psi4 import core; from psi4.driver import constants, driver_nbody_multilevel, p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.task_base import BaseComputer, AtomicComputer, EnergyGradientHessianWfnReturn; from psi4.driver.driver_cbs import CompositeComputer; from psi4.driver.driver_findif import FiniteDifferenceComputer. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). FragBasIndex = Tuple[Tuple[int], Tuple[int]]. SubTaskComputers = Union[AtomicComputer, CompositeComputer, FiniteDifferenceComputer]. [docs]def nbody():; """"""; Computes the nbody interaction energy, gradient, or Hessian depending on input.; This is a generalized universal function for computing interaction and total quantities. :returns: *return type of func* |w--w| The data. :returns:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:7398,validat,validator,7398,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"`'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\n""); p4util.banner(""CP Computation: Complex.\nFull Basis Set.""); psi4.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). psi4.clean(); psi4.set_global_option('DF_INTS_IO',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:19437,Validat,ValidationError,19437,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from p4util.basislistdunning import load_basfam_dunning; from p4util.basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [docs]def corresponding_jfit(name):; """"""Function to return an appropriate J fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(); ; for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.jfit; return None. [docs]def corresponding_jkfit(name):; """"""Function to return an appropriate JK fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_fa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html:4301,validat,validate,4301,psi4manual/1.0.0/_modules/p4util/basislist.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html,1,['validat'],['validate']
Security,"``s``, and ``(``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from basislistdunning import load_basfam_dunning; from basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [docs]def corresponding_jkfit(name):; """"""Function to return an appropriate JK fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.jkfit; return None. [docs]def corresponding_rifit(name):; """"""Function to return an appropriate RI fitting basis for; the orbital basis *name* in coded or ornate form. ``None``; is returned if no fitting basis is defined or if the; orbital basis is not found.; """"""; basisfamily_list = load_basis_f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html:3943,validat,validate,3943,psi4manual/4.0b5/_modules/p4util/basislist.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html,1,['validat'],['validate']
Security,"a .gbs extension,; after applying the following transformations. All letters lowercase; Replace all * with s; Replace all + with p; Replace all ( ) , with _ (underscores replace parentheses and commas). For example, basis 6-31++G** is stored in psi4/share/basis/6-31ppgss.gbs,; and cc-pV(D+d)Z is stored in psi4/share/basis/cc-pv_dpd_z.gbs.; Only one basis set may be specified per file.; Copy the new basis set file into psi4/share/basis.; Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (2) Use new basis set file in arbitrary location.; Prepare a basis set file exactly as above. Append the directory; containing the basis set file to the environment variable; PSIPATH.; Request the new basis set in an input file in the usual manner.; set basis new_basis_name. (3) Include new basis set in input file.; Construct for a basis set a section like the one below that includes; [basis name], PUREAM value, and element basis set; specifications. Hash signs denote comments. This format is exactly like; the stand-alone basis file except for the addition of the basis name in; brackets.; [ sto-3g ]; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Copy the section into a Psi4 input file and surround it with the; command basis {...}, as shown below. Multiple basis sets can be; specified by adding additional sections within the surrounding brackets.; Use assign statements to actually request the basis set. (See; mints2 for an example.); basis {. # assign basset to all atoms and addl to hydrogens; assign basset; assign H addl. # basis set section like in snippet above goes here; [basset]; ... # additional basis set sections follow; [addl]; ...; }. Table Of Contents. Basis Sets; Built-In Basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/basissets-1.html:6823,Hash,Hash,6823,psi4manual/1.0.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/basissets-1.html,2,['Hash'],['Hash']
Security,"a MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; kwargs = p4util.kwargs_lower(kwargs); metadata = _process_cbs_kwargs(kwargs); return_wfn = kwargs.pop('return_wfn', False); verbose = kwargs.pop('verbose', 0); ptype = kwargs.pop('ptype'). if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:46225,Validat,ValidationError,46225,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"a basis has not been set for; *role* for every atom in *mol*, unless *deffit* is set (JFIT,; JKFIT, or RIFIT), whereupon empty atoms are assigned to *role*; from the :py:class:`~BasisFamily`. This function is significantly; re-worked from its libmints analog. """"""; # Update geometry in molecule, if there is a problem an exception is thrown.; mol.update_geometry(). # Paths to search for gbs files: here + PSIPATH + library; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/basis'; basisPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath. # Validate deffit for role; univdef = {'JFIT': 'def2-qzvpp-jfit',; 'JKFIT': 'def2-qzvpp-jkfit',; 'RIFIT': 'def2-qzvpp-ri',; 'F12': 'def2-qzvpp-f12'}. if deffit is not None:; if deffit not in univdef.keys():; raise ValidationError(""""""BasisSet::construct: deffit argument invalid: %s"""""" % (deffit)). # Map of GaussianShells; atom_basis_shell = OrderedDict(); names = {}; summary = []. for at in range(mol.natom()):; symbol = mol.atom_entry(at).symbol() # O, He; label = mol.atom_entry(at).label() # O3, C_Drot, He; basdict = mol.atom_entry(at).basissets() # {'BASIS': 'sto-3g', 'DF_BASIS_MP2': 'cc-pvtz-ri'}. if label not in atom_basis_shell:; atom_basis_shell[label] = OrderedDict(). # Establish search parameters for what/where basis entries suitable for atom; seek = {}; try:; requested_basname = basdict[role]; except KeyError:; if role == 'BASIS' or deffit is None:; raise BasisSetNotDefined(""""""BasisSet::construct: No basis set specified for %s and %s."""""" %; (symbol, role)); else:; # No auxiliary basis set for atom, so try darnedest to find one.; # This involves querying the BasisFamily for default and; # default-default and finally the universal default (defined; # in this function). Since user hasn't indicated any specifics,; # look onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:22152,Validat,ValidationError,22152,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['Validat'],['ValidationError']
Security,"a compound single-point energy.; If a nested series of python functions is intended; (see :ref:`sec:intercalls`), use keyword ``cp_func`` instead of ``func``. :type check_bsse: :ref:`boolean <op_py_boolean>`; :param check_bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:19298,Validat,ValidationError,19298,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"a dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:30539,Validat,ValidationError,30539,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"a fixed scale to facilitate comparison across projects. """"""; import hashlib; import matplotlib.pyplot as plt. # initialize plot, fix dimensions for consistent Illustrator import; fig, ax = plt.subplots(figsize=(12, 7)); plt.ylim([0, 4.86]); plt.xlim([0, 6]); plt.xticks([]). # label plot and tiers; ax.text(0.4, 4.6, title,; verticalalignment='bottom', horizontalalignment='left',; family='Times New Roman', weight='bold', fontsize=12). widths = [0.15, 0.02, 0.02, 0.02] # TT, HB, MX, DD; xval = 0.1 # starting posn along x-axis. # plot bar sets; for bar in data:; if bar is not None:; lefts = [xval, xval + 0.025, xval + 0.065, xval + 0.105]. rect = ax.bar(lefts, bar['data'], widths, linewidth=0); rect[0].set_color('grey'); rect[1].set_color('red'); rect[2].set_color('green'); rect[3].set_color('blue'). ax.text(xval + .08, 4.3, bar['mc'],; verticalalignment='center', horizontalalignment='right', rotation='vertical',; family='Times New Roman', fontsize=8); xval += 0.20. # save and show; pltuid = title + '_' + hashlib.sha1(title + repr([bar['mc'] for bar in data if bar is not None])).hexdigest(); pltfile = expand_saveas(saveas, pltuid, def_prefix='bar_', relpath=relpath); files_saved = {}; for ext in graphicsformat:; savefile = pltfile + '.' + ext.lower(); plt.savefig(savefile, transparent=True, format=ext, bbox_inches='tight'); files_saved[ext.lower()] = savefile; if view:; plt.show(); plt.close(); return files_saved. [docs]def flat(data, color=None, title='', xlimit=4.0, xlines=[0.0, 0.3, 1.0], mae=None, mape=None, view=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generates a slat diagram between model chemistries with errors in; single-item list *data*, which is supplied as part of the dictionary; for each participating reaction, along with *dbse* and *rxn* keys in; argument *data*. Limits of plot are *xlimit* from the zero-line. If; *color* is None, slats are black, if 'sapt', colors are taken from; sapt_colors module. Summary statistic *mae* is plotted",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html:3783,hash,hashlib,3783,psi4manual/1.0.0/_modules/qcdb/mpl.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/mpl.html,1,['hash'],['hashlib']
Security,"a"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:173242,Validat,ValidationError,173242,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"a^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:2649,validat,validate,2649,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,4,['validat'],['validate']
Security,"abel.split('\n'.join(leftover_lines)))); if len(basblock) == 1:; if not assignments:; # case with no [basname] markers where whole block is contents of gbs file; mol.set_basis_all_atoms(name, role=role); basstrings[basname(name)] = basblock[0]; else:; message = (; ""Conflicting basis set specification: assign lines present but shells have no [basname] label.""; """"); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; basstrings[basname(basblock[idx])] = basblock[idx + 1]. return basstrings. anon.__name__ = 'basisspec_psi4_yo__' + cleanbas; qcdb.libmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MAYER_INDICES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def py_psi_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN == None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = py_psi_set_global_option_python. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.2.1;  · . PSI4. Module code. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/python_helpers.html:10577,Validat,ValidationError,10577,psi4manual/1.2.1/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"able for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; core.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); core.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:14904,Validat,ValidationError,14904,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,2,['Validat'],['ValidationError']
Security,"able for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; # TODO db(func=cbs,tabulate=[non-current-energy]) # broken; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if db_subset.lower() == 'small':; try:; database.HRXN_SM; except AttributeError:; raise ValidationError(""""""Special subset 'small' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_SM; elif db_subset.lower() == 'large':; try:; database.HRXN_LG; except AttributeError:; raise ValidationError(""""""Special subset 'large' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_LG; elif db_subset.lower() == 'equilibrium':; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError(""""""Special subset 'equilibrium' not available for database %s."""""" % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = p4util.getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = p4util.getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError(""""""Special subset '%s' not available for database %s."""""" % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError(""""""Subset element '%s' not a member of database %s."""""" % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = p4util.drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; psi4.print_out(""\n\n""); p4util.banner((""Database %s Computation"" % (db_name))); psi4.print_out(""\n""). # write index of calcs to output file; if db_mode == 'continuous':; instructions = """"""\n The database single-job procedure has been selected through mode='continuo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:14784,Validat,ValidationError,14784,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"able value %20.12f for variable %s\\n' % (core.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); core.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); core.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:23727,Validat,ValidationError,23727,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,2,['Validat'],['ValidationError']
Security,"able value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (62 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int); for rxn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:23601,Validat,ValidationError,23601,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"ablish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:31172,Validat,ValidationError,31172,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ablish function to call (only energy makes sense for cbs); if ptype not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""Wrapper complete_basis_set is unhappy to be calling function '%s' instead of 'energy'."""""" % ptype). optstash = p4util.OptionsState(; ['BASIS'],; ['WFN'],; ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. do_scf = True; do_corl = False; do_delta = False; do_delta2 = False; do_delta3 = False; do_delta4 = False; do_delta5 = False. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for reference energy; cbs_scf_wfn = kwargs.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:30819,Validat,ValidationError,30819,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"accessible, but graphicsformat; array requests among ‘png’, ‘pdf’, and ‘eps’ formats. relpath; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary.; Prepares disthist diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames.; >>>. plot_flat(modelchem, benchmark='default', sset='default', failoninc=True, verbose=False, color='sapt', xlimit=4.0, xlines=[0.0, 0.3, 1.0], view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Computes individual errors and summary statistics for single; model chemistry modelchem versus benchmark over; subset sset over all component databases. Thread color can be; ‘rgb’ for old coloring, a color name or ‘sapt’ for spectrum coloring.; saveas conveys directory (‘/’) and/or filename for saving the; resulting plot. File extension is not accessible, but graphicsformat; array requests among ‘png’, ‘pdf’, and ‘eps’ formats. relpath; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary.; Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames.; asdf.plot_flat(‘CCSD-CP-atqzadz’, failoninc=False). plot_iowa(modelchem, benchmark='default', sset='default', failoninc=True, verbose=False, title='', xtitle='', xlimit=2.0, view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Computes individual errors for single modelchem versus; benchmark over subset sset. Coloring green-to-purple with; maximum intensity at xlimit. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. plot_liliowa(modelchem, benchmark='default', failoninc=True, xlimit=2.0, view=True, saveas=None, relpath=False, graphicsformat=['pd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:36991,access,accessible,36991,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['access'],['accessible']
Security,"acetylene), test case 16 from the S22 database. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. stability3; Test LDA stability analysis against QChem. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf-level-shift-rks; SCF level shift on an RKS computation. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. cc36; CC2(RHF)/cc-pVDZ energy of H2O. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. fnocc3; Test FNO-QCISD(T) computation. frac-sym; Fractional occupation with symmetry. tdscf-7; TD-HF test variable access. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Poin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:21156,Access,Accesses,21156,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['Access'],['Accesses']
Security,"ach job in task list. Parameters:; client (qcportal.FractalClient | None). get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None). Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as FiniteDifference-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None). Return type:; AtomicResult. plan()[source]¶. validator set_driver  »  driver[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes; Molden Interface Keywords; NORMAL_MODES_WRITE; WRITER_FILE_LABEL. psi4.driver.qcdb.vib Module; Functions. API; FiniteDifferenceComputer; FiniteDifferenceComputer.driver; FiniteDifferenceComputer.findifrec; FiniteDifferenceComputer.metameta; FiniteDifferenceComputer.method; FiniteDifferenceComputer.molecule; FiniteDifferenceComputer.task_list; FiniteDifferenceComputer.computer; FiniteDifferenceComputer.build_tasks(); FiniteDifferenceComputer.compute(); FiniteDifferenceComputer.get_psi_results(); FiniteDifferenceComputer.get_results(); FiniteDifferenceComputer.plan(); FiniteDifferenceComputer.set_driver; FiniteDifferenceComputer.set_molecule. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:10722,validat,validator,10722,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,1,['validat'],['validator']
Security,"add basis fit as associated helper basis; member dualfit to a BasisFamily object. add_jfit(fit)[source]¶; Function to add basis fit as associated fitting basis; member jfit to a BasisFamily object. add_jfit_default(fit)[source]¶; Function to add basis fit as associated fitting basis; member jdef to a BasisFamily object. add_jkfit(fit)[source]¶; Function to add basis fit as associated fitting basis; member jkfit to a BasisFamily object. add_jkfit_default(fit)[source]¶; Function to add basis fit as associated fitting basis; member jkdef to a BasisFamily object. add_rifit(fit)[source]¶; Function to add basis fit as associated fitting basis; member rifit to a BasisFamily object. add_rifit_default(fit)[source]¶; Function to add basis fit as associated fitting basis; member ridef to a BasisFamily object. name()[source]¶; Function to return the ornate name of the orbital basis,; e.g., 6-311++G** for 6-311ppgss. corresponding_basis(name, role='BASIS')[source]¶; Function to validate if the orbital basis name in coded or; ornate form is in Psi4’s standard installed bases list. None; is returned if the orbital basis is not found. load_basis_families()[source]¶; Function to load into the array basisfamily_list; BasisFamily objects for all Psi4’s standard installed bases. print_basis_families()[source]¶; Function to print to the output file a formatted summary; of all the BasisFamily objects in basisfamily_list, by; default all Psi4’s standard installed bases. sanitize_basisname(name)[source]¶; Function to return name in coded form, stripped of; characters that confuse filenames, characters into lowercase,; + into p, * into s, and (, ), & ,; into _. Module to hold and distribute the -D dispersion correction parameters. dash_server(func, dashlvl, mode='psi4')[source]¶; Function to serve up dispersion correction parameters in whatever form needed.; When mode is ‘dftd3’, returns a string suitable for writing to ./dftd3_parameters; to calculuate the correction at dashlvl with the de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:120749,validat,validate,120749,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['validat'],['validate']
Security,"add_dualfit(fit)[source]¶; Function to add basis fit as associated helper basis; member dualfit to a BasisFamily object. add_jkfit(fit)[source]¶; Function to add basis fit as associated fitting basis; member jkfit to a BasisFamily object. add_rifit(fit)[source]¶; Function to add basis fit as associated fitting basis; member rifit to a BasisFamily object. name()[source]¶; Function to return the ornate name of the orbital basis,; e.g., 6-311++G** for 6-311ppgss. corresponding_dualfit(name)[source]¶; Function to return an appropriate DUAL helper basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. corresponding_jkfit(name)[source]¶; Function to return an appropriate JK fitting basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. corresponding_orbital(name)[source]¶; Function to validate if the orbital basis name in coded or; ornate form is in Psi4’s standard installed bases list. None; is returned if the orbital basis is not found. corresponding_rifit(name)[source]¶; Function to return an appropriate RI fitting basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. load_basis_families()[source]¶; Function to load into the array basisfamily_list; BasisFamily objects for all Psi4’s standard installed bases. print_basis_families()[source]¶; Function to print to the output file a formatted summary; of all the BasisFamily objects in basisfamily_list, by; default all Psi4’s standard installed bases. sanitize_basisname(name)[source]¶; Function to return name in coded form, stripped of; characters that confuse filenames, characters into lowercase,; + into p, * into s, and (, ), & ,; into _. Module with utility functions used by several Python functions. all_casings(input_string)[source]¶; Function to r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:28584,validat,validate,28584,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['validat'],['validate']
Security,"adient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. efp = core.get_active_efp(); efp_present = efp.nfragments() > 0. translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and; not core.get_option('SCF', 'PERTURB_H')",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:3326,validat,validation,3326,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['validat'],['validation']
Security,"adient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:3286,validat,validation,3286,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['validat'],['validation']
Security,"ads for OpenMP parallelization; and threaded BLAS (see section Threading), we set -n4 below.; The next step is then to actually run the computation:; 1/psi/install/directory/bin/psi4 -i input.in -o input.out -n 4. And then to clean up the scratch directories previously created:; 1; 2; 3; 4foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. Note again that the specific commands for your PBS system may differ. Refer; to your system administrator. Command Line Options¶; PSI4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.; The set of three commands below are completely equivalent, while the fourth is,; perhaps, the most common usage.; 1; 2; 3; 4; 5>>> psi4; >>> psi4 -i input.dat -o output.dat; >>> psi4 input.dat output.dat. >>> psi4 descriptive_filename.in descriptive_filename.out. Command-line arguments to PSI4 can be accessed through psi4 --help. -a, --append¶; Append results to output file. Default: Truncate first. -h, --help¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. -k, --skip-preprocessor¶; Skips input preprocessing. Expert mode. -l <name>, --psidatadir <name>¶; Mainly for use by developers, this overrides the value of; PSIDATADIR and specifies the path to the Psi data; library (ends in share/psi4). -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename with any; any “.in” or “.dat” extension replaced by “.out”. -p <prefix>, --prefix <",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/external-1.html:16511,access,accessed,16511,psi4manual/1.2.1/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/external-1.html,4,['access'],['accessed']
Security,"ads for OpenMP parallelization; and threaded BLAS (see section Threading), we set -n4 below.; The next step is then to actually run the computation:; 1/psi/install/directory/bin/psi4 -i input.in -o input.out -n 4. And then to clean up the scratch directories previously created:; 1; 2; 3; 4foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. Note again that the specific commands for your PBS system may differ. Refer; to your system administrator. Command Line Options¶; PSI4 can be invoked with no command line arguments, as it takes as input; by default the file “input.dat” and directs output by default to “output.dat”.; The set of three commands below are completely equivalent, while the fourth is,; perhaps, the most common usage.; 1; 2; 3; 4; 5>>> psi4; >>> psi4 -i input.dat -o output.dat; >>> psi4 input.dat output.dat. >>> psi4 descriptive_filename.in descriptive_filename.out. Command-line arguments to PSI4 can be accessed through psi4 --help. -a, --append¶; Append results to output file. Default: Truncate first. -h, --help¶; Display the command-line options and usage information. -i <filename>, --input <filename>¶; Input file name. Default: input.dat. -k, --skip-preprocessor¶; Skips input preprocessing. Expert mode. -l <name>, --psidatadir <name>¶; Mainly for use by developers, this overrides the value of; PSIDATADIR and specifies the path to the Psi data; library (ends in share/psi4). -m, --messy¶; Leave temporary files after the run is completed. -n <threads>, --nthread <threads>¶; Number of threads to use (overrides OMP_NUM_THREADS). -o <filename>, --output <filename>¶; Output file name. Use stdout as <filename> to redirect; to the screen. Default: when the input filename is “input.dat”,; then the output filename defaults to “output.dat”. Otherwise, the; output filename defaults to the the input filename with any; any ”.in” or ”.dat” extension replaced by ”.out”. -p <prefix>, --prefix <",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:16400,access,accessed,16400,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,2,['access'],['accessed']
Security,"ag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed; # goto GH:psi4/psi4 > Settings > Branches > 1.3.x > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/4385008 # !Varies!; # uncheck ""Include administrators"" and Save changes. >>> git push upstream 1.3.x; >>> git push upstream v1.3.1. # re-engage ""Include administrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4-dev, psi4-docs.; Other packages, the “ecosy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_release-1.html:7506,hash,hash,7506,psi4manual/1.4.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_release-1.html,2,['hash'],['hash']
Security,"ag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master; >>> git push upstream v1.3rc2. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed; # goto GH:psi4/psi4 > Settings > Branches > 1.3.x > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/4385008 # !Varies!; # uncheck ""Include administrators"" and Save changes. >>> git push upstream 1.3.x; >>> git push upstream v1.3.1. # re-engage ""Include administrators"" protections. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/manage_release-1.html:7692,hash,hash,7692,psi4manual/1.5.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/manage_release-1.html,3,['hash'],['hash']
Security,"ag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:20172,Validat,ValidationError,20172,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"ag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]; class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs]; @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy to be calling function ({driver}) not among {egh}.""""""). return driver. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.get_option('SCF', 'PERTURB_H'); and not hasattr(self.molecule, 'EFP')); if 'ref_gradient' in data:; logger.info(""""""hessian() using ref_gradient to assess stationary ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:41059,validat,validator,41059,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,3,['validat'],['validator']
Security,"age; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. ## Force Python 3 print syntax, if this is python 2.X; #if sys.hexversion < 0x03000000:; from __future__ import print_function. """"""Module with functions to parse the input file and convert; Psithon into standard Python. Particularly, forms psi4; module calls that access the C++ side of Psi4. """"""; import psi4; import pubchem; import re; import os; import sys; from psiexceptions import *. [docs]def bad_option_syntax(line):; """"""Function to report bad syntax to screen and output file.""""""; raise ValidationError('Unsupported syntax:\n\n%s\n\n' % (line)). [docs]def process_word_quotes(matchobj):; """"""Function to determine if argument needs wrapping in quotes as string.""""""; dollar = matchobj.group(2); val = matchobj.group(3); if(dollar):; # This is a python variable, make sure that it starts with a letter; if(re.match(r'^[A-Za-z][\w]*', val)):; return val; else:; print(""Invalid Python variable: %s"" % val); sys.exit(1); elif(re.match(r'^-?\d+\.?\d*(?:[Ee]-?\d+)?$', val)):; # This must be a number, don't wrap it in quotes; return val; elif(re.match(r'^\'.*\'$', val) or re.match(r'^\"".*\""$', val)):; # This is already wrapped in quotes, do nothing; return val; else:; # This must be a string; return ""\""%s\"""" % val. [docs]def quotify(string):; """"""Func",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/inputparser.html:1231,access,access,1231,psi4manual/4.0b5/_modules/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/inputparser.html,1,['access'],['access']
Security,"agment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:21617,Validat,ValidationError,21617,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"agment_charges=None, fragment_multiplicities=None):; """"""Check consistency of fragment specifiers wrt type and length. For; charge & multiplicity, scientific defaults are not computed or applied;; rather, missing slots are filled with `None` for later processing. """"""; if fragment_separators is None:; if fragment_charges is None and fragment_multiplicities is None:; frs = [] # np.array([], dtype=int) # if empty, needs to be both ndarray and int; frc = [None]; frm = [None]; else:; raise ValidationError(; """"""Fragment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == le",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:21062,Validat,ValidationError,21062,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"agments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See `seed_atoms`.; Any existing fragmentation info/chgmult encoded in `self` is lost. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:52231,Validat,ValidationError,52231,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"agments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially; hydrogen-bonded) fragments. See `seed_atoms`.; Any existing fragmentation info/chgmult encoded in `self` is lost. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [molparse.from_arrays(geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = Molecule.contiguize_from_fragment_pattern(frag_pattern,; geom=cgeom,; elez=celez,; elem=celem,; mass=cmass); molrec = molparse.from_arrays(geom=dcont",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:55372,Validat,ValidationError,55372,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"ailable to the job, not the memory per thread. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module. These can be accessed through the get_variable() function.; For example, after performing a density fitted MP2 computation, both the; spin component scaled energy and the unscaled MP2 energy are made; available:; e_mp2=get_variable('MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; accumulate over a PSI4 instance and are not cleared by clean().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the last will; include both SCF TOTAL ENERGY and FCI; TOTAL ENERGY. Don’t get excited that you got a; high-quality calculation cheaply. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:23731,access,accessed,23731,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['access'],['accessed']
Security,"aise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (extern",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:5385,Validat,ValidationError,5385,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['Validat'],['ValidationError']
Security,"aise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = PsiMod.get_option('DF_INTS_IO'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; PsiMod.print_out('\n'); PsiMod.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); PsiMod.print_out(' BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:5441,Validat,ValidationError,5441,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"al == 'DF':; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''); # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; core.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); core.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if core.get_option('SCF', 'SCF_TYPE') not in ['CD', 'DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). fnocc_wfn = core.fnocc(ref_wfn). optstash.restore(); return fnocc_wfn. def run_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:114871,Validat,ValidationError,114871,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"al == 'DF':; if psi4.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; psi4.set_local_option('FNOCC', 'DF_BASIS_CC', ''); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""); else:; raise ValidationError(""""""Invalid type '%s' for DFCC"""""" % type_val). # triples?; if name == 'ccsd':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', False); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'); elif name == 'fno-ccsd(t)':; psi4.set_local_option('FNOCC', 'COMPUTE_TRIPLES', True); psi4.set_local_option('FNOCC', 'NAT_ORBS', True); set_cholesky_from('CC_TYPE'). if psi4.get_option('SCF', 'SCF_TYPE') not in ['CD', 'DF']:; raise ValidationError(""""""Invalid scf_type for DFCC.""""""). # save DF or CD ints generated by SCF for use in CC; psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). fnocc_wfn = psi4.fnocc(ref_wfn). optstash.restore(); return fnocc_wfn. [docs]def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); level = kwargs.get('level', 0). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:99305,Validat,ValidationError,99305,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"al EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external potential to the dimer wave function. total_external_potential = core.ExternalPotential(). for frag, frag_qxyz in external_potential.items():; if frag.upper() in ""ABC"":; chrgfield = QMMMbohr(); for qxyz in frag_qxyz:; chrgfield.extern.addCharge(*validate_qxyz(qxyz)). wfn.set_potential_variable(frag.upper(), chrgfield.extern); total_external_potential.appendCharges(chrgfield.extern.getCharges()). else:; core.print_out(""\n Warning! Unknown key for the external_potentials argument: %s"" % fra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:36707,Validat,ValidationError,36707,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"al and haphazard, so don’t start relying upon them. It is; tentatively envisioned that log files will have much of the same results as output; files but more as structured data than narrative, nicely formatted data.; In some cases where external calls are involved, the most detailed; information may only be collectable in the log file. It is; worthwhile to check the log file if expected results are missing from; the usual output file. If the log file is empty, the logging level may; be set too low.; To change the logging level to DEBUG from the command-line:; >>> psi4 --logging 10. To change the logging level to DEBUG in PsiAPI:; >>> psi4.set_output_file(<filebase>, loglevel=10). How to find the Psi4 module from the executable and vice versa¶; Because of the different conventions of C++/Linux and Python installation; layouts, the PSI4 executable and the PSI4 Python module aren’t; at fixed locations relative to each other. Accessors have been added; so that the executable can show where the module is, and the module; can show where the executable is. > /path/to/psi4/install/bin/psi4 --module; /path/to/psi4/install/lib//; > python -c ""import psi4;print(psi4.executable)""; /path/to/psi4/install/bin/psi4. table of contents. Compiling and Installing from Source; Planning: how to configure Psi4 and invoke CMake; How to build and install Psi4, the compact version; How to build, test, and install Psi4, in detail; What are the tools and dependencies strictly required for building Psi4; What are the add-on capabilities for Psi4 and what are their dependencies; How to use conda to get a Psi4 development environment; How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda; How to see what build configuration options are available; How to install elsewhere than /usr/local/psi4; How to compile for debugging; How to choose the compilation directory, {objdir}; How to save configuration settings for a future compilation; Wh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:62082,Access,Accessors,62082,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,5,['Access'],['Accessors']
Security,"al2sym[zeta_sym2val[b] - 1])); # reassemble def2-svp* properly instead of def2-dzvp*; if def2_basis.match(basisname.group('pre')) and b == ""d"":; BSET.append(basisname.group('pre') + ""s"" + basisname.group('post')[1:]); # reassemble pc-n basis sets properly; elif pc_basis.match(basisname.group('pre')):; BSET.append(basisname.group('pre') + ""{0:d}"".format(zeta_sym2val[b] - 1)); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(""""""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]'"""""" % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n"""""". for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e=sys.exc_info()[1]; raise ValidationError(""""""Basis set '%s' not available for molecule."""""" % (basis)). return (BSET, ZSET). def _contract_bracketed_basis(basisarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets *basisarray* (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]).; Used to print a nicely formatted basis set string in the results table. """"""; if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]. pre = basisarray[1][:zetaindx]; post = basisarray[1][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post; return basisstring. [docs]def xtpl_highest_1(functionname, zHI, valueHI, verbose=True, **kwargs):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.cbs`. .. math:: E_{total}^X = E_{total}^X. """"""; if isinstance(valueHI, float):. i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:4587,Validat,ValidationError,4587,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"al_option('CCEOM','R_CONVERGENCE',1e-4); psi4.set_local_option('CCEOM','E_CONVERGENCE',1e-5); psi4.cceom(ccwfn); psi4.cclambda(ccwfn); psi4.ccdensity(ccwfn). psi4.set_global_option('WFN', 'SCF'); psi4.revoke_global_option_changed('WFN'); psi4.set_global_option('DERTYPE', 'NONE'); psi4.revoke_global_option_changed('DERTYPE'). optstash.restore(); return ccwfn. [docs]def run_dfmp2_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 property calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX'],; ['SCF_TYPE']). psi4.set_global_option('ONEPDM', 'TRUE'); psi4.set_global_option('OPDM_RELAX', 'TRUE'). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if not psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_dipole=False, use_c1=True, **kwargs) # C1 certified. psi4.print_out('\n'); p4util.banner('DFMP2'); psi4.print_out('\n'). dfmp2_wfn = psi4.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; psi4.set_variable('CURRENT ENERGY', psi4.get_variable('SCS-MP2 TOTAL ENERGY')); psi4.set_variable('CURRENT CORRELATION ENERGY', psi4.get_variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; psi4.set_variable('CURRENT ENERGY', psi4.get_variable('MP2 TOTAL ENERGY')); psi4.set_variable('CURRENT CORRELATION ENERGY', psi4.get_variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = psi4.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:63284,Validat,ValidationError,63284,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"al_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); corl_type = core.get_global_option('CC_TYPE'). elif name == 'ccd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'ccsd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'a-ccsd(t)':; core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(AT)'); corl_type = core.get_global_option('CC_TYPE'); elif name == 'dfocc':; pass; else:; raise ValidationError('Unidentified method %s' % (name)). set_cholesky_from(corl_type). # conventional vs. optimized orbitals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'a-ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:56303,Validat,ValidationError,56303,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"al_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:11505,access,access,11505,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['access'],['access']
Security,"al_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') == '':; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n"");; if banner:; core.print_out("" "" + banner.center(58));; if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58));; ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(ref_wfn). # Compute dftd3; if hasattr(ref_wfn, ""_disp_functor""):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variable(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # broken clean-up; if do_broken:; raise ValidationError(""Broken Symmetry computations are temporarily disabled.""); scf_molecule.set_multiplicity(1); core.set_local_option('SCF', 'GUESS', 'READ'); core.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); core.print_out('\n'). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). optstash2.restore(). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n"");; core.print_out("" "" + banner.center(58));. scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs); core.set_legacy_wavefunction(scf_wfn). # The wfn from_file routine adds the npy suffix ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:34786,Validat,ValidationError,34786,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"al_option(opt), psi4.has_global_option_changed(opt))); for module in modules:; try:; if psi4.has_option_changed(module, opt) or not changedOnly:; if not module in options:; options[module] = {}; val = psi4.get_option(module, opt); options[module][opt] = {'value': val,; 'has_changed': psi4.has_option_changed(module, opt)}; if isinstance(val, basestring):; commands += """"""psi4.set_local_option('%s', '%s', '%s')\n"""""" % (module, opt, val); else:; commands += """"""psi4.set_local_option('%s', '%s', %s)\n"""""" % (module, opt, val); #if changedOnly:; # print('Appending module %s option %s value %s has_changed %s.' % \; # (module, opt, psi4.get_option(module, opt), psi4.has_option_changed(module, opt))); except RuntimeError:; pass. if commandsInsteadDict:; return commands; else:; return options. [docs]def mat2arr(mat):; """"""Function to convert psi4.Matrix *mat* to Python array of arrays.; Expects psi4.Matrix to be flat with respect to symmetry. """"""; if mat.rowdim().n() != 1:; raise ValidationError('Cannot convert Matrix with symmetry.'); arr = []; for row in range(mat.rowdim()[0]):; temp = []; for col in range(mat.coldim()[0]):; temp.append(mat.get(row, col)); arr.append(temp); return arr. [docs]def format_currentstate_for_input(func, name, allButMol=False, **kwargs):; """"""Function to return an input file in preprocessed psithon.; Captures memory, molecule, options, function, method, and kwargs.; Used to write distributed (sow/reap) input files. """"""; commands = """"""\n# This is a psi4 input file auto-generated from the %s() wrapper.\n\n"""""" % (inspect.stack()[1][3]); commands += """"""memory %d mb\n\n"""""" % (int(0.000001 * psi4.get_memory())); if not allButMol:; molecule = psi4.get_active_molecule(); molecule.update_geometry(); commands += format_molecule_for_input(molecule); commands += '\n'; commands += prepare_options_for_modules(changedOnly=True, commandsInsteadDict=True); commands += """"""\n%s('%s', """""" % (func.__name__, name.lower()); for key in kwargs.keys():; commands += """"""%s=%r, """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:12273,Validat,ValidationError,12273,psi4manual/1.0.0/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"alidationError(""""""Requested DELTA3 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn)); #; # cbs_delta3_wfn_lesser = kwargs.get('delta3_wfn_lesser', cbs_delta2_wfn).lower(); # if not (cbs_delta3_wfn_lesser in VARH.keys()):; # raise ValidationError(""""""Requested DELTA3 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_lesser' in kwargs:; # cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); # else:; # cbs_delta5_wfn_lesser = cbs_delta4_wfn; # if not (cbs_delta5_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:33888,Validat,ValidationError,33888,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"all counterpoise-corrected interaction energy):; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // CP Computation: Results. //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ============= Hartree =============; System: Energy (full):; Complex -257.4186740329; Monomer 1 -128.7093240575; Monomer 2 -128.7093240575; Interaction -0.0000259178. =========== kcal*mol^-1 ===========; System: Energy (full):; Complex -161532.6634330375; Monomer 1 -80766.3235846726; Monomer 2 -80766.3235846725; Interaction -0.0162636924. And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. Psi4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in Psi4. Table Of Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:21281,access,accessed,21281,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['access'],['accessed']
Security,"alling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; """"""Requested lesser %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn_lo""])). # Build string of title banner; cbsbanners = ''; cbsbanners += """"""core.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Setup: %s ' % label)\n""""""; cbsbanners += """"""core.print_out('\\n')\n\n""""""; exec(cbsbanners). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_alpha'; ]; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian', 'f_options']; GRAND_NEED = []; MODELCHEM = []. NEED = _expand_scheme_orders(metadata[0][""scheme""], metadata[0][""basis""][0], metadata[0][""basis""][1],; metadata[0][""wfn""], metadata[0][""options""], natom); GRAND_NEED.append(; dict(; zip(d_fields, [; 'scf', metadata[0][""scheme""],; _contract_bracketed_basis(metadata[0][""basis""][0]), metadata[0][""wf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:47261,Validat,ValidationError,47261,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"alling; function '%s' instead of 'energy', 'gradient' or 'hessian'."""""" % ptype). optstash = p4util.OptionsState(['BASIS'], ['WFN'], ['WRITER_FILE_LABEL']). # Define some quantum chemical knowledge, namely what methods are subsumed in others. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); natom = molecule.natom(). if metadata[0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (metadata[0][""wfn""])). if len(metadata) > 1:; for delta in metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested higher %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn""])); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; """"""Requested lesser %s method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" %; (delta[""treatment""], delta[""wfn_lo""])). # Build string of title banner; instructions = ""\n"" + p4util.banner(f"" CBS Setup{':' + label if label else ''} "", strNotOutfile=True) + ""\n""; core.print_out(instructions). # Call schemes for each portion of total energy to 'place orders' for calculations needed; d_fields = [; 'd_stage', 'd_scheme', 'd_basis', 'd_wfn', 'd_need', 'd_coef', 'd_energy', 'd_gradient', 'd_hessian', 'd_alpha'; ]; f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_energy', 'f_gradient', 'f_hessian', 'f_options']; GRAND_NEED = []; MODELCHEM = []. NEED = _expand_scheme_orders(metadata[0][""scheme""], metadata[0][""basis""][0], metadata[0][""basis""][1],; metadata[0][""wfn""], metadata[0][""options""], natom); GRAND_NEED.append(; dict(; zip(d_fields, [; 'scf', metadata[0][""scheme""],; _contract_bracketed_basis(metadata[0][""basis""][0]), metadata[0][""wfn""], NEED, +1, 0.0, None, None,; metadata[0][""alpha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:48868,Validat,ValidationError,48868,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"ally choose which fields to include, exclude and change. dict(**kwargs); Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. from_orm(obj). rtype; Model. get_results([client]); Return results as Atomic-flavored QCSchema. json(**kwargs); Generate a JSON representation of the model, include and exclude arguments as per dict(). parse_file(path, *[, encoding]); Parses a file into a Model object. parse_obj(obj). rtype; Model. parse_raw(data, *[, encoding]); Parses raw string or bytes into a Model object. plan(); Form QCSchema input from member data. schema([by_alias, ref_template]). rtype; DictStrAny. schema_json(*[, by_alias, ref_template]). rtype; unicode. serialize(encoding, *[, include, exclude, ...]); Generates a serialized representation of the model. set_basis(basis). set_keywords(keywords). set_method(method). update_forward_refs(**localns); Try to update ForwardRefs on fields based on this Model, globalns and localns. validate(value). rtype; Model. Methods Documentation. compare(other, **kwargs)¶; Compares the current object to the provided object recursively. Parameters. other (Model) – The model to compare to.; **kwargs – Additional kwargs to pass to qcelemental.compare_recursive. Returns; True if the objects match. Return type; bool. compute(client=None)[source]¶; Run quantum chemistry. Parameters; client (Optional[FractalClient]) – . classmethod construct(_fields_set=None, **values)¶; Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data.; Default values are respected, but no other validation is performed.; Behaves as if Config.extra = ‘allow’ was set since it adds all passed values. Return type; Model. Parameters. _fields_set (Optional[SetStr]) – ; values (Any) – . copy(*, include=None, exclude=None, update=None, deep=False)¶; Duplicate a model, optionally choose which fields to include, exclude and change. Parameters. include (Union[AbstractSetIntStr, MappingIntStr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html:2389,validat,validate,2389,psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,1,['validat'],['validate']
Security,"alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]; def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When True, do not print to the output file. Returns; -------; int; Number of bytes of memory set. Raises; ------; ValidationError; When <500MiB or disallowed type or misformatted. Examples; --------. >>> # [1] Passing absolute number of bytes; >>> psi4.set_memory(600000000); >>> psi4.get_memory(); Out[1]: 600000000L. >>> # [2] Passing memory value as string with units; >>> psi4.set_memory('30 GB'); >>> psi4.get_memory(); Out[2]: 30000000000L. >>> # Good examples; >>> psi4.set_memory(800000000) # 800000000; >>> psi4.set_memory(2004088624.9) # 2004088624; >>> psi4.set_memory(1.0e9) # 1000000000; >>> psi4.set_memory('600 mb') # 600000000; >>> psi4.set_memory('600.0 MiB') # 629145600; >>> psi4.set_memory('.6 Gb') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_mem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/util.html:3925,Validat,ValidationError,3925,psi4manual/master/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"alse, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" %; (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:9916,Validat,ValidationError,9916,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"alse`, interpret `elbl` as only the user/tagging; extension to nucleus label, e.g. `_mine` or `4` in the previous examples.; missing_enabled_return; {'minimal', 'none', 'error'}; What to do when an enabled domain is of zero-length? Respectively, return; a fully valid but empty molrec, return empty dictionary, or throw error.; np_out; When `True`, fields geom, elea, elez, elem, mass, real, elbl will be ndarray.; Use `False` to get a json-able version. Returns; -------; molrec : dict; Molecule dictionary spec follows. Its principles are. (1) contents are fully validated and defaulted - no error; checking necessary,. (2) contents may be mildly redundant - atomic numbers and; element symbols present,. (3) big system, nat-length single-type arrays, not small system,; nat-number heterogeneous objects,. (4) some fields are optional (e.g., fix_symmetry) but largely; self-describing so units or fix_com must be present. (5) apart from some mild optional fields, _all_ fields will; be present (corollary of ""fully validated and defaulted"") - no; need to check for every key. in some cases like efp, keys will; appear in blocks, so pre-handshake there will be a few hint keys; and post-handshake they will be joined by full qm-like molrec. (6) molrec should be idempotent through this function (equiv to; schema validator) but are not idempotent throughout its life. if; fields permit, frame may be changed. Future? if fields permit,; mol may be symmetrized. Coordinates and angles may change units; or range if program returns them in only one form. name : str, optional; Label for molecule; should be valid Python identifier.; units : {'Angstrom', 'Bohr'}; Units for `geom`.; input_units_to_au : float, optional; If `units='Angstrom'`, overrides consumer's value for [A]-->[a0] conversion.; fix_com : bool; Whether translation of `geom` is allowed or disallowed.; fix_orientation : bool; Whether rotation of `geom` is allowed or disallowed.; fix_symmetry : str, optional; Maximal point group symm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:5900,validat,validated,5900,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['validat'],['validated']
Security,"alue'] = 'aug-cc-pvtz/mp2fit'; elif self.method in ['ccsd(t)-f12-cabsfit']:; if self.unaugbasis and self.auxbasis:; #options['BASIS']['JKFIT']['value'] = self.auxbasis + '/jkfit'; #options['BASIS']['JKFITB']['value'] = self.unaugbasis + '/jkfit'; #options['BASIS']['MP2FIT']['value'] = self.auxbasis + '/mp2fit'; #options['BASIS']['DFLHF']['value'] = self.auxbasis + '/jkfit'; options['BASIS']['JKFITC']['value'] = 'aug-cc-pv5z/mp2fit'; else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)); elif ('df-' in self.method) or ('f12' in self.method) or (self.method in ['mp2c', 'dft-sapt', 'dft-sapt-pbe0acalda']):; if self.unaugbasis and self.auxbasis:; options['BASIS']['JKFIT']['value'] = self.auxbasis + '/jkfit'; options['BASIS']['JKFITB']['value'] = self.unaugbasis + '/jkfit'; options['BASIS']['MP2FIT']['value'] = self.auxbasis + '/mp2fit'; options['BASIS']['DFLHF']['value'] = self.auxbasis + '/jkfit'; else:; raise ValidationError(""""""Auxiliary basis not predictable from orbital basis '%s'"""""" % (self.basis)); return text, options. [docs] def prepare_basis_for_molpro(self):; text = ''; ; for opt, val in self.options['BASIS'].items():; #print opt, val['value']; #print molpro_basissets.altbasis.keys(); if not text:; text += """"""basis={\n""""""; try:; # jaxz, maxz, etc.; for line in molpro_basissets.altbasis[val['value']]:; text += """"""%s\n"""""" % (line); text += '\n'; except KeyError:; # haxz; if val['value'].startswith('heavy-aug-'):; text += """"""set,%s; default,%s,H=%s\n"""""" % (opt.lower(), self.augbasis, self.unaugbasis); # xz, axz, 6-31g*; else:; text += """"""set,%s; default,%s\n"""""" % (opt.lower(), val['value']); ; if text:; text += """"""}\n\n"""""". return text. [docs] def format_infile_string(self):; """""". """"""; # Handle memory and comment; memcmd, _memkw = """"""***, %s\nmemory,%d,m\n"""""" % (self.molecule.tagline, int(math.ceil(self.memory / 8.0))), {}. # Handle molecule and basis set; molcmd, _molkw = self.molecule.format_molecule_for_molp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html:16362,Validat,ValidationError,16362,psi4manual/1.0.0/_modules/qcdb/molpro2.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molpro2.html,1,['Validat'],['ValidationError']
Security,"alues are the option value. All; are case insensitive.; verbose : int, optional; Control print volume.; Returns; -------; None; """"""; optionre = re.compile(r'\A(?P<module>\w+__)?(?P<option>\w+)\Z', re.IGNORECASE); rejected = {}. for k, v, in options_dict.items():; mobj = optionre.match(k); module = mobj.group('module').upper()[:-2] if mobj.group('module') else None; option = mobj.group('option').upper(). if module:; if (module, option, v) not in [('SCF', 'GUESS', 'READ')]:; # TODO guess/read exception is for distributed driver. should be handled differently.; try:; core.set_local_option(module, option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_local_option', module, option, v); else:; try:; core.set_global_option(option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_global_option', option, v). if rejected:; raise ValidationError(f'Error setting options: {rejected}'); # TODO could subclass ValidationError and append rejected so that run_json could handle remanants. [docs]def set_module_options(module, options_dict):; """"""; Sets Psi4 module options from a module specification and input dictionary.; """""". for k, v, in options_dict.items():; core.set_local_option(module.upper(), k.upper(), v). ## OEProp helpers. [docs]def pcm_helper(block):; """"""; Passes multiline string *block* to PCMSolver parser. Parameters; ----------; block: multiline string with PCM input in PCMSolver syntax.; """""". suffix = str(os.getpid()) + '.' + str(uuid.uuid4())[:8]; pcmsolver_fname = 'pcmsolver.' + suffix + '.inp'; with open(pcmsolver_fname, 'w') as handle:; handle.write(block); import pcmsolver; parsed_pcm = pcmsolver.parse_pcm_input(pcmsolver_fname); os.remove(pcmsolver_fname); pcmsolver_parsed_fname = '@pcmsolver.' + suffix; with open(pcmsolver_parsed_fname, 'w') as tmp:; tmp.write(parsed_pcm); core.set_local_option('PCM', 'PCMSOLVER_PARSED_FNAME', '{}'.format(pcmsolver_parsed_fname)).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:12964,Validat,ValidationError,12964,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"alues.index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" %; (basisstring, zeta_val2sym[zeta_sym2val[b] - 1])); # reassemble def2-svp* properly instead of def2-dzvp*; if def2_basis.match(basisname.group('pre')) and b == ""d"":; BSET.append(basisname.group('pre') + ""s"" + basisname.group('post')[1:]); # reassemble pc-n basis sets properly; elif pc_basis.match(basisname.group('pre')):; BSET.append(basisname.group('pre') + ""{0:d}"".format(zeta_sym2val[b] - 1)); # assemble nZaPa basis sets; elif zapa_basis.match(basisname.group('post')):; bzapa = b.replace(""d"",""2"").replace(""t"",""3"").replace(""q"",""4""); BSET.append(basisname.group('pre') + bzapa + basisname.group('post')); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(; """"""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[1234]' or '[1234567]ZaPa' """""" % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n""""""; elif isinstance(molecule, core.Molecule):; molecule = qcdb.Molecule(molecule.to_dict()). for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e = sys.exc_info()[1]; raise ValidationError(""""""Basis set '%s' not available for molecule."""""" % (basis)). return (BSET, ZSET). def _contract_bracketed_basis(basisarray):; """"""Function to reform a bracketed basis set string from a sequential series; of basis sets. Essentially the inverse of _expand_bracketed_basis(). Used to; print a nicely formatted basis set string in the results table. Parameters; ----------; basisarray : list; Basis set names, differing by zeta level, e.g. ``[""cc-pvqz"", ""cc-pv5z""]``. Retur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:4583,Validat,ValidationError,4583,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ame']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exists, must be Python 2; str = str; unicode = unicode; bytes = str; basestring = basestring. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:87213,Validat,ValidationError,87213,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"ame.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). def scf_xtpl_truhlar_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme using power form for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Truhlar, Chem. Phys. Lett. 294 (1998) 45-48, DOI: 10.1016/S0009-2614(98)00866-5. .. math:: E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4. """""". if type(valueLO) != type(valueHI):; raise ValidationError(""scf_xtpl_truhlar_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.40. beta_division = 1 / (zHI ** (-1 * alpha) - zLO ** (-1 * alpha)); beta_mult = zHI ** (-1 * alpha). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Truhlar 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:9088,Validat,ValidationError,9088,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ame; with open(csx, 'r') as handle:; csxdict = xd.parse(handle). return csxdict. [docs]def getFromDict(dataDict, mapList):; return reduce(lambda d, k: d[k], mapList, dataDict). [docs]def csx2endict():; """"""Grabs the CSX file as a dictionary, encodes translation of PSI variables; to XML blocks, gathers all available energies from CSX file into returned; dictionary. """"""; blockprefix = ['chemicalSemantics', 'molecularCalculation', 'quantumMechanics', 'singleReferenceState', 'singleDeterminant']; blockmidfix = ['energies', 'energy']; prefix = 'cs:'. pv2xml = {; 'MP2 CORRELATION ENERGY': [['mp2'], 'correlation'],; 'MP2 SAME-SPIN CORRELATION ENERGY': [['mp2'], 'sameSpin correlation'],; 'HF TOTAL ENERGY': [['abinitioScf'], 'electronic'],; 'NUCLEAR REPULSION ENERGY': [['abinitioScf'], 'nuclearRepulsion'],; 'DFT FUNCTIONAL TOTAL ENERGY': [['dft'], 'dftFunctional'],; 'DFT TOTAL ENERGY': [['dft'], 'electronic'],; 'DOUBLE-HYBRID CORRECTION ENERGY': [['dft'], 'doubleHybrid correction'],; 'DISPERSION CORRECTION ENERGY': [['dft'], 'dispersion correction'],; }. csxdict = xml2dict(); enedict = {}; for pv, lpv in pv2xml.items():; address = blockprefix + lpv[0] + blockmidfix; indices = [prefix + bit for bit in address]; try:; qwer = getFromDict(csxdict, indices); except KeyError:; continue; for v in qwer:; vv = v.values(); if vv[0] == prefix + lpv[1]:; enedict[pv] = float(vv[1]). return enedict. [docs]def compare_csx():; """"""Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. """"""; if 'csx4psi' in sys.modules.keys():; if core.get_global_option('WRITE_CSX'):; enedict = csx2endict(); compare_integers(len(enedict) >= 2, True, 'CSX harvested'); for pv, en in enedict.items():; compare_values(core.get_variable(pv), en, 6, 'CSX ' + pv + ' ' + str(round(en, 4))). Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. Module code. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:18282,validat,validate,18282,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['validat'],['validate']
Security,"ame_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Helgaker SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Helgaker SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" %; (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_truhlar_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname : string; Name of the CBS component.; zLO : int; Lower zeta level.; valueLO : float; Lower value used for extrapolation.; zHI : int; Higher zeta level. Should be equal to zLO + 1.; valueHI : float; Higher value used for extrapolation.; alpha : float, optional; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:10092,Validat,ValidationError,10092,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ame_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme). return value. elif isinstance(valueLO, (core.Matrix, core.Vector)):; beta = valueHI.clone(); beta.name = 'Helgaker SCF (%s, %s) beta' % (zLO, zHI); beta.subtract(valueLO); beta.scale(beta_division); beta.scale(beta_mult). value = valueHI.clone(); value.subtract(beta); value.name = 'Helgaker SCF (%s, %s) data' % (zLO, zHI). if verbose > 2:; core.print_out(""""""\n ==> Helgaker 2-point exponential SCF extrapolation for method: %s <==\n\n"""""" %; (functionname.upper())); core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_helgaker_2: datatype is not recognized '%s'."" % type(valueLO)). [docs]def scf_xtpl_truhlar_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme using power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 3.4`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [2]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta X^{-\alpha}, \alpha = 3.4`. References; ----------. .. [2] Truhlar, Chem. Phys. Lett. 294 (1998) 45-48,; DOI: 10.1016/S0009-2614(98)00866-5. """""". if type(valueLO) != type(valueHI):; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:10334,Validat,ValidationError,10334,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"ameters; ----------; expected : file; Reference FCHK file against which `computed` is compared.; computed : file; Input FCHK file to compare against `expected`.; atol_exponent : int or float; Absolute tolerance for high accuracy fields -- 1.e-8 or 1.e-9 is suitable.; Values less than one are taken literally; one or greater taken as decimal digits for comparison.; So `1` means `atol=0.1` and `2` means `atol=0.01` but `0.04` means `atol=0.04`; Note that the largest expressable processed atol will be `~0.99`.; label : str; Label for passed and error messages. """"""; fchk_ref = fchkfile_to_string(expected).splitlines(); fchk_calc = fchkfile_to_string(computed).splitlines(). high_accuracy = atol_exponent; low_accuracy = 3. # Those listed below need super high scf convergence (d_conv 1e-12) and might; # show machine dependence. They will be tested with low_accuracy.; sensitive = ['Current cartesian coordinates', 'MO coefficients']. if len(fchk_ref) != len(fchk_calc):; raise ValidationError('The two FCHK files to compare have a different file length! \n'). index = 0; max_length = len(fchk_calc); tests = []; for start in range(max_length):; if index >= max_length:; break; line = fchk_calc[index]; if ""N="" in line:; offset, calc = _consume_fchk_section(fchk_calc, index); _, ref = _consume_fchk_section(fchk_ref, index); if any(x in line for x in sensitive):; test = compare_arrays(ref, calc, low_accuracy, f"" matrix section: {line}""); else:; test = compare_arrays(ref, calc, high_accuracy, f"" matrix section: {line}""); index += offset; elif "" R "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_values(ref, calc, high_accuracy, f"" float value: {line}""); index += 1; elif "" I "" in line and ""N="" not in line:; calc = line.split()[-1]; ref = fchk_ref[index].split()[-1]; test = compare_integers(ref, calc, f"" int value: {line}""); index += 1; else:; test = compare_strings(line, fchk_ref[index], f""FCK text line {index+1}.""); index += 1;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html:4044,Validat,ValidationError,4044,psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html,1,['Validat'],['ValidationError']
Security,"an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! FISAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' FISAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('FISAPT requires requires \""reference rhf\"".'). if ref_wfn is None:; core.timer_on(""FISAPT: Dimer SCF""); ref_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""FISAPT: Dimer SCF""). core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(),; ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"",; core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). sapt_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SAPT"", core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"", core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). # Turn of dispersion for -d; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:146165,Validat,ValidationError,146165,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"an absolute paths for returned code and file dictionary.; Prepares flat diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames.; asdf.plot_flat(‘CCSD-CP-atqzadz’, failoninc=False). plot_iowa(modelchem, benchmark='default', sset='default', failoninc=True, verbose=False, title='', xtitle='', xlimit=2.0, view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Computes individual errors for single modelchem versus; benchmark over subset sset. Coloring green-to-purple with; maximum intensity at xlimit. Prepares Iowa plot instructions and; either executes them if matplotlib available (Canopy) or prints them. plot_liliowa(modelchem, benchmark='default', failoninc=True, xlimit=2.0, view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Note that not possible to access sset of component databases. That is, for Database SSIBBI, SSI-only arylaryl is accessible b/c not defined in BBI, but SSI-only neutral is not accessible. plot_modelchems(modelchem, benchmark='default', mbenchmark=None, sset='default', msset=None, failoninc=True, verbose=False, color='sapt', xlimit=4.0, labeled=True, view=True, mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Computes individual errors and summary statistics over all component; databases for each model chemistry in array modelchem versus benchmark; over subset sset. mbenchmark and msset are array options (same; length as modelchem) that override benchmark and sset, respectively,; for non-uniform specification. Thread color can be ‘rgb’ for old; coloring, a color name or ‘sapt’ for spectrum coloring.; saveas conveys directory (‘/’) and/or filename for saving the; resulting plot. File extension is not accessible, but graphicsformat; array requests among ‘png’, ‘pdf’, and ‘eps’ formats. relpath; forces paths to saved fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:38150,access,accessible,38150,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,4,['access'],['accessible']
Security,"ance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct wavefunction from the provided information. set_memory(inputval[, execute]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dicti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:261733,validat,validate,261733,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['validat'],['validate']
Security,"ance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:312916,validat,validate,312916,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['validat'],['validate']
Security,"ance.PYinput_units_to_au = 1.0 / psi_bohr2angstroms. instance.update_geometry(); return instance. @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' does not exist."""""" %; (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(r'^(?:\s*)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER +; '(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)', re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match he",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:9768,Validat,ValidationError,9768,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"and a speculative next tag, say v1.1rc2,; and use 7 “z”s for the part you can’t predict. 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18>>> vi psi4/metadata.py. >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 5d87b55..6cbc05e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,6 +1,6 @@; -__version__ = '1.1a1'; -__version_long = '1.1a1+007a9b6'; -__version_upcoming_annotated_v_tag = '1.1a2'; +__version__ = '1.1rc1'; +__version_long = '1.1rc1+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.1rc2'. >>> git add psi4/metadata.py. >>> git commit -m ""v1.1rc1"". OBSERVE undefined version state. 1; 2; 3; 4; 5; 6; 7; 8; 9>>> git describe --abbrev=7 --long --always HEAD; v1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. >>> psi4/versioner.py; Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded); undefined {master} 6100822 1.0.0.999 1.0 <-- undefined+6100822. Note 7-char git hash for the new commit, here “6100822”. ACT to bump tag in git, then bump git tag in code. Use the decided-upon tag v1.1rc1 and the observed hash “6100822” to; mint a new annotated tag, minding that “v”s are present here.; Use the observed hash to edit psi4/psi4/metadata.py and commit immediately. 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18>>> git tag -a v1.1rc1 6100822 -m ""v1.1rc1"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 6cbc05e..fdc202e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,5 +1,5 @@; __version__ = '1.1rc1'; -__version_long = '1.1rc1+zzzzzzz'; +__version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> psi4/versioner.py; Amazing, this can't actually happen that git hash stored at git commit.; >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.1rc1"". OBSERVE current versioning state. Nothing to make note of, this is just a snapshot. 1; 2; 3; 4; 5; 6; 7; 8;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/manage_git-1.html:2345,hash,hash,2345,psi4manual/1.1.0/manage_git-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/manage_git-1.html,6,['hash'],['hash']
Security,"and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(dashparam). # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html:3115,Validat,Validate,3115,psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['Validate']
Security,"and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. return {'method': method_name, 'basis': basis}. # Drop out for unsupported calls; if ptype is None:; raise ValidationError(""A CBS call was detected, but no ptype was passed in. Please alert a dev.""); elif ptype not in [""energy"", ""gradient"", ""hessian""]:; raise ValidationError(f""{ptype.title()}: Cannot extrapolate or delta correct {ptype} yet.""). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['verbose'] = cbs_verbose. if user_dertype is not None:; cbs_kwargs['dertype'] = user_dertype. # Find method and basis; metadata = []; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; stage = {}; stage['wfn'] = method_list[0]; stage['basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; stage['scheme'] = kwargs.pop('scf_scheme'); stage['stage'] = ""scf""; stage['treatment'] = ""scf""; else:; # _validate_cbs_inputs will produce scf stage automatically; stage = {}; stage['wfn'] = method_list[0]; stage['basis']",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:41119,Validat,ValidationError,41119,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,4,['Validat'],['ValidationError']
Security,"and_fill_efp(fragment_files=None, hint_types=None, geom_hints=None):. if (; fragment_files is None; or hint_types is None; or geom_hints is None; or fragment_files == [None]; or hint_types == [None]; or geom_hints == [None]; or not (len(fragment_files) == len(hint_types) == len(geom_hints)); ):. raise ValidationError(; """"""Missing or inconsistent length among efp quantities: fragment_files ({}), hint_types ({}), and geom_hints ({})"""""".format(; fragment_files, hint_types, geom_hints; ); ). # NOTE: imposing case on file; try:; files = [f.lower() for f in fragment_files]; except AttributeError:; raise ValidationError(""""""fragment_files not strings: {}"""""".format(fragment_files)). if all(f in [""xyzabc"", ""points"", ""rotmat""] for f in hint_types):; types = hint_types; else:; raise ValidationError(""""""hint_types not among 'xyzabc', 'points', 'rotmat': {}"""""".format(hint_types)). hints = []; hlen = {""xyzabc"": 6, ""points"": 9, ""rotmat"": 12}; for ifr, fr in enumerate(geom_hints):; try:; hint = [float(f) for f in fr]; except (ValueError, TypeError):; raise ValidationError(""""""Un float-able elements in geom_hints[{}]: {}"""""".format(ifr, fr)). htype = hint_types[ifr]; if len(hint) == hlen[htype]:; hints.append(hint); else:; raise ValidationError(""""""EFP hint type {} not {} elements: {}"""""".format(htype, hlen[htype], hint)). return {""fragment_files"": files, ""hint_types"": types, ""geom_hints"": hints}. def validate_and_fill_geometry(geom=None, tooclose=0.1, copy=True):; """"""Check `geom` for overlapping atoms. Return flattened"""""". npgeom = np.array(geom, copy=copy, dtype=float).reshape((-1, 3)). # Upper triangular; metric = tooclose ** 2; tooclose_inds = []; for x in range(npgeom.shape[0]):; diffs = npgeom[x] - npgeom[x + 1 :]; dists = np.einsum(""ij,ij->i"", diffs, diffs). # Record issues; if np.any(dists < metric):; indices = np.where(dists < metric)[0]; tooclose_inds.extend([(x, y, dist) for y, dist in zip(indices + x + 1, dists[indices] ** 0.5)]). if tooclose_inds:; raise ValidationError(; """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:17174,Validat,ValidationError,17174,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"andard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n""); core.print_out("" "" + banner.center(58)). scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). # The wfn from_file routine adds the npy suffix if needed, but we add it here so that; # we can use os.path.isfile to query whether the file exists before attempting to read; read_filename = scf_wfn.get_scratch_filename(180) + '.npy'; if ((core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename)):; old_wfn = core.Wavefunction.from_file(read_filename). Ca_occ = old_wfn.Ca_subset(""SO"", ""OCC""); Cb_occ = old_wfn.Cb_subset(""SO"", ""OCC""). if old_wfn.molecule().schoenflies_symbol() != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if old_wfn.basisset().name() == scf_wfn.basisset().name():; core.print_out(f"" Reading orbitals from file {read_filename}, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out(f"" Reading orbitals from file {read_filename}, projecting to new basis.\n\n""); core.print_out("" Computing basis projection from %s to %s\n\n"" % (old_wfn.basisset().name(), scf_wfn.basisset().name())). pCa = scf_wfn.basis_projection(Ca_occ, old_wfn.nalphapi(), old_wfn.basisset(), scf_wfn.basisset()); pCb = scf_wfn.basis_projection(Cb_occ, old_wfn.nbetapi(), old_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Strip off headers to only get R, RO, U, CU; old_ref = old_wfn.name().replace(""KS"", """").replace(""HF"", """"); new_ref = scf_wfn.name().replace(""KS"", """").replace(""HF"", """"); if old_ref != new_ref:; scf_wfn.reset_occ_ = True. elif (core.get_option('SCF', 'GUESS') == 'READ') and not os.pat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:52416,Validat,ValidationError,52416,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"andles delta corrections. Parameters; ----------; method_name : str; A ``""method/basis""`` style string defining the calculation. Returns; -------; tuple; Tuple in the ``(method_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based wrapper of the CBS function. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:62490,Validat,ValidationError,62490,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ands = '\n'; # commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); # commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; # (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); # exec(commands); #; # psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). def _expand_scheme_orders(scheme: str, basisname: List[str], basiszeta: List[int], wfnname: str, options: Dict) -> Dict[str, Dict[str, Any]]:; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszeta, with *basisname* and *basiszeta* distributed therein. """"""; Nxtpl = len(basiszeta). try:; scheme.split(); except AttributeError:; raise UpgradeHelper(scheme, repr(scheme.__name__), 1.6, ' Replace extrapolation function with function name.'). if scheme not in xtpl_procedures:; raise ValidationError(f""Extrapolation function ({scheme}) not among registered extrapolation schemes: {list(xtpl_procedures.keys())}. Use 'register_xtpl_function' function.""). if int(scheme.split(""_"")[-1]) != Nxtpl:; raise ValidationError(f""""""Call to '{scheme}' not valid with '{len(basiszeta)}' basis sets.""""""). NEED = {}; for idx in range(Nxtpl):; NEED[_lmh_labels[Nxtpl][idx]] = dict(; zip(_f_fields, [wfnname, basisname[idx], basiszeta[idx], options, 0.0, None, None, None, None])); return NEED. def _contract_scheme_orders(needdict, datakey: str = 'f_energy') -> Dict[str, Any]:; """"""Prepared named arguments for extrapolation functions by; extracting zetas and values (which one determined by *datakey*) out; of *needdict* and returning a dictionary whose keys are constructed; from _lmh_labels. """"""; largs = {}; largs['functionname'] = needdict['HI']['f_wfn']; Nxtpl = len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:37044,Validat,ValidationError,37044,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['Validat'],['ValidationError']
Security,"angular frequency :math:`\omega`.; When converting to other physical quantities, the broadening parameter has to be modified accordingly.; If :math:`\gamma_{\omega}` is the chosen broadening parameter then:. - Wavelength: :math:`gamma_{\lambda} = \frac{\lambda_{ij}^{2}}{2\pi c}\gamma_{\omega}`; - Frequency: :math:`gamma_{\nu} = \frac{\gamma_{\omega}}{2\pi}`; - Energy: :math:`gamma_{E} = \gamma_{\omega}\hbar`. References; ----------; A. Rizzo, S. Coriani, K. Ruud, ""Response Function Theory Computational Approaches to Linear and Nonlinear Optical Spectroscopy"". In Computational Strategies for Spectroscopy.; https://doi.org/10.1002/9781118008720.ch2; """""". # Transmute inputs to np.ndarray; if isinstance(poles, list):; poles = np.array(poles); if isinstance(residues, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelengt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:10268,Validat,Validate,10268,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,4,['Validat'],['Validate']
Security,"another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished at a variety of levels,; ranging from global environment variables to direct control of thread count in; the input file, to even directives specific to each model. This hierarchy is; explained below. Note that each deeper level trumps all previous levels.; (1) OpenMP/MKL Environment Variables. Deprecated since version 1.1: Environment variables OMP_NUM_THREADS and MKL_NUM_THREADS; do not affect threading in PSI4. (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads. Note that is is not available for PsiAPI mode of operation.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in PSI4 can; override the number of threads set by environment variables. This functionality; is accessed via the set_num_threads() function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a PSI4 input file. An example input for this feature is:; # A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1, 5):; set_num_threads(nthread); energy(""scf/cc-pvdz""). In PsiAPI mode of operation, this syntax, psi4.set_num_threads(nthread), is; the primary way to control threading.; (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; set MODULE_NAME df_ints_num_threads n. to explicitly control the nu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external.html:13202,access,accessed,13202,psi4manual/master/external.html,https://psicode.org,https://psicode.org/psi4manual/master/external.html,9,['access'],['accessed']
Security,"ansforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. To; facilitate this workflow, PSI4 exports key quantities such as integrals,; densities and molecular orbitals in NumPy format. From this point, the; programmer can simply call the appropriate PSI4 functions to compute the; desired input quantities, retrieve them in NumPy format, and then write the; remaining code using standard Python and/or NumPy syntax. This approach does; not require any recompilation of code, resulting in a particularly facile; development workflow. Detailed examples and tutorials are available in the; Psi4NumPy repository. Avoiding the need to modify Psi4, using plugins¶; In the early days when PSI4 was still primarily a C++ code, development; was very cumbersome due to a lengthy build process. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from exter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_ways_to_add.html:3136,access,access,3136,psi4manual/master/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_ways_to_add.html,9,['access'],['access']
Security,"ant to change and for the current has_changed status; (presumably reflecting whether the user has changed the value, as long as; no preceeding code has corrupted that definition). The python function; then makes its changes to the option and runs any c-side modules with; those changes. Finally, just before the function returns, the options are; reset to the user’s value and has_changed status (which should now again; reflect only whether the user has changed the value). Warning; PUREAM is an exception in that its value and; has_changed() value only reflect what the user has explicitly set.; This keyword should not be queried to find out the current; PUREAM state for the active basis; use instead,; psi4.MintsHelper().basisset().has_puream(). Reading Options in Module¶. Handling Options in Driver¶; This section is about the scopes of options and how best to handle them in; the python driver. There are four groups of commands available.; Options from the c-side Options object are accessible in the Python driver through four sets of commands. get; get_global_option(); get_local_option(); get_option(). set; set_global_option(); set_local_option(). has_changed; has_global_option_changed(); has_local_option_changed(); has_option_changed(). revoke_changed; revoke_global_option_changed(); revoke_local_option_changed(). There’s a pattern here. Setting something, either a value (set) or a; negative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/optionshandling-1.html:6379,access,accessible,6379,psi4manual/4.0b5/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/optionshandling-1.html,4,['access'],['accessible']
Security,"ants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Convert wrapper directives from options (where ppl know to find them) to kwargs (suitable for non-globals transmitting); kwargs['findif_verbose'] = core.get_option(""FINDIF"", ""PRINT""); kwargs['findif_stencil_size'] = core.get_option(""FINDIF"", ""POINTS""); kwargs['findif_step_size'] = core.get_option(""FINDIF"", ""DISP_SIZE""). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name); _filter_renamed_methods(""gradient"", lowername). # * Prevent methods that do not have associated derivatives; if lowername in energy_only_methods:; raise ValidationError(f""`gradient('{name}')` does not have an associated gradient.""). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_global_option('BASIS') or kwargs.get('basis'); if lowername in integrated_basis_methods and userbas is None:; kwargs['basis'] = '(auto)'. # Are we planning?; plan = task_planner.task_planner(""gradient"", lowername, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:43371,Validat,ValidationError,43371,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Validat'],['ValidationError']
Security,"any-body gradients of different BSSE schemes. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. scf-upcast-custom-basis; test scf castup with custom basis sets. aediis-2; EDIIS test case from 10.1063/1.1470195. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. mints2-bse; Similar to mints2, but using the BSE to specify the basis sets. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. soscf-large; Second-order SCF convergnece: Benzene. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, rest",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:18155,validat,validate,18155,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['validat'],['validate']
Security,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec GEOS[rgt]; molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""PsiMod.print_ou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:38617,access,accessed,38617,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['access'],['accessed']
Security,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(format_molecule_for_input(GEOS[rgt])); molecule = PsiMod.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:38925,access,accessed,38925,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['access'],['accessed']
Security,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; core.print_out(instructions). with open('%s-master.in' % (dbse), 'w') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # build string of title banner; banners = ''; banners += """"""core.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""core.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""core.print_out(' Database Contributions Map:\\n %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:17899,access,accessed,17899,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,3,['access'],['accessed']
Security,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). fmaster = open('%s-master.in' % (dbse), 'w'); fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)); fmaster.close(). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # extra definition of molecule so that logic in building commands string has something to act on; exec(p4util.format_molecule_for_input(GEOS[rgt])); molecule = psi4.get_active_molecule(). # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:39671,access,accessed,39671,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['access'],['accessed']
Security,"ap') command.\n"""""" % (dbse); instructions += """""" The former may look very peculiar since processed and pickled python rather than\n""""""; instructions += """""" raw input is written. Follow the instructions below to continue.\n\n""""""; instructions += """""" (1) Run all of the %s-*.in input files on any variety of computer architecture.\n"""""" % (dbse); instructions += """""" The output file names must be as given below.\n\n""""""; for rgt in HSYS:; instructions += """""" psi4 -i %-27s -o %-27s\n"""""" % (rgt + '.in', rgt + '.out'); instructions += """"""\n (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructions += """""" %s-master.in into that directory and run it. The job will be trivial in\n"""""" % (dbse); instructions += """""" length and give summary results for the database in its output file.\n\n""""""; instructions += """""" psi4 -i %-27s -o %-27s\n\n"""""" % (dbse + '-master.in', dbse + '-master.out'); instructions += """""" Alternatively, a single-job execution of the database may be accessed through\n""""""; instructions += """""" the database wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructions). with open('%s-master.in' % (dbse), 'w') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); fmaster.write(""database('%s', '%s', mode='reap', cp='%s', rlxd='%s', zpe='%s', benchmark='%s', linkage=%d, subset=%s, tabulate=%s)\n\n"" %; (name, db_name, db_cp, db_rlxd, db_zpe, db_benchmark, os.getpid(), HRXN, db_tabulate)). # Loop through chemical systems; ERGT = {}; ERXN = {}; VRGT = {}; VRXN = {}; for rgt in HSYS:; VRGT[rgt] = {}. # build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Database %s Computation: Reagent %s \\n %s')\n"""""" % (db_name, rgt, TAGL[rgt]); banners += """"""psi4.print_out('\\n')\n\n"""""". # build string of lines that defines contribution of rgt to each rxn; actives = ''; actives += """"""psi4.print_out(' Database Contributions Map:\\n %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:17779,access,accessed,17779,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['access'],['accessed']
Security,"apt_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS""),; ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SAPT"", sapt_basis). minao = core.BasisSet.build(ref_wfn.molecule(), ""BASIS"",; core.get_global_option(""MINAO_BASIS"")); ref_wfn.set_basisset(""MINAO"", minao). fisapt_wfn = core.fisapt(ref_wfn). optstash.restore(); return fisapt_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """""". # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = core.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to core.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:108766,Validat,ValidationError,108766,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ar point group to the point group object arg2. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits) → None; Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float) → None; Assigns the value arg3 to the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str; Gets the cleaned up label of atom arg2 (C2 => C, H4 = H). symmetrize(self: psi4.core.Molecule, arg0: float) → None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule) → str; Returns the symmetry specified in the input. to_arrays(); Exports coordinate info into NumPy arrays. Returns:; geom, mass, elem, elez, uniq (ndarray, ndarray, ndarray, ndarray, ndarray) – (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; —–; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True); Serializes instance into Molecule dictionary. to_schema(dtype, units='Angstrom', return_type='json'); Serializes instance into JSON or YAML according to schema dtype. to_string(dtype, units='Angstrom', atom_format=None, ghost_format=None, width=17, prec=12); Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None; Translates molecule by arg2. units(self: psi4.core.Molecule) → str; Returns units used to define the geometry, i.e. ‘Angstrom’ or ‘Bohr’. update_geometry(self: psi4.core.Molecule) → None; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:55479,hash,hash,55479,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,1,['hash'],['hash']
Security,"ar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.core.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, str):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]; # else:; # raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); # else:; # func = func.lower(); # if func not in dashcoeff[dashlvl].keys():; # raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html:3010,Validat,ValidationError,3010,psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,1,['Validat'],['ValidationError']
Security,"arameter then:. - Wavelength: :math:`gamma_{\lambda} = \frac{\lambda_{ij}^{2}}{2\pi c}\gamma_{\omega}`; - Frequency: :math:`gamma_{\nu} = \frac{\gamma_{\omega}}{2\pi}`; - Energy: :math:`gamma_{E} = \gamma_{\omega}\hbar`. References; ----------; A. Rizzo, S. Coriani, K. Ruud, ""Response Function Theory Computational Approaches to Linear and Nonlinear Optical Spectroscopy"". In Computational Strategies for Spectroscopy.; https://doi.org/10.1002/9781118008720.ch2; """""". # Transmute inputs to np.ndarray; if isinstance(poles, list):; poles = np.array(poles); if isinstance(residues, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:10457,Validat,Validate,10457,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,4,['Validat'],['Validate']
Security,"are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". from psi4 import core; from psi4 import extras. [docs]class PsiException(Exception):; """"""Error class for Psi.""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Error called for problems with the input file. Prints; error message *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); # print(""%s"" % repr(msg)); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class PsiImportError(PsiException):; """"""Error called for problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/exceptions.html:1307,Validat,ValidationError,1307,psi4manual/1.3.2/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/exceptions.html,1,['Validat'],['ValidationError']
Security,"are supported for the selected JK routine.; """"""; scf_type = core.get_global_option('SCF_TYPE'); supp_jk_type = ['DF', 'DISK_DF', 'MEM_DF', 'CD', 'PK', 'DIRECT', 'OUT_OF_CORE']; supp_string = ', '.join(supp_jk_type[:-1]) + ', or ' + supp_jk_type[-1] + '.'. if scf_type not in supp_jk_type:; raise ValidationError(""Method %s: Requires support for non-symmetric density matrices.\n""; "" Please set SCF_TYPE to %s"" % (name, supp_string)). def check_disk_df(name, optstash):. optstash.add_option(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); elif core.get_global_option('SCF_TYPE') == ""DF"":; core.set_global_option('SCF_TYPE', 'DISK_DF'); core.print_out("""""" Method '%s' requires SCF_TYPE = DISK_DF, setting.\n"""""" % name); else:; if core.get_global_option('SCF_TYPE') != ""DISK_DF"":; raise ValidationError("" %s requires SCF_TYPE = DISK_DF, please use SCF_TYPE = DF to automatically choose the correct DFJK implementation."" % name). def print_ci_results(ciwfn, rname, scf_e, ci_e, print_opdm_no=False):; """"""; Printing for all CI Wavefunctions; """""". # Print out energetics; core.print_out(""\n ==> Energetics <==\n\n""); core.print_out("" SCF energy = %20.15f\n"" % scf_e); if ""CI"" in rname:; core.print_out("" Total CI energy = %20.15f\n"" % ci_e); elif ""MP"" in rname:; core.print_out("" Total MP energy = %20.15f\n"" % ci_e); elif ""ZAPT"" in rname:; core.print_out("" Total ZAPT energy = %20.15f\n"" % ci_e); else:; core.print_out("" Total MCSCF energy = %20.15f\n"" % ci_e). # Nothing to be done for ZAPT or MP; if (""MP"" in rname) or (""ZAPT"" in rname):; core.print_out(""\n""); return. # Initial info; ci_nroots = core.get_option(""DETCI"", ""NUM_ROOTS""); irrep_labels = ciwfn.molecule().irrep_labels(). # Grab the D-vector; dvec = ciwfn.D_vector(); dvec.init_io_files(True). for root in range(ci_nroots):; core.print_out(""\n ==> %s root %d inform",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html:4621,Validat,ValidationError,4621,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc_util.html,2,['Validat'],['ValidationError']
Security,are_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energies_from_fcidump; expand_psivars; fcidump; fcidump_from_file; find_approximate_string_matches; format_molecule_for_input; format_options_for_input; free_atom_volumes; Gaussian; get_memory; get_psifile; getattr_ignorecase; hamiltonian_solver; hold_options_state; import_ignorecase; InPsight; kwargs_lower; levenshtein; Lineshape; Lorentzian; mat2arr; message_box; oeprop; OptionsState; OptionsStateCM; OptionState; pcm_helper; plump_qcvar; prefactor_ecd; prefactor_opa; prepare_options_for_modules; prepare_options_for_set_options; provenance_stamp; sanitize_method; set_memory; set_module_options; set_options; SolverEngine; spectrum; state_to_atomicinput; temp_circular_import_blocker; ParsingError; PastureRequiredError; pcm_helper; process_input; prop; properties; PsiException; compare_vibinfos; filter_nonvib; filter_omega_to_real; harmonic_analysis; hessian_symmetrize; print_molden_vibs; print_vibs; thermo; QMMM; QMMMbohr; sanitize_method; sanitize_name; scf_helper; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_module_options; set_options; tdscf; TDSCFConvergenceError; temp_circular_import_blocker; TestComparisonError; UpgradeHelper; ValidationError; vibanal_wfn.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:794557,Validat,ValidationError,794557,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['Validat'],['ValidationError']
Security,"args)[source]¶. compute(client=None)[source]¶. Parameters:; client (qcportal.FractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. molecule; dummy basis, def2-svp; e/g/h member data; QCVariables; module if simple. client (qcportal.FractalClient | None) – . Returns:. ret – Energy, gradient, or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as Composite-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None) – . Return type:; AtomicResult. plan()[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Complete Basis Set; Output; Extrapolation Schemes; xtpl_highest_1(); scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(); scf_xtpl_helgaker_3(); corl_xtpl_helgaker_2(); _get_default_xtpl(); register_xtpl_function(). Aliases; sherrill_gold_standard(); allen_focal_point(); register_composite_function(). API; CompositeComputer; CompositeComputer.basis; CompositeComputer.cbsrec; CompositeComputer.compute_list; CompositeComputer.driver; CompositeComputer.keywords; CompositeComputer.metadata; CompositeComputer.metameta; CompositeComputer.method; CompositeComputer.molecule; CompositeComputer.results_list; CompositeComputer.task_list; CompositeComputer.trove; CompositeComputer.verbose; CompositeComputer.build_tasks(); CompositeComputer.compute(); CompositeComputer.get_psi_results(); CompositeComputer.get_results(); CompositeComputer.plan(); CompositeComputer.set_molecule. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .  ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cbs.html:40636,validat,validator,40636,psi4manual/1.8.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cbs.html,2,['validat'],['validator']
Security,"args.pop('scf_wfn', 'hf').lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn)). cbs_delta2_wfn_lesser = kwargs.get('delta2_wfn_lesser', cbs_delta_wfn).lower(); if cbs_delta2_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta2_wfn_lesser)). # # Establish method",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:31705,Validat,ValidationError,31705,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irrepped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]; def _to_array(; matrix: Union[core.Matrix, core.Vector],; copy: bool = True,; dense: bool = False,; ) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a |PSIfour| Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irrepped Psi4 objects to d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:5619,Validat,ValidationError,5619,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,3,['Validat'],['ValidationError']
Security,"arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irrepped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_type == core.Vector:; # Build an irrepped array back out; if dim1 is not None:; if dim2 is not None:; raise ValidationError(""Array_to_Matrix: If dim2 should not be supplied for 1D vectors.""). dim1 = core.Dimension.from_list(dim1); ret = self(name, dim1). start1 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; if (d1 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1]; start1 += d1. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0]); ret.np[:] = arr; return ret. else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). [docs]def _to_array(; matrix: Union[core.Matrix, core.Vector],; copy: bool = True,; dense: bool = False,; ) -> Union[np.ndarray, List[np.ndarray]]:; """"""; Converts a |PSIfour| Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters; ----------; matrix; Pointers to which Psi4 core class should be used in the construction.; copy; Copy the data if `True`, return a view otherwise; dense; Converts irrepped Psi4 objects to dia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:5615,Validat,ValidationError,5615,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"array to a Psi4 object. Examples; --------. >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4); """""". # What type is it? MRO can help.; arr_type = self.__mro__[0]. # Irreped case; if isinstance(arr, (list, tuple)):; if (dim1 is not None) or (dim2 is not None):; raise ValidationError(""Array_to_Matrix: If passed input is list of arrays dimension cannot be specified.""). irreps = len(arr); if arr_type == core.Matrix:; sdim1 = core.Dimension(irreps); sdim2 = core.Dimension(irreps). for i in range(irreps):; d1, d2 = _find_dim(arr[i], 2); sdim1[i] = d1; sdim2[i] = d2. ret = self(name, sdim1, sdim2). elif arr_type == core.Vector:; sdim1 = core.Dimension(irreps). for i in range(irreps):; d1 = _find_dim(arr[i], 1); sdim1[i] = d1[0]. ret = self(name, sdim1); else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % str(arr_type)). for view, vals in zip(ret.nph, arr):; if 0 in view.shape: continue; view[:] = vals. return ret. # No irreps implied by list; else:; if arr_type == core.Matrix:. # Build an irreped array back out; if dim1 is not None:; if dim2 is None:; raise ValidationError(""Array_to_Matrix: If dim1 is supplied must supply dim2 also""). dim1 = core.Dimension.from_list(dim1); dim2 = core.Dimension.from_list(dim2). if dim1.n() != dim2.n():; raise ValidationError(""Array_to_Matrix: Length of passed dim1 must equal length of dim2.""). ret = self(name, dim1, dim2). start1 = 0; start2 = 0; for num, interface in enumerate(ret.nph):; d1 = dim1[num]; d2 = dim2[num]; if (d1 == 0) or (d2 == 0):; continue. view = np.asarray(interface); view[:] = arr[start1:start1 + d1, start2:start2 + d2]; start1 += d1; start2 += d2. return ret. # Simple case without irreps; else:; ret = self(name, arr.shape[0], arr.shape[1]); ret.np[:] = arr; return ret. elif arr_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:3850,Validat,ValidationError,3850,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,3,['Validat'],['ValidationError']
Security,"arties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import logging; import math; from typing import Callable, Optional, Union. import numpy as np. from psi4 import core. from .aliases import allen_focal_point, sherrill_gold_standard; from .constants import nppp; from .p4util.exceptions import ValidationError. logger = logging.getLogger(__name__). _zeta_val2sym = {k + 2: v for k, v in enumerate('dtq5678')}; Extrapolatable = Union[float, core.Matrix, core.Vector]. [docs]; def xtpl_highest_1(functionname: str, zHI: int, valueHI: Extrapolatable, verbose: int = 1, **kwargs) -> Extrapolatable:; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'mp2') used in summary printing.; zHI; Zeta-level, only used for printing.; valueHI; Energy, gradient, or Hessian value at the basis set.; verbose; Controls volume of printing. Returns; -------; float or ~numpy.ndarray; Returns :math:`E_{total}^{\infty}` which is equal to valueHI.; Eponymous function applied to input zetas and values; type from `valueHI`. Notes; -----; .. math:: E_{total}^X = E_{total}^{\infty}. Examples; --------; >>> # [1] Fancy way to get HF/cc-pCV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs_helper.html:1366,Validat,ValidationError,1366,psi4manual/1.9.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs_helper.html,2,['Validat'],['ValidationError']
Security,"artrees/Bohr/Bohr. Returns:(Matrix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). It’s handy to collect the wavefunction after a frequency; calculation through e, wfn = psi4.frequency(...,; return_wfn=True) as the frequencies can be accessed through; psi4.core.Wavefunction.frequencies(), the Hessian through; psi4.core.Wavefunction.hessian(), and much other computation; info through psi4.core.Wavefunction.frequency_analysis; (note no parentheses). Examples of using this data; structure can be found fd-freq-gradient and; python/vibanalysis. Formatted printing of vibrational; results is available through qcdb.vib.print_vibs(). Results accessible through psi4.core.Wavefunction.frequency_analysis¶. key; description (lbl & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; nd.array(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy;  ; ndarray(ndof) int. TRV; translation/rotation/vibration;  ; ndarray(ndof) str ‘TR’ or ‘V’ or ‘-‘ for partial. gamma; irreducible representation;  ; ndarray(ndof) str irrep or None if unclassifiable. mu; reduced mass; u; ndarray(ndof) float (+/+). k; force constant; mDyne/A; ndarray(ndof) float (+/-). DQ0; RMS deviation v=0; a0 u^1/2; ndarray(ndof) float (+/0). Qtp0; Turning point v=0; a0 u^1/2; ndarray(ndof) float (+/0). Xtp0; Turning point v=0; a0; ndarray(ndof) float (+/0). theta_vib; char temp; K; ndarray(ndof) float (+/0). Visualization of Normal M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/freq-1.html:4762,access,accessible,4762,psi4manual/1.3.2/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/freq-1.html,2,['access'],['accessible']
Security,"as a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC), after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE (CFOUR)¶CFOUR — This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the \(\langle ab\vert\vert cd\rangle\) molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the \(\langle ab\vert\vert cd\rangle\) and \(\langle ab\vert\vert ci\rangle\) integrals are held in core; (=5) \(\langle ij\vert\vert kl\rangle\) and \(\langle ij\vert\vert ka\rangle\) and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC (CFOUR)¶CFOUR — Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if CFOUR_CC_PROGRAM =EXTERNAL has been specified. Type: boolean; Default: true. CFOUR_INTEGRALS (CFOUR)¶CFOUR — This keyword defines what type of integral input will be written by xjoda. VMOL (=1) has to be used with the programs of CFOUR. Using ARGOS (=0), input for Pitzer’s ARGOS integral program will be written. (Default: VMOL). Type: string; Possible Values: VMOL, ARGOS; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:52304,access,access,52304,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['access'],['access']
Security,"as changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_local) + ')', self.value_local); text += """""" Used (has changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_used) + ')', self.value_used); else:; text += """""" ==> %s Option in Global Scope <==\n\n"""""" % (self.option); text += """""" Global (has changed?) value: %7s %s\n"""""" % ('(' + str(self.haschanged_global) + ')', self.value_global); text += """"""\n""""""; return text. [docs] def restore(self):; psi4.set_global_option(self.option, self.value_global); if not self.haschanged_global:; psi4.revoke_global_option_changed(self.option); if self.module:; psi4.set_local_option(self.module, self.option, self.value_local); if not self.haschanged_local:; psi4.revoke_local_option_changed(self.module, self.option). [docs]class OptionsState(object):; """"""Class to contain multiple :py:func:`~optproc.OptionsState` objects.; Used in python driver functions to collect several options before altering; them, then restoring before function return. ::. >>> optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). """"""; def __init__(self, *largs):; self.data = []; for item in largs:; if len(item) == 2:; self.data.append(OptionState(item[1], item[0])); elif len(item) == 1:; self.data.append(OptionState(item[0])); else:; raise ValidationError('Each argument to OptionsState should be an array, the first element of which is the module scope and the second element of which is the module name. Bad argument: %s' % (item)). def __str__(self):; text = ''; for item in self.data:; text += str(item); return text. [docs] def restore(self):; for item in self.data:; item.restore(). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/optproc.html:3974,Validat,ValidationError,3974,psi4manual/1.0.0/_modules/p4util/optproc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/optproc.html,1,['Validat'],['ValidationError']
Security,"as_array_variable(key). def _core_wavefunction_has_variable(cls, key):; return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key):; if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return core.array_variable(key); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls, key):; if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return cls.array_variable(key); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key, val):; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(val)); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). def _core_wavefunction_set_variable(cls, key, val):; if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(val)); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:19065,Validat,ValidationError,19065,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"ashes denote function calls; stage: scf, corl, delta1, delta2, ...; e/d/dd=dg/g/h := energy, dipole, dipole derivative = dipole gradient, gradient, Hessian. cbs_text_parser(); -----------------; * called from task_planner() only if ""/"" in method. _parse_cbs_gufunc_string(); --------------------------; * break user string into paired method and basis stages. * transform user string into cbs kwargs inc'l basic cbs_metadata; cbs kwargs may signal simple method/basis single point -or- a modelchem requiring CompositeComputer. ----------------------------; CompositeComputer.__init__(); ----------------------------. _process_cbs_kwargs(); ---------------------; * if input is cbs_metadata dict, skip to _validate_cbs_inputs(); * otherwise, transform user kwargs into trial cbs_metadata format (aka dict spec). _validate_cbs_inputs(); ----------------------. _get_default_xtpl(); -------------------; * supply default xtpl fn for stage and basis conditions. _expand_bracketed_basis(); -------------------------; * parse and validate user bases. * check and supply defaults for cbs_metadata format (various calls to above two fns). * BaseComputer.__init__(). _build_cbs_compute(); --------------------. _expand_scheme_orders(); -----------------------; * form f_fields dict of entries for each zeta in a scheme (single NEED; entries related by nonlinear fn; (that is, constructing the CBS energy from the component energies is nonlinear)). _contract_bracketed_basis(); ---------------------------; * form basis abbr. string from basis seq. * form d_fields list of stages or stage halves from NEEDs (GRAND_NEED; items related linearly to form final val); * form list of entries (entry:= mtd-bas-opt specification) mentioned in GRAND_NEED (MODELCHEM; redundant, naive); * form subset of MODELCHEM with minimal list of jobs (job:= entry on which to call QC) to satisfy CBS (JOBS; minimal, enlightened); * form superset of JOBS with maximal list of entries resulting from JOBS (TROVE); * return GRAND_NEED/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:2291,validat,validate,2291,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['validat'],['validate']
Security,"asis of 1st & 2nd fragments.   2_((3,), (2, 3));   1; always; total energy for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_gradient; ntasks; when driver is g/h; all individual gradients.   1_((1, 2), (1, 2));   (nat, 3); when driver is g/h; total gradient for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat, 3); when driver is g/h; total gradient for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. intermediates_hessian; ntasks; when driver is h; all individual Hessians.   1_((1, 2), (1, 2));   (nat*3, nat*3); when driver is h; total Hessian for 1st modelchem, 1st & 2nd fragments in basis of 1st & 2nd fragments.   2_((3,), (2, 3));   (nat*3, nat*3); when driver is h; total Hessian for 2nd modelchem, 3rd fragment in basis of 2nd and 3rd fragments.   …. validator set_bsse_type  »  bsse_type[source]¶. validator set_embedding_charges  »  embedding_charges[source]¶. validator set_max_nbody  »  max_nbody[source]¶. validator set_molecule  »  molecule[source]¶. validator set_nfragments  »  nfragments[source]¶. validator set_return_total_data  »  return_total_data[source]¶. table of contents. Basis Set Superposition Corrections; nbody(); API; BsseEnum; BsseEnum.cp; BsseEnum.nocp; BsseEnum.vmfc. ManyBodyComputer; ManyBodyComputer.basis; ManyBodyComputer.bsse_type; ManyBodyComputer.driver; ManyBodyComputer.embedding_charges; ManyBodyComputer.keywords; ManyBodyComputer.max_nbody; ManyBodyComputer.method; ManyBodyComputer.molecule; ManyBodyComputer.nbodies_per_mc_level; ManyBodyComputer.nfragments; ManyBodyComputer.quiet; ManyBodyComputer.return_total_data; ManyBodyComputer.task_list; ManyBodyComputer.build_tasks(); ManyBodyComputer.compute(); ManyBodyComputer.get_psi_results(); ManyBodyComputer.get_results(); ManyBodyComputer.plan(); ManyBodyComputer.prepare_results(); ManyBodyComputer.set_bsse_type; ManyBodyComputer.set_embedding_charges; ManyBodyComputer.set_max_nbody; ManyB",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:35070,validat,validator,35070,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,3,['validat'],['validator']
Security,"asis set specification: assign lines present but shells have no [basname] label.""; """"); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; basstrings[basname(basblock[idx])] = basblock[idx + 1]. return basstrings. anon.__name__ = 'basisspec_psi4_yo__' + cleanbas; qcdb.libmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MBIS_CHARGES','MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; # old: (replacement, release after next); ""SCSN-MP2 CORRELATION ENERGY"": (""SCS(N)-MP2 CORRELATION ENERGY"", 1.5),; ""SCSN-MP2 TOTAL ENERGY"": (""SCS(N)-MP2 TOTAL ENERGY"", 1.5),; ""MAYER_INDICES"": (""MAYER INDICES"", 1.5),; ""WIBERG_LOWDIN_INDICES"": (""WIBERG LOWDIN INDICES"", 1.5),; ""LOWDIN_CHARGES"": (""LOWDIN CHARGES"", 1.5),; ""MULLIKEN_CHARGES"": (""MULLIKEN CHARGES"", 1.5),; ""(AT) CORRECTION ENERGY"": (""A-(T) CORRECTION ENERGY"", 1.5),; ""CCSD(AT) TOTAL ENER",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:17977,Validat,ValidationError,17977,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"ass; else:; psi4.set_local_option('SCF','REFERENCE','RHF'); elif psi4.get_option('SCF','REFERENCE') == 'UKS':; if (len(psi4.get_option('SCF', 'DFT_FUNCTIONAL')) > 0) or psi4.get_option('SCF', 'DFT_CUSTOM_FUNCTIONAL') is not None:; pass; else:; psi4.set_local_option('SCF','REFERENCE','UHF'); return optstash. [docs]def dft_set_reference_local(name):; """"""; Figures out the correct DFT reference to set locally; """""". optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). return optstash. [docs]def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES',; 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES',; 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI',; 'NO_OCCUPATIONS']. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html:3093,Validat,ValidationError,3093,psi4manual/1.0.0/_modules/procedures/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html,1,['Validat'],['ValidationError']
Security,"ass=None,; real=None,; elbl=None,; # processing details; speclabel=True,; nonphysical=False,; mtol=1.0e-3,; verbose=1,; ):; """"""Check the nuclear identity arrays for consistency and fill in knowable values."""""". if elea is None:; elea = np.asarray([None] * nat); else:; # -1 equivalent to None; elea = np.asarray(elea); if -1 in elea:; elea = np.array([(None if at == -1 else at) for at in elea]) # Rebuild to change dtype if needed. if elez is None:; elez = np.asarray([None] * nat); else:; elez = np.asarray(elez). if elem is None:; elem = np.asarray([None] * nat); else:; elem = np.asarray(elem). if mass is None:; mass = np.asarray([None] * nat); else:; mass = np.asarray(mass). if real is None:; real = np.asarray([None] * nat); else:; real = np.asarray(real). if elbl is None:; elbl = np.asarray([None] * nat); else:; elbl = np.asarray(elbl). if not ((nat,) == elea.shape == elez.shape == elem.shape == mass.shape == real.shape == elbl.shape):; raise ValidationError(; """"""Dimension mismatch natom {} among A {}, Z {}, E {}, mass {}, real {}, and elbl {}"""""".format(; (nat,), elea.shape, elez.shape, elem.shape, mass.shape, real.shape, elbl.shape; ); ). if nat:; A, Z, E, mass, real, label = zip(; *[; reconcile_nucleus(; A=elea[at],; Z=elez[at],; E=elem[at],; mass=mass[at],; real=real[at],; label=elbl[at],; speclabel=speclabel,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose,; ); for at in range(nat); ]; ); else:; A = Z = E = mass = real = label = []; return {; ""elea"": np.array(A, dtype=int),; ""elez"": np.array(Z, dtype=int),; ""elem"": np.array(E),; ""mass"": np.array(mass, dtype=float),; ""real"": np.array(real, dtype=bool),; ""elbl"": np.array(label),; }. def validate_and_fill_fragments(nat, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None):; """"""Check consistency of fragment specifiers wrt type and length. For; charge & multiplicity, scientific defaults are not computed or applied;; rather, missing slots are filled with `None` for later processing. """"""; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:19283,Validat,ValidationError,19283,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"ata[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs) -> core.Matrix:; """"""Chains dot products together from a series of Psi4 Matrix classes. Uses :func:`~psi4.core.doublet`. Parameters; ----------; args; Arbitrary number of :class:`~psi4.core.Matrix` arguments to be; multiplied.; trans; Optional iterable of booleans of length number of `args` to designate; transposes, if any. """"""; trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irrepped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Vector.to_array = _to_array; core.Vector.shape = _np_shape; core.Vector.np = _np_view; core.Vector.nph = _np",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:14341,Validat,ValidationError,14341,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,4,"['Validat', 'access']","['ValidationError', 'access']"
Security,ate_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; libint2_configuration; libint2_print_out; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energies_from_fcidump; expand_psivars; fcidump; fcidump_from_file; find_approximate_string_matches; format_molecule_for_input; format_options_for_input; free_atom_volumes; Gaussian; get_memory; get_psifile; getattr_ignorecase; hamiltonian_solver; hold_options_state; import_ignorecase; InPsight; kwargs_lower; levenshtein; libint2_configuration; libint2_print_out; Lineshape; Lorentzian; mat2arr; message_box; oeprop; OptionsState; OptionsStateCM; OptionState; pcm_helper; plump_qcvar; prefactor_ecd; prefactor_opa; prepare_options_for_modules; prepare_options_for_set_options; provenance_stamp; sanitize_method; set_memory; set_module_options; set_options; SolverEngine; spectrum; state_to_atomicinput; temp_circular_import_blocker; ParsingError; PastureRequiredError; pcm_helper; process_input; prop; properties; PsiException; compare_vibinfos; filter_nonvib; filter_omega_to_real; harmonic_analysis; hessian_symmetrize; print_molden_vibs; print_vibs; thermo; QMMM; QMMMbohr; sanitize_method; sanitize_name; scf_helper; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_module_options; set_options; tdscf; TDSCFConvergenceError; temp_circular_import_blocker; TestComparisonError; UpgradeHelper; ValidationError; vibanal_wfn.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:824990,Validat,ValidationError,824990,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['Validat'],['ValidationError']
Security,"ath))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_option('BASIS'); user_df_basis_scf = PsiMod.get_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:30975,Validat,ValidationError,30975,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:35119,validat,validator,35119,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,3,['validat'],['validator']
Security,"ation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zLO), eLO); cbsscheme += """""" HI-zeta (%s) Correlation Energy: %16.8f\n"""""" % (str(zHI), eHI); cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def scf_xtpl_helgaker_3(**largs):; r""""""Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by :py:func:`~wrappers.complete_basis_set`. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha X}. """"""; energypiece = 0.0; functionname = sys._getframe().f_code.co_name; f_fields = ['f_wfn', 'f_portion', 'f_basis', 'f_zeta', 'f_energy']; [mode, NEED, wfnname, BSET, ZSET] = validate_scheme_args(functionname, **largs). if (mode == 'requisition'):. # Impose restrictions on zeta sequence; if (len(ZSET) != 3):; raise ValidationError('Call to \'%s\' not valid with \'%s\' basis sets.' % (functionname, len(ZSET))). # Return array that logs the requisite jobs; NEED = {'HI': dict(zip(f_fields, [wfnname, 'tot', BSET[2], ZSET[2], 0.0])),; 'MD': dict(zip(f_fields, [wfnname, 'tot', BSET[1], ZSET[1], 0.0])),; 'LO': dict(zip(f_fields, [wfnname, 'tot', BSET[0], ZSET[0], 0.0]))}. return NEED. elif (mode == 'evaluate'):. # Extract required energies and zeta integers from array; eHI = NEED['HI']['f_energy']; eMD = NEED['MD']['f_energy']; eLO = NEED['LO']['f_energy']; zHI = NEED['HI']['f_zeta']; zMD = NEED['MD']['f_zeta']; zLO = NEED['LO']['f_zeta']. # Compute extrapolated energy; ratio = (eHI - eMD) / (eMD - eLO); alpha = -1 * math.log(ratio); beta = (eHI - eMD) / (math.exp(-1 * alpha * zMD) * (ratio - 1)); energypiece = eHI - beta * math.exp(-1 * alpha * zHI). # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> %s <==\n\n"""""" % (functionname); cbsscheme += """""" LO-zeta (%s) Corr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:96874,Validat,ValidationError,96874,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:59639,Validat,ValidationError,59639,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"ations. ON (=0) uses rotationally projected coordinates, while OFF (=1) retains the rotational degrees of freedom. At a stationary point on the potential energy surface, both options will give equivalent harmonic force fields, but OFF should be used at non-stationary points. Type: string; Possible Values: ON, OFF; Default: ON. CFOUR_FD_STEPSIZE¶. Specifies the step length in mass-weighted coordinates (in ) used in generating the force constant matrix by finite difference of Cartesian gradients. Type: integer; Default: 5. CFOUR_FD_USEGROUP¶. In finite difference calculations using the FINDIF option, this keyword specifies the point group to be used in generating the symmetry-adapted vibrational coordinates. FULL (= 0) specifies the full molecular point group, COMP (= 1) specifies the Abelian subgroup used in the electronic structure calculation. Type: string; Possible Values: FULL, COMP; Default: FULL. CFOUR_FILE_RECSIZ¶. This specifies the physical length (in integer words) of the records used in the word-addressable direct access files used by CFOUR. This value should always be chosen as a multiple of 512 bytes, as your local system manager certainly understands. Type: integer; Default: 2048. CFOUR_FILE_STRIPE¶. This option allows the splitting of files. Input is required in the form N1/N2/N3/N4/N5, where N1, N2, N3, N4, and N5 specify the number of files in which MOINTS, GAMLAM, MOABCD, DERINT, and DERGAM are splitted, respectively. Type: string; Default: 0/0/0/0/0. CFOUR_FINITE_PERTURBATION¶. Specifies the field strength for a perturbation (defined within a %perturbation section). The value must be given as an integer, and the field strength used by the program will be then the value of the keyword . Type: integer; Default: 0. CFOUR_FOCK¶. This option is used to control the algorithm used for construction of the Fock matrix in SCF calculations. PK (=0) uses the PK-supermatrix approach while AO (=1) constructs the matrix directly from the basis function integrals. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:25968,access,access,25968,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['access'],['access']
Security,"atistics of last iteration. See keys above. """"""; message: str; iteration: int; wfn: core.Wavefunction; what: str; stats: Dict[str, Any]. def __init__(self, iteration: int, wfn: core.Wavefunction, what: str, stats: Dict[str, Any]):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; available. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html:9582,Validat,ValidationError,9582,psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,1,['Validat'],['ValidationError']
Security,"atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_ancho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:20273,Validat,ValidationError,20273,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"ators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; frm = fragment_multiplicities; else:; raise ValidationError(; """"""fragment_multiplicities not among None or positive integer: {}"""""".format(fragment_multiplicities); ). if not (len(frc) == len(frm) == len(frs) + 1):; raise ValidationError(; """"""Dimension mismatch among fragment quantities: sep + 1 ({}), chg ({}), and mult({})"""""".format(; len(frs) + 1, len(frc), len(frm); ); ). return {""fragment_separators"": list(frs), ""fragment_charges"": frc, ""fragment_multiplicities"": frm}. def validate_and_fill_unsettled_geometry(geom_unsettled, variables):; lgeom = [len(g) for g in geom_unsettled]. if lgeom[0] not in [0, 3]:; raise ValidationError(""""""First line must be Cartesian or single atom.""""""). if any(l == 3 for l in lgeom) and not all((l in [3, 6]) for l in lgeom):; raise ValidationError(; """"""Mixing Cartesian and Zmat formats must occur in just that order once absolute frame established.""""""; ). allowed_to_follow = {0: [2], 2: [4], 3: [3, 6], 4: [6], 6: [3, 6]}. for il in range(len(lgeom) - 1):; if lgeom[il + 1] not in allowed_to_fol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:21916,Validat,ValidationError,21916,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"attr_ignorecase"",; ""hold_options_state"",; ""import_ignorecase"",; ""kwargs_lower"",; ""mat2arr"",; ""prepare_options_for_modules"",; ""prepare_options_for_set_options"",; ""provenance_stamp"",; ""state_to_atomicinput"",; ]. import os; import ast; import sys; import math; import pickle; import inspect; import warnings; from contextlib import contextmanager; import collections; from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Union; from types import ModuleType. import numpy as np; from qcelemental.models import AtomicInput. from psi4 import core; from psi4.metadata import __version__; from .exceptions import ValidationError; from . import p4regex. [docs]; def kwargs_lower(kwargs: Dict[str, Any]) -> Dict[str, Any]:; """"""Function to rebuild and return *kwargs* dictionary sanitized. Should be; called by every function that could be called directly by the user. Parameters; ----------; kwargs; Input kwargs for any user-facing function. Returns; -------; lowered : Dict[str, Any]; Sanitized kwargs with all keys made lowercase. Also turns boolean-like; values into actual booleans. Also turns values lowercase if sensible. """"""; caseless_kwargs = {}; for key, value in kwargs.items():; lkey = key.lower(); if lkey in ['subset', 'banner', 'restart_file', 'write_orbitals']: # only kw for which case matters; lvalue = value; else:; try:; lvalue = value.lower(); except (AttributeError, KeyError):; lvalue = value. if lkey in ['irrep', 'check_bsse', 'linkage', 'bsse_type']:; caseless_kwargs[lkey] = lvalue. elif 'dertype' in lkey:; if p4regex.der0th.match(str(lvalue)):; caseless_kwargs[lkey] = 0; elif p4regex.der1st.match(str(lvalue)):; caseless_kwargs[lkey] = 1; elif p4regex.der2nd.match(str(lvalue)):; caseless_kwargs[lkey] = 2; else:; raise KeyError(f'Derivative type key {key} was not recognized'). elif lvalue is None:; caseless_kwargs[lkey] = None. elif p4regex.yes.match(str(lvalue)):; caseless_kwargs[lkey] = True. elif p4regex.no.match(str(lvalue)):; caseless_kwargs[lkey] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:2336,Sanitiz,Sanitized,2336,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,1,['Sanitiz'],['Sanitized']
Security,"available at http://sirius.chem.vt.edu/psi4manual/latest/index.html; (link “docs” off http://www.psicode.org), and it is automatically updated. However,; if your system has the appropriate utilities (notably the sphinx package; and LaTeX), you may build the package documentation from the top-level; $objdir by running make doc. The resulting files will appear in the; $prefix/doc area. Step 6: Cleaning; All object files and libraries can be removed to save disk space by running; make clean in $objdir. Step 7: User Configuration; After the PSI4 package has been successfully installed, the user will need; to add the installation directory into his/her path. If the package has; been installed in the default location /usr/local/psi, then in C shell,; the user should add something like the following to their .cshrc file:; setenv PSI /usr/local/psi; set path = ($path $PSI/bin). Next, the user needs to tell the PSI4 I/O manager how to handle scratch files.; Identify the path to a fast scratch disk for which the user has write access.; If the local /tmp volume is large enough, it might be used.; However, a dedicated scratch volume (using RAID0 striping for speed) is; recommended. Warning; Scratch should NOT be a NFS-mounted volume, as writes to a; remote disk over the network can be very slow and can tie up the network; and negatively impact other users. Specify scratch location by editing the .cshrc file to set the scratch; environment variable PSI_SCRATCH. If the selected location is; /scratch/user, add something like the following:; setenv PSI_SCRATCH /scratch/user. In a bash shell, the corresponding commands to be added to .bashrc is; the following:; export PSI=/usr/local/psi; PATH=$PSI/bin:$PATH ; export PATH; export PSI_SCRATCH=/scratch/user. More advanced control of scratch files and is handled through a; .psi4rc file, which is discussed at section Scratch Files and the ~/.psi4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; gri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:19059,access,access,19059,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,3,['access'],['access']
Security,"axis1 = 2; else:; axis1 = 1; result = [0.0, 0.0, 0.0]; # do the pi/2 rotation in the plane; result[axis0] = d[axis1]; result[axis1] = -1.0 * d[axis0]; result = normalize(result); return result. else:; # normalize the cross product and return the result; result = scale(result, 1.0 / math.sqrt(resultdotresult)); return result. [docs]def determinant(mat):; """"""Given 3x3 matrix *mat*, compute the determinat. """"""; if len(mat) != 3 or len(mat[0]) != 3 or len(mat[1]) != 3 or len(mat[2]) != 3:; raise ValidationError('determinant() only defined for arrays of dimension 3x3\n'). det = mat[0][0] * mat[1][1] * mat[2][2] - mat[0][2] * mat[1][1] * mat[2][0] + \; mat[0][1] * mat[1][2] * mat[2][0] - mat[0][1] * mat[1][0] * mat[2][2] + \; mat[0][2] * mat[1][0] * mat[2][1] - mat[0][0] * mat[1][2] * mat[2][1]; return det. [docs]def diagonalize3x3symmat(M):; """"""Given an real symmetric 3x3 matrix *M*, compute the eigenvalues. """"""; if len(M) != 3 or len(M[0]) != 3 or len(M[1]) != 3 or len(M[2]) != 3:; raise ValidationError('diagonalize3x3symmat() only defined for arrays of dimension 3x3\n'). A = copy.deepcopy(M) # Symmetric input matrix; Q = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # Storage buffer for eigenvectors; w = [A[0][0], A[1][1], A[2][2]] # Storage buffer for eigenvalues; # sd, so # Sums of diagonal resp. off-diagonal elements; # s, c, t # sin(phi), cos(phi), tan(phi) and temporary storage; # g, h, z, theta # More temporary storage. # Calculate SQR(tr(A)); sd = 0.0; for i in range(3):; sd += math.fabs(w[i]); sd = sd * sd. # Main iteration loop; for nIter in range(50):. # Test for convergence; so = 0.0; for p in range(3):; for q in range(p + 1, 3):; so += math.fabs(A[p][q]); if so == 0.0:; return w, Q # return eval, evec. if nIter < 4:; thresh = 0.2 * so / (3 * 3); else:; thresh = 0.0. # Do sweep; for p in range(3):; for q in range(p + 1, 3):. g = 100.0 * math.fabs(A[p][q]); if nIter > 4 and (math.fabs(w[p]) + g == math.fabs(w[p])) and \; (math.fabs(w[q]) + g == math.fabs(w[q])):; A[p][q]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html:5617,Validat,ValidationError,5617,psi4manual/1.0.0/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html,2,['Validat'],['ValidationError']
Security,"ay arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built; CMAKE_INSIST_FIND_PACKAGE_libefp — CMake variable to force detecting pre-built libefp and not falling back on i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/libefp.html:7216,access,accessible,7216,psi4manual/master/libefp.html,https://psicode.org,https://psicode.org/psi4manual/master/libefp.html,13,['access'],['accessible']
Security,"ay arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) None. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list variable to specify where pre-built dependencies can be found. For libefp, set to an installation directory containing include/efp.h; libefp_DIR — CMake variable to specify where pre-built libefp can be found. Set to installation directory containing share/cmake/libefp/libefpConfig.cmake; CMAKE_DISABLE_FIND_PACKAGE_libefp — CMake variable to force internal build of libefp instead of detecting pre-built. Examples. Build bundled. >>> cmake -DENABLE_libefp=ON. Build without libefp. >>> cmake. Link against pre-built. >>> cm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:7267,access,accessible,7267,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,2,['access'],['accessible']
Security,"ay arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, Psi4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal Psi4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. 2aminopyridine¶. rotate: click+drag; translate: alt+click+drag; zoom: scroll. Visualization by ChemDoodle Web; Comment; 2-aminopyridine, S22 Complex Elec.: 6-31G* Rest: 6-311++G(3df,2p). Full Geometry in Angstroms; N -0.297712 -1.170382 0.001714; C -0.912531 0.026013 0.004723; C -0.175714 1.226496 0.003700; C 1.204216 1.176210 0.000547; C 1.842683 -0.065832 -0.001280; C 1.045154 -1.196712 0.000533; H -0.697132 2.173907 0.003778; H 1.778223 2.092763 0.001427; H 2.918377 -0.152929 -0.000909; H 1.493951 -2.183173 0.004591; N -2.277071 0.027597 -0.043650; H -2.727502 0.885639 0.221497; H -2.756811 -0.823399 0.254372. pyrazine¶. rotate: click+drag; translate: alt+click+drag; zoom: scroll. Visualization by ChemDoodle Web; Comment; Pyrazine Elec.: 6-31G* Rest: 6-311++G(3df,2p). Full Geometry in Angstroms; C 0.696140 -1.130872 -0.001974; C -0.696140 -1.130872 -0.001974; N -1.414480 0.000953 0.003286; C -0.696730 1.129848 -0.00",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/libefp-1.html:6561,access,accessible,6561,psi4manual/1.0.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/libefp-1.html,2,['access'],['accessible']
Security,"ay well together. Returns; -------; bool; Whether DAMPING is enabled during scf. """"""; # Q: I changed the enabled criterion get_option <-- has_option_changed; enabled = (core.get_option('SCF', 'DAMPING_PERCENTAGE') > 0.0); if enabled:; parameter = core.get_option('SCF', ""DAMPING_PERCENTAGE""); if parameter < 0.0 or parameter > 100.0:; raise ValidationError('SCF DAMPING_PERCENTAGE ({}) must be between 0 and 100'.format(parameter)). stop = core.get_option('SCF', 'DAMPING_CONVERGENCE'); if stop < 0.0:; raise ValidationError('SCF DAMPING_CONVERGENCE ({}) must be > 0'.format(stop)). return enabled. def _validate_diis():; """"""Sanity-checks DIIS control options. Raises; ------; ValidationError; If any of |scf__diis|, |scf__diis_start|,; |scf__diis_min_vecs|, |scf__diis_max_vecs| don't play well together. Returns; -------; bool; Whether DIIS is enabled during scf. """"""; enabled = bool(core.get_option('SCF', 'DIIS')); if enabled:; start = core.get_option('SCF', 'DIIS_START'); if start < 1:; raise ValidationError('SCF DIIS_START ({}) must be at least 1'.format(start)). minvecs = core.get_option('SCF', 'DIIS_MIN_VECS'); if minvecs < 1:; raise ValidationError('SCF DIIS_MIN_VECS ({}) must be at least 1'.format(minvecs)). maxvecs = core.get_option('SCF', 'DIIS_MAX_VECS'); if maxvecs < minvecs:; raise ValidationError(; 'SCF DIIS_MAX_VECS ({}) must be at least DIIS_MIN_VECS ({})'.format(maxvecs, minvecs)). return enabled. def _validate_frac():; """"""Sanity-checks FRAC control options. Raises; ------; ValidationError; If any of |scf__frac_start| don't play well together. Returns; -------; bool; Whether FRAC is enabled during scf. """"""; enabled = (core.get_option('SCF', 'FRAC_START') != 0); if enabled:; if enabled < 0:; raise ValidationError('SCF FRAC_START ({}) must be at least 1'.format(enabled)). return enabled. def _validate_MOM():; """"""Sanity-checks MOM control options. Raises; ------; ValidationError; If any of |scf__mom_start|, |scf__mom_occ| don't play well together. Returns; -------;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:23935,Validat,ValidationError,23935,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Validat'],['ValidationError']
Security,"b') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more."""""".format(; memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount); return memory_amount. [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return core.get_memory(). [docs]def success(label):; """"""Function to print a '*",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html:5047,Validat,ValidationError,5047,psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"b') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount); return memory_amount. [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return core.get_memory(). [docs]def success(label):; """"""Function to print a '*",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:5089,Validat,ValidationError,5089,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"b') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]; def get_memory() -> int:; """"""Return the total memory allocation in bytes.""""""; return core.get_memory(). [docs]; def copy_file_to_scratch(filena",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:5795,Validat,ValidationError,5795,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,3,['Validat'],['ValidationError']
Security,"b') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]def get_memory() -> int:; """"""Return the total memory allocation in bytes.""""""; return core.get_memory(). [docs]def copy_file_to_scratch(filename: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html:5736,Validat,ValidationError,5736,psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"b') # 600000000; >>> psi4.set_memory(' 100000000kB ') # 100000000000; >>> psi4.set_memory('2 eb') # 2000000000000000000. >>> # Bad examples; >>> psi4.set_memory({}) # odd type; >>> psi4.set_memory('') # no info; >>> psi4.set_memory(""8 dimms"") # unacceptable units; >>> psi4.set_memory(""1e5 gb"") # string w/ exponent; >>> psi4.set_memory(""5e5"") # string w/o units; >>> psi4.set_memory(2000) # mem too small; >>> psi4.set_memory(-5e5) # negative (and too small). """"""; # Handle memory given in bytes directly (int or float); if isinstance(inputval, (int, float)):; val = inputval; units = ''; # Handle memory given as a string; elif isinstance(inputval, str):; memory_string = re.compile(r'^\s*(\d*\.?\d+)\s*([KMGTPBE]i?B)\s*$', re.IGNORECASE); matchobj = re.search(memory_string, inputval); if matchobj:; val = float(matchobj.group(1)); units = matchobj.group(2); else:; raise ValidationError(""""""Invalid memory specification: {}. Try 5e9 or '5 gb'."""""".format(repr(inputval))); else:; raise ValidationError(""""""Invalid type {} in memory specification: {}. Try 5e9 or '5 gb'."""""".format(; type(inputval), repr(inputval))). # Units decimal or binary?; multiplier = 1000; if ""i"" in units.lower():; multiplier = 1024; units = units.lower().replace(""i"", """").upper(). # Build conversion factor, convert units; unit_list = ["""", ""KB"", ""MB"", ""GB"", ""TB"", ""PB"", ""EB""]; mult = 1; for unit in unit_list:; if units.upper() == unit:; break; mult *= multiplier. memory_amount = int(val * mult). # Check minimum memory requirement; min_mem_allowed = 262144000; if memory_amount < min_mem_allowed:; raise ValidationError(; """"""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more.""""""; .format(memory_amount / 1024**2, memory_amount / 1000**2)). if execute:; core.set_memory_bytes(memory_amount, quiet); return memory_amount. [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return core.get_memory(). [docs]def copy_file_to_scratch(filename, pref",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html:5502,Validat,ValidationError,5502,psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,3,['Validat'],['ValidationError']
Security,"b):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monomers' in kwargs:; external_indices = kwargs['external_monomers']. # Check input args; if not bsse == 'off' and not bsse == 'on' and not bsse == 'both':; raise ValidationError('n_body: bsse argument is one of on, off, or both'); if max_n_body < 1:; raise ValidationError('n_body: max_n_body must be at least 1'); if max_n_body > molecule.nfragments():; raise ValidationError('n_body: max_n_body must be <= to the number of fragments in the molecule'). # Set to save RI integrals for repeated full-basis computations; ri_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). # Tell 'em what you're gonna tell 'em; has_external = 'No'; if (external):; has_external = 'Yes'; psi4.print_out('\n'); psi4.print_out(' ==> N-Body Interaction Energy Analysis <==\n\n'); psi4.print_out(' BSSE Treatment: %s\n' % (bsse)); psi4.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); psi4.print_out(' Compute Total Energy: %s\n' % (do_total)); psi4.print_out(' External Field: %s\n' % (has_external)); if (external):; psi4.print_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:6194,Validat,ValidationError,6194,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"bal. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. cc30; CCSD/sto-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:16114,validat,validate,16114,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,4,['validat'],['validate']
Security,"ball from GitHub Repository. Find-the-code Quiz¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base. Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,; and optimization for a variety of processor architectures, I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself. I’m on Linux or Mac (Intel or Silicon chips) or Windows (native or WSL/Ubuntu Bash Shell). I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility. I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4. In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub; I want to develop using PSI4 infrastructure and libraries, not; on them; I think a plugin might do. I’ve got a PSI4 compilation. Use it, then consult plugins; I’d rather not compile PSI4 or I don’t have compilers —; Goto Binary-Package then consult; plugins through conda. I really like parentheses and/or DBOC, so I want Psi3. —; Psi3 is available from sourceforge, but you’re on your own. Binary Installer¶. Get Initially; Just go to http://www.psicode.org/downloads.html, select “Installer”,; “Stable Release”, and your choice of architecture and Python version,; and follow the instructions there. Build; Not a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_obtaining.html:1926,access,access,1926,psi4manual/master/build_obtaining.html,https://psicode.org,https://psicode.org/psi4manual/master/build_obtaining.html,3,['access'],['access']
Security,"base.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_global_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:31518,Validat,ValidationError,31518,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"basis == 2:; return ""corl_xtpl_helgaker_2""; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata: CBSMetadata, molecule: Union[""qcdb.Molecule"", core.Molecule]) -> CBSMetadata:; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata; List of dicts containing CBS stage keywords.; molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if len(metadata) == 0 and stage[""wfn""] not in [""hf"", ""c4-hf"", ""scf"", ""c4-scf""]:; scf = {}; if stage[""wfn""].startswith(""c4""):; scf[""wfn""] = ""c4-hf""; else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = None; scf[""options""] = False; scf[""options_lo""] = False; metadata.append(scf); # 2c) keep processing current stage; stage[""treatment""] = item.get(""treatment"", ""scf"" if len(metadata) == 0 else ""corl""); stage[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(met",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:17753,Validat,ValidationError,17753,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,4,['Validat'],['ValidationError']
Security,"basisstring):; basisname = legit_compound_basis.match(basisstring); # filter out commas and be forgiving of e.g., t5q or 3q; bn_gz = basisname.group('zeta'); zetas = [z for z in zeta_values if (z in bn_gz or str(zeta_values.index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" % (basisstring, b)); BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(""""""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z'."""""" % (basisstring)); else:; BSET.append(basisstring); ZSET.append(0). if molecule is None:; molecule = """"""\nH\nH 1 1.00\n"""""". for basis in BSET:; try:; qcdb.BasisSet.pyconstruct(molecule, ""BASIS"", basis); except qcdb.BasisSetNotFound:; e=sys.exc_info()[1]; raise ValidationError(""""""Basis set '%s' not available for molecule."""""" % (basis)). return (BSET, ZSET). def _contract_bracketed_basis(basisarray):; r""""""Function to reform a bracketed basis set string from a sequential series; of basis sets *basisarray* (e.g, form 'cc-pv[q5]z' from array [cc-pvqz, cc-pv5z]).; Used to print a nicely formatted basis set string in the results table. """"""; if len(basisarray) == 1:; return basisarray[0]. else:; zetaindx = [i for i in range(len(basisarray[0])) if basisarray[0][i] != basisarray[1][i]][0]; ZSET = [bas[zetaindx] for bas in basisarray]. pre = basisarray[0][:zetaindx]; post = basisarray[0][zetaindx + 1:]; basisstring = pre + '[' + ''.join(ZSET) + ']' + post; return basisstring. [docs]def xtpl_highest_1(functionname, zHI, valueHI, verbose=True):; r""""""Scheme for total or correlation energies with a single basis or the highest; zeta-level among an array of bases. Used by :py:func:`~psi4.cbs`. .. math:: E_{total}^X = E_{total}^X. """"""; if isinstance(valueHI, float):. if verbose:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:3644,Validat,ValidationError,3644,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"be as given below (default). """"""; step4 = """"""; (4) Reap; ---------; Gather all the resulting output files in this directory along with the; three read-only files from (0). Invoke psi4 again. The job will be; trivial in length (unless sto-3g integrals on the molecule are costly); and give results for the harmonic and anharmonic frequency stages in this; output file. psi4 %-27s %-27s. """""" % (os.path.splitext(psi4.outfile_name())[0] + '.in', psi4.outfile_name()). if stage == 'harmonic':; instructions = step0 + step1 + stepFiles + step2; elif stage == 'anharmonic':; instructions = step0 + step3 + stepFiles + step4. return instructions. [docs]def sown_jobs_status(dir, prefix, zmats, validate_func=None, linkage=None, keys=None):; """"""Evaluate the output file status of jobs in *zmats* which should; exist at *dir* + '/' + prefix + '-' + job + '.out'. Returns string with; formatted summary of job status and boolean of whether all complete.; Return boolean *isOk* signals whether all *zmats* have completed and,; if *validate_func* present, are validated. """"""; isOk = True; msgError = ''; instructions = '\n'; instructions += p4util.banner(prefix + ' Status: ' + datetime.datetime.now().strftime(""%Y-%m-%d %H:%M""), strNotOutfile=True); instructions += '\n'; for job in sorted(zmats):; outfile = dir + '/' + prefix + '-' + job + '.out'; fjafile = dir + '/' + prefix + '-' + job + '.fja'; formatArgs = [prefix + '-' + job, '', '', '', '']; if os.path.isfile(outfile):; with open(outfile, 'r') as handle:; for line in handle:; if line.find('Buy a developer a beer!') > -1:; formatArgs[3] = 'Completed'; if reap_job_validate is not None:; isOkJob, msg, temp = reap_job_validate(dir, prefix, job, linkage, keys); if isOkJob:; formatArgs[4] = '& Validated'; else:; isOk = False; msgError += msg; formatArgs[4] = 'INVALID'; break; else:; isOk = False; formatArgs[2] = 'Running'; elif os.path.isfile(fjafile):; formatArgs[3] = 'Completed'; else:; isOk = False; formatArgs[1] = 'Waiting'; instructions += """"",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:28151,validat,validated,28151,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,1,['validat'],['validated']
Security,"be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : ~typing.Dict[str, ~numpy.ndarray]; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`. """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vibrec.update({k: qca.json() for k, qca in vibinfo.items()}). core.print_out(vibtext); core.print_out(qcdb.vib.print_vibs(vibinfo, shortlong=True, normco='x', atom_lbl=symbols)). if core.has_option_changed('THERMO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:89911,Validat,ValidationError,89911,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Validat'],['ValidationError']
Security,"before altering them,; then restore them before function return. Parameters; ----------; largs; Specify which keywords to store value and has_changed state. Examples; --------; >>> optstash = OptionsState(; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). """""". def __init__(self, *largs: List[List[str]]):; self.data = {}; for item in largs:; self.add_option(item). [docs]; def add_option(self, item: List[str]):; """"""Store info for another keyword, `item`. Parameters; ----------; item; A one-membered list with a global keyword or a two-membered list; with a module keyword and module. """"""; if len(item) == 2:; key = (item[1], item[0]); elif len(item) == 1:; key = (item[0], ); else:; raise ValidationError(; 'Each argument to OptionsState should be an array, the first element of which is the module scope and the second element of which is the module name. Bad argument: %s'; % (item)). if key in self.data:; raise ValidationError(; 'Malformed options state, duplicate key adds of ""{}"". This should not happen, please raise a issue on github.com/psi4/psi4'.format(key)); else:; self.data[key] = OptionState(*key). def __str__(self):; text = ''; for key, item in self.data.items():; text += str(item); return text. [docs]; def restore(self):; """"""Restore value and has_changed status of each keyword to saved condition.""""""; for key, item in self.data.items():; item.restore(). [docs]; @contextmanager; def OptionsStateCM(osd) -> Iterator[None]:; """"""Return a context manager that will collect the state (value and changed; status) of a list of keywords `osd` that can initialize; :py:class:`OptionsState` on entry to the with-statement and restore the; collected state when exiting the with-statement. """"""; oso = OptionsState(osd); yield; oso.restore(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.p4util.optproc. © Copyright 2007-2024, The Psi4 Project.; Last upda",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/optproc.html:4845,Validat,ValidationError,4845,psi4manual/master/_modules/psi4/driver/p4util/optproc.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/optproc.html,1,['Validat'],['ValidationError']
Security,"before altering them,; then restore them before function return. Parameters; ----------; largs; Specify which keywords to store value and has_changed state. Examples; --------; >>> optstash = OptionsState(; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). """""". def __init__(self, *largs: List[List[str]]):; self.data = {}; for item in largs:; self.add_option(item). [docs]; def add_option(self, item: List[str]):; """"""Store info for another keyword, `item`. Parameters; ----------; item; A one-membered list with a global keyword or a two-membered list; with a module keyword and module. """"""; if len(item) == 2:; key = (item[1], item[0]); elif len(item) == 1:; key = (item[0], ); else:; raise ValidationError(; 'Each argument to OptionsState should be an array, the first element of which is the module scope and the second element of which is the module name. Bad argument: %s'; % (item)). if key in self.data:; raise ValidationError(; 'Malformed options state, duplicate key adds of ""{}"". This should not happen, please raise a issue on github.com/psi4/psi4'.format(key)); else:; self.data[key] = OptionState(*key). def __str__(self):; text = ''; for key, item in self.data.items():; text += str(item); return text. [docs]; def restore(self):; """"""Restore value and has_changed status of each keyword to saved condition.""""""; for key, item in self.data.items():; item.restore(). [docs]; @contextmanager; def OptionsStateCM(osd) -> Iterator[None]:; """"""Return a context manager that will collect the state (value and changed; status) of a list of keywords `osd` that can initialize; :py:class:`OptionsState` on entry to the with-statement and restore the; collected state when exiting the with-statement. """"""; oso = OptionsState(osd); yield; oso.restore(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.p4util.optproc. © Copyright 2007-2023, The Psi4 Project.; Last updated on ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html:4850,Validat,ValidationError,4850,psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/optproc.html,1,['Validat'],['ValidationError']
Security,"before altering them,; then restore them before function return. Parameters; ----------; largs; Specify which keywords to store value and has_changed state. Examples; --------; >>> optstash = OptionsState(; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). >>> print(optstash). >>> optstash.restore(). """""". def __init__(self, *largs: List[List[str]]):; self.data = {}; for item in largs:; self.add_option(item). [docs]; def add_option(self, item: List[str]):; """"""Store info for another keyword, `item`. Parameters; ----------; item; A one-membered list with a global keyword or a two-membered list; with a module keyword and module. """"""; if len(item) == 2:; key = (item[1], item[0]); elif len(item) == 1:; key = (item[0], ); else:; raise ValidationError(; 'Each argument to OptionsState should be an array, the first element of which is the module scope and the second element of which is the module name. Bad argument: %s'; % (item)). if key in self.data:; raise ValidationError(; 'Malformed options state, duplicate key adds of ""{}"". This should not happen, please raise a issue on github.com/psi4/psi4'.format(key)); else:; self.data[key] = OptionState(*key). def __str__(self):; text = ''; for key, item in self.data.items():; text += str(item); return text. [docs]; def restore(self):; """"""Restore value and has_changed status of each keyword to saved condition.""""""; for key, item in self.data.items():; item.restore(). [docs]; @contextmanager; def OptionsStateCM(osd) -> Iterator[None]:; """"""Return a context manager that will collect the state (value and changed; status) of a list of keywords `osd` that can initialize; :py:class:`OptionsState` on entry to the with-statement and restore the; collected state when exiting the with-statement. """"""; oso = OptionsState(osd); yield; oso.restore(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.p4util.optproc. © Copyright 2007-2024, The Psi4 Project.; Last updated on ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/optproc.html:4838,Validat,ValidationError,4838,psi4manual/1.9.x/_modules/psi4/driver/p4util/optproc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/optproc.html,1,['Validat'],['ValidationError']
Security,"bel).group(1); ghostAtom = True. # Save the actual atom symbol (H1 => H); atomSym = re.split('(\d+)', atomLabel)[0].upper(). # Check that the atom symbol is valid; if not atomSym in el2z:; raise ValidationError('Illegal atom symbol in geometry specification: %s' % (atomSym)). zVal = el2z[atomSym]; charge = float(zVal); if ghostAtom:; zVal = 0; charge = 0.0. # handle cartesians; if len(entries) == 4:; tempfrag.append(iatom); xval = self.get_coord_value(entries[1]); yval = self.get_coord_value(entries[2]); zval = self.get_coord_value(entries[3]); self.full_atoms.append(CartesianEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:17472,Validat,ValidationError,17472,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"bel, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all atoms with *label*.""""""; raise FeatureNotImplemented('Molecule::set_basis_by_label') # FINAL. [docs] def nfrozen_core(self, depth=False):; """"""Number of frozen core for molecule given freezing state. >>> print H2OH2O.nfrozen_core(); 2. """"""; if depth == False or depth.upper() == 'FALSE':; return 0. elif depth == True or depth.upper() == 'TRUE':; # Freeze the number of core electrons corresponding to the; # nearest previous noble gas atom. This means that the 4p block; # will still have 3d electrons active. Alkali earth atoms will; # have one valence electron in this scheme.; nfzc = 0; for A in range(self.natom()):; if self.Z(A) > 2:; nfzc += 1; if self.Z(A) > 10:; nfzc += 4; if self.Z(A) > 18:; nfzc += 4; if self.Z(A) > 36:; nfzc += 9; if self.Z(A) > 54:; nfzc += 9; if self.Z(A) > 86:; nfzc += 16; if self.Z(A) > 108:; raise ValidationError(""Invalid atomic number""); return nfzc. else:; raise ValidationError(""Frozen core '%s' is not supported, options are {true, false}."" % (depth)). # <<< Involved Methods for Frame >>>. [docs] def translate(self, r):; """"""Translates molecule by r. >>> H2OH2O.translate([1.0, 1.0, 0.0]). """"""; temp = [None, None, None]; for at in range(self.nallatom()):; temp = scale(self.full_atoms[at].compute(), self.input_units_to_au); temp = add(temp, r); temp = scale(temp, 1.0 / self.input_units_to_au); self.full_atoms[at].set_coordinates(temp[0], temp[1], temp[2]). [docs] def center_of_mass(self):; """"""Computes center of mass of molecule (does not translate molecule). >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_m = 0.0. for at in range(self.natom()):; m = self.mass(at); ret = add(ret, scale(self.xyz(at), m)); total_m += m. ret = scale(ret, 1.0 / total_m); return ret. [docs] def move_to_com(self):; """"""Moves molecule to center of mass. """"""; com = scale(self.center_of_mass(), -1.0); self.translate(com). [docs] def set_c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:49754,Validat,ValidationError,49754,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"ber data. schema([by_alias, ref_template]). rtype; DictStrAny. schema_json(*[, by_alias, ref_template]). rtype; unicode. serialize(encoding, *[, include, exclude, ...]); Generates a serialized representation of the model. set_basis(basis). set_keywords(keywords). set_method(method). update_forward_refs(**localns); Try to update ForwardRefs on fields based on this Model, globalns and localns. validate(value). rtype; Model. Methods Documentation. compare(other, **kwargs)¶; Compares the current object to the provided object recursively. Parameters. other (Model) – The model to compare to.; **kwargs – Additional kwargs to pass to qcelemental.compare_recursive. Returns; True if the objects match. Return type; bool. compute(client=None)[source]¶; Run quantum chemistry. Parameters; client (Optional[FractalClient]) – . classmethod construct(_fields_set=None, **values)¶; Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data.; Default values are respected, but no other validation is performed.; Behaves as if Config.extra = ‘allow’ was set since it adds all passed values. Return type; Model. Parameters. _fields_set (Optional[SetStr]) – ; values (Any) – . copy(*, include=None, exclude=None, update=None, deep=False)¶; Duplicate a model, optionally choose which fields to include, exclude and change. Parameters. include (Union[AbstractSetIntStr, MappingIntStrAny]) – fields to include in new model; exclude (Union[AbstractSetIntStr, MappingIntStrAny]) – fields to exclude from new model, as with values this takes precedence over include; update (DictStrAny) – values to change/add in the new model. Note: the data is not validated before creating; the new model: you should trust this data; deep (bool) – set to True to make a deep copy of the model; self (Model) – . Return type; Model. Returns; new model instance. dict(**kwargs)¶; Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Return type; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html:3005,validat,validation,3005,psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,1,['validat'],['validation']
Security,"ber of irreps. np; View without only one irrep. classmethod np_read(filename, prefix=''); Reads the data from a NumPy compress file. np_write(filename=None, prefix=''); Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph; View with irreps. print_out(self: psi4.core.Vector) → None; Prints the vector to the output file. scale(self: psi4.core.Vector, sc: float) → None; Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None; Set a vector block. shape; Shape of the Psi4 data object. to_array(copy=True, dense=False); Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vector.html:8645,access,accessor,8645,psi4manual/1.3.2/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vector.html,1,['access'],['accessor']
Security,"beta5] » ; Module code ». Source code for qcdb.dbproc; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. r""""""File to. """"""; import sys; import os; import glob; import ast. [docs]def useful():; print ""in qcdb.useful()""; return 'qcdb successfully accessed'. [docs]def drop_duplicates(seq):; """"""Function that given an array or array of arrays *seq*, returns an; array without any duplicate entries. There is no guarantee of which; duplicate entry is dropped. """"""; noDupes = []; seq2 = sum(seq, []); [noDupes.append(i) for i in seq2 if not noDupes.count(i)]; return noDupes. [docs]def dictify_database_docstrings():; """""". """"""; db_path = os.path.expanduser('~loriab/linux/qcdb/databases'); sys.path.append(db_path). DSD = {}; module_choices = []; for module in glob.glob(db_path + '/*.py'):; filename = os.path.split(module)[1]; basename = os.path.splitext(filename)[0]; div = '=' * len(basename). module_choices.append(basename); DSD[basename] = {}. M = ast.parse(''.join(open(module))); DS = ast.get_docstring(M); if not DS:; DS = """"; DS = str.replace(DS, '|dl|', '-->'); DS = str.replace(DS, '|dr|', '<--'); DS = str.replace(DS, ""``'"", ''); DS = str.replace(DS, ""'``"", ''). lst = DS.split(""\n- **""). #DSD[basename]['general'] = str.re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html:1106,access,accessed,1106,psi4manual/4.0b5/_modules/qcdb/dbproc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/dbproc.html,1,['access'],['accessed']
Security,"bject; * @param max_am maximum angular momentum to build; * @return pair containing shell labels and four-center; * test basis for use in benchmarking; * See libmints/benchmark.cc for details; The libmints version seems not to have been updated along with the classes. static zero_ao_basis_set()[source]¶; Returns an empty basis set object.; Returns a BasisSet object that actually has a single s-function; at the origin with an exponent of 0.0 and contraction of 1.0.; * @return A new empty BasisSet object. zero_so_basis_set(factory)[source]¶; NYI Returns an empty SO basis set object.; * Returns an SOBasis object that actually has a single s-function; * at the origin with an exponent of 0.0 and contraction of 1.0.; * @return A new empty SOBasis object. class PreservingDict(*args, **kwargs)[source]¶; Class to store quantum chemical quantities extracted from output; files. Extends the dictionary object to (1) store key as all-caps; version of itself and (2) validate value for duplicate values for the; same key by testing which has more decimal places and whether value; the same within a plausing rounding error. Allows consistency checks; when parsing output files without loss of precision. setdefault(key, value=None)[source]¶. update(*args, **kwargs)[source]¶. class BasisSet(name, fullname=None, latex=None, citations=None, doi=None, comment=None, zeta=None, build=None)[source]¶; Specialization of QCEssential for basis sets. class Citation(doi, fullname=None, dsdbid=None, comment=None)[source]¶; Class to hold reference to a single published scientific work. class Error(name, fullname=None, latex=None, citations=None, doi=None, comment=None)[source]¶; Specialization of QCEssential for measures of error. class Method(name, fullname=None, latex=None, citations=None, doi=None, comment=None)[source]¶; Specialization of QCEssential for quantum chemical methods. class Publication(name, fullname=None, latex=None, dsdbid=None, doi=None, comment=None, owner=None)[source]¶; Specializa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:67319,validat,validate,67319,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['validat'],['validate']
Security,"ble %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; PsiMod.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); PsiMod.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); PsiMod.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; if (s[13:] == envv.upper().split()):; VRGT[rgt][envv] = float(s[10]); PsiMod.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv.upper(), VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; PsiMod.print_out(""\n""); banner((""Database %s Results"" % (db_name))); PsiMod.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = defaultdict(int); for rxn in HR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:45134,Validat,ValidationError,45134,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ble %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if (db_mode.lower() == 'sow'):; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse + '-' + str(rxn)])); maxrgt = max(maxactv); table_delimit = '-' * (54 + 20 * maxrgt); tables = ''. # find any reactions that are incomplete; FAIL = collections.defaultdict(int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:46732,Validat,ValidationError,46732,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ble(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS/UKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:86430,Validat,ValidationError,86430,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"ble; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; pass. def corl_xt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:5460,Validat,ValidationError,5460,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"blic License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""create_plugin"",; ""sanitize_name"",; ]. import os; import sys; from pathlib import Path. from psi4 import core; from psi4.driver.util import tty. [docs]; def sanitize_name(name: str) -> str:; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", ""bitand"", ""bitor"",; ""bool"", ""break"", ""case"", ""catch"", ""char"", ""char16_t"", ""char32_t"",; ""class"", ""compl"", ""concept"", ""const"", ""constexpr"", ""const_cast"",; ""continue"", ""decltype"", ""default"", ""delete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""req",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html:1525,sanitiz,sanitized,1525,psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/pluginutil.html,1,['sanitiz'],['sanitized']
Security,"blished by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]; def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html:1591,Validat,ValidationError,1591,psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"blished by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Array function, including NumPy interface and Python extensions to core array; classes:. - Matrix (constructor, view, access, serialization); - Vector (constructor, view, access, serialization); - Dimension (constructor); - CIVector (view); """""". __all__ = [; ""array_to_matrix"",; ""block_diagonal_array"",; ]. import sys; from typing import Any, Dict, Iterator, List, Optional, Tuple, Union. import numpy as np. from psi4 import core. from .exceptions import ValidationError. ### Matrix and Vector properties. def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; if copy:; return tuple([np.array(x) for x in self.array_interface()]); else:; return tuple(self.array_interface()). def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; if not hasattr(arr, 'shape'):; raise ValidationError(""Expected numpy array, found object of type '%s'"" % type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(; self: Union[core.Matrix, core.Vector],; arr: Union[np.ndarray, List[np.ndarray]],; name: str = ""New Matrix"",; dim1: Optional[Union[List, Tuple, core.Dimension]] = None,; dim2: Optional[core.Dimension] = None,; ) -> Union[core.Matrix, c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html:1589,Validat,ValidationError,1589,psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"bmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MAYER_INDICES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. def _core_has_variable(key):; return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(cls, key):; return cls.has_scalar_variable(key) or cls.has_array_variable(key). def _core_variable(key):; if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return core.array_variable(key); else:; raise KeyError(""psi4.core.variable: Requested variable "" + key + "" was not set!\n""). def _core_wavefunction_variable(cls, key):; if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return cls.array_variable(key); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key, val):; if isinstance(val, core.Matrix):; if core.has_scalar_v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:17799,Validat,ValidationError,17799,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"bmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""core.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (core.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; core.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; core.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); core.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); core.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); core.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; core.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); core.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:23569,Validat,ValidationError,23569,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,2,['Validat'],['ValidationError']
Security,"bmol.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())). elif db_mode == 'reap':; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); else:; while 1:; line = freagent.readline(); if not line:; if ERGT[rgt] == 0.0:; psi4.print_out('Warning: Output file \'%s.out\' has no DATABASE RESULT line.\n' % (rgt)); psi4.print_out(' Database summary will have 0.0 and **** in its place.\n'); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['DATABASE', 'RESULT:', 'computation']):; if int(s[3]) != db_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rgt, str(s[3]), str(db_linkage))); if s[6] != rgt:; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with reagent %s.'; % (rgt, s[6], rgt)); if (s[8:10] == ['electronic', 'energy']):; ERGT[rgt] = float(s[10]); psi4.print_out('DATABASE RESULT: electronic energy = %20.12f\n' % (ERGT[rgt])); elif (s[8:10] == ['variable', 'value']):; for envv in db_tabulate:; envv = envv.upper(); if (s[13:] == envv.split()):; VRGT[rgt][envv] = float(s[10]); psi4.print_out('DATABASE RESULT: variable %s value = %20.12f\n' % (envv, VRGT[rgt][envv])); freagent.close(). # end sow after writing files; if db_mode == 'sow':; return 0.0. # Reap all the necessary reaction computations; psi4.print_out(""\n""); p4util.banner((""Database %s Results"" % (db_name))); psi4.print_out(""\n""). maxactv = []; for rxn in HRXN:; maxactv.append(len(ACTV[dbse ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:23443,Validat,ValidationError,23443,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"bol(Patm)) or (c4mol.symbol(at) == 'GH'))]; allowed = list(set(sameElem) & set(Cwhite)). for Catm in allowed:; if all([abs(Cgeom[Catm][ax] - Pgeom[Patm][ax]) < COORD_ZERO for ax in range(3)]):; mapMat[Patm] = Catm; Pwhite.remove(Patm); Cwhite.remove(Catm); # print 'matchd on atom', 'Patm', Patm, 'Catm', Catm; break; else:; # print 'failed on atom', 'Patm', Patm, 'rejecting', exfp; break; else:; # print 'accept exchflp', exfp, 'with map', mapMat; break; else:; print('else of for', exfp, mapMat); print('qcdb.orient.create_orientation_from_molecules debug info'); print('\nPatm', Patm, 'Catm', Catm, 'Pwhite', Pwhite, \; 'Cwhite', Cwhite, 'sameElem', sameElem, 'allowed', allowed, \; '\nCgeom[Catm]: ', Cgeom[Catm], '\nPgeom[Patm]: ', Pgeom[Patm], \; '\nmapMat', mapMat); print('\nPgeom: '); for item in Pgeom:; print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])); print('\nCgeom: '); for item in Cgeom:; print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])); print(self); raise ValidationError(""""""Atom unreconcilable between QC programs.""""""). self.Cexchflip = exfp; self.Catommap = mapMat; # Note that this is resetting the geom but not the atoms, so c4mol.print_out() is deceptive; c4mol.rotate(exfp); new_geom = []; for at in range(Nat):; new_geom.append(Cgeom[mapMat[at]]); c4mol.set_geometry(new_geom). # One last check that p4mol and c4mol align; Pgeom = p4mol.geometry(); Cgeom = c4mol.geometry(). if not all([all([abs(Cgeom[at][ax] - Pgeom[at][ax]) < COORD_ZERO for ax in range(3)]) for at in range(Nat)]):; raise ValidationError(""""""Geometries unreconcilable between QC programs:\n P4 %s\n C4 %s"""""" % (Pgeom, Cgeom)). [docs] def transform_coordinates(self, coord):; """""". """"""; #print self; print(""Original""); coord.print_out(). coord.translate(scale(self.Cshift, -1.0)); print(""Shift""); coord.print_out(). coord.rotate(self.Crotate); print(""Rotate""); coord.print_out(). coord.rotate(self.Cexchflip); print(""ExchFlip""); coord.print_out(). geom = coord.geometry(); new_geom = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html:9628,Validat,ValidationError,9628,psi4manual/1.0.0/_modules/qcdb/orient.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html,1,['Validat'],['ValidationError']
Security,"broken symmetry.'); molecule.set_multiplicity(3); PsiMod.print_out(""\n\n\tComputing high-spin triplet guess\n\n""); scf_helper(name, **kwargs); molecule.set_multiplicity(1); PsiMod.set_local_option('SCF', 'GUESS', 'READ'); PsiMod.print_out(""\n\n\tComputing broken symmetry solution from high-spin triplet guess\n\n""); ; returnvalue = scf_helper(name, **kwargs); ; optstash.restore(); return returnvalue. [docs]def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """"""; optstash = OptionsState(; ['DF_BASIS_SCF']). returnvalue = run_scf(name, **kwargs). if (PsiMod.get_option('SCF', 'SCF_TYPE') == 'DF'):. # if the df_basis_scf basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_SCF') == '':; jkbasis = corresponding_jkfit(PsiMod.get_global_option('BASIS')); if jkbasis:; PsiMod.set_global_option('DF_BASIS_SCF', jkbasis); PsiMod.print_out('\nNo DF_BASIS_SCF auxiliary basis selected, defaulting to %s\n\n' % (jkbasis)); else:; raise ValidationError('Keyword DF_BASIS_SCF is required.'). PsiMod.scfgrad(). else:; PsiMod.deriv(). optstash.restore(); return returnvalue. [docs]def run_libfock(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. """"""; if (name.lower() == 'cphf'):; PsiMod.set_global_option('MODULE', 'RCPHF'); if (name.lower() == 'cis'):; PsiMod.set_global_option('MODULE', 'RCIS'); if (name.lower() == 'tdhf'):; PsiMod.set_global_option('MODULE', 'RTDHF'); if (name.lower() == 'cpks'):; PsiMod.set_global_option('MODULE', 'RCPKS'); if (name.lower() == 'tda'):; PsiMod.set_global_option('MODULE', 'RTDA'); if (name.lower() == 'tddft'):; PsiMod.set_global_option('MODULE', 'RTDDFT'). PsiMod.libfock(). [docs]def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; return PsiMod.mcscf(). [docs]def scf_he",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:4966,Validat,ValidationError,4966,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"bs_wrapper_methods(**kwargs):; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]. cbs_methods = []; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?![^\[\]]*\]|[^\(\)]*\))"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:56967,Validat,ValidationError,56967,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"bsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:; raise ValidationError(""Extrapolation function names follow <scf|corl>_xtpl_<scientist>_<#basis>""). [docs]def register_composite_function(func: Callable):; """"""Register a user-defined composite method function to use like a built-in one. Parameters; ----------; func; A Python function that defines a configuration of the :py:func:`psi4.cbs` wrapper.; See :source:`psi4/driver/aliases.py` and :srcsample:`cbs-xtpl-nbody` for examples. """"""; composite_procedures[func.__name__] = func. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.6;  · . PSI4. Module code; psi4.driver.driver_cbs_helper. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:22012,Validat,ValidationError,22012,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for data",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:34009,Validat,ValidationError,34009,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:34726,Validat,ValidationError,34726,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"bsse: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('cp_func' in kwargs):; if ('func' in kwargs):; kwargs['cp_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cp_func'] = energy; func = kwargs['cp_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper counterpoise_correct.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:18803,Validat,ValidationError,18803,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"bute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import sys. from psi4.driver.util.filesystem import *; from psi4.driver.util import tty. [docs]def sanitize_name(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, ``-``,; & ``,`` into ``_``. Also checks the sanitized name against a list of restricted C++ keywords.; """"""; if name[0].isalpha():; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); temp = temp.replace('-', '_'). # Taken from http://en.cppreference.com/w/cpp/keyword; cpp_keywords = [; ""alignas"", ""alignof"", ""and"", ""and_eq"", ""asm"", ""atomic_cancel"",; ""atomic_commit"", ""atomic_noexcept"", ""auto"", ""bitand"", ""bitor"",; ""bool"", ""break"", ""case"", ""catch"", ""char"", ""char16_t"", ""char32_t"",; ""class"", ""compl"", ""concept"", ""const"", ""constexpr"", ""const_cast"",; ""continue"", ""decltype"", ""default"", ""delete"", ""do"", ""double"",; ""dynamic_cast"", ""else"", ""enum"", ""explicit"", ""export"", ""extern"",; ""false"", ""float"", ""for"", ""friend"", ""goto"", ""if"", ""import"", ""inline"",; ""int"", ""long"", ""module"", ""mutable"", ""namespace"", ""new"", ""noexcept"",; ""not"", ""not_eq"", ""nullptr"", ""operator"", ""or"", ""or_eq"", ""private"",; ""protected"", ""public"", ""register"", ""reinterpret_cast"", ""req",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/plugin.html:1419,sanitiz,sanitized,1419,psi4manual/1.1.0/_modules/psi4/driver/plugin.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/plugin.html,1,['sanitiz'],['sanitized']
Security,"buted in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with non-generic exceptions classes.""""""; from __future__ import print_function. [docs]class QcdbException(Exception):; """"""Error class for QCDB.""""""; pass. [docs]class FeatureNotImplemented(QcdbException):; """"""Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: Feature %s is not yet implemented.\n\n' % (msg)). [docs]class ValidationError(QcdbException):; """"""Error called for problems with syntax input file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class IncompleteAtomError(QcdbException):; """"""Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg. [docs]class ParsingValidationError(QcdbException):; """"""Error called for problems with syntax from a QC output file. Prints; error message *msg* to standard output stream. """"""; def __init__(self, msg):; QcdbException.__init__(self, msg); self.msg = msg; print('\nQcdbException: %s\n\n' % (msg)). [docs]class FragmentCountError(QcdbException):; """"""Error called molecule has wrong number of fragments for method.; Prints error message *msg* to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html:1488,Validat,ValidationError,1488,psi4manual/1.0.0/_modules/qcdb/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/exceptions.html,1,['Validat'],['ValidationError']
Security,"bvious way. The possible geometry data is as follows:. geometry: list of floats; (3 * nat) The molecular geometry as a flat list in bohr. All coordinates; are given for one atom before proceeding to the next atom. energy: int; The last computed electronic energy at the geometry. gradient: list of floats; (3 * nat) The last computed gradient of energy with respect to changes in; geometry at the geometry, as a flat list. All coordinates are given for; displacing one atom before proceeding to the next atom. reference : dict; A geometry data dict, as described above, for the reference geometry.; """""". msg_dict = {; ""1_0"":; ""energies to determine gradients"",; ""2_1"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points"",; ""2_0"":; ""gradients to determine vibrational frequencies and \n""; "" normal modes. Resulting frequencies are only valid at stationary points""; }. try:; print_msg = msg_dict[mode]; except KeyError:; raise ValidationError(""FINDIF: Mode {} not recognized."".format(mode)). def init_string(data):; return f"""""" Using finite-differences of {print_msg}.; Generating geometries for use with {data[""stencil_size""]}-point formula.; Displacement size will be {data[""step_size""]:6.2e}.\n"""""". # Genuine support for qcdb molecules would be nice. But that requires qcdb CdSalc tech.; # Until then, silently swap the qcdb molecule out for a psi4.core.Molecule.; if isinstance(mol, qcdb.Molecule):; mol = core.Molecule.from_dict(mol.to_dict()). data = _initialize_findif(mol, freq_irrep_only, mode, stencil_size, step_size, init_string, t_project, r_project,; True, 1). # We can finally start generating displacements.; ref_geom = np.array(mol.geometry()). # Now we generate the metadata...; findifrec = {; ""step"": {; ""units"": ""bohr"",; ""size"": data[""step_size""]; },; ""stencil_size"": data[""stencil_size""],; ""displacement_space"": ""CdSALC"",; ""project_translations"": data[""project_translations""],; ""project_rotations"": da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:16308,Validat,ValidationError,16308,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['Validat'],['ValidationError']
Security,"c or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if input.der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif input.der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:21455,Validat,ValidationError,21455,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"c single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:23263,Validat,ValidationError,23263,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,1,['Validat'],['ValidationError']
Security,"c single-geometry computations. Parameters. molecule (Any) – The molecule to use in the computation.; basis (str) – The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, …).; method (str) – The quantum chemistry method to evaluate (e.g., B3LYP, MP2, …).; driver ({energy,gradient,hessian,properties}) – The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver.; keywords (Dict[Any], Optional) – The keywords to use in the computation.; computed (bool, Default: False) – Whether quantum chemistry has been run on this task.; result (Any, Optional) – AtomicResult return.; result_id (str, Optional) – The optional ID for the computation.; extra_data (Any) – . Return type; None. Methods Summary. compare(other, **kwargs); Compares the current object to the provided object recursively. compute([client]); Run quantum chemistry. construct([_fields_set]); Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data. copy(*[, include, exclude, update, deep]); Duplicate a model, optionally choose which fields to include, exclude and change. dict(**kwargs); Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. from_orm(obj). rtype; Model. get_results([client]); Return results as Atomic-flavored QCSchema. json(**kwargs); Generate a JSON representation of the model, include and exclude arguments as per dict(). parse_file(path, *[, encoding]); Parses a file into a Model object. parse_obj(obj). rtype; Model. parse_raw(data, *[, encoding]); Parses raw string or bytes into a Model object. plan(); Form QCSchema input from member data. schema([by_alias, ref_template]). rtype; DictStrAny. schema_json(*[, by_alias, ref_template]). rtype; unicode. serialize(encoding, *[, include, exclude, ...]); Generates a serialized representation of the model. set_basis(basis). set_keywords(keywords). set_method",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html:1312,validat,validated,1312,psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,1,['validat'],['validated']
Security,"c symbol to use; *mass* mass to use if non standard; *charge* charge to use if non standard; *lineno* line number when taken from a string. """"""; self.lock_frame = False. if self.atom_at_position([x, y, z]) == -1:; # Dummies go to full_atoms, ghosts need to go to both.; self.full_atoms.append(CartesianEntry(self.nallatom(), Z, charge, mass, label, label, \; NumberValue(x), NumberValue(y), NumberValue(z))); if label.upper() != 'X':; self.atoms.append(self.full_atoms[-1]); else:; raise ValidationError(""Molecule::add_atom: Adding atom on top of an existing atom.""). [docs] def atom_entry(self, atom):; """"""Returns the CoordEntry for an atom.""""""; return self.atoms[atom]. [docs] def atom_at_position(self, b, tol=0.05):; """"""Tests to see of an atom is at the passed position *b* in Bohr with a tolerance *tol*. >>> print H2OH2O.atom_at_position([1.35*(1.0/psi_bohr2angstroms), 0.10*(1.0/psi_bohr2angstroms), 0.0*(1.0/psi_bohr2angstroms)]); 3. """"""; if len(b) != 3:; raise ValidationError('ERROR: atom_at_position() requires as argument a vector of length 3\n'). for at in range(self.natom()):; a = self.xyz(at); if distance(b, a) < tol:; return at; return -1. [docs] def is_variable(self, vstr):; """"""Checks to see if the variable str is in the list, returns; true if it is, and returns false if not. >>> H2OH2O.is_variable('R'); False. """"""; return True if vstr.upper() in self.all_variables else False. [docs] def get_variable(self, vstr):; """"""Checks to see if the variable str is in the list, sets it to; val and returns true if it is, and returns false if not. """"""; vstr = vstr.upper(); try:; return self.geometry_variables[vstr]; except KeyError:; raise ValidationError('ERROR: Geometry variable %s not known.\n' % (vstr)). [docs] def set_variable(self, vstr, val):; """"""Assigns the value val to the variable labelled string in the; list of geometry variables. Also calls update_geometry(). """"""; self.__dict__['lock_frame'] = False; self.__dict__['geometry_variables'][vstr.upper()] = val; print ""Set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:31074,Validat,ValidationError,31074,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['Validat'],['ValidationError']
Security,"c-mp') and (level == 4):; emp4 = PsiMod.get_variable(""MP4 TOTAL ENERGY""); cemp4 = PsiMod.get_variable(""MP4 CORRELATION ENERGY""); PsiMod.set_variable(""CURRENT ENERGY"",emp4); PsiMod.set_variable(""CURRENT CORRELATION ENERGY"",cemp4). # restore symmetry for fno-cc; if (PsiMod.get_option('FNOCC','NAT_ORBS')):; molecule.reset_point_group(user_pg); molecule.update_geometry(). # restore options; optstash.restore(). return PsiMod.get_variable(""CURRENT ENERGY""). [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); uppername = name.upper(); kwargs = kwargs_lower(kwargs). # save user options; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'CEPA_NO_SINGLES']). PsiMod.set_local_option('FNOCC','RUN_CEPA', True). # what type of cepa?; cepa_level = uppername; if (lowername == 'cepa(2)'):; raise ValidationError(""Error: %s not implemented\n"" % lowername); if (lowername == 'dci'):; cepa_level = 'CISD'; if (lowername == 'sdci'):; cepa_level = 'CISD'. if (lowername == 'fno-cepa(0)'):; cepa_level = 'CEPA(0)'; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); if (lowername == 'fno-cepa(1)'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(1)'; if (lowername == 'fno-cepa(3)'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CEPA(3)'; if (lowername == 'fno-acpf'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'ACPF'; if (lowername == 'fno-aqcc'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'AQCC'; if (lowername == 'fno-sdci'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'; if (lowername == 'fno-dci'):; PsiMod.set_local_option('FNOCC', 'NAT_ORBS', True); cepa_level = 'CISD'. PsiMod.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level). # override symmetry for fno-cepa; if (PsiMod.get_option('FNOCC','NAT_ORBS'))",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:76613,Validat,ValidationError,76613,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"c-pVDZ, ...).""); method: str = Field(..., description=""The quantum chemistry method to evaluate (e.g., B3LYP, MP2, ...).""); driver: DriverEnum = Field(..., description=""The resulting type of computation: energy, gradient, hessian, properties.""; ""Note for finite difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs] @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs] @validator(""method""); def set_method(cls, method):; return method.lower(). [docs] @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs] def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": {; ""stdout"": True,; },; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs] def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Molecule; qca_next_branch = True. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). if not qca_next_branch:; # QCFractal v0.15.8. # Build the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_base.html:3330,validat,validator,3330,psi4manual/1.7.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/task_base.html,1,['validat'],['validator']
Security,"c.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with PsiAPI helpers for PSIthon `{...}` syntax.; Also, many Python extensions to core classes:. - core (variable-related, gradient, python option),; - Wavefunction (variable-related, freq, Lagrangian, constructor, scratch file, serialization),; - Matrix (doublet, triplet),; - BasisSet (constructor); - JK (constructor); - VBase (grid); - OEProp (avail prop); """""". __all__ = [; ""basis_helper"",; ""pcm_helper"",; ""plump_qcvar"",; ""set_options"",; ""set_module_options"",; ]. import math; import os; import re; import uuid; import warnings; from collections import Counter; from itertools import product; from pathlib import Path; from tempfile import NamedTemporaryFile; from typing import Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np; import qcelemental as qcel. from psi4 import core, extras. from .. import qcdb; from . import optproc; from .exceptions import TestComparisonError, UpgradeHelper, ValidationError. ## Python basis helps. @staticmethod; def _pybuild_basis(; mol: core.Molecule,; key: Optional[str] = None,; target: Optional[Union[str, Callable]] = None,; fitrole: str = ""ORBITAL"",; other: Optional[Union[str, Callable]] = None,; puream: int = -1,; return_atomlist: bool = False,; *,; quiet: bool = False,; ) -> Union[core.BasisSet, List[core.BasisSet]]:; """"""Build a primary or auxiliary basis set. Parameters; ----------; mol; Molecule for which to build the basis set instance.; key; {'BASIS', 'ORBITAL', 'DF_BASIS_SCF', 'DF_BASIS_MP2', 'DF_BASIS_CC', 'BASIS_RELATIVISTIC', 'DF_BASIS_SAD'}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ``""ORBITAL""`` or ``""BASIS""``.; target; Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/python_helpers.html:2072,Validat,ValidationError,2072,psi4manual/master/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"c/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; energy('mp3'). will run OCC, while; set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Adding Methods to Driver. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/proc_py.html:6544,access,access,6544,psi4manual/1.6.x/proc_py.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/proc_py.html,1,['access'],['access']
Security,"c2""; [master 16dbd3e] Records tag for v1.3rc2. # goto GH:psi4/psi4 > Settings > Branches > master > Edit; # https://github.com/psi4/psi4/settings/branch_protection_rules/424295; # uncheck ""Include administrators"" and Save changes. >>> git push upstream master. # re-engage ""Include administrators"" protections. Tag postrelease¶. # be on clean maintenance branch up-to-date with upstream in both commits and tags; # * mind which version strings get ""v"" and which don't; # * if not fork, replace ""upstream"" with ""origin"". >>> git checkout 1.3.x; Switched to branch '1.3.x'. >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; ...; -__version__ = '1.3'; -__version_long = '1.3+zzzzzzz'; +__version__ = '1.3.1'; +__version_long = '1.3.1+zzzzzzz'. >>> git add psi4/metadata.py; >>> git commit -m ""v1.3.1""; [1.3.x 2ce1c29] v1.3.1. >>> git log --oneline | head -1; 786fb2b v1.3.1; >>> git tag -a v1.3.1 2ce1c29 -m ""v1.3.1"". # skipping the hash recording and ""upcoming"" step b/c only tags matter on maintenance branch. # free pushing to maintenance branches at present so GitHub interface steps not needed. # see note at ""Tag postrelease"" for why atomic commit needed. Collect docs from GHA artifacts. >>> git push --atomic upstream 1.3.x v1.3.1. Initialize release branch¶. follow tagging procedure; before re-engaing the “include admin” button, push a branch at the tag commit (not the records commit); >>> git log --online | head -2; 45315cb Records tag for v1.3; 20e5c7e v1.3. >>> git checkout 20e5c7e; >>> git checkout -b 1.3.x; Switched to a new branch '1.3.x'; >>> git push upstream 1.3.x. set up new branch as protected branch through GitHub psi4 org Settings. Should be already covered under 1.*.x rule. Build Conda Psi4 stack at specific commit¶; By “Psi4 stack”, mean packages psi4, psi4-rt, psi4-dev.; Package psi4-docs used to be in “Psi4 stack”, but it’s handled by GHA and netlify now, not Conda, so skip directions below.; Other packages, the “ecosystem s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/manage_release.html:8080,hash,hash,8080,psi4manual/1.7.x/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/manage_release.html,2,['hash'],['hash']
Security,"c2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.gro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:120162,Validat,ValidationError,120162,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"c>` |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------+. .. include:: autodoc_dft_opt.rst. .. warning:: Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:49280,access,accesses,49280,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['access'],['accesses']
Security,"c_ss_alpha()); PsiMod.dfmp2(); returnvalue += dfun.c_alpha() * PsiMod.get_variable('SCS-DF-MP2 CORRELATION ENERGY'). else:; PsiMod.dfmp2(); returnvalue += dfun.c_alpha() * PsiMod.get_variable('DF-MP2 CORRELATION ENERGY'). PsiMod.set_variable('DFT TOTAL ENERGY', returnvalue); PsiMod.set_variable('CURRENT ENERGY', returnvalue). optstash.restore(); return returnvalue. [docs]def run_dft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. """"""; optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE']). PsiMod.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = PsiMod.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; PsiMod.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). if (PsiMod.get_option('SCF', 'SCF_TYPE') != 'DF'):; raise ValidationError('SCF_TYPE must be DF for DFT gradient (for now).'). returnvalue = run_scf_gradient(name, **kwargs). optstash.restore(); return returnvalue. [docs]def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; optstash = OptionsState(; ['TRANSQT2', 'WFN'],; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). if (name.lower() == 'zapt'):; PsiMod.set_local_option('TRANSQT2', 'WFN', 'ZAPTN'); PsiMod.set_local_option('DETCI', 'WFN', 'ZAPTN'); level = kwargs['level']; maxnvect = (level + 1) / 2 + (level + 1) % 2; PsiMod.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if ((level + 1) % 2):; PsiMod.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; PsiMod.set_local_option('D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:24610,Validat,ValidationError,24610,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"cal/mol', citation=None, doi=None, comment=None):; # geometry; self.dbrxn = dbse + '-' + str(rxn); # qcdb.Method; self.method = method; # mode, e.g., unCP, CP, RLX, etc.; self.mode = mode; # qcdb.BasisSet; self.basis = basis; # numerical value for reaction; self.value = float(value); # energy unit attached to value, defaults to kcal/mol; self.units = units; # publication citation of value; self.citation = citation; # digital object identifier for publication (maybe this should be doi of datum, not of pub?); self.doi = doi; # addl comments; self.comment = comment. @classmethod; [docs] def library_modelchem(cls, dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, doi=None,; comment=None):; """"""Constructor when method and basis are strings corresponding to; qcdb.Method and qcdb.BasisSet already defined in methods and bases. """"""; # computational method; try:; tmp_method = methods[method.upper()]; except KeyError as e:; raise ValidationError(""""""Invalid ReactionDatum method %s: %s"""""" % (method, e)); # computational basis set; try:; tmp_basis = bases[basis.lower()]; except KeyError as e:; raise ValidationError(""""""Invalid ReactionDatum basis %s: %s"""""" % (basis, e)); # publication; if citation is None:; tmp_pub = citation; else:; try:; tmp_pub = pubs[citation.lower()]; except KeyError as e:; raise ValidationError(""""""Invalid ReactionDatum publication %s: %s"""""" % (citation, e)); return cls(dbse, rxn, tmp_method, mode, tmp_basis, value, units, citation=tmp_pub, doi=doi, comment=comment). def __str__(self):; text = ''; text += """""" ==> ReactionDatum <==\n\n""""""; text += """""" Database reaction: %s\n"""""" % (self.dbrxn); text += """""" Method: %s\n"""""" % (self.method.fullname); text += """""" Mode: %s\n"""""" % (self.mode); text += """""" Basis: %s\n"""""" % (self.basis.fullname); text += """""" Value: %f [%s]\n"""""" % (self.value, self.units); text += """""" Citation: %s %s\n"""""" % (self.citation.name, self.citation.doi); text += """""" DOI: %s\n"""""" % (self.doi); text += """""" Comment: %s\n"""""" %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:10778,Validat,ValidationError,10778,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"calar. may be string; return float(val). if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; reshaper = (-1, ); elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); elif key.upper().endswith(""QUADRUPOLES""):; reshaper = (-1, 3, 3); elif key.upper().endswith(""OCTUPOLES""):; reshaper = (-1, 3, 3, 3); elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; reshaper = (3, ); elif ""QUADRUPOLE POLARIZABILITY TENSOR"" in key.upper():; reshaper = (3, 3, 3); elif any((key.upper().endswith(p) or f""{p} -"" in key.upper()) for p in _multipole_order):; p = [p for p in _multipole_order if (key.upper().endswith(p) or f""{p} -"" in key.upper())]; reshaper = tuple([3] * _multipole_order.index(p[0])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES""]:; reshaper = (-1, ); elif ""GRADIENT"" in key.upper():; reshaper = (-1, 3); elif ""HESSIAN"" in key.upper():; ndof = int(math.sqrt(len(tgt))); reshaper = (ndof, ndof); else:; raise ValidationError(f'Uncertain how to reshape array: {key}'). return tgt.reshape(reshaper). _multipole_order = [""dummy"", ""dummy"", ""QUADRUPOLE"", ""OCTUPOLE"", ""HEXADECAPOLE""]; for order in range(5, 10):; _multipole_order.append(f""{int(2**order)}-POLE""). def _qcvar_reshape_set(key: str, val: np.ndarray) -> np.ndarray:; """"""Reverse :py:func:`_qcvar_reshape_get` for internal; :py:class:`psi4.core.Matrix` storage. """"""; reshaper = None; if key.upper().startswith(""MBIS""):; if key.upper().endswith(""CHARGES""):; return val; elif key.upper().endswith(""DIPOLES""):; reshaper = (-1, 3); return val.reshape(reshaper); elif key.upper().endswith(""QUADRUPOLES""):; val = val.reshape(-1, 3, 3); val = np.array([_multipole_compressor(val[iat], 2) for iat in range(len(val))]); return val; elif key.upper().endswith(""OCTUPOLES""):; val = val.reshape(-1, 3, 3, 3); val = np.array([_multipole_compressor(val[iat], 3) for iat in range(len(val))]); return val; elif key.upper().endswith(""DIPOLE"") or ""DIPOLE -"" in key.upper():; r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:29745,Validat,ValidationError,29745,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"calc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). psi4.hessian(name[, molecule, return_wfn, func, dertype, irrep])[source]; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. Returns:; Matrix – Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. Returns:; (Matrix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). It’s handy to collect the wavefunction after a frequency; calculation through e, wfn = psi4.frequency(...,; return_wfn=True) as the frequencies can be accessed through; psi4.core.Wavefunction.frequencies(), the Hessian through; psi4.core.Wavefunction.hessian(), and much other computation; info through psi4.core.Wavefunction.frequency_analysis; (note no parentheses). Examples of using this data; structure can be found fd-freq-gradient and; psi4/tests/pytests/test_vibanalysis.py. Formatted printing of vibrational; results is available through psi4.driver.qcdb.vib.print_vibs(). Results accessible through psi4.core.Wavefunction.frequency_analysis¶. key; description (lbl & comment); units; data (real/imaginary modes). omega; frequency; cm^-1; ndarray(ndof) complex (real/imag). q; normal mode, normalized mass-weighted; a0 u^1/2; ndarray(ndof, ndof) float. w; normal mode, un-mass-weighted; a0; ndarray(ndof, ndof) float. x; normal mode, normalized un-mass-weighted; a0; ndarray(ndof, ndof) float. degeneracy; degree of degeneracy. ndarray(ndof) int. TRV; translation/rotation/vibration. ndarray(ndof) str ‘TR’ or ‘V’ or ‘-’ for partia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:4515,access,accessed,4515,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,4,['access'],['accessed']
Security,"cale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def naivemult(v, u):; """"""Compute by-element multiplication of vectors *v* and *u*.""""""; if len(u) != len(v):; raise ValidationError('naivemult() only defined for vectors of same length \n'); return [u[i] * v[i] for i in range(len(v))]. [docs]def normalize(v):; """"""Compute normalized vector *v*.""""""; vmag = norm(v); return [v[i] / vmag for i in range(len(v))]. [docs]def distance(v, u):; """"""Compute the distance between points defined by vectors *v* and *u*.""""""; return norm(sub(v, u)). [docs]def cross(v, u):; """"""Compute cross product of length 3 vectors *v* and *u*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('cross() only defined for vectors of length 3\n'); return [v[1] * u[2] - v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp_unit(axis, perpendicular); third_axis = scale(third_axis, norm(perpendicular)). result = add(parallel, add(scale(perpendicular, math.cos(theta)), scale(third_axis, math.sin(theta)))); for item in range(len(result)):; if math.fabs(result[item]) < ZERO:; result[item] = 0.0; return result. [docs]def perp_unit(u, v):; """"""Compute unit vector perpendicular to length 3 vectors *u* and *v*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('perp_unit() only defined for vectors of length 3\n'). # try cross product; result = cross(u, v); resultdotresult = dot(result, result). if resultdotresult < 1.E-16:; # cross product is too small to normalize; # find the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html:2804,Validat,ValidationError,2804,psi4manual/1.0.0/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/vecutil.html,1,['Validat'],['ValidationError']
Security,"can be created in two ways:; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> numpy_mat_view = np.asarray(mat). # Access the NumPy object and set all values to 1 through broadcasting; >>> numpy_mat_view[:] = 1. >>> print(np.array(mat)); [[ 1. 1. 1.]; [ 1. 1. 1.]; [ 1. 1. 1.]]. Secondly, these objects have a .np attribute for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; 1; 2; 3; 4; 5; 6; 7; 8>>> dim = psi4.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None)[source]¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters:; arr (array or list of arrays) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (list, tuple, or core.Dimension (optional)) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 – Same as dim1 only if using a psi4.core.Dimension object. Returns:matrix – Returns the given",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/numpy-1.html:2534,access,accessor,2534,psi4manual/1.2.1/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/numpy-1.html,4,['access'],['accessor']
Security,"cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper n_body.' % (func.__name__)); if (func is db):; raise ValidationError('Wrapper n_body is unhappy to be calling function \'%s\'.' % (func.__name__)). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). # N-body run configuration; bsse = 'on'; if 'bsse' in kwargs:; bsse = kwargs['bsse']. max_n_body = molecule.nfragments(); if 'max_n_body' in kwargs:; max_n_body = kwargs['max_n_body']. do_total = False; if 'do_total' in kwargs:; do_total = kwargs['do_total']. external = None; external_indices = []; if 'external' in kwargs:; external = kwargs['external']; external_indices = [molecule.nfragments()]; if 'external_monome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:4363,Validat,ValidationError,4363,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"can’t predict. >>> vi psi4/metadata.py. >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 5d87b55..6cbc05e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,6 +1,6 @@; -__version__ = '1.1a1'; -__version_long = '1.1a1+007a9b6'; -__version_upcoming_annotated_v_tag = '1.1a2'; +__version__ = '1.1rc1'; +__version_long = '1.1rc1+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.1rc2'. >>> git add psi4/metadata.py. >>> git commit -m ""v1.1rc1"". OBSERVE undefined version state. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. >>> psi4/versioner.py; Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded); undefined {master} 6100822 1.0.0.999 1.0 <-- undefined+6100822. Note 7-char git hash for the new commit, here “6100822”. ACT to bump tag in git, then bump git tag in code. Use the decided-upon tag v1.1rc1 and the observed hash “6100822” to; mint a new annotated tag, minding that “v”s are present here.; Use the observed hash to edit psi4/psi4/metadata.py and commit immediately. >>> git tag -a v1.1rc1 6100822 -m ""v1.1rc1"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 6cbc05e..fdc202e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,5 +1,5 @@; __version__ = '1.1rc1'; -__version_long = '1.1rc1+zzzzzzz'; +__version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> psi4/versioner.py; Amazing, this can't actually happen that git hash stored at git commit.; >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.1rc1"". OBSERVE current versioning state. Nothing to make note of, this is just a snapshot. >>> psi4/versioner.py; Defining development snapshot version: 1.1rc2.dev1+4e0596e (computed); 1.1rc2.dev1 {master} 4e0596e 1.0.0.999 1.0 <-- 1.1rc2.dev1+4e0596e. >>> git describe --abbrev=7 --long --always HEAD; v1.1rc1-1-g4e0596e. >>> git des",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_git.html:2362,hash,hash,2362,psi4manual/master/manage_git.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_git.html,9,['hash'],['hash']
Security,"cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme); logger.debug(cbsscheme). return final. elif isinstance(valueLO, np.ndarray):. value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]; def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; els",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:21060,Validat,ValidationError,21060,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,3,['Validat'],['ValidationError']
Security,"cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (19 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % final; core.print_out(cbsscheme); logger.debug(cbsscheme). return final. elif isinstance(valueLO, np.ndarray):. value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). if verbose > 2:; cbsscheme = f""""""\n ==> Helgaker 2-point correlated extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""corl_xtpl_helgaker_2: datatype is not recognized '{type(valueLO)}'.""). xtpl_procedures = {; ""xtpl_highest_1"": xtpl_highest_1,; ""scf_xtpl_helgaker_2"": scf_xtpl_helgaker_2,; ""scf_xtpl_truhlar_2"": scf_xtpl_truhlar_2,; ""scf_xtpl_karton_2"": scf_xtpl_karton_2,; ""scf_xtpl_helgaker_3"": scf_xtpl_helgaker_3,; ""corl_xtpl_helgaker_2"": corl_xtpl_helgaker_2,; }. composite_procedures = {; ""sherrill_gold_standard"": sherrill_gold_standard,; ""allen_focal_point"": allen_focal_point,; }. [docs]def register_xtpl_function(func: Callable):; """"""Register a user-defined extrapolation function to use like an built-in one. Parameters; ----------; func; A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See :source:`psi4/driver/driver_cbs_helper.py` and :srcsample:`pywrap-cbs1` for; examples. The name of the function should follow the pattern ``<scf|corl>_xtpl_<scientist>_<#basis>``. """"""; if func.__name__.split(""_"")[-1].isdigit():; xtpl_procedures[func.__name__] = func; else:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:20968,Validat,ValidationError,20968,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,2,['Validat'],['ValidationError']
Security,"cbsscheme += """""" Extrapolated Correlation Energy: %16.8f\n"""""" % (energypiece); cbsscheme += """""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionnam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:100921,Validat,ValidationError,100921,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy('rhf'). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, get_variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special comment at the top (starting with the #! comment marker). This should be very descriptive since it is inlined into the manual (unless !nosample is present in this comment) as a sample input.; The reference values are assigned to variables for later use. The compare_values function (along with several relatives in psi4/psi4/driver/p4util/util.py for comparing strings, matrices, etc.) checks that the computed values match these reference values to suitable precision. This function prints an error message and signals that the test failed to the make system, if the values don’t match. Any lines of the input associated with the validation process should be flagged with #TEST at the end of each line, so that they can be removed when copying from the tests to the samples directory.; Finally, add the directory name to the list of tests in psi4/tests/CMakeLists.txt.; In preparing the test case, turn energy, density, amplitude, and; geometry convergence criteria to very tight levels, and use these; results for reference energies, reference geometries, reference cube; files, etc.. Then, either remove or relax the convergence settings,; if these are not a vital part of the test. In choosing the number of; digits for compare_values and other compare_* functions,; select a number looser than the convergence set in the test or the; default convergence for the calculation type (energy, gradient, etc.). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/add_tests-1.html:2664,validat,validation,2664,psi4manual/1.3.2/add_tests-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/add_tests-1.html,2,['validat'],['validation']
Security,"cc/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). return func(name, **kwargs). Naturally, in the run function, you must either use the type keyword for; type switching or translate it into whatever DO_CD-like keywords your; module uses. At run time with a closed-shell molecule,; 1energy('mp3'). will run OCC, while; 1; 2set qc_module fnocc; energy('mp3'). will run FNOCC mp3.; A special case is DETCI that can run mp3, but oughtn’t to be used for such. So above, ROHF CONV mp3 has no default, but can still access the detci code with; 1; 2; 3set reference rohf; set qc_module detci; energy('mp3'). While the below gives an error; 1; 2set reference rohf; energy('mp3'). Again, whenever a single method name needs to call multiple proc.py run; functions, it should be managed. In Overlapping capabilities of . “Y” is available; “D” is default. “Y” means method available in; module, “D” means module is default for that method, “” mean method not; available. table of contents. Adding Methods to Driver; proc.py; Managed Methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Adding New Code to PSI4. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/proc_py-1.html:6800,access,access,6800,psi4manual/1.3.2/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/proc_py-1.html,2,['access'],['access']
Security,"cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------+. .. include:: autodoc_dft_opt.rst. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:49523,access,accesses,49523,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['access'],['accesses']
Security,"ce code for psi4.driver.qcdb.molecule; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2019 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections. import numpy as np. import qcelemental as qcel. from .util import parse_dertype; from .libmintsmolecule import *; from .psiutil import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_mul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:1103,hash,hashlib,1103,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,1,['hash'],['hashlib']
Security,"ce in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_mode == 'continuous':; pass; elif db_mode == 'sow':; pass; elif db_mode == 'reap':; db_linkage = kwargs.get('linkage', None); if db_linkage is None:; raise ValidationError(""""""Database execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Database execution mode '%s' not valid."""""" % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:11474,Validat,ValidationError,11474,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,7,['Validat'],['ValidationError']
Security,"ce(122, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); PsiMod.set_local_option('SAPT', 'SAPT_LEVEL', 'MP2C'); PsiMod.print_out('\n'); banner('MP2C'); PsiMod.print_out('\n'). PsiMod.set_variable('MP2C DIMER MP2 ENERGY', e_dimer_mp2); PsiMod.set_variable('MP2C MONOMER A MP2 ENERGY', e_monomerA_mp2); PsiMod.set_variable('MP2C MONOMER B MP2 ENERGY', e_monomerB_mp2). e_sapt = PsiMod.sapt(); return e_sapt. [docs]def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """""". molecule = PsiMod.get_active_molecule(); user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); if (sapt_basis == 'dimer'):; PsiMod.set_gl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:25290,Validat,ValidationError,25290,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"ce(self). copy(self, arg0); Returns a copy of the matrix. dim(self, h); Returns the dimensions of the vector per irrep h. dimpi(self); Returns the Dimension object. from_array([name, dim1, dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_list(x). from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get_block(self, slice); Get a vector block. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. print_out(self); Prints the vector to the output file. scale(self, sc); Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set_block(self, slice, block); Set a vector block. to_array([copy, dense]); Converts a Psi4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Attributes Documentation. name¶; The name of the Vector. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. array_interface(self: psi4.core.Vector) → list¶. copy(self: psi4.core.Vector, arg0: psi4.core.Vector) → None¶; Returns a copy of the matrix. dim(self: psi4.core.Vector, h: int = 0) → int¶; Returns the dimensions of the vector per irrep h. dimpi(self: psi4.core.Vector) → psi4.core.Dimension¶; Returns the Dimension object. classmethod from_array(name='New Matrix', dim1=None, dim2=None)¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters. arr (Union[ndarray, List[ndarray]]) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (Union[List, Tuple, Dimension, None]) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.vector.html:1395,access,accessor,1395,psi4manual/1.4.0/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.vector.html,1,['access'],['accessor']
Security,"ce(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; # elif der2nd.match(str(dertype)):; # raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]; # else:; # raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); # else:; # func = func.lower(); # if func not in dashcoeff[dashlvl].keys():; # raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); # if dashparam is None:; # # (normal) case where all param taken from dashcoeff above; # pass; # else:; # # case where items in dashparam dict can override param taken from dashcoeff above; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html:3689,Validat,ValidationError,3689,psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,2,['Validat'],['ValidationError']
Security,"center of mass; self.Pshift = []; # Matrix to rotate Pmol to inertial frame; self.Protate = []. # <<< Changeable (Cfour) >>>. # Molecule; self.Cmol = molChangeable; # Vector to shift Cmol to center of mass; self.Cshift = []; # Matrix to rotate Cmol to inertial frame; self.Crotate = []; # Matrix to rotate Cmol to axis representation of Pmol; self.Cexchflip = []; # Vector to map Cmol to atom ordering of Pmol; self.Catommap = []. try:; if ((self.Pmol.nallatom() == self.Cmol.nallatom()) and \; (abs(self.Pmol.nuclear_repulsion_energy() - self.Cmol.nuclear_repulsion_energy()) < 1.0e-3)):; self.create_orientation_from_molecules(self.Pmol, self.Cmol); else:; print('qcdb.orient.__init__ debug info'); self.Pmol.print_out(); print('natom', self.Pmol.natom(), 'NRE', self.Pmol.nuclear_repulsion_energy(), 'rotor', self.Pmol.rotor_type()); self.Cmol.print_out(); print('natom', self.Cmol.natom(), 'NRE', self.Cmol.nuclear_repulsion_energy(), 'rotor', self.Cmol.rotor_type()); raise ValidationError(""""""OrientMols Molecule arguments differ fatally.""""""); except AttributeError:; raise ValidationError(""""""OrientMols must be instantiated with two qcdb.Molecule objects.""""""). def __str__(self):; text = """""" ==> qcdb OrientMols <==\n\n""""""; text += """""" natom: %d\n\n"""""" % (self.Pmol.natom()); text += """""" PNRE: %16.8f\n"""""" % (self.Pmol.nuclear_repulsion_energy()); text += """""" Pshift: %s\n"""""" % (self.Pshift); text += """""" Protate: %s\n"""""" % (self.Protate); text += """"""\n CNRE: %16.8f\n"""""" % (self.Cmol.nuclear_repulsion_energy()); text += """""" Cshift: %s\n"""""" % (self.Cshift); text += """""" Crotate: %s\n"""""" % (self.Crotate); text += """""" Cexchflip: %s\n"""""" % (self.Cexchflip); text += """""" Catommap: %s\n"""""" % (self.Catommap); return text. [docs] def create_orientation_from_molecules(self, Pmol, Cmol):; """"""Finds the shift, rotation, axis exchange, axis inversion,; and atom remapping necessary to bring the geometry of *Cmol*; into coincidence with the geometry of *Pmol*. *Pmol* and *Cmol*; must be :py:class:`qcd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html:3260,Validat,ValidationError,3260,psi4manual/1.0.0/_modules/qcdb/orient.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/orient.html,1,['Validat'],['ValidationError']
Security,"cepa_level in ['cepa(1)', 'cepa(3)']:; psi4.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif psi4.get_option('FNOCC', 'NAT_ORBS'):; psi4.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). optstash.restore(); return fnocc_wfn. [docs]def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """""". optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF', 'SCF_TYPE']; ). user_ref = psi4.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; psi4.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; psi4.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. molecule = ref_wfn.molecule(). # The DF case; if psi4.get_option('DETCI', 'MCSCF_TYPE') == 'DF':. # Do NOT set global options in general, this is a bit of a hack; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'). # The non-DF case; else:; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). # Second-order SCF requires non-symmetric density matrix support; if psi4.get_option('DETCI', 'MCSCF_SO'):; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = psi4.detci(ref_wfn). # We always would like to print a little dipole information; oeprop = psi4.OEProp(ciwfn); oeprop.set_title(name.upper()); oepr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:107956,Validat,ValidationError,107956,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"ces of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-upcast-custom-basis; test scf castup with custom basis sets. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:3168,validat,validate,3168,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['validat'],['validate']
Security,"cess this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_wavefunction_factory(name, ref_wfn, reference):; """"""Builds the correct wavefunction from the provided information; """""". if core.has_option_changed(""SCF"", ""DFT_DISPERSION_PARAMETERS""):; modified_disp_params = core.get_option(""SCF"", ""DFT_DISPERSION_PARAMETERS""); else:; modified_disp_params = None. # Figure out functional; superfunc, disp_type = dft_funcs.build_superfunctional(name, (reference in [""RKS"", ""RHF""])). # Build the wavefunction; core.prepare_options_for_module(""SCF""); if reference in [""RHF"", ""RKS""]:; wfn = core.RHF(ref_wfn, superfunc); elif reference == ""ROHF"":; wfn = core.ROHF(ref_wfn, superfunc); elif reference in [""UHF"", ""UKS""]:; wfn = core.UHF(ref_wfn, superfunc); elif reference == ""CUHF"":; wfn = core.CUHF(ref_wfn, superfunc); else:; raise ValidationError(""SCF: Unknown reference (%s) when building the Wavefunction."" % reference). if disp_type:; if isinstance(disp_type, dict):; wfn._disp_functor = empirical_dispersion.EmpericalDispersion(superfunc.name(),; disp_type[""type""], dashparams=disp_type[""params""],; citation=disp_type[""citation""], tuple_params=modified_disp_params); else:; wfn._disp_functor = empirical_dispersion.EmpericalDispersion(; disp_type[0], disp_type[1], tuple_params=modified_disp_params); wfn._disp_functor.print_out(); if (disp_type[""type""] == 'nl'):; del wfn._disp_functor. # Set the DF basis sets; if (""DF"" in core.get_global_option(""SCF_TYPE"")) or \; (core.get_option(""SCF"", ""DF_SCF_GUESS"") and (core.get_global_option(""SCF_TYPE"") == ""DIRECT"")):; aux_basis = core.BasisSet.build(wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=wfn.basisset().has_puream()); wfn.set_basisset(""DF_BASIS_SCF"", aux_basis); else:; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:26809,Validat,ValidationError,26809,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"cessed). extern = domain == ""efp"". processed = validate_and_fill_frame(; extern=extern, fix_com=fix_com, fix_orientation=fix_orientation, fix_symmetry=fix_symmetry; ); update_with_error(molinit, processed). if verbose >= 2:; print(""RETURN FROM qcel.molparse.from_arrays(domain={})"".format(domain.upper())); pprint.pprint(molinit). if not np_out:; molinit = unnp(molinit). return molinit. def validate_and_fill_units(; name=None,; units=""Angstrom"",; input_units_to_au=None,; comment=None,; provenance=None,; connectivity=None,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:12733,Validat,ValidationError,12733,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"cf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:164028,Validat,ValidationError,164028,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"ch up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - hand it off for more checks; newinput += parse_multiline_array(input_list); else:; # Nothing to do - just add the line to the string; newinput += ""%s\n"" % (input_list.pop(0)); return newinput. [docs]; def process_input(raw_input: str, print_level: int = 1) -> str:; """"""Function to preprocess *raw input*, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. Parameters; ----------; raw_input; Input in a mixture of Python and PSIthon syntax.; print_level; *raw_input* is printed to the output file unless *print_level* =0. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/inputparser.html:18198,validat,validate,18198,psi4manual/1.9.x/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/inputparser.html,2,['validat'],['validate']
Security,"ch up; while not check_parentheses_and_brackets(line, 0):; thisline = input_list.pop(0).strip(); line += thisline; return ""%s\n"" % (line). def process_multiline_arrays(inputfile):; """"""Function to find array inputs that are spread across multiple; lines and squash them into a single line. """"""; # This function takes multiline array inputs, and puts them on a single line; # Start by converting the input to a list, splitting at newlines; input_list = inputfile.split(""\n""); set_re = re.compile(r'^(\s*?)set\s+(?:([-,\w]+)\s+)?(\w+)[\s=]+\[.*', re.IGNORECASE); newinput = """"; while len(input_list):; line = input_list[0]; if set_re.match(line):; # We've found the start of a set matrix [ .... line - hand it off for more checks; newinput += parse_multiline_array(input_list); else:; # Nothing to do - just add the line to the string; newinput += ""%s\n"" % (input_list.pop(0)); return newinput. [docs]; def process_input(raw_input: str, print_level: int = 1) -> str:; """"""Function to preprocess *raw input*, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python. Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user's .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed *raw_input*. Parameters; ----------; raw_input; Input in a mixture of Python and PSIthon syntax.; print_level; *raw_input* is printed to the output file unless *print_level* =0. """"""; # Check if the infile is actually an outfile (yeah we did); psi4_id = re.compile(r'Psi4: An Open-Source Ab Initio Electronic Structure Package'); if re.search(psi4_id, raw_input):; input_lines = raw_input.split(""\n""); input_re = re.compile(r'^\s*?\=\=> Input File <\=\='); input_start = -1; for line_count in range(len(input_lines)):; line = input_lines[line_count]; if re.match(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html:18211,validat,validate,18211,psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/inputparser.html,1,['validat'],['validate']
Security,"changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Select certain irreps; if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # Does an analytic procedure exist for the requested method?; if (dertype == 2):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); optstash.restore(). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Frequency execution mode \'sow\' not valid for analytic frequency calculation.'). # TODO: check that current energy's being set to the right figure when this code is actually used; psi4.set_variable('CURRENT ENERGY', psi4.wavefunction().energy()). # TODO: return hessian matrix. elif (dertype == 1):; # Ok, we're doing frequencies by gradients; print('Performing finite difference by gradient calculations'). func = procedures['gradient'][lowername]. if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Frequency execution mode \'sow\' not yet implemented for finite difference of analytic gradient calculation.'). # Obtain list of displacements; displacements = psi4.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; psi4.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print(' %d displacements needed.' % ndisp). #print displacements to output.dat; #for n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:62236,Validat,ValidationError,62236,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Validat'],['ValidationError']
Security,class in psi4.core). UHF_NOONS (SCF). UKSFunctions (class in psi4.core). UNCP-CORRECTED 2-BODY INTERACTION ENERGY. UNFREEZE_DIHEDRALS (OPTKING). unify() (psi4.core.FISAPT method). unify_part2() (psi4.core.FISAPT method). unit() (psi4.core.SymmetryOperation method). units. ; molecule. units() (psi4.core.Molecule method). Unnormalized (psi4.core.PrimitiveType attribute). up (psi4.driver.p4util.InPsight attribute). UPDATE (DETCI). update() (psi4.core.SOMCSCF method). update_density() (psi4.core.TwoBodyAOInt method). update_geometry() (psi4.core.Molecule method). (psi4.driver.p4util.InPsight method). update_orbitals() (psi4.core.IntegralTransform method). UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() (psi4.core.HF method). Va() (psi4.core.HF method). VAL_EX_LEVEL (DETCI). valid_methods (psi4.core.OEProp attribute). validate_diis() (psi4.core.HF method). validate_options() (psi4.core.Options method). ValidationError. value (psi4.core.DerivCalcType attribute). (psi4.core.DiagonalizeOrder attribute). (psi4.core.FragmentType attribute). (psi4.core.GaussianType attribute). (psi4.core.GeometryUnits attribute). (psi4.core.PrimitiveType attribute). (psi4.core.PsiReturnType attribute). (psi4.core.SaveType attribute). value() (psi4.core.SuperFunctional method). values() (psi4.core.SuperFunctional method). variable() (in module psi4.core). (psi4.core.Wavefunction method). variables() (in module psi4.core). (psi4.core.Wavefunction method). Vb() (psi4.core.HF method). VBase (class in psi4.core). vdot() (psi4.core.CIVector method). VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector (class in psi4.core). Vector3 (class in psi4.core). vector_axpy() (psi4.driver.p4util.SolverEngine method). vector_copy() (psi4.driver.p4util.SolverEngine method). vector_dot() (psi4.core.Matrix method). (psi4.core.Vector method). (psi4.driver.p4util.SolverEngine static method). vector_multiply() (psi4.core.CIVector method). ve,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:130663,Validat,ValidationError,130663,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,1,['Validat'],['ValidationError']
Security,"cls.scalar_variable(key); elif cls.has_array_variable(key):; return cls.array_variable(key); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key, val):; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(val)); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). def _core_wavefunction_set_variable(cls, key, val):; if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(val)); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already an array variable!""); else:; cls.set_scalar_variable(key, val). def _core_del_variable(key):; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls, key):; if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables():; return {**core.scalar_var",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:19546,Validat,ValidationError,19546,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"cnt % 3):; core.print_out(""\n""). # Print CIVector information; ciwfn.print_vector(dvec, root). # True to keep the file; dvec.close_io_files(True). def prepare_sapt_molecule(sapt_dimer: core.Molecule, sapt_basis: str) -> Tuple[core.Molecule, core.Molecule, core.Molecule]:; """"""; Prepares a dimer molecule for a SAPT computations. Returns the dimer, monomerA, and monomerB.; """""". # Shifting to C1 so we need to copy the active molecule; sapt_dimer = sapt_dimer.clone(); if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(); else:; sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). nfrag = sapt_dimer.nfragments(). if nfrag == 3:; # Midbond case; if sapt_basis == 'monomer':; raise ValidationError(""SAPT basis cannot both be monomer centered and have midbond functions.""). midbond = sapt_dimer.extract_subsets(3); ztotal = 0; for n in range(midbond.natom()):; ztotal += midbond.Z(n). if ztotal > 0:; raise ValidationError(""SAPT third monomer must be a midbond function (all ghosts).""). ghosts = ([2, 3], [1, 3]); elif nfrag == 2:; # Classical dimer case; ghosts = (2, 1); else:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, ghosts[0]); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, ghosts[1]); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'); else:; raise ValidationError(""SAPT basis %s not recognized"" % sapt_basis). return (sapt_dimer, monomerA, monomerB). def sapt_empirical_dispersion(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:7322,Validat,ValidationError,7322,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['Validat'],['ValidationError']
Security,"code('ascii', 'ignore')] = v.encode('ascii', 'ignore'); else:; nouni_interface[k.encode('ascii', 'ignore')] = v. return nouni_interface. class numpy_holder(object):; """"""; Blank object, stupid. Apparently you cannot create a view directly from a dictionary; """"""; def __init__(self, interface):; self.__array_interface__ = translate_interface(interface). def _get_raw_views(self, copy=False):; """"""; Gets simple raw view of the passed in object.; """"""; ret = []; for data in self.array_interface():. # Yet another hack; if isinstance(data[""shape""], list):; data[""shape""] = tuple(data[""shape""]). if 0 in data[""shape""]:; ret.append(np.empty(shape=data[""shape""])); else:; ret.append(np.array(numpy_holder(data), copy=copy)); return ret. def _find_dim(arr, ndim):; """"""; Helper function to help deal with zero or sized arrays; """""". # Zero arrays; if (arr is None) or (arr is False):; return [0] * ndim. # Make sure this is a numpy array like thing; try:; arr.shape; except:; raise ValidationError(""Expected numpy array, found object of type '%s'"", type(arr)). if len(arr.shape) == ndim:; return [arr.shape[x] for x in range(ndim)]; else:; raise ValidationError(""Input array does not have a valid shape.""). [docs]def array_to_matrix(self, arr, name=""New Matrix"", dim1=None, dim2=None):; """"""; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters; ----------; arr : array or list of arrays; Numpy array or list of arrays to use as the data for a new core.Matrix; name : str; Name to give the new core.Matrix; dim1 : list, tuple, or core.Dimension (optional); If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 :; Same as dim1 only if using a Psi4.Dimension object. Returns; -------; matrix : :py:class:`~psi4.core.Matrix` or :py:class:`~psi4.core.Vector`; Returns the given Psi4 obj",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:2448,Validat,ValidationError,2448,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['Validat'],['ValidationError']
Security,"com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzN = re.compile(r'(?:\s*)([A-Z](?:[a-z])?)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE); xyzC = re.compile(r'(?:\s*)(\d+\.?\d*)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:3141,Validat,ValidationError,3141,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recip",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_release-1.html:11441,hash,hash,11441,psi4manual/1.4.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_release-1.html,2,['hash'],['hash']
Security,"conda label¶. Go through each active conda package off https://anaconda.org/psi4/repo. Find the most recent build set (Linux/Mac, active py versions) that psi/psi-rt/psi-dev is using; _add_ (not replace) the main label. This makes a conda install psi4 -c psi4 get everything psi4 needs. For the moment conda install psi4 -c psi4/label/dev will get the same set, until package psi4-1.4a1.dev1 gets uploaded. May help to check versions and build versions against ltrtver in conda_build_config.yaml.; This step is manual, so takes a while. (It gets checked when Psi4conda installers are built b/c that pulls from “main”, not “dev”). Build Psi4conda set¶; Installers are build using the project constructor and build binary bash scripts, one per OS per Python version. In analogy to Miniconda, they’re called Psi4Conda. They can be built anywhere (Mac can be built on Linux) and get served from vergil (cdsgroup webserver). Need a conda env with constructor and cookiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_release-1.html:11101,access,accessed,11101,psi4manual/1.4.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_release-1.html,2,['access'],['accessed']
Security,"coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requested normal coordinates not among allowed q/w/x: """""" + normco). nat = int(len(vibinfo['q'].data[:, 0]) / 3); if atom_lbl is None:; atom_lbl = [''] * nat. active = [idx for idx, trv in enumerate(vibinfo['TRV'].data) if trv == 'V']. presp = 2; colsp = 2; if shortlong:; groupby = groupby if groupby else 3; ncprec = ncprec if ncprec else 2; width = (ncprec + 4) * 3; prewidth = 24; else:; groupby = groupby if groupby else 6; ncprec = ncprec if ncprec else 4; width = ncprec + 8; prewidth = 24; if groupby == -1:; groupby = len(active). omega_str = _format_omega(vibinfo['omega'].data, decimals=prec). text = ''; for row in grouper(active, groupby):. text += """"""\n{:{presp}}{:{prewidth}}"""""".format('', 'Vibration', prewidth=prewidth, presp=presp); for vib in row:; if vib is None:; # ran out of vibrations in this row; break; text += """"""{:^{width}d}{:{colsp}}"""""".format(vib + 1, '', width=width, colsp=colsp); text += '\n'. text += """"""{:{presp}}{:{prewidth}}"""""".format('', 'Freq [cm^-1]', prewidth=pre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html:26306,Validat,ValidationError,26306,psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,12,['Validat'],['ValidationError']
Security,"core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:92037,Validat,ValidationError,92037,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except:; raise PastureRequiredError(""RUN_CCTRANSORT""). while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:90904,Validat,ValidationError,90904,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"core.Dimension(irreps, name); for i in range(irreps):; ret[i] = dims[i]; return ret. def _dimension_to_tuple(self: core.Dimension) -> Tuple[int]:; """"""Serializes :class:`~psi4.core.Dimension` to a tuple."""""". if isinstance(self, (tuple, list)):; return tuple(self). irreps = self.n(); ret = []; for i in range(irreps):; ret.append(self[i]); return tuple(ret). def _dimension_iter(dim) -> Iterator[int]:; """"""; Provides an iterator class for the Dimension object. Example; -------; >>> dim = psi4.core.Dimension(...); >>> list(dim). """"""; for i in range(dim.n()):; yield dim[i]. # Dimension attributes; core.Dimension.from_list = _dimension_from_list; core.Dimension.to_tuple = _dimension_to_tuple; core.Dimension.__iter__ = _dimension_iter. # General functions for NumPy array manipulation. [docs]; def block_diagonal_array(*args: List[np.ndarray]) -> np.ndarray:; """"""; Convert square NumPy array to a single block diagonal array. Mimic of SciPy's :func:`scipy.linalg.block_diag`. Parameters; ----------; args; Arbitrary number of square arrays. """""". # Validate the input matrices.; dim = 0; for matrix in args:; try:; shape = matrix.shape; dim += shape[0]; except (AttributeError, TypeError):; raise ValidationError(""Cannot construct block diagonal from non-arrays.""); if len(shape) != 2:; raise ValidationError(""Cannot construct block diagonal from non-2D arrays.""); if shape[0] != shape[1]:; raise ValidationError(""Cannot construct block diagonal from non-square arrays.""). # If this is too slow, try a sparse matrix?; block_diag = np.zeros((dim, dim)); start = 0; for matrix in args:; next_block = slice(start, start + matrix.shape[0]); block_diag[next_block, next_block] = matrix; start += matrix.shape[0]. return block_diag. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.p4util.numpy_helper. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/numpy_helper.html:17582,Validat,Validate,17582,psi4manual/master/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/p4util/numpy_helper.html,4,['Validat'],"['Validate', 'ValidationError']"
Security,"core.Dispersion, arg0: psi4.core.Molecule) → str¶; docstring. print_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule) → str¶; docstring. print_out(self: psi4.core.Dispersion) → None¶; docstring. s6(self: psi4.core.Dispersion) → float¶; docstring. s8(self: psi4.core.Dispersion) → float¶; docstring. set_bibtex(self: psi4.core.Dispersion, arg0: str) → None¶; Set the BibTeX key for the literature reference. set_citation(self: psi4.core.Dispersion, arg0: str) → None¶; docstring. set_description(self: psi4.core.Dispersion, arg0: str) → None¶; docstring. set_name(self: psi4.core.Dispersion, arg0: str) → None¶; docstring. sr6(self: psi4.core.Dispersion) → float¶; docstring. class psi4.core.ERI¶; Bases: psi4.core.TwoBodyAOInt; Computes normal two electron reuplsion integrals. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; Compute ERIs between 4 shells. class psi4.core.ESPPropCalc¶; Bases: psi4.core.Prop; ESPPropCalc gives access to routines calculating the ESP on a grid. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi::Matrix) → psi::Vector¶; Computes ESP on specified grid Nx3 (as SharedMatrix). class psi4.core.ElectricFieldInt¶; Bases: psi4.core.OneBodyAOInt; Computes electric field integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.ElectrostaticInt¶; Bases: psi4.core.OneBodyAOInt; Computes electrostatic integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:82141,access,access,82141,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['access'],['access']
Security,"core.Molecule, core.Molecule]:; """"""; Prepares a dimer molecule for a SAPT computations. Returns the dimer, monomerA, and monomerB.; """""". # Shifting to C1 so we need to copy the active molecule; sapt_dimer = sapt_dimer.clone(); if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(); else:; sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). nfrag = sapt_dimer.nfragments(). if nfrag == 3:; # Midbond case; if sapt_basis == 'monomer':; raise ValidationError(""SAPT basis cannot both be monomer centered and have midbond functions.""). midbond = sapt_dimer.extract_subsets(3); ztotal = 0; for n in range(midbond.natom()):; ztotal += midbond.Z(n). if ztotal > 0:; raise ValidationError(""SAPT third monomer must be a midbond function (all ghosts).""). ghosts = ([2, 3], [1, 3]); elif nfrag == 2:; # Classical dimer case; ghosts = (2, 1); else:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, ghosts[0]); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, ghosts[1]); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'); else:; raise ValidationError(""SAPT basis %s not recognized"" % sapt_basis). return (sapt_dimer, monomerA, monomerB). def sapt_empirical_dispersion(name, dimer_wfn, **kwargs):; sapt_dimer = dimer_wfn.molecule(); sapt_dimer, monomerA, monomerB = prepare_sapt_molecule(sapt_dimer, ""dimer""); disp_name = name.split(""-"")[1]. # Get the names right between SAPT0 and FISAPT0; saptd_name = name.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html:7546,Validat,ValidationError,7546,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc_util.html,3,['Validat'],['ValidationError']
Security,"core.print_out("""""" LO-zeta (%s)"""""" % str(zLO)); core.print_out("""""" LO-zeta Data""""""); valueLO.print_out(); core.print_out("""""" HI-zeta (%s)"""""" % str(zHI)); core.print_out("""""" HI-zeta Data""""""); valueHI.print_out(); core.print_out("""""" Extrapolated Data:\n""""""); value.print_out(); core.print_out("""""" Alpha (exponent) Value: %16.8f\n"""""" % (alpha)); core.print_out("""""" Beta Data:\n""""""); beta.print_out(). return value. else:; raise ValidationError(""scf_xtpl_truhlar_2: datatype is not recognized '%s'."" % type(valueLO)). def scf_xtpl_karton_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`.; Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333, DOI: 10.1007/s00214-005-0028-6. .. math:: E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3. """""". if type(valueLO) != type(valueHI):; raise ValidationError(""scf_xtpl_karton_2: Inputs must be of the same datatype! (%s, %s)""; % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 6.30. beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), zeta_val2sym[zLO].upper(), zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:11636,Validat,ValidationError,11636,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') == '':; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n"");; if banner:; core.print_out("" "" + banner.center(58));; if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58));; ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE')); core.set_legacy_wavefunction(ref_wfn). # Compute dftd3; if ""_disp_functor"" in dir(ref_wfn):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variable(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # broken clean-up; if do_broken:; raise ValidationError(""Broken Symmetry computations are temporarily disabled.""); scf_molecule.set_multiplicity(1); core.set_local_option('SCF', 'GUESS', 'READ'); core.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); core.print_out('\n'). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). # Set to read and project, and reset bases to final ones; optstash2.restore(); core.set_local_option('SCF', 'GUESS', 'READ'). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'). # EFP preparation; efp = core.get_active_efp(); if efp.nfragments() > 0:; core.set_legacy_molecule(scf_molecule); core.set_global_option('QMEFP', True) # apt to go haywire if set locally to efp; core.efp_set_options(); efp.set_qm_atoms(); efp.print_out(). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:34460,Validat,ValidationError,34460,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:127927,Validat,ValidationError,127927,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"core.set_variable(""CURRENT CORRELATION ENERGY"", cemp4). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_NO_SINGLES']). core.set_local_option('FNOCC', 'RUN_CEPA', True); core.set_local_option('FNOCC', 'USE_DF_INTS', False). # what type of cepa?; if name in ['lccd', 'fno-lccd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', True); elif name in ['cepa(0)', 'fno-cepa(0)', 'lccsd', 'fno-lccsd']:; cepa_level = 'cepa(0)'; core.set_local_option('FNOCC', 'CEPA_NO_SINGLES', False); elif name in ['cepa(1)', 'fno-cepa(1)']:; cepa_level = 'cepa(1)'; elif name in ['cepa(3)', 'fno-cepa(3)']:; cepa_level = 'cepa(3)'; elif name in ['acpf', 'fno-acpf']:; cepa_level = 'acpf'; elif name in ['aqcc', 'fno-aqcc']:; cepa_level = 'aqcc'; elif name in ['cisd', 'fno-cisd']:; cepa_level = 'cisd'; else:; raise ValidationError(""""""Error: %s not implemented\n"""""" % name). core.set_local_option('FNOCC', 'CEPA_LEVEL', cepa_level.upper()). if name in ['fno-lccd', 'fno-lccsd', 'fno-cepa(0)', 'fno-cepa(1)', 'fno-cepa(3)',; 'fno-acpf', 'fno-aqcc', 'fno-cisd']:; core.set_local_option('FNOCC', 'NAT_ORBS', True). # throw an exception for open-shells; if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(""""""Error: %s requires 'reference rhf'."""""" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_option('FNOCC', 'USE_DF_INTS') == False:; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn); else:; scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:122370,Validat,ValidationError,122370,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(); user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False); ptype = kwargs.pop('ptype', None). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis). ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:58158,Sanitiz,Sanitize,58158,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,1,['Sanitiz'],['Sanitize']
Security,"cportal.FractalClient | None). get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into FiniteDifference-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. undisplaced molecule; compute basis if simple, else dummy basis def2-svp; e/g/h member data; QCVariables; module. client (qcportal.FractalClient | None). Returns:. ret – Gradient or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=None)[source]¶; Return results as FiniteDifference-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None). Return type:; AtomicResult. plan()[source]¶. validator set_driver  »  driver[source]¶. validator set_molecule  »  molecule[source]¶. table of contents. Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Visualization of Normal Modes; Molden Interface Keywords; NORMAL_MODES_WRITE; WRITER_FILE_LABEL. psi4.driver.qcdb.vib Module; Functions. API; FiniteDifferenceComputer; FiniteDifferenceComputer.driver; FiniteDifferenceComputer.findifrec; FiniteDifferenceComputer.metameta; FiniteDifferenceComputer.method; FiniteDifferenceComputer.molecule; FiniteDifferenceComputer.task_list; FiniteDifferenceComputer.computer; FiniteDifferenceComputer.build_tasks(); FiniteDifferenceComputer.compute(); FiniteDifferenceComputer.get_psi_results(); FiniteDifferenceComputer.get_results(); FiniteDifferenceComputer.plan(); FiniteDifferenceComputer.set_driver; FiniteDifferenceComputer.set_molecule. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Harmonic Vibrational Analysis ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:10764,validat,validator,10764,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,1,['validat'],['validator']
Security,"cription"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ]; }; }; }. Fields:. basis (str); cbsrec (List[Dict[str, Any]]); compute_list (List[Dict[str, Any]]); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); metadata (Any); metameta (Dict[str, Any]); method (str); molecule (Any); results_list (List[Any]); task_list (List[psi4.driver.task_base.AtomicComputer]); trove (List[Dict[str, Any]]); verbose (int). Validators:. set_molecule » molecule. field basis: str = '(auto)'¶. field cbsrec: List[Dict[str, Any]] = []¶. field compute_list: List[Dict[str, Any]] = []¶. field driver: DriverEnum [Required]¶. field keywords: Dict[str, Any] = {}¶. field metadata: Any = None¶. field metameta: Dict[str, Any] = {}¶. field method: str = '(auto)'¶. field molecule: Any = None¶. Validated by:. set_molecule. field results_list: List[Any] = []¶. field task_list: List[AtomicComputer] = []¶. field trove: List[Dict[str, Any]] = []¶. field verbose: int = 1¶. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶. Parameters:; client (Optional[FractalClient]) – . get_psi_results(return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:; return_wfn (bool) – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. molecule; dummy basis, def2-svp; e/g/h member data; QCVariables; module if simple. Return type:; Union[float, Matrix, Tuple[Union[float, Matrix], Wavefunction]]. Returns:. ret – Energy, gradient, or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. get_results(client=None)[source]¶; Return results as Composit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:36653,Validat,Validated,36653,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,1,['Validat'],['Validated']
Security,"cription"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ]; }; }; }. Fields:. basis (str); cbsrec (List[Dict[str, Any]]); compute_list (List[Dict[str, Any]]); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); metadata (Any); metameta (Dict[str, Any]); method (str); molecule (Any); results_list (List[Any]); task_list (List[psi4.driver.task_base.AtomicComputer]); trove (List[Dict[str, Any]]); verbose (int). Validators:. set_molecule » molecule. field basis: str = '(auto)'¶. field cbsrec: List[Dict[str, Any]] = []¶. field compute_list: List[Dict[str, Any]] = []¶. field driver: DriverEnum [Required]¶. field keywords: Dict[str, Any] = {}¶. field metadata: Any = None¶. field metameta: Dict[str, Any] = {}¶. field method: str = '(auto)'¶. field molecule: Any = None¶. Validated by:. set_molecule. field results_list: List[Any] = []¶. field task_list: List[AtomicComputer] = []¶. field trove: List[Dict[str, Any]] = []¶. field verbose: int = 1¶. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶. Parameters:; client (qcportal.FractalClient | None) – . get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. molecule; dummy basis, def2-svp; e/g/h member data; QCVariables; module if simple. client (qcportal.FractalClient | None) – . Returns:. ret – Energy, gradient, or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(cl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cbs.html:39460,Validat,Validated,39460,psi4manual/1.8.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cbs.html,2,['Validat'],['Validated']
Security,"cription"": "":py:class:`~qcelemental.models.AtomicResult` return.""; },; ""result_id"": {; ""title"": ""Result Id"",; ""description"": ""The optional ID for the computation."",; ""type"": ""string""; }; },; ""required"": [; ""molecule"",; ""basis"",; ""method"",; ""driver""; ]; }; }; }. Fields:. basis (str); cbsrec (List[Dict[str, Any]]); compute_list (List[Dict[str, Any]]); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); metadata (Any); metameta (Dict[str, Any]); method (str); molecule (Any); results_list (List[Any]); task_list (List[psi4.driver.task_base.AtomicComputer]); trove (List[Dict[str, Any]]); verbose (int). Validators:. set_molecule » molecule. field basis: str = '(auto)'¶. field cbsrec: List[Dict[str, Any]] = []¶. field compute_list: List[Dict[str, Any]] = []¶. field driver: DriverEnum [Required]¶. field keywords: Dict[str, Any] = {}¶. field metadata: Any = None¶. field metameta: Dict[str, Any] = {}¶. field method: str = '(auto)'¶. field molecule: Any = None¶. Validated by:. set_molecule. field results_list: List[Any] = []¶. field task_list: List[AtomicComputer] = []¶. field trove: List[Dict[str, Any]] = []¶. field verbose: int = 1¶. build_tasks(obj, **kwargs)[source]¶. compute(client=None)[source]¶. Parameters:; client (qcportal.FractalClient | None). get_psi_results(client=None, *, return_wfn=False)[source]¶; Called by driver to assemble results into Composite-flavored QCSchema,; then reshape and return them in the customary Psi4 driver interface: (e/g/h, wfn). Parameters:. return_wfn – Whether to additionally return the dummy Wavefunction; calculation result as the second element of a tuple. Contents are:. molecule; dummy basis, def2-svp; e/g/h member data; QCVariables; module if simple. client (qcportal.FractalClient | None). Returns:. ret – Energy, gradient, or Hessian according to self.driver.; wfn – Wavefunction described above when return_wfn specified. Return type:; float | Matrix | Tuple[float | Matrix, Wavefunction]. get_results(client=N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cbs.html:39499,Validat,Validated,39499,psi4manual/master/cbs.html,https://psicode.org,https://psicode.org/psi4manual/master/cbs.html,1,['Validat'],['Validated']
Security,"cs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'Angstrom' or 'Bohr'.""""""). # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au * self.atoms[atom].compute()[2]. [docs] def xyz(self, atom, posn=None):; """"""Returns a Vector3 with x, y, z position of atom (0-indexed); in Bohr or coordinate at *posn*. >>> print H2OH2O.xyz(4); [3.175492014248769, -0.7062681346308132, -1.4334725450878665]. """"""; temp = sca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:5651,Validat,ValidationError,5651,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"cs] def charge_specified(self):; """"""Whether the charge was given by the user. >>> print H2OH2O.charge_specified(); True. """"""; return self.PYcharge_specified. [docs] def multiplicity(self):; """"""Get the multiplicity (defined as 2Ms + 1). >>> print H2OH2O.multiplicity(). """"""; return self.PYmultiplicity. [docs] def set_multiplicity(self, mult):; """"""Sets the multiplicity (defined as 2Ms + 1). >>> H2OH2O.set_multiplicity(3). """"""; self.PYmultiplicity_specified = True; self.PYmultiplicity = mult. [docs] def multiplicity_specified(self):; """"""Whether the multiplicity was given by the user. >>> print H2OH2O.multiplicity_specified(); True. """"""; return self.PYmultiplicity_specified. [docs] def units(self):; """"""Gets the geometry units. >>> print H2OH2O.units(); Angstrom. """"""; return self.PYunits. [docs] def set_units(self, units):; """"""Sets the geometry units. >>> H2OH2O.set_units('Angstom'). """"""; if units == 'Angstrom' or units == 'Bohr':; self.PYunits = units; else:; raise ValidationError(""""""Argument to Molecule::set_units must be 'Angstrom' or 'Bohr'.""""""). [docs] def has_zmatrix(self):; """"""Gets the presence of any zmatrix entry. >>> print H2OH2O.has_zmatrix(); False. """"""; return self.zmat. [docs] def set_has_zmatrix(self, tf):; """"""Sets the presence of any zmatrix entry. >>> H2OH2O.set_has_zmatrix(True). """"""; self.zmat = tf. # <<< Simple Methods for Coordinates >>>. [docs] def Z(self, atom):; """"""Nuclear charge of atom (0-indexed). >>> print H2OH2O.Z(4); 1. """"""; return self.atoms[atom].Z(). [docs] def x(self, atom):; """"""x position of atom (0-indexed) in Bohr. >>> print H2OH2O.x(4); 3.17549201425. """"""; return self.input_units_to_au * self.atoms[atom].compute()[0]. [docs] def y(self, atom):; """"""y position of atom (0-indexed) in Bohr. >>> print H2OH2O.y(4); -0.706268134631. """"""; return self.input_units_to_au * self.atoms[atom].compute()[1]. [docs] def z(self, atom):; """"""z position of atom (0-indexed) in Bohr. >>> print H2OH2O.z(4); -1.43347254509. """"""; return self.input_units_to_au ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:6600,Validat,ValidationError,6600,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"cs]; def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html:2482,access,access,2482,psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/wrapper_database.html,3,['access'],['access']
Security,"ct(mol, ""DF_BASIS_MP2"", """", ""RIFIT"", ""6-31+G(d,p)"")``. """"""; #print type(mol), type(key), type(target), type(fitrole), type(other); orbonly = True if (fitrole == 'BASIS' and other is None) else False; if orbonly:; orb = target; aux = None; else:; orb = other; aux = target. #print 'BasisSet::pyconstructP', 'key =', key, 'aux =', aux, 'fitrole =', fitrole, 'orb =', orb, 'orbonly =', orbonly #, mol. # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # Apply requested basis set(s) to the molecule; # - basstrings only a temp object so using fitrole as dict key instead of psi4 keyword; # - error checking not needed since C-side already checked for NULL ptr; mol.clear_basis_all_atoms(); # TODO now need to clear shells, too; basstrings = defaultdict(dict); if orb is None or orb == '':; raise ValidationError(""""""Orbital basis argument must not be empty.""""""); elif callable(orb):; basstrings['BASIS'] = orb(mol, 'BASIS'); elif isinstance(orb, basestring):; mol.set_basis_all_atoms(orb, role='BASIS'); else:; raise ValidationError(""""""Orbital basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). if aux is None or aux == '':; pass; elif callable(aux):; basstrings[fitrole] = aux(mol, fitrole); elif isinstance(aux, basestring):; mol.set_basis_all_atoms(aux, role=fitrole); else:; raise ValidationError(""""""Auxiliary basis argument must be function that applies basis sets to Molecule or a string of the basis to be applied to all atoms.""""""). # Not like we're ever using a non-G94 format; parser = Gaussian94BasisSetParser(). # Molecule and parser prepped, call the constructor; bs, msg = BasisSet.construct(parser, mol, fitrole, None if fitrole == 'BASIS' else fitrole, basstrings[fitrole]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:19569,Validat,ValidationError,19569,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['Validat'],['ValidationError']
Security,"ction Energy', nocp_interaction_energy). for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; core.set_variable(var_key, nocp_energy_body_dict[n] - nocp_energy_body_dict[1]). # Compute vmfc energy and ptype; if do_vmfc:; _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)""); vmfc_interaction_energy = vmfc_energy_body_dict[max_nbody] - vmfc_energy_body_dict[1]; core.set_variable('Valiron-Mayer Function Couterpoise Total Energy', vmfc_energy_body_dict[max_nbody]); core.set_variable('Valiron-Mayer Function Couterpoise Interaction Energy', vmfc_interaction_energy). for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; core.set_variable(var_key, vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]). if return_method == 'cp':; ptype_body_dict = cp_ptype_body_dict; energy_body_dict = cp_energy_body_dict; elif return_method == 'nocp':; ptype_body_dict = nocp_ptype_body_dict; energy_body_dict = nocp_energy_body_dict; elif return_method == 'vmfc':; ptype_body_dict = vmfc_ptype_body_dict; energy_body_dict = vmfc_energy_body_dict; else:; raise ValidationError(""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). # Figure out and build return types; if return_total_data:; ret_energy = energy_body_dict[max_nbody]; else:; ret_energy = energy_body_dict[max_nbody]; ret_energy -= energy_body_dict[1]. if ptype != 'energy':; if return_total_data:; np_final_ptype = ptype_body_dict[max_nbody].copy(); else:; np_final_ptype = ptype_body_dict[max_nbody].copy(); np_final_ptype -= ptype_body_dict[1]. ret_ptype = core.Matrix.from_array(np_final_ptype); else:; ret_ptype = ret_energy. # Build and set a wavefunction; wfn = core.Wavefunction.build(molecule, 'sto-3g'); wfn.nbody_energy = energies_dict; wfn.nbody_ptype = ptype_dict; wfn.nbody_body_energy = energy_body_dict; wfn.nbody_body_ptype = ptype_body_dict. if ptype == 'gradient':; wfn.set_gradient(ret_pt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html:15220,Validat,ValidationError,15220,psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"ction Energy', nocp_interaction_energy). for n in nbody_range[1:]:; var_key = 'NOCP-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, nocp_energy_body_dict[n] - nocp_energy_body_dict[1]). # Compute vmfc energy and ptype; if do_vmfc:; _print_nbody_energy(vmfc_energy_body_dict, ""Valiron-Mayer Function Couterpoise (VMFC)""); vmfc_interaction_energy = vmfc_energy_body_dict[max_nbody] - vmfc_energy_body_dict[1]; psi4.set_variable('Valiron-Mayer Function Couterpoise Total Energy', vmfc_energy_body_dict[max_nbody]); psi4.set_variable('Valiron-Mayer Function Couterpoise Interaction Energy', vmfc_interaction_energy). for n in nbody_range[1:]:; var_key = 'VMFC-CORRECTED %d-BODY INTERACTION ENERGY' % n; psi4.set_variable(var_key, vmfc_energy_body_dict[n] - vmfc_energy_body_dict[1]). if return_method == 'cp':; ptype_body_dict = cp_ptype_body_dict; energy_body_dict = cp_energy_body_dict; elif return_method == 'nocp':; ptype_body_dict = nocp_ptype_body_dict; energy_body_dict = nocp_energy_body_dict; elif return_method == 'vmfc':; ptype_body_dict = vmfc_ptype_body_dict; energy_body_dict = vmfc_energy_body_dict; else:; raise ValidationError(""N-Body Wrapper: Invalid return type. Should never be here, please post this error on github.""). # Figure out and build return types; if return_total_data:; ret_energy = energy_body_dict[max_nbody]; else:; ret_energy = energy_body_dict[max_nbody]; ret_energy -= energy_body_dict[1]. if ptype != 'energy':; if return_total_data:; np_final_ptype = ptype_body_dict[max_nbody].copy(); else:; np_final_ptype = ptype_body_dict[max_nbody].copy(); np_final_ptype -= ptype_body_dict[1]. ret_ptype = psi4.Matrix.from_array(np_final_ptype); else:; ret_ptype = ret_energy. # Build and set a wavefunction; wfn = psi4.new_wavefunction(molecule, 'sto-3g'); wfn.nbody_energy = energies_dict; wfn.nbody_ptype = ptype_dict; wfn.nbody_body_energy = energy_body_dict; wfn.nbody_body_ptype = ptype_body_dict. if ptype == 'gradient':; wfn.set_gradient(ret_ptyp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html:15157,Validat,ValidationError,15157,psi4manual/1.0.0/_modules/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"ction method, [1], [2]. append() psi4.core.BSVec method, [1], [2]. psi4.core.VectorMatrix method, [1], [2]. apply_denominator() psi4.core.Matrix method, [1], [2]. approx_solve() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. AQCCCORRELATIONENERGY. AQCCDIPOLEX. AQCCDIPOLEY. AQCCDIPOLEZ. AQCCQUADRUPOLEXX. AQCCQUADRUPOLEXY. AQCCQUADRUPOLEXZ. AQCCQUADRUPOLEYY. AQCCQUADRUPOLEYZ. AQCCQUADRUPOLEZZ. AQCCTOTALENERGY. arbitrary-order coupled-cluster theory. ; CI. arbitrary-order perturbation theory. ; CI. architectures. args psi4.driver.ConvergenceError attribute. psi4.driver.CSXError attribute. psi4.driver.Dftd3Error attribute. psi4.driver.ManagedMethodError attribute. psi4.driver.OptimizationConvergenceError attribute. psi4.driver.ParsingError attribute. psi4.driver.PastureRequiredError attribute. psi4.driver.PsiException attribute. psi4.driver.PsiImportError attribute. psi4.driver.TestComparisonError attribute. psi4.driver.ValidationError attribute. array_interface() psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. array_to_matrix() in module psi4.driver.p4util.numpy_helper. arrays() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Ascending psi4.core.DiagonalizeOrder attribute, [1], [2]. atom_at_position() psi4.core.Molecule method, [1], [2]. atomic_displacements() in module psi4.core, [1]. atomic_point_charges() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. aux_overlap() psi4.core.FDDS_Dispersion method, [1], [2]. AUXILIARY_BOND_FACTOR (OPTKING). AVG_STATES (DETCI). AVG_WEIGHTS (DETCI)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:7609,Validat,ValidationError,7609,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['Validat'],['ValidationError']
Security,"ction printing; and CMake variables is purely formal. In practice, they get run; together and linked as ${LAPACK_LIBRARIES} ${BLAS_LIBRARIES}.; Sometimes the CMake’s library search capabilites falter at SONAMEs; (e.g., libblas.so.3 vs. libblas.so), extensions (static; vs. dynamic), or suffixes (e.g., libacml_mp.so vs.; libacml.so). The developers would be interested in hearing; of such problems to expand the math detection capabilities. The; immediate solution, however, is to form symlinks between the; library names that exist and the names expected. Consult file; psi4/cmake/math/MathLibs.cmake for the library patterns being; sought.; The BLAS/LAPACK interface is standardized, so only libraries, not; headers, need to be detected. The exception is MKL, where the mkl.h; header defines additional functionality; it must be located to use; BLAS threading. How to configure Python for building Psi4¶; Role and Dependencies. Role — In PSI4, Python allows the core compiled C++ code to; be flexibly accessed for manipulation and extension in an interpreted; language.; Downstream Dependencies — PSI4 \(\Leftarrow\) Python Interpreter. CMake Variables. PYTHON_EXECUTABLE — specify name or full path to Python interpreter.; PYTHON_LIBRARY — specify path to Python library.; PYTHON_INCLUDE_DIR — specify directory of Python headers. Contains Python.h. Examples. Build with detected Python from PATH. >>> cmake. Build with specific Python. >>> cmake -DPYTHON_EXECUTABLE=/path/to/interp/python2.7. Build with full Python specification to root directory ${PFXC}. >>> cmake -DPYTHON_EXECUTABLE=""${PFXC}/bin/python"" \; -DPYTHON_LIBRARY=""${PFXC}/lib/libpython3.5m.so"" \; -DPYTHON_INCLUDE_DIR=""${PFXC}/include/python3.5m"". What Python is Psi4 running¶; The Python detected at build-time is embedded into the PSI4; executable. That is, the top line of bin/psi4 is something like; #!/path/to/miniconda/envs/p4deps/bin/python3.5, and that’s the Python; through which PSI4 is running, rather than the Python of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:34397,access,accessed,34397,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,4,['access'],['accessed']
Security,"ction printing; and CMake variables is purely formal. In practice, they get run; together and linked as ${LAPACK_LIBRARIES} ${BLAS_LIBRARIES}.; Sometimes the CMake’s library search capabilites falter at SONAMEs; (e.g., libblas.so.3 vs. libblas.so), extensions (static; vs. dynamic), or suffixes (e.g., libacml_mp.so vs.; libacml.so). The developers would be interested in hearing; of such problems to expand the math detection capabilities. The; immediate solution, however, is to form symlinks between the; library names that exist and the names expected. Consult file; psi4/cmake/math/MathLibs.cmake for the library patterns being; sought.; The BLAS/LAPACK interface is standardized, so only libraries, not; headers, need to be detected. The exception is MKL, where the mkl.h; header defines additional functionality; it must be located to use; BLAS threading. How to configure Python for building Psi4¶; Role and Dependencies. Role — In PSI4, Python allows the core compiled C++ code to; be flexibly accessed for manipulation and extension in an interpreted; language.; Downstream Dependencies — PSI4 \(\Leftarrow\) Python Interpreter. CMake Variables. PYTHON_EXECUTABLE — specify name or full path to Python interpreter.; PYTHON_LIBRARY — specify path to Python library.; PYTHON_INCLUDE_DIR — specify directory of Python headers. Contains Python.h. Examples. Build with detected Python from PATH. >>> cmake. Build with specific Python. >>> cmake -DPYTHON_EXECUTABLE=/path/to/interp/python3.6. Build with full Python specification to root directory ${PFXC}. >>> cmake -DPYTHON_EXECUTABLE=""${PFXC}/bin/python"" \; -DPYTHON_LIBRARY=""${PFXC}/lib/libpython3.5m.so"" \; -DPYTHON_INCLUDE_DIR=""${PFXC}/include/python3.5m"". What Python is Psi4 running¶; The Python detected at build-time is embedded into the PSI4; executable. That is, the top line of bin/psi4 is something like; #!/path/to/miniconda/envs/p4deps/bin/python3.5, and that’s the Python; through which PSI4 is running, rather than the Python of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:43744,access,accessed,43744,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['access'],['accessed']
Security,"ction printing; and CMake variables is purely formal. In practice, they get run; together and linked as ${LAPACK_LIBRARIES} ${BLAS_LIBRARIES}.; Sometimes the CMake’s library search capabilites falter at SONAMEs; (e.g., libblas.so.3 vs. libblas.so), extensions (static; vs. dynamic), or suffixes (e.g., libacml_mp.so vs.; libacml.so). The developers would be interested in hearing; of such problems to expand the math detection capabilities. The; immediate solution, however, is to form symlinks between the; library names that exist and the names expected. Consult file; psi4/cmake/math/MathLibs.cmake for the library patterns being; sought.; The BLAS/LAPACK interface is standardized, so only libraries, not; headers, need to be detected. The exception is MKL, where the mkl.h; header defines additional functionality; it must be located to use; BLAS threading. How to configure Python for building Psi4¶; Role and Dependencies. Role — In PSI4, Python allows the core compiled C++ code to; be flexibly accessed for manipulation and extension in an interpreted; language.; Downstream Dependencies — PSI4 \(\Leftarrow\) Python Interpreter. CMake Variables; Note that in v1.4, PSI4 switched from Numpy-written CMake Python; detection to new CMake-written CMake Python detection. Usually only; Python_EXECUTABLE is now needed to hint Python’s location. See; https://cmake.org/cmake/help/latest/module/FindPython.html for full; guidance. Python_EXECUTABLE — specify name or full path to Python interpreter.; Python_LIBRARY — specify path to Python library.; Python_INCLUDE_DIR — specify directory of Python headers. Contains Python.h. Examples. Build with detected Python from PATH. >>> cmake. Build with specific Python. >>> cmake -DPython_EXECUTABLE=/path/to/interp/python3.9. Build with full Python specification to root directory ${PFXC}. >>> cmake -DPython_EXECUTABLE=""${PFXC}/bin/python"" \; -DPython_LIBRARY=""${PFXC}/lib/libpython3.9.so"" \; -DPython_INCLUDE_DIR=""${PFXC}/include/python3.9"". What Py",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:48367,access,accessed,48367,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,9,['access'],['accessed']
Security,"ctionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; import json; import os; import re; import shutil; import sys; from typing import Union. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *; from psi4.driver.mdi_engine import mdi_run. # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". derivatives = {""gradient"": 1, ""hessian"": 2}. if ptype not in derivatives:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to find the highest derivative; if user_dertype is None:; if (ptype == 'hessian') and (method_name in procedures['hessian']):; dertype = 2; # Will need special logic if we ever have managed Hessians; elif method_name in procedures['gradient']:; dertype = 1; if procedures['gradient'][method_name].__name__.startswith('select_'):; try:; procedures['gradient'][method_name](method_name, probe=True); except ManagedMethodError:; dertype = 0; elif method_name in procedures['energy']:; dertype = 0; else:; # Quick sanity check. Only *should* be able to be None or int, but hey, kids today...; if not isinstance(user_dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:2207,Validat,ValidationError,2207,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"ctions should call; this function, common exceptions being when multireference; SCF is needed or when restarting from converged SCF. """""". if post_scf:; name = ""scf"". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['INTS_TOLERANCE'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'ORBITALS_WRITE'],; ['SCF_TYPE'], # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ). # Make sure we grab the correctly scoped integral threshold for SCF; core.set_global_option('INTS_TOLERANCE', core.get_option('SCF', 'INTS_TOLERANCE')). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', core.get_active_molecule()); read_orbitals = core.get_option('SCF', 'GUESS') == ""READ""; do_timer = kwargs.pop(""do_timer"", True); ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is not None:; raise ValidationError(""Cannot seed an SCF calculation with a reference wavefunction ('ref_wfn' kwarg).""). # decide if we keep the checkpoint file; _chkfile = kwargs.get('write_orbitals', True); write_checkpoint_file = False; if isinstance(_chkfile, str):; write_checkpoint_file = True; filename = kwargs.get('write_orbitals'); core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif _chkfile is True:; write_checkpoint_file = True. # Continuum solvation needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM"") or core.get_option(""SCF"", ""DDX""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM or DDX continuum solvation does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE"") or ""external_potentials"" in kwargs:; c1_molecule = scf_molecule.clone(); if getattr(scf_m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:46135,Validat,ValidationError,46135,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"ctions should call; this function, common exceptions being when multireference; SCF is needed or when restarting from converged SCF. """""". if post_scf:; name = ""scf"". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['INTS_TOLERANCE'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'ORBITALS_WRITE'],; ['SCF_TYPE'], # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ). # Make sure we grab the correctly scoped integral threshold for SCF; core.set_global_option('INTS_TOLERANCE', core.get_option('SCF', 'INTS_TOLERANCE')). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', core.get_active_molecule()); read_orbitals = core.get_option('SCF', 'GUESS') == ""READ""; do_timer = kwargs.pop(""do_timer"", True); ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is not None:; raise ValidationError(""Cannot seed an SCF calculation with a reference wavefunction ('ref_wfn' kwarg).""). # decide if we keep the checkpoint file; _chkfile = kwargs.get('write_orbitals', True); write_checkpoint_file = False; if isinstance(_chkfile, str):; write_checkpoint_file = True; filename = kwargs.get('write_orbitals'); core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif _chkfile is True:; write_checkpoint_file = True. # Continuum solvation needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM"") or core.get_option(""SCF"", ""DDX""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM or DDX continuum solvation does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE""):; c1_molecule = scf_molecule.clone(); if getattr(scf_molecule, ""_initial_cartesian"", None",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:45837,Validat,ValidationError,45837,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"ctive_molecule()); molecule.update_geometry(); molstr = molecule.create_psi4_string_from_molecule(); natom = molecule.natom(). # Establish method for correlation energy; cbs_corl_wfn = kwargs.pop('corl_wfn', '').lower(); if cbs_corl_wfn:; do_corl = True. # Establish method for reference energy; if do_corl and cbs_corl_wfn.startswith('c4-'):; default_scf = 'c4-hf'; else:; default_scf = 'hf'; cbs_scf_wfn = kwargs.pop('scf_wfn', default_scf).lower(). if do_scf:; if cbs_scf_wfn not in VARH.keys():; raise ValidationError(""""""Requested SCF method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_scf_wfn)). # ... resume correlation logic; if do_corl:; if cbs_corl_wfn not in VARH.keys():; raise ValidationError(""""""Requested CORL method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_corl_wfn)). cbs_corl_wfn_lesser = kwargs.get('corl_wfn_lesser', cbs_scf_wfn).lower(); if cbs_corl_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested CORL method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for delta correction energy; if 'delta_wfn' in kwargs:; do_delta = True; cbs_delta_wfn = kwargs['delta_wfn'].lower(); if cbs_delta_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA method '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn)). cbs_delta_wfn_lesser = kwargs.get('delta_wfn_lesser', cbs_corl_wfn).lower(); if cbs_delta_wfn_lesser not in VARH.keys():; raise ValidationError(""""""Requested DELTA method lesser '%s' is not recognized. Add it to VARH in wrapper.py to proceed."""""" % (cbs_delta_wfn_lesser)). # Establish method for second delta correction energy; if 'delta2_wfn' in kwargs:; do_delta2 = True; cbs_delta2_wfn = kwargs['delta2_wfn'].lower(); if cbs_delta2_wfn not in VARH.keys():; raise ValidationError(""""""Requested DELTA2 method '%s' is not recognized. Add it to VARH in wrapper.py to proceed.""""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:39882,Validat,ValidationError,39882,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ctives += """"""PsiMod.print_out(' Database Contributions Map:\\n %s\\n')\n"""""" % ('-' * 75); for rxn in HRXN:; db_rxn = dbse + '-' + str(rxn); if rgt in ACTV[db_rxn]:; actives += """"""PsiMod.print_out(' reagent %s contributes by %.4f to reaction %s\\n')\n"""""" \; % (rgt, RXNM[db_rxn][rgt], db_rxn); actives += """"""PsiMod.print_out('\\n')\n\n"""""". # build string of commands for options from the input file TODO: handle local options too; commands = ''; commands += """"""\nPsiMod.set_memory(%s)\n\n"""""" % (user_memory); for chgdopt in PsiMod.get_global_option_list():; if PsiMod.has_global_option_changed(chgdopt):; chgdoptval = PsiMod.get_global_option(chgdopt); #chgdoptval = PsiMod.get_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed by database wrapper.' % (chgdopt)). # build string of molecule and commands that are dependent on the database; commands += '\n'; commands += """"""PsiMod.set_global_option('BASIS', '%s')\n"""""" % (user_basis); if not((user_df_basis_scf == """") or (user_df_basis_scf == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SCF', '%s')\n"""""" % (user_df_basis_scf); if not((user_df_basis_mp2 == """") or (user_df_basis_mp2 == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_MP2', '%s')\n"""""" % (user_df_basis_mp2); if not((user_df_basis_sapt == """") or (user_df_basis_sapt == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_SAPT', '%s')\n"""""" % (user_df_basis_sapt); if not((user_df_basis_elst == """") or (user_df_basis_elst == 'NONE')):; commands += """"""PsiMod.set_global_option('DF_BASIS_ELST', '%s')\n"""""" % (user_df_basis_elst); commands += """"""molecule = PsiMod.get_active_molecule()\n""""""; commands += """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:41033,Validat,ValidationError,41033,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"ctory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any doc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/plugins.html:6781,access,accessed,6781,psi4manual/master/plugins.html,https://psicode.org,https://psicode.org/psi4manual/master/plugins.html,15,['access'],['accessed']
Security,"cule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Sanitize total_method_name; label = total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_name.replace(' ', ''). # Split into components; method_list, basis_list = _parse_cbs_gufunc_string(total_method_name). # Single energy call?; single_call = len(method_list) == 1; single_call &= '[' not in basis_list[0]; single_call &= ']' not in basis_list[0]. if single_call:; method_name = method_list[0]; basis = basis_list[0]. # Save some global variables so we can reset them later; optstash = p4util.OptionsState(['BASIS']); core.set_global_option('BASIS', basis); ptype_value, wfn = func(method_name, return_wfn=True, molecule=molecule, **kwargs); core.clean(). optstash.restore(). if return_wfn:; return (ptype_value, wfn); else:; return ptype_value. # Drop out for props and freqs; if ptype in [""properties"", ""frequency""]:; raise ValidationError(""%s: Cannot extrapolate or delta correct %s yet."" % (ptype.title(), ptype)). # Catch kwarg issues for CBS methods only; user_dertype = kwargs.pop('dertype', None); cbs_verbose = kwargs.pop('cbs_verbose', False). # If we are not a single call, let CBS wrapper handle it!; cbs_kwargs = {}; cbs_kwargs['ptype'] = ptype; cbs_kwargs['return_wfn'] = True; cbs_kwargs['molecule'] = molecule; cbs_kwargs['verbose'] = cbs_verbose. # Find method and basis; if method_list[0] in ['scf', 'hf', 'c4-scf', 'c4-hf']:; cbs_kwargs['scf_wfn'] = method_list[0]; cbs_kwargs['scf_basis'] = basis_list[0]; if 'scf_scheme' in kwargs:; cbs_kwargs['scf_scheme'] = kwargs['scf_scheme']; else:; cbs_kwargs['corl_wfn'] = method_list[0]; cbs_kwargs['corl_basis'] = basis_list[0]; if 'corl_scheme' in kwargs:; cbs_kwargs['corl_scheme'] = kwargs['corl_scheme']. if len(method_list) > 1:; cbs_kwargs['delta_wfn'] = method_list[1]; cbs_kwargs['delta_basis'] = basis_list[1]; if 'delta_scheme' in kwargs:; cbs_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:67293,Validat,ValidationError,67293,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"cule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). [docs] def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs] def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. [docs] def compute(self, client: Optional[""qcportal.FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:54534,Validat,ValidationError,54534,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"cule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:54712,Validat,ValidationError,54712,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"cule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""basis"": job[""f_basis""],; ""keywords"": keywords or {},; }); self.task_list.append(task). # logger.debug(""TASK\n"" + pp.pformat(task.dict())). def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. def plan(self):; # uncalled function; return [t.plan() for t in self.task_list]. def compute(self, client: Optional[""FractalClient""] = None):; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if labe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:54322,Validat,ValidationError,54322,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"cule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(dashparam). # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Find out if running from Psi4 for scratch detail",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html:3704,Validat,ValidationError,3704,psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"cule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:20907,Validat,ValidationError,20907,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"cule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:21126,Validat,ValidationError,21126,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"current namespace pidspace. kwargs_lower(kwargs)[source]¶; Function to rebuild and return kwargs dictionary; with all keys made lowercase. Should be called by every; function that could be called directly by the user. driver¶; Module with a procedures dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. gradient(name, **kwargs)[source]¶; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. hessian(name, **kwargs)[source]¶; Function to compute force constants. Presently identical to frequency(). molden(filename)[source]¶. parse_arbitrary_order(name)[source]¶; Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. parse_cotton_irreps(irrep)[source]¶; Function to return validated Cotton ordering index from string or integer; irreducible representation irrep. physconst¶; # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.3597",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:9418,validat,validated,9418,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['validat'],['validated']
Security,"current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; # all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; # setting available memory to 2 M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:2202,access,access,2202,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,9,['access'],['access']
Security,"cvars, inc'l number, E, DG, G, H as available; * form model, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import copy; import logging; import re; import sys; from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. try:; from pydantic.v1 import Field, validator; except ImportError:; from pydantic import Field, validator. from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core. from . import driver_util, p4util, qcdb; from .constants import pp; from .driver_cbs_helper import ( # lgtm[py/unused-import]; composite_procedures,; register_composite_function,; register_xtpl_function,; xtpl_procedures,; ); from .driver_util import UpgradeHelper; from .p4util.exceptions import ValidationError; from .procrouting.interface_cfour import cfour_psivar_list; from .task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_xtpl_helgaker_3():; p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html:5422,Validat,ValidationError,5422,psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"d (bool); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); method (str); molecule (Any); owner_group (str | None); priority (str); protocols (qcelemental.models.results.AtomicResultProtocols | Dict[str, Any] | None); result (Any); result_id (str | None); tag (str). Validators:. set_basis » basis; set_keywords » keywords; set_method » method. field basis: str [Required]¶; The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, …). Validated by:. set_basis. field computed: bool = False¶; Whether quantum chemistry has been run on this task. field driver: DriverEnum [Required]¶; The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver. field keywords: Dict[str, Any] [Optional]¶; The keywords to use in the computation. Validated by:. set_keywords. field method: str [Required]¶; The quantum chemistry method to evaluate (e.g., B3LYP, MP2, …). Validated by:. set_method. field molecule: Any [Required]¶; The molecule to use in the computation. field owner_group: Optional[str] = None¶; group in the chown sense. field priority: str = 1¶; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}¶; Output modifications. field result: Any [Optional]¶; AtomicResult return. field result_id: Optional[str] = None¶; The optional ID for the computation. field tag: str = '*'¶; The tags to pass along to compute managers. compute(client=None)[source]¶; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None) – . get_results(client=None)[source]¶; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None) – . Return type:; AtomicResult. plan()[source]¶; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  »  psi4.driver.AtomicComputer.basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html:5583,Validat,Validated,5583,psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.AtomicComputer.html,1,['Validat'],['Validated']
Security,"d (bool); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); method (str); molecule (Any); owner_group (str | None); priority (str); protocols (qcelemental.models.results.AtomicResultProtocols | Dict[str, Any] | None); result (Any); result_id (str | None); tag (str). Validators:. set_basis » basis; set_keywords » keywords; set_method » method. field basis: str [Required]¶; The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, …). Validated by:. set_basis. field computed: bool = False¶; Whether quantum chemistry has been run on this task. field driver: DriverEnum [Required]¶; The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver. field keywords: Dict[str, Any] [Optional]¶; The keywords to use in the computation. Validated by:. set_keywords. field method: str [Required]¶; The quantum chemistry method to evaluate (e.g., B3LYP, MP2, …). Validated by:. set_method. field molecule: Any [Required]¶; The molecule to use in the computation. field owner_group: Optional[str] = None¶; group in the chown sense. field priority: str = 1¶; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}¶; Output modifications. field result: Any [Optional]¶; AtomicResult return. field result_id: Optional[str] = None¶; The optional ID for the computation. field tag: str = '*'¶; The tags to pass along to compute managers. compute(client=None)[source]¶; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None) – . get_results(client=None)[source]¶; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None) – . Return type:; AtomicResult. plan()[source]¶; Form QCSchema input from member data.; :rtype: AtomicInput. Return type:; AtomicInput. validator set_basis  »  psi4.driv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.AtomicComputer.html:5615,Validat,Validated,5615,psi4manual/1.9.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.AtomicComputer.html,1,['Validat'],['Validated']
Security,"d (bool); driver (qcelemental.models.common_models.DriverEnum); keywords (Dict[str, Any]); method (str); molecule (Any); owner_group (str | None); priority (str); protocols (qcelemental.models.results.AtomicResultProtocols | Dict[str, Any] | None); result (Any); result_id (str | None); tag (str). Validators:. set_basis » basis; set_keywords » keywords; set_method » method. field basis: str [Required]¶; The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, …). Validated by:. set_basis. field computed: bool = False¶; Whether quantum chemistry has been run on this task. field driver: DriverEnum [Required]¶; The resulting type of computation: energy, gradient, hessian, properties.Note for finite difference that this should be the target driver, not the means driver. field keywords: Dict[str, Any] [Optional]¶; The keywords to use in the computation. Validated by:. set_keywords. field method: str [Required]¶; The quantum chemistry method to evaluate (e.g., B3LYP, MP2, …). Validated by:. set_method. field molecule: Any [Required]¶; The molecule to use in the computation. field owner_group: Optional[str] = None¶; group in the chown sense. field priority: str = 1¶; The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}. field protocols: Union[AtomicResultProtocols, Dict[str, Any], None] = {'stdout': True}¶; Output modifications. field result: Any [Optional]¶; AtomicResult return. field result_id: Optional[str] = None¶; The optional ID for the computation. field tag: str = '*'¶; The tags to pass along to compute managers. compute(client=None)[source]¶; Run quantum chemistry. Parameters:; client (qcportal.client.FractalClient | None). get_results(client=None)[source]¶; Return results as Atomic-flavored QCSchema. Parameters:; client (qcportal.FractalClient | None). Return type:; AtomicResult. plan()[source]¶; Form QCSchema input from member data. Return type:; AtomicInput. validator set_basis  »  psi4.driver.AtomicComputer.basis[sour",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.AtomicComputer.html:5622,Validat,Validated,5622,psi4manual/master/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.AtomicComputer.html,1,['Validat'],['Validated']
Security,"d (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; core.print_out(""\nRelativistic analytic gradients are not implemented yet, re-routing to finite differences.\n""); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). dertype = min(dertype, derivatives[ptype]). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _process_displacement(derivfunc, method, molecule, displacement, n, ndisp, **kwargs):; """"""A helper function to perform all processing for an individual f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:4095,Validat,ValidationError,4095,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"d * physconst.psi_hartree2kcalmol); line2 = ' SAPT Induction (Monomer Basis) %10.4lf mH %10.4lf kcal mol^-1\n' % (CTm * 1000.0, CTm * physconst.psi_hartree2kcalmol); line3 = ' SAPT Charge Transfer %10.4lf mH %10.4lf kcal mol^-1\n\n' % (CT * 1000.0, CT * physconst.psi_hartree2kcalmol); PsiMod.print_out(line1); PsiMod.print_out(line2); PsiMod.print_out(line3); PsiMod.set_variable('SAPT CT ENERGY', CT). molecule.reset_point_group(user_pg); molecule.update_geometry(). optstash.restore(); return e_sapt. [docs]def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; # TODO: Check to see if we really need to run the SCF code.; scf_helper(name, **kwargs); vscf = PsiMod.get_variable('SCF TOTAL ENERGY'). # The parse_arbitrary_order method provides us the following information; # We require that level be provided. level is a dictionary; # of settings to be passed to PsiMod.mrcc; if not('level' in kwargs):; raise ValidationError('level parameter was not provided.'). level = kwargs['level']. # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = PsiMod.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) == False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); PsiMod.mrcc_generate_input(level). # Lo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:64068,Validat,ValidationError,64068,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"d = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:. prop = prop.upper(); if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everyt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:98876,Validat,ValidationError,98876,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"d = []. if 'properties' in kwargs:; properties = kwargs['properties']. for prop in properties:. prop = prop.upper(); if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(""""""CC property name %s not recognized"""""" % name.upper()). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:78128,Validat,ValidationError,78128,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"d arguments for extrapolation functions by; extracting zetas and values (which one determined by *datakey*) out; of *needdict* and returning a dictionary whose keys are contructed; from _lmh_labels. """"""; largs = {}; largs['functionname'] = needdict['HI']['f_wfn']; Nxtpl = len(needdict); zlabels = _lmh_labels[Nxtpl] # e.g., ['LO', 'HI']. for zeta in range(Nxtpl):; zlab = zlabels[zeta] # e.g., LO; largs['z' + zlab] = needdict[zlab]['f_zeta']; largs['value' + zlab] = needdict[zlab][datakey]. return largs. ## Aliases ##; complete_basis_set = cbs. def _cbs_wrapper_methods(**kwargs):; cbs_method_kwargs = ['scf_wfn', 'corl_wfn', 'delta_wfn']; cbs_method_kwargs += ['delta%d_wfn' % x for x in range(2, 6)]. cbs_methods = []; for method in cbs_method_kwargs:; if method in kwargs:; cbs_methods.append(kwargs[method]); return cbs_methods. def _parse_cbs_gufunc_string(method_name):; method_name_list = re.split( """"""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(""""""CBS gufunc: Too many brackets given! %s """""" % method_str). if method_str.count('/') != 1:; raise ValidationError(""""""CBS gufunc: All methods must specify a basis with '/'. %s"""""" % method_str). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; Text based wrapper of the CBS function.; """""". # Catch kwarg issues for all methods; kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:65175,Validat,ValidationError,65175,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"d efficiency in the rest of the; code).; DFMP2 likes disk. At a minimum, doubles are required for; RHF-MP2, and doubles are required for UHF-MP2.; DFMP2 likes threads. Some of the formation of the tensor; relies on threaded BLAS (such as MKL) for efficiency. The main; step is done via small/medium-sized DGEMMs inside of; OpenMP, so make sure to set the OMP_NESTED environment variable; to FALSE to prevent thread thrash (or just as well, do not define; OMP_NESTED at all).; Freezing core is good for both efficiency and correctness purposes.; Freezing virtuals is not recommended. The DFMP2 module will remind you how; many frozen/active orbitals it is using in a section just below the title.; ROHF-MBPT(2) may be preferred to UHF-MP2, as the latter can suffer from; severe spin contamination in some cases.; MP2 is not suitable for systems with multireference character. The; orbital energies will come together and an explosion will occur. Conventional MP2¶; Module: Keywords, PSI Variables, MP2; PSI4 also has a non-density-fitted MP2 algorithm for RHF, UHF, and; ROHF energies and RHF gradients. This code is not highly optimized, so the; density-fitted module DFMP2 is always the default. To access the; conventional MP2 code, set MP2_TYPE to conv and call; energy('mp2')/optimize('mp2'). MP2_TYPE¶. What algorithm to use for the MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. Table Of Contents. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2; MP2_TYPE. Previous topic; DFT: Density Functional Theory; Next topic; OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dfmp2-1.html:7848,access,access,7848,psi4manual/4.0b3/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dfmp2-1.html,2,['access'],['access']
Security,"d function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. add_array(self: psi4.core.Options, arg0: str) → None; add array option. add_bool(self: psi4.core.Options, arg0: str, arg1: bool) → None; add bool option. add_int(self: psi4.core.Options, arg0: str, arg1: int) → None; add int option. add_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None; add string option. add_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None; add string option. get_bool(self: psi4.core.Options, arg0: str) → bool; get boolean option. get_current_module(self: psi4.core.Options) → str; gets current module. get_double(self: psi4.core.Options, arg0: str) → float; get double option. get_int(self: psi4.core.Options, arg0: str) → int; get integer option. get_int_vector(self: psi4.core.Options, arg0: str) → List[int]; get int vector option. get_str(*args, **kwargs); Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.options.html:3093,validat,validate,3093,psi4manual/1.2.1/api/psi4.core.options.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.options.html,1,['validat'],['validate']
Security,"d function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. read_globals(self: psi4.core.Options) → bool¶; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str) → None¶; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool) → None¶; set bool option. set_current_module(self: psi4.core.Options, arg0: str) → None¶; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float) → None¶; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int) → None¶; set int option. set_read_globals(self: psi4.core.Options, arg0: bool) → None¶; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str) → None¶; set string option. validate_options(self: psi4.core.Options) → None¶; validate options for arg0 module. class psi4.core.OrbitalSpace¶; Bases: pybind11_builtins.pybind11_object; Contains information about the orbitals. C(self: psi4.core.OrbitalSpace) → psi4.core.Matrix¶; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace) → psi::BasisSet¶; The AO basis set used to create C. build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float) → psi4.core.OrbitalSpace¶; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = this space - orb_space The third argument is the tolerance for linear dependencies. build_ri_space(molecule: psi::Molecule, obs_key: str, aux_key: str, lindep_tol: float) → psi4.core.OrbitalSpace¶; Given two basis sets, it merges the b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:152687,validat,validate,152687,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['validat'],['validate']
Security,"d identified will give *wrong* answers. Consider this your warning.""); endif(). ############################ Options: Build How? #############################; include(psi4OptionsTools); option_with_print(BUILD_SHARED_LIBS ""Build internally built Psi4 add-on libraries as shared, not static"" OFF); option_with_print(ENABLE_OPENMP ""Enables OpenMP parallelization"" ON); option_with_print(ENABLE_AUTO_BLAS ""Enables CMake to auto-detect BLAS"" ON); option_with_print(ENABLE_AUTO_LAPACK ""Enables CMake to auto-detect LAPACK"" ON); option_with_print(ENABLE_PLUGIN_TESTING ""Test the plugin templates build and run"" OFF); option_with_flags(ENABLE_XHOST ""Enables processor-specific optimization (with MSVC, it enables AVX2 instructions)"" ON; ""-xHost"" ""-march=native"" ""/arch:AVX2""); option_with_flags(ENABLE_CODE_COVERAGE ""Enables details on code coverage"" OFF; ""-ftest-coverage""); option_with_flags(ENABLE_BOUNDS_CHECK ""Enables bounds check in Fortran"" OFF; ""-ftrapuv -check all -fpstkchk"" ""-fcheck=all"" ""-fbounds-check -fcheck-array-temporaries""); option_with_flags(ENABLE_ASAN ""Enables address sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=address -fno-omit-frame-pointer""); option_with_flags(ENABLE_TSAN ""Enables thread sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=thread -fPIE -pie -fno-omit-frame-pointer""); option_with_flags(ENABLE_UBSAN ""Enables undefined behavior sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=undefined -fno-omit-frame-pointer""); option_with_flags(ENABLE_MSAN ""Enables memory sanitizer (requires similarly compiled Python and Numpy)"" OFF; ""-fsanitize=memory -fPIE -pie -fno-omit-frame-pointer""); option_with_default(MAX_AM_ERI ""Maximum angular momentum for integrals"" 5); option_with_default(CMAKE_BUILD_TYPE ""Build type (Release or Debug)"" Release); option_with_default(FC_SYMBOL ""The type of Fortran name mangling"" 2). Note that external projects will have their own sets of build; configuration o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:17033,sanitiz,sanitizer,17033,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,8,['sanitiz'],['sanitizer']
Security,"d most users will ever; need to access directly to perform frequency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/freq-1.html:1579,access,accessed,1579,psi4manual/1.4.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/freq-1.html,5,['access'],['accessed']
Security,"d to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; optstash.restore(). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # call thermo module; PsiMod.thermo(). optstash.restore(); return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **kwargs). [docs]def molden(filename):; """"""Function to write wavefunction information in molden; format to *filename*. """"""; m = PsiMod.MoldenWriter(PsiMod.wavefunction()); m.write(filename). [docs]def parse_cotton_irreps(irrep):; r""""""Function to return validated Cotton ordering index from string or integer; irreducible representation *irrep*. """"""; cotton = {; 'c1': {; 'a': 1,; '1': 1; },; 'ci': {; 'ag': 1,; 'au': 2,; '1': 1,; '2': 2; },; 'c2': {; 'a': 1,; 'b': 2,; '1': 1,; '2': 2; },; 'cs': {; 'ap': 1,; 'app': 2,; '1': 1,; '2': 2; },; 'd2': {; 'a': 1,; 'b1': 2,; 'b2': 3,; 'b3': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2v': {; 'a1': 1,; 'a2': 2,; 'b1': 3,; 'b2': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4; },; 'c2h': {; 'ag': 1,; 'bg': 2,; 'au': 3,; 'bu': 4,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; },; 'd2h': {; 'ag': 1,; 'b1g': 2,; 'b2g': 3,; 'b3g': 4,; 'au': 5,; 'b1u': 6,; 'b2u': 7,; 'b3u': 8,; '1': 1,; '2': 2,; '3': 3,; '4': 4,; '5': 5,; '6': 6,; '7': 7,; '8': 8; }; }. point_group = PsiMod.get_active_molecule().schoenflies_symbol().lower(); irreducible_representation = str(irrep).lower(). try:; return cotton[point_group][irreducible_representation]; except KeyError:; raise ValidationError(""Irrep \'%s\' not valid for point group \'%s\'."" % (str(irrep),",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:68054,validat,validated,68054,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['validat'],['validated']
Security,"d', 'ccd', 'ccsd', 'ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); if corl_type not in [""DF"", ""CD""]:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC""""""). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccsd', 'omp2']:; for k, v in dfocc_wfn.variables(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:61637,Validat,ValidationError,61637,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"d('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', psi4.get_active_molecule()); else:; psi4.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = sapt_dimer.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). do_delta_mp2 = True if name.endswith('dmp2') else False. sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'). if sapt_basis == 'dimer':; psi4.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); if do_delta_mp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:79972,Validat,ValidationError,79972,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"d('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', psi4.get_active_molecule()); else:; psi4.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(); sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e. # Shifting to C1 so we need to copy the active molecule; if sapt_dimer.schoenflies_symbol() != 'c1':; psi4.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer = sapt_dimer.clone(); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(). if psi4.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = sapt_dimer.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = sapt_dimer.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, 1); monomerB.set_name('monomerB'); sapt_dimer.update_geometry(); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); psi4.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); psi4.set_global_option('DF_INTS_IO', 'LOAD'). if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); psi4.print_out('\n'); p4util.banner('Monomer A HF (Dimer Basis)'); psi4.print_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:85602,Validat,ValidationError,85602,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"d(CartesianEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; xval, yval, zval)). # handle first line of Zmat; elif len(entries) == 1:; zmatrix = True; tempfrag.append(iatom); self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel)). # handle second line of Zmat; elif len(entries) == 3:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); rval = self.get_coord_value(entries[2]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval)). # handle third line of Zmat; elif len(entries) == 5:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Molecule::create_molecule_from_string: Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Molecule::create_molecule_from_string: Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; atomMass, atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; zmatrix = True; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:19883,Validat,ValidationError,19883,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,d(basis_def2qzvpd); basisfamily_list.append(basis_def2qzvpp); basisfamily_list.append(basis_def2qzvppd). # Others; basis_dz = BasisFamily('DZ'); basis_dzp = BasisFamily('DZP'); basis_dzvp = BasisFamily('DZVP'); basis_psi3dzp = BasisFamily('psi3-DZP'); basis_psi3tz2p = BasisFamily('psi3-TZ2P'); basis_psi3tz2pf = BasisFamily('psi3-TZ2PF'); basis_sadlejlpoldl = BasisFamily('sadlej-lpol-dl'); basis_sadlejlpolds = BasisFamily('sadlej-lpol-ds'); basis_sadlejlpolfl = BasisFamily('sadlej-lpol-fl'); basis_sadlejlpolfs = BasisFamily('sadlej-lpol-fs'). basisfamily_list.append(basis_dz); basisfamily_list.append(basis_dzp); basisfamily_list.append(basis_dzvp); basisfamily_list.append(basis_psi3dzp); basisfamily_list.append(basis_psi3tz2p); basisfamily_list.append(basis_psi3tz2pf); basisfamily_list.append(basis_sadlejlpoldl); basisfamily_list.append(basis_sadlejlpolds); basisfamily_list.append(basis_sadlejlpolfl); basisfamily_list.append(basis_sadlejlpolfs). # Here lie practical (non-validated) fitting bases for; # Pople orbital basis sets. basis_sto3g.add_jkfit('cc-pvdz-ri'); basis_sto3g.add_rifit('cc-pvdz-ri'); basis_321g.add_jkfit('cc-pvdz-ri'); basis_321g.add_rifit('cc-pvdz-ri'). basis_631g.add_jkfit('cc-pvdz-jkfit'); basis_631g_d_.add_jkfit('cc-pvdz-jkfit'); basis_631g_d_p_.add_jkfit('cc-pvdz-jkfit'); basis_631gs.add_jkfit('cc-pvdz-jkfit'); basis_631gss.add_jkfit('cc-pvdz-jkfit'); basis_631g.add_rifit('cc-pvdz-ri'); basis_631g_d_.add_rifit('cc-pvdz-ri'); basis_631g_d_p_.add_rifit('cc-pvdz-ri'); basis_631gs.add_rifit('cc-pvdz-ri'); basis_631gss.add_rifit('cc-pvdz-ri'). basis_631pg.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg_d_.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg_d_p_.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pgs.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pgss.add_jkfit('heavy-aug-cc-pvdz-jkfit'); basis_631pg.add_rifit('heavy-aug-cc-pvdz-ri'); basis_631pg_d_.add_rifit('heavy-aug-cc-pvdz-ri'); basis_631pg_d_p_.add_rifit('heavy-aug-cc-pvdz-ri'); basi,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislistother.html:11065,validat,validated,11065,psi4manual/1.0.0/_modules/p4util/basislistother.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislistother.html,5,['validat'],['validated']
Security,"d); optstash = driver_util._set_convergence_criterion('energy', cbs_methods[0], 8, 10, 8, 10, 8). else:; # Allow specification of methods to arbitrary order; lowername = name.lower(); _filter_renamed_methods(""gradient"", lowername); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Prevent methods that do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:42356,Validat,ValidationError,42356,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"d, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. append() psi4.core.BSVec method, [1], [2]. psi4.core.VectorMatrix method, [1], [2]. apply_denominator() psi4.core.Matrix method, [1], [2]. approx_solve() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF method, [1], [2]. AQCCCORRELATIONENERGY. AQCCDIPOLEX. AQCCDIPOLEY. AQCCDIPOLEZ. AQCCQUADRUPOLEXX. AQCCQUADRUPOLEXY. AQCCQUADRUPOLEXZ. AQCCQUADRUPOLEYY. AQCCQUADRUPOLEYZ. AQCCQUADRUPOLEZZ. AQCCTOTALENERGY. arbitrary-order coupled-cluster theory. ; CI. arbitrary-order perturbation theory. ; CI. architectures. args psi4.driver.ConvergenceError attribute. psi4.driver.CSXError attribute. psi4.driver.Dftd3Error attribute. psi4.driver.ManagedMethodError attribute. psi4.driver.ParsingError attribute. psi4.driver.PastureRequiredError attribute. psi4.driver.PsiException attribute. psi4.driver.PsiImportError attribute. psi4.driver.TestComparisonError attribute. psi4.driver.ValidationError attribute. array_interface() psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. array_to_matrix() in module psi4.driver.p4util.numpy_helper. arrays() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Ascending psi4.core.DiagonalizeOrder attribute, [1], [2]. atom_at_position() psi4.core.Molecule method, [1], [2]. atomic_displacements() in module psi4.core, [1]. atomic_point_charges() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. AUXILIARY_BOND_FACTOR (OPTKING). AVG_STATES (DETCI). AVG_WEIGHTS (DETCI). axpy() psi4.core.CIVector method, [1], [2]. psi4.core.Matrix method, [1], [2]. B. B_RAS3_MAX (DETCI). back_transform() psi4.core.Matrix me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:6279,Validat,ValidationError,6279,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['Validat'],['ValidationError']
Security,"d, but there are only %d atoms in this molecule."" % \; (number, self.natom())); self.atoms[number].set_shell(bshash, role). [docs] def nfrozen_core(self, depth=False):; """"""Number of frozen core for molecule given freezing state. >>> print H2OH2O.nfrozen_core(); 2. """"""; if depth == False or depth.upper() == 'FALSE':; return 0. elif depth == True or depth.upper() == 'TRUE':; # Freeze the number of core electrons corresponding to the; # nearest previous noble gas atom. This means that the 4p block; # will still have 3d electrons active. Alkali earth atoms will; # have one valence electron in this scheme.; nfzc = 0; for A in range(self.natom()):; if self.Z(A) > 2:; nfzc += 1; if self.Z(A) > 10:; nfzc += 4; if self.Z(A) > 18:; nfzc += 4; if self.Z(A) > 36:; nfzc += 9; if self.Z(A) > 54:; nfzc += 9; if self.Z(A) > 86:; nfzc += 16; if self.Z(A) > 108:; raise ValidationError(""Molecule::nfrozen_core: Invalid atomic number""); return nfzc. else:; raise ValidationError(""Molecule::nfrozen_core: Frozen core '%s' is not supported, options are {true, false}."" % (depth)). # <<< Involved Methods for Frame >>>. [docs] def translate(self, r):; """"""Translates molecule by r. >>> H2OH2O.translate([1.0, 1.0, 0.0]). """"""; temp = [None, None, None]; for at in range(self.nallatom()):; temp = scale(self.full_atoms[at].compute(), self.input_units_to_au); temp = add(temp, r); temp = scale(temp, 1.0 / self.input_units_to_au); self.full_atoms[at].set_coordinates(temp[0], temp[1], temp[2]). [docs] def center_of_mass(self):; """"""Computes center of mass of molecule (does not translate molecule). >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_m = 0.0. for at in range(self.natom()):; m = self.mass(at); ret = add(ret, scale(self.xyz(at), m)); total_m += m. ret = scale(ret, 1.0 / total_m); return ret. [docs] def move_to_com(self):; """"""Moves molecule to center of mass. """"""; com = scale(self.center_of_mass(), -1.0); self.translate(com). [doc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:53441,Validat,ValidationError,53441,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"d, flipped, and otherwise badgered into coincidence, then the same; manipulations are applied to the gradient in GRD, the result of which; is printed below and passed on to Optking.; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-scf Gradient Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ... Irrep: 1 Size: 4 x 3. 1 2 3. 1 0.0000000 -0.0122978 0.0000000; 2 -0.0051192 0.0040993 -0.0088667; 3 -0.0051192 0.0040993 0.0088667; 4 0.0102384 0.0040993 0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; Matrix object through; psi4.core.get_gradient().; Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the PSI4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:22262,access,accessed,22262,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,5,['access'],['accessed']
Security,d. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_lesser' in kwargs:; # cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); # else:; # cbs_delta5_wfn_lesser = cbs_delta4_wfn; # if not (cbs_delta5_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; # pass; else:;,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:34583,Validat,ValidationError,34583,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"d. Replace\n\n\t\tpubchem:%s\n\n"" % (string); msg += ""\twith the Chemical ID number or exact name from one of the following and re-run.\n\n""; msg += ""\t Chemical ID IUPAC Name\n\n""; for result in results:; msg += ""%s"" % (result); if result.name().lower() == string.lower():; #We've found an exact match!; return result.getMoleculeString(); return msg. def process_molecule_command(matchobj):; """"""Function to process match of ``molecule name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); geometry = matchobj.group(3); geometry = pubchemre.sub(process_pubchem_command, geometry); from_filere = re.compile(r'^(\s*from_file\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE); geometry = from_filere.sub(process_from_file_command,geometry); molecule = spaces. if name != """":; if sys.version_info >= (3, 0):; if not name.isidentifier():; raise ValidationError('Molecule name not valid Python identifier: ' + name); else:; if not re.match(r'^[^\d\W]\w*\Z', name):; raise ValidationError('Molecule name not valid Python identifier: ' + name). molecule += 'core.efp_init()\n' # clear EFP object before Molecule read in; molecule += spaces. if name != """":; molecule += '%s = ' % (name). molecule += 'geometry(""""""%s""""""' % (geometry); if name != """":; molecule += ',""%s""' % (name). molecule += "")\n""; molecule += '%score.IO.set_default_namespace(""%s"")' % (spaces, name). return molecule. def process_literal_blocks(matchobj):; """"""Function to process match of ``literals_psi4_yo-...``.""""""; return literals[matchobj.group(1)]. def process_cfour_command(matchobj):; """"""Function to process match of ``cfour name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); cfourblock = matchobj.group(3). literalkey = str(uuid.uuid4())[:8]; literals[literalkey] = cfourblock; return ""%score.set_global_option(\""%s\"", \""\""\""%s\n\""\""\"")\n"" % \; (spaces, 'LITERAL_CFOUR', 'literals_psi4_yo-' + literalkey). def process_extract_command(matchobj):; """"""Function to process match of ``extract_su",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html:8082,Validat,ValidationError,8082,psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,1,['Validat'],['ValidationError']
Security,"d.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`; """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(; nmwhess, geom, m, wfn.basisset(), irrep_labels, dipder=dipder, project_trans=project_trans, project_rot=project_rot); vibrec.u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:88132,Validat,ValidationError,88132,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Validat'],['ValidationError']
Security,"d.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict; A dictionary of vibrational information. See :py:func:`~psi4.driver.qcdb.vib.harmonic_analysis`; """""". if hess is None:; nmwhess = np.asarray(wfn.hessian()); else:; nmwhess = hess. dipder = wfn.variables().get(""CURRENT DIPOLE GRADIENT"", None); if dipder is not None:; dipder = np.asarray(dipder).T. mol = wfn.molecule(); geom = np.asarray(mol.geometry()); symbols = [mol.symbol(at) for at in range(mol.natom())]. vibrec = {'molecule': mol.to_dict(np_out=False), 'hessian': nmwhess.tolist()}. if molecule is not None:; molecule.update_geometry(); if mol.natom() != molecule.natom():; raise ValidationError('Impostor molecule trying to be analyzed! natom {} != {}'.format(; mol.natom(), molecule.natom())); if abs(mol.nuclear_repulsion_energy() - molecule.nuclear_repulsion_energy()) > 1.e-6:; raise ValidationError('Impostor molecule trying to be analyzed! NRE {} != {}'.format(; mol.nuclear_repulsion_energy(), molecule.nuclear_repulsion_energy())); if not np.allclose(np.asarray(mol.geometry()), np.asarray(molecule.geometry()), atol=1.e-6):; core.print_out(; 'Warning: geometry center/orientation mismatch. Normal modes may not be in expected coordinate system.'; ); # raise ValidationError('Impostor molecule trying to be analyzed! geometry\n{}\n !=\n{}'.format(; # np.asarray(mol.geometry()), np.asarray(molecule.geometry()))); mol = molecule. m = np.asarray([mol.mass(at) for at in range(mol.natom())]); irrep_labels = mol.irrep_labels(). vibinfo, vibtext = qcdb.vib.harmonic_analysis(nmwhess,; geom,; m,; wfn.basisset(),; irrep_labels,; dipder=dipder,; project_trans=project_trans,; project_rot=project_rot); vib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:81582,Validat,ValidationError,81582,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"d_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(r""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def _cbs_gufunc(func, total_method_name, **kwargs):; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; func : function; Function to be called (energy, gradient, frequency or cbs).; total_method_name : str; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; tuple or float; Float, or if ``return_wfn`` is specified, a tuple of ``(value, wavefunction)``.; """""". # Catch kwarg iss",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:64226,Validat,ValidationError,64226,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"d_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(r""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_method_nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:39464,Validat,ValidationError,39464,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"d_list, basis_list)`` format, where ``method_list``; is the list of the component methods, and ``basis_list`` is the list of; basis sets forming the extrapolation for each specified method.; E.g. ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""`` would return:; ``([""mp2"", ""ccsd(t)""], [""cc-pv[tq]z"", ""cc-pvtz""])``.; """""". method_name_list = re.split(r""""""\+(?=\s*[Dd]:)"""""", method_name); if len(method_name_list) > 2:; raise ValidationError(; ""CBS gufunc: Text parsing is only valid for a single delta, please use the CBS wrapper directly""). method_list = []; basis_list = []; for num, method_str in enumerate(method_name_list):; if (method_str.count(""["") > 1) or (method_str.count(""]"") > 1):; raise ValidationError(f""""""CBS gufunc: Too many brackets given! {method_str}""""""). if method_str.count('/') != 1:; raise ValidationError(f""""""CBS gufunc: All methods must specify a basis with '/'. {method_str}""""""). if num > 0:; method_str = method_str.strip(); if method_str[:2].lower() != 'd:':; raise ValidationError(""""""CBS gufunc: Delta method must start with 'D:'.""""""); else:; method_str = method_str[2:]; method, basis = method_str.split('/'); method_list.append(method); basis_list.append(basis); return method_list, basis_list. def cbs_text_parser(total_method_name: str, **kwargs) -> Dict:; """"""; A text based parser of the CBS method string. Provided to handle ""method/basis""; specification of the requested calculations. Also handles ""simple"" (i.e.; one-method and one-basis) calls. Parameters; ----------; total_method_name; String in a ``""method/basis""`` syntax. Simple calls (e.g. ``""blyp/sto-3g""``) are; bounced out of CBS. More complex calls (e.g. ``""mp2/cc-pv[tq]z""`` or; ``""mp2/cc-pv[tq]z+D:ccsd(t)/cc-pvtz""``) are expanded by `_parse_cbs_gufunc_string()`; and pushed through :py:func:`~psi4.driver.cbs`. Returns; -------; dict of updated CBS keyword arguments; """""". ptype = kwargs.pop('ptype', None). # Sanitize total_method_name; total_method_name = total_method_name.lower(); total_method_name = total_met",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:39656,Validat,ValidationError,39656,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,4,['Validat'],['ValidationError']
Security,"dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]; # else:; # raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); # else:; # func = func.lower(); # if func not in dashcoeff[dashlvl].keys():; # raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); # if dashparam is None:; # # (normal) case where all param taken from dashcoeff above; # pass; # else:; # # case where items in dashparam dict can override param taken from dashcoeff above; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]. # TODO temp until figure out paramfile; allowed_funcs = ['HF/MINIS', 'DFT/MINIS', 'HF/MINIX', 'DFT/MINIX',; 'HF/SV', 'DFT/SV', 'HF/def2-SV(P)', 'DFT/def2-SV(P)', 'HF/def2-SVP',; 'DFT/def2-SVP', 'HF/DZP', 'DFT/DZP', 'HF/def-TZVP', 'DFT/def-TZVP',; 'HF/def2-TZVP', 'DFT/def2-TZVP', 'HF/631Gd', 'DFT/631Gd',; 'HF/def2-TZVP', 'DFT/def2-TZVP', 'HF/cc-pVDZ', 'DFT/cc-pVDZ',; 'HF/aug-cc-pVDZ', 'DFT/aug-cc-pVDZ', 'DFT/SV(P/h,c)', 'DFT/LANL',; 'DFT/pobTZVP', 'TPSS/def2-SVP', 'PW6B95/def2-SVP',; # specials; 'hf3c', 'pbeh3c']; allowed_funcs = [f.lower(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html:3959,Validat,ValidationError,3959,psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,1,['Validat'],['ValidationError']
Security,"dashcoeff_supplement; self.dashcoeff_supplement = dashcoeff_supplement; self.save_pairwise_disp = save_pairwise_disp. resolved = qcng.programs.empirical_dispersion_resources.from_arrays(; name_hint=name_hint,; level_hint=level_hint,; param_tweaks=param_tweaks,; dashcoeff_supplement=self.dashcoeff_supplement); self.fctldash = resolved['fctldash']; self.dashlevel = resolved['dashlevel']; self.dashparams = resolved['dashparams']; self.description = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['description']; self.ordered_params = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['default'].keys(); self.dashlevel_citation = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['citation']; self.dashparams_citation = resolved['dashparams_citation']. if engine is None:; self.engine = _capable_engines_for_disp[self.dashlevel][0]; else:; if self.dashlevel in _engine_can_do[engine]:; self.engine = engine; else:; raise ValidationError(""""""This little engine ({}) can't ({})"""""".format(engine, self.dashlevel)). if self.engine == 'libdisp':; self.disp = core.Dispersion.build(self.dashlevel, **resolved['dashparams']). [docs] def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs] def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; Sys",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html:6066,Validat,ValidationError,6066,psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/empirical_dispersion.html,3,['Validat'],['ValidationError']
Security,"data (energy/gradient/Hessian) of the system, otherwise returns interaction data. Default is False for energies, True for gradients and Hessians. Note that the calculation of total counterpoise corrected energies implies the calculation of the energies of monomers in the monomer basis, hence specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs] @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs] @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs] @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs] @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs] @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs] def build",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:34898,validat,validator,34898,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. [docs]; @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. [docs]; @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). [docs]; @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). [docs]; @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. [docs]; @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs]; def build_tasks(; self,; mb_computer: SubTaskComputers,; mc_level_idx: int,; **kwargs: Dict[str, Any],; ) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level speci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:35243,validat,validator,35243,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,3,['validat'],['validator']
Security,"data = filename; elif isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(data):; """"""; Converts an object with a .nph accessor to a serialized dictionary; """""". json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in data.nph:; json_data[""shape""].append(view.shape); json_data[""data""].append(view.tostring()). if len(json_data[""shape""][0]) == 1:; json_data[""type""] = ""vector""; elif len(json_data[""shape""][0]) == 2:; json_data[""type""] = ""matrix""; else:; raise ValidationError(""_to_json is only used for vector and matrix objects.""). return json_data. def _from_serial(self, json_data):; """"""; Converts serialized data to the correct Psi4 data type; """""". if json_data[""type""] == ""vector"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); ret = self(""Vector from JSON"", dim1); elif json_data[""type""] == ""matrix"":; dim1 = core.Dimension.from_list([x[0] for x in json_data[""shape""]]); dim2 = core.Dimension.from_list([x[1] for x in json_data[""shape""]]); ret = self(""Matrix from JSON"", dim1, dim2); else:; raise ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""]))",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html:10305,access,accessor,10305,psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/numpy_helper.html,4,['access'],['accessor']
Security,"data object. Methods Summary. array_interface(self). dim(self, h); Returns the dimensions of the vector per irrep h. dimpi(self); Returns the Dimension object. from_array(arr[, name, dim1, dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_list(x). from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get_block(self, slice); Get a vector block. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. print_out(self); Prints the vector to the output file. scale(self, sc); Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set_block(self, slice, block); Set a vector block. to_array([copy, dense]); Converts a Psi4 Matrix or Vector to a numpy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Attributes Documentation. name¶; The name of the Vector. Used in printing. np¶; View without only one irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. array_interface(self: psi4.core.Vector) → list¶. dim(self: psi4.core.Vector, h: int=0) → int¶; Returns the dimensions of the vector per irrep h. dimpi(self: psi4.core.Vector) → psi4.core.Dimension¶; Returns the Dimension object. classmethod from_array(arr, name='New Matrix', dim1=None, dim2=None)¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters:; arr (array or list of arrays) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (list, tuple, or core.Dimension (optional)) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diago",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vector.html:1351,access,accessor,1351,psi4manual/1.3.2/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vector.html,1,['access'],['accessor']
Security,"data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:10294,access,access,10294,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,8,['access'],['access']
Security,"data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within Psi4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:10862,access,access,10862,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['access'],['access']
Security,"data, *[, encoding]); Parses raw string or bytes into a Model object. plan(); Form QCSchema input from member data. schema([by_alias, ref_template]). rtype; DictStrAny. schema_json(*[, by_alias, ref_template]). rtype; unicode. serialize(encoding, *[, include, exclude, ...]); Generates a serialized representation of the model. set_basis(basis). set_keywords(keywords). set_method(method). update_forward_refs(**localns); Try to update ForwardRefs on fields based on this Model, globalns and localns. validate(value). rtype; Model. Methods Documentation. compare(other, **kwargs)¶; Compares the current object to the provided object recursively. Parameters. other (Model) – The model to compare to.; **kwargs – Additional kwargs to pass to qcelemental.compare_recursive. Returns; True if the objects match. Return type; bool. compute(client=None)[source]¶; Run quantum chemistry. Parameters; client (Optional[FractalClient]) – . classmethod construct(_fields_set=None, **values)¶; Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data.; Default values are respected, but no other validation is performed.; Behaves as if Config.extra = ‘allow’ was set since it adds all passed values. Return type; Model. Parameters. _fields_set (Optional[SetStr]) – ; values (Any) – . copy(*, include=None, exclude=None, update=None, deep=False)¶; Duplicate a model, optionally choose which fields to include, exclude and change. Parameters. include (Union[AbstractSetIntStr, MappingIntStrAny]) – fields to include in new model; exclude (Union[AbstractSetIntStr, MappingIntStrAny]) – fields to exclude from new model, as with values this takes precedence over include; update (DictStrAny) – values to change/add in the new model. Note: the data is not validated before creating; the new model: you should trust this data; deep (bool) – set to True to make a deep copy of the model; self (Model) – . Return type; Model. Returns; new model instance. dict(**kwargs)¶; Generate a dict",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html:2945,validat,validated,2945,psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.AtomicComputer.html,1,['validat'],['validated']
Security,"data. field basis: str = '(auto)'¶. field bsse_type: List[BsseEnum] = [BsseEnum.cp]¶; Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. Validated by:. set_bsse_type. field driver: DriverEnum [Required]¶; The computation driver; i.e., energy, gradient, hessian. field embedding_charges: Dict[int, List[float]] = {}¶; Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. Validated by:. set_embedding_charges. field keywords: Dict[str, Any] = {}¶; The computation keywords/options. field max_nbody: int = -1¶; Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments. Validated by:. set_max_nbody. field method: str = '(auto)'¶. field molecule: Any [Required]¶; The target molecule, if not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end. field nfragments: int = -1¶; Number of distinct fragments comprising full molecular supersystem. Validated by:. set_nfragments. field quiet: bool = False¶; Whether to print/log formatted n-body energy analysi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:16171,Validat,Validated,16171,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,3,['Validat'],['Validated']
Security,"data.py b/psi4/metadata.py; index 5d87b55..6cbc05e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,6 +1,6 @@; -__version__ = '1.1a1'; -__version_long = '1.1a1+007a9b6'; -__version_upcoming_annotated_v_tag = '1.1a2'; +__version__ = '1.1rc1'; +__version_long = '1.1rc1+zzzzzzz'; +__version_upcoming_annotated_v_tag = '1.1rc2'. >>> git add psi4/metadata.py. >>> git commit -m ""v1.1rc1"". OBSERVE undefined version state. >>> git describe --abbrev=7 --long --always HEAD; v1.1a1-418-g6100822. >>> git describe --abbrev=7 --long --dirty; v1.1a1-418-g6100822. >>> psi4/versioner.py; Undefining version for irreconcilable tags: 1.1a1 (computed) vs 1.1rc1 (recorded); undefined {master} 6100822 1.0.0.999 1.0 <-- undefined+6100822. Note 7-char git hash for the new commit, here “6100822”. ACT to bump tag in git, then bump git tag in code. Use the decided-upon tag v1.1rc1 and the observed hash “6100822” to; mint a new annotated tag, minding that “v”s are present here.; Use the observed hash to edit psi4/psi4/metadata.py and commit immediately. >>> git tag -a v1.1rc1 6100822 -m ""v1.1rc1"". >>> vi psi4/metadata.py; >>> git diff; diff --git a/psi4/metadata.py b/psi4/metadata.py; index 6cbc05e..fdc202e 100644; --- a/psi4/metadata.py; +++ b/psi4/metadata.py; @@ -1,5 +1,5 @@; __version__ = '1.1rc1'; -__version_long = '1.1rc1+zzzzzzz'; +__version_long = '1.1rc1+6100822'; __version_upcoming_annotated_v_tag = '1.1rc2'. >>> psi4/versioner.py; Amazing, this can't actually happen that git hash stored at git commit.; >>> git add psi4/metadata.py; >>> git commit -m ""Records tag for v1.1rc1"". OBSERVE current versioning state. Nothing to make note of, this is just a snapshot. >>> psi4/versioner.py; Defining development snapshot version: 1.1rc2.dev1+4e0596e (computed); 1.1rc2.dev1 {master} 4e0596e 1.0.0.999 1.0 <-- 1.1rc2.dev1+4e0596e. >>> git describe --abbrev=7 --long --always HEAD; v1.1rc1-1-g4e0596e. >>> git describe --abbrev=7 --long --dirty; v1.1rc1-1-g4e0596e. >>> git tag; v1.0; v1.1a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_git.html:2461,hash,hash,2461,psi4manual/master/manage_git.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_git.html,9,['hash'],['hash']
Security,"date qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.core.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, str):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]; # else:; # raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); # else:; # func = func.lower(); # if func not in dashcoeff[dashlvl].keys():; # raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); # if dashparam is None:; # # (normal) case where all param taken from dashcoeff above; # pass; # else:; # # case where items in dashparam dict can override param taken from dashcoeff above; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html:3319,Validat,ValidationError,3319,psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,1,['Validat'],['ValidationError']
Security,"dation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import collections; import math; import os; import re; import sys. from psi4.driver import constants; from psi4.driver import p4util; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:2098,access,accessible,2098,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,3,['access'],['accessible']
Security,"db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for rxn in HRXN:; temp.append(ACTV['%s-%s' % (dbse, rxn)]); HSYS = drop_duplicates(sum(temp, [])). # Sow all the necessary reagent computations; PsiMod.print_out(""\n\n""); banner((""Database %s Computation"" % (db_name)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:35720,Validat,ValidationError,35720,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = kwargs.get('cp', False). if db_cp is True:; try:; database.ACTV_CP; except AttributeError:; raise ValidationError(""""""Counterpoise correction mode 'yes' invalid for database %s."""""" % (db_name)); else:; ACTV = database.ACTV_CP; elif db_cp is False:; pass; else:; raise ValidationError(""""""Counterpoise correction mode '%s' not valid."""""" % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = kwargs.get('rlxd', False). if db_rlxd is True:; if db_cp is True:; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif db_cp is False:; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif db_rlxd is False:; #elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = kwargs.get('zpe', False). if db_zpe is True:; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif db_zpe is False:; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if db_benchmark.lower() == 'default':; pass; else:; BIND = p4util.getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:12806,Validat,ValidationError,12806,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,11,['Validat'],['ValidationError']
Security,"db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if (user_reference == 'RHF') or (user_reference == 'RKS'):; try:; database.isOS; except AttributeError:; pass; else:; if input.yes.match(str(database.isOS)):; openshell_override = 1; PsiMod.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if input.no.match(str(db_symm)):; symmetry_override = 1; elif input.yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; #db_mode = 'continuous'; #if(kwargs.has_key('mode')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise Validati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:31828,Validat,ValidationError,31828,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_global_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.match(r'^sapt', lowername):; try:; database.ACTV_SA; ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:30373,Validat,ValidationError,30373,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_global_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecule = PsiMod.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:30374,Validat,ValidationError,30374,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"dcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:116228,Validat,ValidationError,116228,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"dcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and not ""cvs"" in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; try:; adcc.set_n_threads(core.get_num_threads()); except AttributeError:; # Before adcc 0.13.3:; adcc.thread_pool.reinit(core.get_num_threads(), core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; ""{}"".format(str(ex))); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); ad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:113943,Validat,ValidationError,113943,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"dd ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def scf_helper(name, **kwargs):; """"""Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). """""". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'SCF_TYPE'] # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO']). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', psi4.get_active_molecule()); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass scf_helper a reference wavefunction""). # Second-order SCF requires non-symmetric density matrix support; if psi4.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if psi4.has_option_changed('SCF', 'BASIS_GUESS'):; cast = psi4.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF', '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:26848,Validat,ValidationError,26848,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"dd it to VARH in wrapper.py to proceed."""""" % (cbs_delta3_wfn_lesser)); #; # # Establish method for fourth delta correction energy; # if 'delta4_wfn' in kwargs:; # do_delta4 = True; # cbs_delta4_wfn = kwargs['delta4_wfn'].lower(); # if not (cbs_delta4_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA4 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn)); #; # if 'delta4_wfn_lesser' in kwargs:; # cbs_delta4_wfn_lesser = kwargs['delta4_wfn_lesser'].lower(); # else:; # cbs_delta4_wfn_lesser = cbs_delta3_wfn; # if not (cbs_delta4_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA4 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta4_wfn_lesser)); #; # # Establish method for fifth delta correction energy; # if 'delta5_wfn' in kwargs:; # do_delta5 = True; # cbs_delta5_wfn = kwargs['delta5_wfn'].lower(); # if not (cbs_delta5_wfn in VARH.keys()):; # raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)); #; # if 'delta5_wfn_lesser' in kwargs:; # cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); # else:; # cbs_delta5_wfn_lesser = cbs_delta4_wfn; # if not (cbs_delta5_wfn_lesser in VARH.keys()):; # raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:34241,Validat,ValidationError,34241,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"de from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: str; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:2429,access,accessible,2429,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,1,['access'],['accessible']
Security,"de to what changed,; why it changed, and how to interface with PSI4’s one-electron integral; machinery now. Calling compute_shell(int P, int Q)¶; The hand-implemented OS recursion code also took care of the Cartesian->pure; transformation (if required by the basis set). The mechanism for handling this; was to provide a public facing compute_shell(int P, int Q) method for the; caller; this then looked up the appropriate GaussianShell objects that were; passed into the corresponding (private) compute_pair(GaussianShell &s1,; GaussianShell &s2) function that computed the integrals and transformed them; to the spherical harmonic basis, if needed. The switch to Libint2 integrals; preserves this mechanism, but the compute_shell(int P, int Q) simply looks; up the appropriate Libint2-compatible shells and hands them off to the; re-written, private compute_pair() routines, which call Libint2 directly.; Therefore, any calls to shell-pair level integral computations should look the; same as before the introduction of Libint2, however access to the integrals has; changed, as described below. Accessing integrals¶; Before the Libint2 transition, one electron integrals were computed in a flat; array, internally called buffer_, which was accessed through the integral; object’s buffer() method. For integrals with multiple operators, e.g.,; dipole operators that have three distinct components, the buffer was simply; elongated by the appropriate amount and the caller was responsible for striding; through each resulting batch correctly. The Libint2 engines instead return a; list of pointers into each operator’s batch of integrals, the ordering of which; are detailed on the Libint2 wiki. For this reason, the call to buffer(); that returns a single buffer must be replaced with a call to buffer() to; get a list of pointers; we recommend that be assigned the type const auto; &. For simple integrals, such as overlap or kinetic, only the buffer; corresponding to the zeroth element of this arr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_integrals.html:12841,access,access,12841,psi4manual/master/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_integrals.html,5,['access'],['access']
Security,"de used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import re; import sys; import uuid; import warnings. import numpy as np. import qcelemental as qcel; from psi4 import core; from psi4.driver import qcdb. from . import optproc; from .exceptions import TestComparisonError, ValidationError. ## Python basis helps. @staticmethod; def _pybuild_basis(mol,; key=None,; target=None,; fitrole='ORBITAL',; other=None,; puream=-1,; return_atomlist=False,; quiet=False):; if key == 'ORBITAL':; key = 'BASIS'. def _resolve_target(key, target):; """"""Figure out exactly what basis set was intended by (key, target); """"""; horde = qcdb.libmintsbasisset.basishorde; if not target:; if not key:; key = 'BASIS'; target = core.get_global_option(key). if target in horde:; return horde[target]; return target. # Figure out what exactly was meant by 'target'.; resolved_target = _resolve_target(key, target). # resolved_target needs to be either a string or function for pyconstuct.; # if a string, they search for a gbs file with that name.; # if a function, it needs to apply a basis to each atom. bs, basisdict = qcdb.BasisSet.pyconstruct(; mol.to_dict(), key, resolved_target, fitrole, other, return_dict=True, return_atomlist=return_atomlist). if return_atomlist:; atom_basis_lis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:1334,Validat,ValidationError,1334,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"def _get_default_xtpl(nbasis, xtpl_type):; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis : int; Number of basis sets; xtpl_type : {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; function; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(""Wrong number of basis sets supplied to scf_xtpl: %d"" % nbasis); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(""Wrong number of basis sets supplied to corl_xtpl: %d"" % nbasis); else:; raise ValidationError(""Stage treatment must be 'corl' or 'scf', not '%s'"" % xtpl_type). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for item in cbs_metadata:; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(""Stage {:d} doesn't have defined level of theory!"".format(cbs_metadata.index(item))); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(""Stage {:d} doesn't have defined basis sets!"".format(cbs_metadata.index(item))); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:28912,validat,validates,28912,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validates']
Security,"default_xtpl(nbasis: int, xtpl_type: str) -> Callable:; """""" A helper function to determine default extrapolation type. Parameters; ----------; nbasis; Number of basis sets; xtpl_type; {'scf', 'corl'}; Extrapolation type: 'scf' for the total energy, 'corl' for just the; correlation component. Returns; -------; Callable; Extrapolation function to be used.; """""". if nbasis == 1 and xtpl_type in [""scf"", ""corl""]:; return xtpl_highest_1; elif xtpl_type == ""scf"":; if nbasis == 2:; return scf_xtpl_helgaker_2; elif nbasis == 3:; return scf_xtpl_helgaker_3; else:; raise ValidationError(f""Wrong number of basis sets supplied to scf_xtpl: {nbasis}""); elif xtpl_type == ""corl"":; if nbasis == 2:; return corl_xtpl_helgaker_2; else:; raise ValidationError(f""Wrong number of basis sets supplied to corl_xtpl: {nbasis}""); else:; raise ValidationError(f""Stage treatment must be 'corl' or 'scf', not '{xtpl_type}'""). def _validate_cbs_inputs(cbs_metadata, molecule):; """""" A helper function which validates the ``cbs_metadata`` format,; expands basis sets, and provides sensible defaults for optional arguments. Parameters; ----------; cbs_metadata : list; List of dicts containing CBS stage keywords.; molecule : qcdb.molecule or psi4.core.Molecule; Molecule to be passed to _expand_bracketed_basis(). Returns; -------; list; Validated list of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". metadata = []; for iitem, item in enumerate(cbs_metadata):; # 1a) all items must have wfn; if ""wfn"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined level of theory!""); # 1b) all items must have basis set; if ""basis"" not in item:; raise ValidationError(f""Stage {iitem} doesn't have defined basis sets!""); # 2a) process required stage parameters and assign defaults; stage = {}; stage[""wfn""] = item[""wfn""].lower(); stage[""basis""] = _expand_bracketed_basis(item[""basis""].lower(), molecule); # 2b) if first item is not HF, generate it; if le",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:29415,validat,validates,29415,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['validat'],['validates']
Security,"defined sequence'); core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). from pkg_resources import parse_version; min_version = ""0.15.16""; if parse_version(adcc.__version__) < parse_version(min_version):; raise ModuleNotFoundError(""adcc version {} is required at least. ""; ""Version {}""; "" was found."".format(min_version,; adcc.__version__)). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:117061,Validat,ValidationError,117061,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"defined sequence'); core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") <",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:116807,Validat,ValidationError,116807,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"defined sequence'); core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c conda-forge adcc'.""). min_version = ""0.15.16""; if parse_version(adcc.__version__) < parse_version(min_version):; raise ModuleNotFoundError(""adcc version {} is required at least. ""; ""Version {}""; "" was found."".format(min_version,; adcc.__version__)). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:117259,Validat,ValidationError,117259,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. efp = core.get_active_efp(); efp_present = efp.nfragments() > 0. translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and; not core.get_option('SCF', 'PERTURB_H') and; not efp_present); rotations_projection_sound = (translations_projection_sound and; stationary_point). return translations_projection_sound, rotations_projection_sound. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: *float* |w--w| Total electronic energy in Hartrees. SAPT & EFP return interaction energy. :returns",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:3789,Validat,ValidationError,3789,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"dertype, int):; raise ValidationError(""_find_derivative_type: user_dertype should only be None or int!""); dertype = user_dertype. if (core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and (dertype != 0):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with derivatives, so stopping.'). if (core.get_global_option('PCM')) and (dertype != 0):; core.print_out('\nPCM analytic gradients are not implemented yet, re-routing to finite differences.\n'); dertype = 0. # Summary validation; if (dertype == 2) and (method_name in procedures['hessian']):; pass; elif (dertype == 1) and (method_name in procedures['gradient']):; pass; elif (dertype == 0) and (method_name in procedures['energy']):; pass; else:; alternatives = ''; alt_method_name = p4util.text.find_approximate_string_matches(method_name, procedures['energy'].keys(), 2); if len(alt_method_name) > 0:; alternatives = """""" Did you mean? %s"""""" % (' '.join(alt_method_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _process_displacement(derivfunc, method, molecule, displacement, n, ndisp, **kwargs):; """"""A helper function to perform all processing for an individual finite; difference computation. Parameters; -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:3749,Validat,ValidationError,3749,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,"described above when *return_wfn* specified. """"""; nbody_model = self.get_results(client=client); ret = nbody_model.return_result. wfn = core.Wavefunction.build(self.molecule, ""def2-svp"", quiet=True). # TODO all besides nbody may be better candidates for extras than qcvars. energy/gradient/hessian_body_dict in particular are too simple for qcvars (e.g., ""2""); dicts = [; #""energies"", # retired; #""ptype"", # retired; ""intermediates"",; ""intermediates_energy"", #""intermediates2"",; ""intermediates_gradient"", #""intermediates_ptype"",; ""intermediates_hessian"", #""intermediates_ptype"",; ""energy_body_dict"",; ""gradient_body_dict"", # ptype_body_dict; ""hessian_body_dict"", # ptype_body_dict; ""nbody"",; ""cp_energy_body_dict"",; ""nocp_energy_body_dict"",; ""vmfc_energy_body_dict"",; ""cp_gradient_body_dict"",; ""nocp_gradient_body_dict"",; ""vmfc_gradient_body_dict"",; ""cp_hessian_body_dict"",; ""nocp_hessian_body_dict"",; ""vmfc_hessian_body_dict"",; ]. for qcv, val in nbody_model.extras['qcvars'].items():; if isinstance(val, dict):; if qcv in dicts:; for qcv2, val2 in val.items():; for obj in [core, wfn]:; try:; obj.set_variable(str(qcv2), val2); except ValidationError:; obj.set_variable(f""{self.driver.name} {qcv2}"", val2); else:; for obj in [core, wfn]:; obj.set_variable(qcv, val). if self.driver == 'gradient':; ret = core.Matrix.from_array(ret); wfn.set_gradient(ret); elif self.driver == 'hessian':; ret = core.Matrix.from_array(ret); grad = core.Matrix.from_array(nbody_model.properties.return_gradient); wfn.set_hessian(ret); wfn.set_gradient(grad). if return_wfn:; return (ret, wfn); else:; return ret. # TODO questions to check:; # * can work with supersystem and embedding_charges?; # * can levels work with same method, different basis?. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver_nbody. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html:92905,Validat,ValidationError,92905,psi4manual/master/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" %; (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzN = re.compile(r'(?:\s*)([A-Z](?:[a-z])?)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE); xyzC = re.compile(r'(?:\s*)(\d+\.?\d*)(?:\s+)' +; NUMBER + '(?:\s+)' + NUMBER + '(?:\s+)' + NUMBER + '(?:\s*)', re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:5659,Validat,ValidationError,5659,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"difrec[""stencil_size""] == 5:; fc = (-offdiag_en(0) - offdiag_en(1) + 9 * offdiag_en(2) - offdiag_en(3) - offdiag_en(4) +; 9 * offdiag_en(5) - offdiag_en(6) - offdiag_en(7) + E[i][0] - 7 * E[i][1] - 7 * E[i][2] +; E[i][3] + E[j][0] - 7 * E[j][1] - 7 * E[j][2] + E[j][3] +; 12 * ref_energy) / (12 * findifrec[""step""][""size""]**2); H_irr[i, j] = fc; H_irr[j, i] = fc. B_pi.append(data[""salc_list""].matrix_irrep(h)); H_pi.append(_process_hessian_symmetry_block(H_irr, B_pi[-1], massweighter, irrep_lbls[h], data[""print_lvl""])). # All blocks of the Hessian are now constructed!; return _process_hessian(H_pi, B_pi, massweighter, data[""print_lvl""]). [docs]; class FiniteDifferenceComputer(BaseComputer):. molecule: Any; driver: DriverEnum; metameta: Dict[str, Any] = {}; task_list: Dict[str, BaseComputer] = {}; findifrec: Dict[str, Any] = {}; computer: BaseComputer = AtomicComputer; method: str. [docs]; @validator('driver'); def set_driver(cls, driver):; egh = ['energy', 'gradient', 'hessian']; if driver not in egh:; raise ValidationError(f""""""Wrapper is unhappy to be calling function ({driver}) not among {egh}.""""""). return driver. [docs]; @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; """"""Initialize FiniteDifference class. data keywords include; * general AtomicInput keys like molecule, driver, method, basis, and keywords.; * specialized findif keys like findif_mode, findif_irrep, and those converted from keywords to kwargs:; findif_stencil_size, findif_step_size, and findif_verbose.; * TODO hangers-on keys present at class initiation get automatically attached to class since `extra = ""allow""` but should be pruned. """"""; findif_stencil_size = data.pop('findif_stencil_size'); findif_step_size = data.pop('findif_step_size'). BaseComputer.__init__(self, **data). translations_projection_sound = (not ""external_potentials"" in data['keywords']['function_kwargs']; and not core.ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:40819,validat,validator,40819,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,6,"['Validat', 'validat']","['ValidationError', 'validator']"
Security,"dimension with symmetry information. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if cls.has_scalar_variable(key):; return cls.scalar_variable(key); elif cls.has_array_variable(key):; return _qcvar_reshape_get(key, cls.array_variable(key)); else:; raise KeyError(""psi4.core.Wavefunction.variable: Requested variable "" + key + "" was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* in global memory."""""". if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(""psi4.core.set_variable: Target variable "" + key + "" already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable "" + key +; "" already a scalar variable",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:28292,Validat,ValidationError,28292,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"ding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """"""; run_scf(name, **kwargs). [docs]def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; oneel_properties = ['dipole', 'quadrupole']; twoel_properties = []; response_properties = ['polarizability', 'rotation', 'roa']; excited_properties = ['oscillator_strength', 'rotational_strength']. one = []; two = []; response = []; excited = []; invalid = []. if 'properties' in kwargs:; properties = kwargs.pop('properties'); properties = drop_duplicates(properties). for prop in properties:; if prop in oneel_properties:; one.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""The \""properties\"" keyword is required with the property() function.""). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if (n_invalid > 0):; print(""The following properties are not currently supported: %s"" % invalid). if (n_excited > 0 and (name.lower() != 'eom-ccsd' and name.lower() != 'eom-cc2')):; raise ValidationError(""Excited state CC properties require EOM-CC2 or EOM-CCSD.""). if ((name.lower() == 'eom-ccsd' or name.lower() == 'eom-cc2') and n_response > 0):; raise ValidationError(""Cannot (yet) compute response properties for excited states.""). if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""Computing both density- and response-based properties.""). if (name.lower() == 'ccsd'):; PsiMod.set_global_option('WFN', 'CCSD'); run_ccenergy('ccsd', **kwargs); PsiMod.set_global_option('WFN', 'CCSD'); elif (name.lower() == 'cc2'):; PsiMod.set_global_option('WFN', 'CC2'); run_ccenergy('cc2', **kwargs); PsiMod.set_global_option('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:17081,Validat,ValidationError,17081,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; # pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = _expand_bracketed_basis(kwargs['corl_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""CORL basis sets through keyword '%s' are required."""""" % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets throug",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:36053,Validat,ValidationError,36053,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"docs]def corl_xtpl_helgaker_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; ""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). # final = valueSCF + value; final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = """"""\n\n ==> Helgaker 2-point correlated extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); # cbsscheme += """""" HI-zeta (%1s) SCF Energy: % 16.12f\n"""""" % (str(zHI), valueSCF); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; #cbsscheme += """""" LO-zeta (%s) Correlation Energy: % 16.12f\n"""""" % (str(zLO), valueLO); #cbsscheme += """""" HI-zeta (%s) Cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:20729,Validat,ValidationError,20729,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html:2478,access,access,2478,psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html,1,['access'],['access']
Security,"docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`psi4/share/psi4/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:2546,access,access,2546,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,3,['access'],['access']
Security,"document.; Use *columnplan* to customize column (from among columnreservoir, below); layout. Use *title* and *indextitle* to customize table caption and; table-of-contents caption, respectively; variables in curly braces will; be substituted. Use *theme* to customize the \ref{tbl:} code. """"""; # define eligible columns for inclusion; columnreservoir = {; 'dbrxn': ['l', r""""""\textbf{Reaction}"""""", """"""{0:25s}""""""],; 'indx': ['r', '', """"""{0:14s}""""""],; 'tagl': ['l', r""""""\textbf{Reaction}"""""", """"""{0:50s}""""""],; 'bm': ['d', r""""""\multicolumn{1}{c}{\textbf{Benchmark}}"""""", """"""{0:8.2f}""""""],; 'mc': ['d', r""""""\multicolumn{1}{c}{\textbf{ModelChem}}"""""", """"""{0:8.2f}""""""],; 'e': ['d', r""""""\multicolumn{1}{c}{\textbf{Error}}"""""", """"""{0:8.2f}""""""],; 'pe': ['d', r""""""\multicolumn{1}{c}{\textbf{\% Err.}}"""""", """"""{0:8.1f}""""""],; 'imag': ['l', '', r""""""\includegraphics[width=1.0cm,height=3.5mm]{%s%%ss.png}"""""" % (plotpath)], # untested; }; for col in columnplan:; if col not in columnreservoir.keys():; raise ValidationError('Column {0} not recognized. Register with columnreservoir.'.format(col)). if isinstance(modelchem, basestring):; if modelchem.lower() == 'all':; mcs = sorted(self.mcs.keys()); else:; mcs = [modelchem]; else:; mcs = modelchem. # commence to generate LaTeX code; tablelines = []; indexlines = []. if standalone:; tablelines += textables.begin_latex_document(). # iterate to produce one LaTeX table per modelchem; for mc in mcs:; # prepare summary statistics; perr = self.compute_statistics(mc, benchmark=benchmark, sset=sset,; failoninc=failoninc, verbose=False,; returnindiv=False); serrors = OrderedDict(); for db in self.dbdict.keys():; serrors[db] = None if perr[db] is None else format_errors(perr[db], mode=3); serrors[self.dbse] = format_errors(perr[self.dbse], mode=3). # prepare individual reactions and errors; terrors = OrderedDict(); isComplete = True; for (lmc, lbm, orxn) in self.get_reactions(mc, benchmark=benchmark,; sset=sset, failoninc=failoninc):; tmp = {}; dbrxn = orxn.dbrxn; tm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:88495,Validat,ValidationError,88495,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Validat'],['ValidationError']
Security,"ds ""creator"", ""version"", ""routine"".; connectivity : list of tuples of int, optional; (nbond, 3) list of (0-indexed) (atomA, atomB, bond_order) (int, int, double) tuples. EFP extension (this + units is minimal). fragment_files : list of str; (nfr, ) lowercased names of efp meat fragment files.; hint_types : {'xyzabc', 'points'}; (nfr, ) type of fragment orientation hint.; geom_hints : list of lists of float; (nfr, ) inner lists have length 6 (xyzabc; to orient the center) or; 9 (points; to orient the first three atoms) of the EFP fragment. QMVZ extension (geom_unsettled replaces geom). geom_unsettled : list of lists of str; (nat, ) all-string Cartesian and/or zmat anchor and value contents; mixing anchors, values, and variables.; variables : list of pairs; (nvar, 2) pairs of variables (str) and values (float). May be incomplete. Raises; ------; qcelemental.ValidationError; For most anything wrong. """"""; # << domain sorting >>; available_domains = [""qm"", ""efp"", ""qmvz""]; if domain not in available_domains:; raise ValidationError(; ""Topology domain {} not available for processing. Choose among {}"".format(domain, available_domains); ). if domain == ""qm"" and (geom is None or np.asarray(geom).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom = []; else:; raise ValidationError(""""""For domain 'qm', `geom` must be provided.""""""); if domain == ""efp"" and (geom_hints is None or np.asarray(geom_hints, dtype=object).size == 0):; if missing_enabled_return == ""none"":; return {}; elif missing_enabled_return == ""minimal"":; geom_hints = []; fragment_files = []; hint_types = []; else:; raise ValidationError(""""""For domain 'efp', `geom_hints` must be provided.""""""). molinit = {}; extern = False. processed = validate_and_fill_units(; name=name,; units=units,; input_units_to_au=input_units_to_au,; comment=comment,; provenance=provenance,; connectivity=connectivity,; always_return_iutau=False,; ); processed[""provenance""] = provenance_sta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:8986,Validat,ValidationError,8986,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"duce meaningful results (database); from an incomplete set of sown files, while others cannot (gradient,; hessian). """"""; E = 0.0. try:; freagent = open('%s.out' % (sowout), 'r'); except IOError:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); else:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (sowout)); return 0.0; else:; while True:; line = freagent.readline(); if not line:; if E == 0.0:; if allvital:; raise ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); else:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (sowout, quantity)); break; s = line.strip().split(None, 10); if (len(s) != 0) and (s[0:3] == [quantity, 'RESULT:', 'computation']):; if int(s[3]) != linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (sowout, str(s[3]), str(linkage))); if s[6] != str(sownum + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (sowout, s[6], str(sownum + 1))); if label == 'electronic energy' and s[8:10] == ['electronic', 'energy']:; E = float(s[10]); psi4.print_out('%s RESULT: electronic energy = %20.12f\n' % (quantity, E)); if label == 'electronic gradient' and s[8:10] == ['electronic', 'gradient']:; E = ast.literal_eval(s[-1]); psi4.print_out('%s RESULT: electronic gradient = %r\n' % (quantity, E)); freagent.close(); return E. [docs]def prepare_options_for_modules(changedOnly=False, commandsInsteadDict=False):; """"""Function to return a string of commands to replicate the; current state of user-modified options. Used to capture C++; options information for distributed (sow/reap) input files. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Need some option to get either all or changed. - Need some option to either get dict or set string or psimod command list. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html:9264,Validat,ValidationError,9264,psi4manual/1.0.0/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/procutil.html,1,['Validat'],['ValidationError']
Security,"dule wrappers). SS_E_CONVERGENCE (CCEOM). SS_R_CONVERGENCE (CCEOM). SS_SKIP_DIAG (CCEOM). SS_VECS_PER_ROOT (CCEOM). STEP_TYPE (OPTKING). success() (in module util). superfunctional_list() (in module functional). symmetry. molecule. T. T2_COUPLED (CCENERGY). T3_WS_INCORE (CCENERGY). (CCEOM). T_AMPS (CCHBAR). Table (class in text). TAU_SQUARED (DCFT). tblhead() (in module wrappers). TDHF_MEM_SAFETY_FACTOR (CPHF). (PLUGIN_FOCK), [1]. TDM (DETCI). TDM_PRINT (DETCI). TDM_WRITE (DETCI). TEST_B (OPTKING). test_ccl_functional() (in module functional). TEST_DERIVATIVE_B (OPTKING). text (module). theory; . ADC. CC. CI. DF-MP2. DFT. SAPT. SCF. cbs(), [1]. threading. TIKHONOW_MAX (PSIMRCC). TIKHONOW_OMEGA (DCFT). (PSIMRCC). TIKHONOW_TRIPLES (PSIMRCC). TILE_SIZE (PLUGIN_TEST_MATRIX), [1]. TILE_SZ (SCF). TPDM (DCFT). (DETCI). TPDM_ADD_REF (TRANSQT). TPDM_FILE (TRANSQT). TPDM_PRINT (DETCI). transition state; . geometry optimization. TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TURN_ON_ACTV (MCSCF). TWO-ELECTRONENERGY. U. UNCP-CORRECTED2-BODYINTERACTIONENERGY. units; . molecule. UNITS (GLOBALS). UPDATE (DETCI). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). util (module). V. VAL_EX_LEVEL (DETCI). validate_bracketed_basis() (in module wrappers). validate_scheme_args() (in module wrappers). ValidationError. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). VECS_WRITE (DETCI). W. WABEI_LOWDISK (CCHBAR). WFN (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CCTRIPLES). (CIS). (CLAG). (DETCI). (GLOBALS). (LMP2). (MP2). (SCF). (TRANSQT). (TRANSQT2). WFN_SYM (MCSCF). (PSIMRCC). wrappers (module). X. XI (CCDENSITY). XI_CONNECT (CCDENSITY). Z. ZAPTnCORRELATIONENERGY. ZAPTnTOTALENERGY. ZERO_INTERNAL_AMPS (PSIMRCC). ZETA (CCDENSITY). (CCLAMBDA). Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/genindex.html:28623,Validat,ValidationError,28623,psi4manual/4.0b2/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/genindex.html,1,['Validat'],['ValidationError']
Security,"dvec.close_io_files(True). def prepare_sapt_molecule(sapt_dimer, sapt_basis):; """"""; Prepares a dimer molecule for a SAPT computations. Returns the dimer, monomerA, and monomerB.; """""". # Shifting to C1 so we need to copy the active molecule; sapt_dimer = sapt_dimer.clone(); if sapt_dimer.schoenflies_symbol() != 'c1':; core.print_out(' SAPT does not make use of molecular symmetry, further calculations in C1 point group.\n'); sapt_dimer.reset_point_group('c1'); sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True); sapt_dimer.update_geometry(); else:; sapt_dimer.update_geometry() # make sure since mol from wfn, kwarg, or P::e; sapt_dimer.fix_orientation(True); sapt_dimer.fix_com(True). nfrag = sapt_dimer.nfragments(). if nfrag == 3:; # Midbond case; if sapt_basis == 'monomer':; raise ValidationError(""SAPT basis cannot both be monomer centered and have midbond functions.""). midbond = sapt_dimer.extract_subsets(3); ztotal = 0; for n in range(midbond.natom()):; ztotal += midbond.Z(n). if ztotal > 0:; raise ValidationError(""SAPT third monomr must be a midbond function (all ghosts).""). ghosts = ([2, 3], [1, 3]); elif nfrag == 2:; # Classical dimer case; ghosts = (2, 1); else:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, ghosts[0]); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, ghosts[1]); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'); else:; raise ValidationError(""SAPT basis %s not recognized"" % sapt_basis). return (sapt_dimer, monomerA, monomerB). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.3.2;  · . PSI4. Module code. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html:7428,Validat,ValidationError,7428,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,3,['Validat'],['ValidationError']
Security,"e :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61109,access,accesses,61109,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,3,['access'],['accesses']
Security,"e = (; ""Conflicting basis set specification: assign lines present but shells have no [basname] label.""; """"); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; basstrings[basname(basblock[idx])] = basblock[idx + 1]. return basstrings. anon.__name__ = 'basisspec_psi4_yo__' + cleanbas; qcdb.libmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MBIS_CHARGES', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; ""SCSN-MP2 CORRELATION ENERGY"": ""SCS(N)-MP2 CORRELATION ENERGY"",; ""SCSN-MP2 TOTAL ENERGY"": ""SCS(N)-MP2 TOTAL ENERGY"",; ""MAYER_INDICES"": ""MAYER INDICES"",; ""WIBERG_LOWDIN_INDICES"": ""WIBERG LOWDIN INDICES"",; ""LOWDIN_CHARGES"": ""LOWDIN CHARGES"",; ""MULLIKEN_CHARGES"": ""MULLIKEN CHARGES"",; ""(AT) CORRECTION ENERGY"": ""A-(T) CORRECTION ENERGY"",; ""CCSD(AT) TOTAL ENERGY"": ""A-CCSD(T) TOTAL ENERGY"",; ""CCSD(AT) CORRELATION ENERGY"": ""A-CCSD(T) CORRELATION ENERG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:17894,Validat,ValidationError,17894,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"e == 1) and not(func is gradient):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; freq_mode = 'continuous'; if ('mode' in kwargs) and ((dertype == 0) or (dertype == 1)):; freq_mode = kwargs['mode']. if (freq_mode.lower() == 'continuous'):; pass; elif (freq_mode.lower() == 'sow'):; pass; elif (freq_mode.lower() == 'reap'):; if('linkage' in kwargs):; freq_linkage = kwargs['linkage']; else:; raise ValidationError('Frequency execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Frequency execution mode \'%s\' not valid.' % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not proc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:60714,Validat,ValidationError,60714,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"e ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:116918,Validat,ValidationError,116918,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"e ValidationError(""_from_json did not recognize type option of %s."" % str(json_data[""type""])). for n in range(len(ret.nph)):; ret.nph[n].flat[:] = np.frombuffer(json_data[""data""][n], dtype=np.double). return ret. def _chain_dot(*args, **kwargs):; """"""; Chains dot products together from a series of Psi4 Matrix classes. By default there is no transposes, an optional vector of booleans can be passed in.; """""". trans = kwargs.pop(""trans"", None); if trans is None:; trans = [False for x in range(len(args))]; else:; if len(trans) != len(args):; raise ValidationError(; ""Chain dot: The length of the transpose arguements is not equal to the length of args.""). # Setup chain; ret = args[0]; if trans[0]:; ret = ret.transpose(). # Run through; for n, mat in enumerate(args[1:]):; ret = core.doublet(ret, mat, False, trans[n + 1]). return ret. def _irrep_access(self, *args, **kwargs):; """"""; Warns user when iterating/accessing an irreped object.; """"""; raise ValidationError(""Attempted to access by index/iteration a Psi4 data object that supports multiple""; "" irreps. Please use .np or .nph explicitly.""). # Matrix attributes; core.Matrix.from_array = classmethod(array_to_matrix); core.Matrix.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Matrix.to_array = _to_array; core.Matrix.shape = _np_shape; core.Matrix.np = _np_view; core.Matrix.nph = _nph_view; core.Matrix.__array_interface__ = _array_conversion; core.Matrix.np_write = _np_write; core.Matrix.np_read = classmethod(_np_read); core.Matrix.to_serial = _to_serial; core.Matrix.from_serial = classmethod(_from_serial); core.Matrix.chain_dot = _chain_dot; core.Matrix.__iter__ = _irrep_access; core.Matrix.__getitem__ = _irrep_access. # Vector attributes; core.Vector.from_array = classmethod(array_to_matrix); core.Vector.from_list = classmethod(lambda self, x: array_to_matrix(self, np.array(x))); core.Vector.to_array = _to_array; core.Vector.shape = _np_shape; core.Vector.np = _np_view; core.Vector.nph = _np",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html:12252,Validat,ValidationError,12252,psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/numpy_helper.html,6,"['Validat', 'access']","['ValidationError', 'access']"
Security,"e and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. func - functional alias or None; dashlvl - functional type d2gr/d3zero/d3bj/d3mzero/d3mbj; dashparam - dictionary; dertype = derivative level. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if dashlvl is not None:; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())); else:; raise ValidationError(""""""Must specify a dashlvl""""""). if func is not None:; dftd3_params = dash_server(func, dashlvl); else:; dftd3_params = {}. if dashparam is not None:; dftd3_params.update(dashparam). # Move ~/.dftd3par.<hostname> out of the way so it won't interfere; defaultfile = os.path.expanduser('~') + '/.dftd3par.' + socket.gethostname(); defmoved = False; if os.path.isfile(defaultfile):; os.rename(defaultfile, defaultfile + '_hide'); defmoved = True. # Find environment by merging PSIPATH and PAT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html:3304,Validat,ValidationError,3304,psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"e are multiple results. Print and exit; msg = ""\tPubchemError\n""; msg += ""\tMultiple pubchem results were found. Replace\n\n\t\tpubchem:%s\n\n"" % (string); msg += ""\twith the Chemical ID number or exact name from one of the following and re-run.\n\n""; msg += ""\t Chemical ID IUPAC Name\n\n""; for result in results:; msg += ""%s"" % (result); if result.name().lower() == string.lower():; #We've found an exact match!; return result.getMoleculeString(); return msg. def process_molecule_command(matchobj):; """"""Function to process match of ``molecule name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); geometry = matchobj.group(3); geometry = pubchemre.sub(process_pubchem_command, geometry); from_filere = re.compile(r'^(\s*from_file\s*:\s*(.*)\n)$', re.MULTILINE | re.IGNORECASE); geometry = from_filere.sub(process_from_file_command,geometry); molecule = spaces. if name != """":; if sys.version_info >= (3, 0):; if not name.isidentifier():; raise ValidationError('Molecule name not valid Python identifier: ' + name); else:; if not re.match(r'^[^\d\W]\w*\Z', name):; raise ValidationError('Molecule name not valid Python identifier: ' + name). molecule += 'core.efp_init()\n' # clear EFP object before Molecule read in; molecule += spaces. if name != """":; molecule += '%s = ' % (name). molecule += 'geometry(""""""%s""""""' % (geometry); if name != """":; molecule += ',""%s""' % (name). molecule += "")\n""; molecule += '%score.IO.set_default_namespace(""%s"")' % (spaces, name). return molecule. def process_literal_blocks(matchobj):; """"""Function to process match of ``literals_psi4_yo-...``.""""""; return literals[matchobj.group(1)]. def process_cfour_command(matchobj):; """"""Function to process match of ``cfour name? { ... }``.""""""; spaces = matchobj.group(1); name = matchobj.group(2); cfourblock = matchobj.group(3). literalkey = str(uuid.uuid4())[:8]; literals[literalkey] = cfourblock; return ""%score.set_global_option(\""%s\"", \""\""\""%s\n\""\""\"")\n"" % \; (spaces, 'LITERAL_CFOUR', 'literals_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html:7956,Validat,ValidationError,7956,psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/inputparser.html,1,['Validat'],['ValidationError']
Security,"e been set as 6/5 so as to match those; # run normally through OEProp so subject to change; if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). optstash.restore(); return returnvalue. ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+--------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:45082,Validat,ValidationError,45082,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"e difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. from qcelemental.models import Molecule. # Build the molecule; mol = Molecule(**self.molecule.to_schema(dtype=2)). meta, ids = client.add_singlepoints(; molecules=mol,; program=""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html:3756,validat,validator,3756,psi4manual/1.9.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/task_base.html,2,['validat'],['validator']
Security,"e difference that this should be the target driver, not the means driver.""); keywords: Dict[str, Any] = Field(default_factory=dict, description=""The keywords to use in the computation.""); protocols: Optional[Union[AtomicResultProtocols, Dict[str, Any]]] = Field({""stdout"": True}, description=""Output modifications.""); tag: str = Field(""*"", description=""The tags to pass along to compute managers.""); priority: str = Field(1, description=""The priority of a Task; higher priority will be pulled first. {high:2, normal:1, low:0}""); owner_group: Optional[str] = Field(None, description=""group in the chown sense.""); computed: bool = Field(False, description=""Whether quantum chemistry has been run on this task.""); result: Any = Field(default_factory=dict, description="":py:class:`~qcelemental.models.AtomicResult` return.""); result_id: Optional[str] = Field(None, description=""The optional ID for the computation.""). class Config(qcel.models.ProtoModel.Config):; pass. [docs]; @validator(""basis""); def set_basis(cls, basis):; return basis.lower(). [docs]; @validator(""method""); def set_method(cls, method):; return method.lower(). [docs]; @validator(""keywords""); def set_keywords(cls, keywords):; return copy.deepcopy(keywords). [docs]; def plan(self) -> AtomicInput:; """"""Form QCSchema input from member data."""""". atomic_model = AtomicInput(**{; ""molecule"": self.molecule.to_schema(dtype=2),; ""driver"": self.driver,; ""model"": {; ""method"": self.method,; ""basis"": self.basis; },; ""keywords"": self.keywords,; ""protocols"": self.protocols,; ""extras"": {; ""psiapi"": True,; ""wfn_qcvars_only"": True,; },; }). return atomic_model. [docs]; def compute(self, client: Optional[""qcportal.client.FractalClient""] = None):; """"""Run quantum chemistry.""""""; from psi4.driver import pp. if self.computed:; return. if client:; self.computed = True. try:; # QCFractal v0.15.8; from qcportal.models import KeywordSet, Molecule; qca_next_branch = False; except ImportError:; # QCFractal `next`; from qcelemental.models import Mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html:3781,validat,validator,3781,psi4manual/1.8.x/_modules/psi4/driver/task_base.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/task_base.html,1,['validat'],['validator']
Security,"e element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. to_array(copy=True, dense=False)¶; Converts a Psi4 Matrix or Vector to a numpy array. Either copies the data or simply; constructs a view. Parameters:; matrix (Matrix or Vector) – Pointers to which Psi4 core class should be used in the construction.; copy (bool, optional) – Copy the data if True, return a view otherwise; dense (bool, optional) – Converts irreped Psi4 objects to diagonally blocked dense arrays if True. Returns a list of arrays otherwise. Returns:array – Returns either a list of np.array’s or the base array depending on options. Return type:ndarray or list of ndarray. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; 1; 2; 3; 4; 5>>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial()¶; Converts an object with a .nph accessor to a serialized dictionary. array_interface(self: psi4.core.Vector) → list. dim(self: psi4.core.Vector, h: int) → int; Returns the dimensions of the vector per irrep h. classmethod from_array(arr, name='New Matrix', dim1=None, dim2=None); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters:; arr (array or list of arrays) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (list, tuple, or core.Dimension (optional)) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 – Same as dim1 only if using a psi4.core.Dimension object. Returns:matrix – Returns the given Psi4 object. Return type:Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; 1;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vector.html:4931,access,accessor,4931,psi4manual/1.2.1/api/psi4.core.vector.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.vector.html,1,['access'],['accessor']
Security,"e for easy access to the underlying data:; 1>>> mat.np[:] = 1. this operation is identical to the above. Warning; The following will lead to reference errors: view =; psi4.Matrix(3, 3).np. Here, the Python garbage collection deletes the Matrix; object, the view then points to deleted data resulting in the view effectively; reading random data. As a general rule, never assign the .nph or .np; accessors. PSI4 Data Objects with Irreps¶; PSI4 data objects natively support multiple irreducible representations; which is quite useful for Quantum Chemistry. However, this is not fundamental; to NumPy and some work around are required to natively support these; operations. Take the following irreped Matrix:; 1; 2; 3; 4; 5; 6; 7; 8>>> dim = psi4.Dimension.from_list([1, 2, 3]); >>> irreped_mat = psi4.Matrix(""New Matrix"", dim, dim). # Create a list of Psi4 arrays; >>> list_of_arrays = irreped_mat.to_array(). # Or, use the .nph irreped accessor; >>> irreped_mat.nph[0][:] = 1. Where .nph is the irreped accessor form. If .np or np.array are; called on irreped Matrices or Vectors an error will be thrown; however, the; irreped form is always valid for non-irreped matrices. Array to Matrix¶; A general function that converts PSI4 data objects to NumPy arrays. psi4.driver.p4util.numpy_helper.array_to_matrix(self, arr, name='New Matrix', dim1=None, dim2=None)[source]¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters:; arr (array or list of arrays) – Numpy array or list of arrays to use as the data for a new core.Matrix; name (str) – Name to give the new core.Matrix; dim1 (list, tuple, or core.Dimension (optional)) – If a single dense numpy array is given, a dimension can be supplied to; apply irreps to this array. Note that this discards all extra information; given in the matrix besides the diagonal blocks determined by the passed; dimension.; dim2 – Same as dim1 only if using a Psi4.Dimension object. Returns:matrix – Returns the given Psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/numpy-1.html:2875,access,accessor,2875,psi4manual/1.1.0/numpy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/numpy-1.html,2,['access'],['accessor']
Security,"e of vectors *v* - *u*.""""""; return [v[i] - u[i] for i in range(len(v))]. [docs]def dot(v, u):; """"""Compute dot product of vectors *v* and *u*.""""""; return sum(u[i] * v[i] for i in range(len(v))). [docs]def scale(v, d):; """"""Compute by-element scale by *d* of vector *v*.""""""; return [d * v[i] for i in range(len(v))]. [docs]def normalize(v):; """"""Compute normalized vector *v*.""""""; vmag = norm(v); return [v[i] / vmag for i in range(len(v))]. [docs]def distance(v, u):; """"""Compute the distance between points defined by vectors *v* and *u*.""""""; return norm(sub(v, u)). [docs]def cross(v, u):; """"""Compute cross product of length 3 vectors *v* and *u*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('cross() only defined for vectors of length 3\n'); return [v[1] * u[2] - v[2] * u[1],; v[2] * u[0] - v[0] * u[2],; v[0] * u[1] - v[1] * u[0]]. [docs]def rotate(v, theta, axis):; """"""Rotate length 3 vector *v* about *axis* by *theta* radians.""""""; if len(v) != 3 or len(axis) != 3:; raise ValidationError('rotate() only defined for vectors of length 3\n'). unitaxis = normalize(copy.deepcopy(axis)); # split into parallel and perpendicular components along axis; parallel = scale(axis, dot(v, axis) / dot(axis, axis)); perpendicular = sub(v, parallel); # form unit vector perpendicular to parallel and perpendicular; third_axis = perp_unit(axis, perpendicular); third_axis = scale(third_axis, norm(perpendicular)). result = add(parallel, add(scale(perpendicular, math.cos(theta)), scale(third_axis, math.sin(theta)))); for item in range(len(result)):; if math.fabs(result[item]) < ZERO:; result[item] = 0.0; return result. [docs]def perp_unit(u, v):; """"""Compute unit vector perpendicular to length 3 vectors *u* and *v*.""""""; if len(u) != 3 or len(v) != 3:; raise ValidationError('perp_unit() only defined for vectors of length 3\n'). # try cross product; result = cross(u, v); resultdotresult = dot(result, result). if resultdotresult < 1.E-16:; # cross product is too small to normalize; # find the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/vecutil.html:1656,Validat,ValidationError,1656,psi4manual/4.0b3/_modules/qcdb/vecutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/vecutil.html,3,['Validat'],['ValidationError']
Security,"e point gradient of 1-1B2 state of H2O with EOM-CCSD. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. opt-multi-dimer-c2h; Multi-fragment opt of C2h metha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:19080,validat,validate,19080,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['validat'],['validate']
Security,"e running total of product evaluations that was performed; done : bool, if all roots were converged; """""". def __init__(self, iteration, wfn, what, stats):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class MissingMethodError(ValidationError):; """"""Error called when method not available. """""". def __init__(self, msg):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; modulemsg = ""not available""; else:; modulemsg = f""not directable to QC_MODULE '{circs[5]}'"". if len(circs) == 7:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}', FREEZE_CORE '{not circs[6]}', and REFERENCE '{circs[4]}' {modulemsg}""""""; else:; msg = f""""""{circs[0]}: Method '{circs[1]}' with {circs[2]} '{circs[3]}' and REFERENCE '{circs[4]}' {modulemsg}""""""; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the specified value of *option* requires some; modul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:6195,Validat,ValidationError,6195,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,3,['Validat'],['ValidationError']
Security,"e specifying ``return_total_data = True`` may carry out more computations than ``return_total_data = False``.""); quiet: bool = Field(False, description=""Whether to print/log formatted n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs] def build_tasks(self, mb_computer: SubTaskComputers, mc_level_idx: int, **kwargs: Dict[str, Any]) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:34926,validat,validator,34926,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"e system. :type properties: array of strings; :param properties: |dl| ``[]`` |dr| || ``['rotation', 'polarizability', 'oscillator_strength', 'roa']`` || etc. Indicates which properties should be computed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); #PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:35055,Validat,ValidationError,35055,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"e that it is; possible to use g++ or another compiler and yet still link against MKL).; Control of threading in PSI4 can be accomplished at a variety of levels,; ranging from global environment variables to direct control of thread count in; the input file, to even directives specific to each model. This hierarchy is; explained below. Note that each deeper level trumps all previous levels.; (1) OpenMP/MKL Environment Variables. Deprecated since version 1.1: Environment variables OMP_NUM_THREADS and MKL_NUM_THREADS; do not affect threading in PSI4. (2) The -n Command Line Flag; To change the number of threads at runtime, the psi4 -n flag may be used. An; example is:; psi4 -i input.dat -o output.dat -n 4. which will run on four threads. Note that is is not available for PsiAPI mode of operation.; (3) Setting Thread Numbers in an Input; For more explicit control, the Process::environment class in PSI4 can; override the number of threads set by environment variables. This functionality; is accessed via the psi4.set_num_threads() function, which controls; both MKL and OpenMP thread numbers. The number of threads may be changed; multiple times in a PSI4 input file. An example input for this feature is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17# A bit small-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. set scf {; basis cc-pvdz; scf_type df; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). In PsiAPI mode of operation, this syntax, psi4.set_num_threads(nthread), is; the primary way to control threading.; (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:11182,access,accessed,11182,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['access'],['accessed']
Security,"e the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The various orbital-optimized methods supported by the OCC/DFOCC; modules in PSI4 are summarized in Table OCC OO; Methods and detailed in Table OCC; OO Capabilities. Note that while two; separate libraries OCC (conventional integrals CONV) and DFOCC; (density-fitted DF and Cholesky-decomposed CD) together provide; the methods described on this page, they are controlled through one; QC_MODULE value OCC. Without set qc_module occ,; these methods may default to implementations in other modules based on efficiency considerations. Orbital-optimized theoretical methods accessible through OCC/DFOCC¶. name; calls method; OO. omp2; orbital-optimized second-order MP perturbation theory; E/G. omp2.5; orbital-optimized average of MP2 and MP3; E/G. omp3; orbital-optimized third-order MP perturbation theory; E/G. oremp2; orbital-optimized second-order REMP hybrid PT; E/G. olccd; orbital-optimized linear coupled cluster doubles; E/G. Detailed orbital-optimized capabilities of the OCC module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[1] ↓ →; FREEZE_CORE[2]→. QC_MODULE=OCC Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:10296,access,accessible,10296,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['access'],['accessible']
Security,"e them if; only the df integrals were run previously.; # Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/psi4/driver/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dct' : run_dct,. Then in psi4/psi4/driver/procrouting/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default modul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/proc_py-1.html:3725,access,access,3725,psi4manual/1.4.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/proc_py-1.html,5,['access'],['access']
Security,"e them if; only the df integrals were run previously.; # Bypass the scf call if a reference wavefunction is given. ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') in ['DF', 'CD']:; psi4.MintsHelper(ref_wfn.basisset()).integrals(). Direct any post-scf modules to be run.; # include if further post-scf modules are needed; psi4.transqt2(); psi4.ccsort(); psi4.mp2(). If an OptionsState object was set up, those options; need to be returned to the original user state with the following.; # include if optstash = OptionsState( was set up previously; optstash.restore(). No function should return anything. CURRENT ENERGY will be set by; energy(), etc.; # never include; return returnvalue. Managed Methods¶; When functionality overlaps between modules, a pattern is needed to (1); access each route through the code without contrivances like ccsd2,; _ccsd, sdci and (2) apportion defaulting among the modules, taking; into account reference (RHF/UHF/ROHF) and calc type (CONV, DF, CD).; Managed methods handle both these cases through the addition of a new; keyword QC_MODULE and a set of type keywords analogous to; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g.,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/proc_py-1.html:3738,access,access,3738,psi4manual/1.0.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/proc_py-1.html,2,['access'],['access']
Security,"e vector per irrep h. dimpi(self); Returns the Dimension object. from_array([name, dim1, dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_list(x). from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get_block(self, slice); Get a vector block. load(self, psio, file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. print_out(self); Prints the vector to the output file. save(self, psio, file); Save the vector to disk. scale(self, sc); Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set_block(self, slice, block); Set a vector block. to_array([copy, dense]); Converts a Psi4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self, other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name¶; The name of the Vector. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. array_interface(self: psi4.core.Vector) → list¶. axpy(self: psi4.core.Vector, a: float, other: psi4.core.Vector) → None¶; Adds to this vector another vector scaled by a. clone(self: psi4.core.Vector) → psi4.core.Vector¶; Clone the vector. copy(self: psi4.core.Vector, arg0: psi4.core.Vector) → None¶; Returns a copy of the matrix. dim(self: psi4.core.Vector, h: int = 0) → int¶; Returns the dimensions of the vector per irrep h. dimpi(self: psi4.core.Vector) → psi4.core.Dimension¶; Returns the Dimension object. classmethod from_array(name='New Matrix', dim1=None, dim2=None)¶; Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). Parameters. arr (Union[ndarray, L",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html:1598,access,accessor,1598,psi4manual/1.6.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html,1,['access'],['accessor']
Security,"e wavefunction""). # Second-order SCF requires non-symmetric density matrix support; if psi4.get_option('SCF', 'SOSCF'):; proc_util.check_non_symmetric_jk_density(""Second-order SCF""). # sort out cast_up settings. no need to stash these since only read, never reset; cast = False; if psi4.has_option_changed('SCF', 'BASIS_GUESS'):; cast = psi4.get_option('SCF', 'BASIS_GUESS'); if yes.match(str(cast)):; cast = True; elif no.match(str(cast)):; cast = False. if psi4.get_option('SCF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; multp = scf_molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF', 'REFERENCE') not in ['UHF', 'UKS']:; raise ValidationError(""""""You must specify 'set reference uhf' to use broken symmetry.""""""); do_broken = True; else:; do_broken = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that can't query PUREAM option directly, as it only; # reflects user changes to value, so load basis and; # read effective PUREAM setting off of it; #psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')); #psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; scf_molecule.set_multiplicity(3); psi4.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); psi4.print_out('\n'). # cast set-up; if (cast):. if yes.match(str(cast)):; guessbasis = '3-21G'; else:; guessbasis = cast. #if (castdf):; # if yes.match(str(castdf)):; # guessbasisdf = p4util.corr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:27904,Validat,ValidationError,27904,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"e"",; ""hold_options_state"",; ""import_ignorecase"",; ""kwargs_lower"",; ""mat2arr"",; ""prepare_options_for_modules"",; ""prepare_options_for_set_options"",; ""provenance_stamp"",; ""plump_qcvar"",; ""state_to_atomicinput"",; ]. import os; import ast; import sys; import math; import pickle; import inspect; import warnings; from contextlib import contextmanager; import collections; from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Union; from types import ModuleType. import numpy as np; from qcelemental.models import AtomicInput. from psi4 import core; from psi4.metadata import __version__; from .exceptions import ValidationError; from . import p4regex. [docs]def kwargs_lower(kwargs: Dict[str, Any]) -> Dict[str, Any]:; """"""Function to rebuild and return *kwargs* dictionary sanitized. Should be; called by every function that could be called directly by the user. Parameters; ----------; kwargs; Input kwargs for any user-facing function. Returns; -------; lowered : Dict[str, Any]; Sanitized kwargs with all keys made lowercase. Also turns boolean-like; values into actual booleans. Also turns values lowercase if sensible. """"""; caseless_kwargs = {}; for key, value in kwargs.items():; lkey = key.lower(); if lkey in ['subset', 'banner', 'restart_file', 'write_orbitals']: # only kw for which case matters; lvalue = value; else:; try:; lvalue = value.lower(); except (AttributeError, KeyError):; lvalue = value. if lkey in ['irrep', 'check_bsse', 'linkage', 'bsse_type']:; caseless_kwargs[lkey] = lvalue. elif 'dertype' in lkey:; if p4regex.der0th.match(str(lvalue)):; caseless_kwargs[lkey] = 0; elif p4regex.der1st.match(str(lvalue)):; caseless_kwargs[lkey] = 1; elif p4regex.der2nd.match(str(lvalue)):; caseless_kwargs[lkey] = 2; else:; raise KeyError(f'Derivative type key {key} was not recognized'). elif lvalue is None:; caseless_kwargs[lkey] = None. elif p4regex.yes.match(str(lvalue)):; caseless_kwargs[lkey] = True. elif p4regex.no.match(str(lvalue)):; caseless_kwargs[lkey] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:2348,Sanitiz,Sanitized,2348,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,1,['Sanitiz'],['Sanitized']
Security,e')):; # db_mode = kwargs['mode']; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if input.yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif input.no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if input.yes.match(str(db_rlxd)):; if input.yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif input.no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif input.no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:33003,Validat,ValidationError,33003,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"e'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |; PSI4 [beta2] » ; Module code ». © Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85972,Validat,ValidationError,85972,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"e(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # Validate arguments; dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; elif der2nd.match(str(dertype)):; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). if func is None:; if dashparam is None:; # defunct case; raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); else:; # case where all param read from dashparam dict (which must have all correct keys); func = 'custom'; dashcoeff[dashlvl][func] = {}; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():; if key in dashparam.keys():; dashcoeff[dashlvl][func][key] = dashparam[key]; else:; raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); else:; func = func.lower(); if func not in dashcoeff[dashlvl].keys():; raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); if dashparam is None:; # (normal) case where all param taken from dashcoeff above; pass; else:; # case where items in dashparam dict can override param taken from dashcoeff above; dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); for key in dashcoeff[dashlvl]['b3lyp'].keys():",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:3615,Validat,ValidationError,3615,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"e(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). # power user returns; E, wfn = psi4.energy(..., return_wfn=True); E, wfn = psi4.optimize(..., return_wfn=True); E, wfn = psi4.frequency(..., return_wfn=True); G, wfn = psi4.gradient(..., return_wfn=True) # used by optimize(); H, wfn = psi4.hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print(wfn.gradient().rms()). # format output for other programs; psi4.molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:. PSIthonPsiAPIbasis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; psi4.set_options({""basis"": basis_set}); psi4.energy('scf').",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:11487,access,access,11487,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['access'],['access']
Security,"e(core.get_global_option('SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if (core.get_option('SCF', 'REFERENCE') == 'ROHF') and \; ((name in ['ccsd(t)', 'ccsd(at)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; core.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn). if name == 'ccsd(at)':; core.cchbar(ref_wfn); core.cclambda(ref_wfn). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') == 'TRUE':; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:71358,Validat,ValidationError,71358,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"e(core.get_option('SCF', 'SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if (core.get_option('SCF', 'REFERENCE') == 'ROHF') and \; ((name in ['ccsd(t)', 'ccsd(at)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']) or; core.get_option('CCTRANSORT', 'SEMICANONICAL')):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn). if name == 'ccsd(at)':; core.cchbar(ref_wfn); core.cclambda(ref_wfn). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') == 'TRUE':; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:67396,Validat,ValidationError,67396,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"e(name, value); else:; self.__dict__[name] = value; except KeyError:; self.__dict__[name] = value. def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrivial geometry variable values as if member data. """"""; if not name in self.__dict__:; if object.__getattribute__(self, 'is_variable')(name):; return object.__getattribute__(self, 'get_variable')(name); else:; raise AttributeError; else:; return self.__dict__[name]. [docs] def get_anchor_atom(self, vstr, line):; """"""Attempts to interpret a string *vstr* as an atom specifier in; a zmatrix. Takes the current *line* for error message printing.; Returns the atom number (adjusted to zero-based counting). """"""; integerNumber = re.compile(r""(-?\d+)"", re.IGNORECASE); if integerNumber.match(vstr):; # This is just a number, return it; return int(vstr) - 1; else:; # Look to see if this string is known; for i in range(self.nallatom()):; if self.full_atoms[i].label() == vstr:; return i; raise ValidationError(""Illegal value %s in atom specification on line %s.\n"" % (vstr, line)). [docs] def geometry(self):; """"""Returns the geometry in Bohr as a N X 3 array. >>> print H2OH2O.geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132, -1.4334725450878665], [3.175492014248769, -0.7062681346308132, 1.4334725450878665]]. """"""; geom = []; for at in range(self.natom()):; geom.append([self.x(at), self.y(at), self.z(at)]); return geom. [docs] def full_geometry(self):; """"""Returns the full (dummies included) geometry in Bohr as a N X 3 array. >>> print H2OH2O.full_geometry(); [[-2.930978460188563, -0.21641143673806384, 0.0], [-3.655219780069251, 1.4409218455037016, 0.0], [-1.1332252981904638, 0.0769345303220403, 0.0], [0.0, 0.0, 0.0], [2.5523113582286716, 0.21064588230662976, 0.0], [3.175492014248769, -0.7062681346308132,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:33524,Validat,ValidationError,33524,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,3,['Validat'],['ValidationError']
Security,"e(r'\A(?P<module>\w+__)?(?P<option>\w+)\Z', re.IGNORECASE); rejected = {}. for k, v, in options_dict.items():. mobj = optionre.match(k.strip()); module = mobj.group('module').upper()[:-2] if mobj.group('module') else None; option = mobj.group('option').upper(). if module:; if ((module, option, v) not in [('SCF', 'GUESS', 'READ')]) and ((module, option) not in [('PCM', 'INPUT')]):; # TODO guess/read exception is for distributed driver. should be handled differently.; try:; core.set_local_option(module, option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_local_option', module, option, v). if (module, option) == (""PCM"", ""INPUT""):; pcm_helper(v). else:; try:; core.set_global_option(option, v); except RuntimeError as err:; rejected[k] = (v, err); if verbose > 1:; print('Setting: core.set_global_option', option, v). if rejected:; raise ValidationError(f'Error setting options: {rejected}'). # TODO could subclass ValidationError and append rejected so that run_json could handle remanants. [docs]; def set_module_options(module: str, options_dict: Dict[str, Any]) -> None:; """"""; Sets Psi4 module options from a module specification and input dictionary. .. deprecated:: 1.5; Use :py:func:`psi4.driver.p4util.set_options` instead. """"""; warnings.warn(; ""Using `psi4.set_module_options(<module>, {<key>: <val>})` instead of `psi4.set_options({<module>__<key>: <val>})` is deprecated, and as soon as 1.5 it will stop working\n"",; category=FutureWarning,; stacklevel=2). for k, v, in options_dict.items():; core.set_local_option(module.upper(), k.upper(), v). ## OEProp helpers. [docs]; def pcm_helper(block: str):; """"""Helper to specify the multiline PCMSolver syntax for PCM.; Prefer to use :py:func:`set_options` with key ``""PCM__INPUT""``. Parameters; ----------; block; Text that goes in a PSIthon ``pcm = {...}`` block. """"""; import pcmsolver. # delete=True works for Unix but not for Windows; with NamedTemporaryFile(mode=""w+t"", delete=False",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:17828,Validat,ValidationError,17828,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,3,['Validat'],['ValidationError']
Security,"e); if level:; kwargs['level'] = level. try:; # Set method-dependent scf convergence criteria; if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 6). procedures['energy'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). optstash.restore(); return PsiMod.get_variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:30261,Validat,ValidationError,30261,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"e); metadata['molecule'] = kwargs.pop('molecule', core.get_active_molecule()); metadata['molecule'].update_geometry(); metadata['molecule'].fix_com(True); metadata['molecule'].fix_orientation(True); metadata['embedding_charges'] = kwargs.get('embedding_charges', False); metadata['kwargs'] = kwargs; core.clean_variables(). if metadata['ptype'] not in ['energy', 'gradient', 'hessian']:; raise ValidationError(""""""N-Body driver: The ptype '%s' is not regonized."""""" % metadata['ptype']). # Parse bsse_type, raise exception if not provided or unrecognized; metadata['bsse_type_list'] = kwargs.pop('bsse_type'); if metadata['bsse_type_list'] is None:; raise ValidationError(""N-Body GUFunc: Must pass a bsse_type""); if not isinstance(metadata['bsse_type_list'], list):; metadata['bsse_type_list'] = [metadata['bsse_type_list']]. for num, btype in enumerate(metadata['bsse_type_list']):; metadata['bsse_type_list'][num] = btype.lower(); if btype.lower() not in ['cp', 'nocp', 'vmfc']:; raise ValidationError(""N-Body GUFunc: bsse_type '%s' is not recognized"" % btype.lower()). metadata['max_nbody'] = kwargs.get('max_nbody', -1); metadata['max_frag'] = metadata['molecule'].nfragments(); if metadata['max_nbody'] == -1:; metadata['max_nbody'] = metadata['molecule'].nfragments(); else:; metadata['max_nbody'] = min(metadata['max_nbody'], metadata['max_frag']). # Flip this off for now, needs more testing; # If we are doing CP lets save them integrals; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # # Set to save RI integrals for repeated full-basis computations; # ri_ints_io = core.get_global_option('DF_INTS_IO'). # # inquire if above at all applies to dfmp2 or just scf; # core.set_global_option('DF_INTS_IO', 'SAVE'); # psioh = core.IOManager.shared_object(); # psioh.set_specific_retention(97, True). bsse_str = metadata['bsse_type_list'][0]; if len(metadata['bsse_type_list']) > 1:; bsse_str = str(metadata['bsse_type_list']); core.print_out(""\n\n""); core.print_out("" ===> N-Body Inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html:7716,Validat,ValidationError,7716,psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_nbody.html,1,['Validat'],['ValidationError']
Security,"e* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`.; *self* may be either a qcdb.Molecule (sensibly) or a psi4.Molecule; (works b/c psi4.Molecule has been extended by this method py-side and; only public interface fns used) or a string that can be instantiated; into a qcdb.Molecule. """"""; # Create (if necessary) and update qcdb.Molecule; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.core.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; # elif der2nd.match(str(dertype)):; # raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html:2930,Validat,Validate,2930,psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,2,['Validat'],['Validate']
Security,"e, ""run_ccsd"": False, ""compute_triples"": False, },; ""fno-qcisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },. ""qcisd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },; ""fno-qcisd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"",",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:172938,Validat,ValidationError,172938,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"e, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ValidationError(""Molecule::init_with_mol2: Malformed Natom\n%s"" % (str(fileNatom))). # Next line begins the useful information.; for i in range(fileNatom):; try:; if xyzM.mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html:7329,Validat,ValidationError,7329,psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qcdb/molecule.html,8,['Validat'],['ValidationError']
Security,"e, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). return psi4.adc(ref_wfn). [docs]def run_dft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-functional-theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). scf_wfn = run_scf(name, **kwargs); returnvalue = psi4.get_variable('CURRENT ENERGY'). for ssuper in superfunctional_list():; if ssuper.name().lower() == name:; dfun = ssuper. if dfun.is_c_hybrid():; if dfun.is_c_scs_hybrid():; psi4.set_local_option('DFMP2', 'MP2_OS_SCALE', dfun.c_os_alpha()); psi4.set_local_option('DFMP2', 'MP2_SS_SCALE', dfun.c_ss_alpha()); dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfun.c_alpha() * psi4.get_variable('SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = psi4.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = dfun.c_alpha() * psi4.get_variable('MP2 CORRELATION ENERGY'). # TODO: delete these variables, since they don't mean what they look to mean?; # 'MP2 TOTAL ENERGY',; # 'MP2 CORRELATION ENERGY',; # 'MP2 SAME-SPIN CORRELATION ENERGY']. psi4.set_variable('DOUBLE-HYBRID CORRECTION ENERGY', vdh); returnvalue += vdh; psi4.set_variable('DFT TOTAL ENERGY', returnvalue); psi4.set_variable(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:70768,Validat,ValidationError,70768,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['Validat'],['ValidationError']
Security,"e, **kwargs):; """"""Function encoding sequence of PSI module calls for; an algebraic diagrammatic construction calculation. .. caution:: Get rid of active molecule lines- should be handled in energy. """"""; if core.get_option('ADC', 'REFERENCE') != 'RHF':; raise ValidationError('ADC requires reference RHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). return core.adc(ref_wfn). def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.backends import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ""NUM_CORE_ORBITALS""). scf_accuracy = max(core.get_option(""SCF"", ""E_CONVERGENCE""),; core.get_option(""SCF"", ""D_CONVERGENCE"")); if core.get_option(""ADC"", ""R_CONVERGENCE"") < ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:110789,Validat,ValidationError,110789,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Validat'],['ValidationError']
Security,"e, database()¶; Code author: Lori A. Burns; Section author: Lori A. Burns. database(name, db_name[, func, mode, cp, rlxd, symm, zpe, benchmark, tabulate, subset])[source]¶; Function to access the molecule objects and reference energies of; popular chemical databases. Aliases:db(). Returns:(float) Mean absolute deviation of the database in kcal/mol. PSI variables:. db_name DATABASE MEAN SIGNED DEVIATION; db_name DATABASE MEAN ABSOLUTE DEVIATION; db_name DATABASE ROOT-MEAN-SQUARE DEVIATION; Python dictionaries of results accessible as DB_RGT and DB_RXN. Note; It is very easy to make a database from a collection of xyz files; using the script psi4/share/scripts/ixyz2database.py.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a Psi4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:1121,access,access,1121,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,2,['access'],['access']
Security,"e, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False)¶; Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict) → psi4.core.Molecule¶; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1)¶; Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict) – Dictionary form of Molecule following known schema.; return_dict (bool) – Additionally return Molecule dictionary intermediate.; nonphysical (bool) – Do allow masses outside an element’s natural range to pass validation?; verbose (int) – Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict) – Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1)¶. fsymbol(self: psi4.core.Molecule, atom: int) → str¶; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int) → int¶; Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self: psi4.core.Molecule) → psi4.core.Matrix¶; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self: psi4.core.Molecule) → int¶; Gets n in Cnv, etc.; If there is no n (e.g. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html:21210,validat,validation,21210,psi4manual/1.7.x/api/psi4.core.Molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Molecule.html,4,['validat'],['validation']
Security,"e, setting; REFERENCE will appropriately set CFOUR_REFERENCE. For a; list of applicable keywords, see source of; qcdb.cfour.muster_psi4options().; Consult Functionality for information on what Cfour; functionality is accessible through Psi4. Psi4 for Cfour Users¶; In the simplest use of the Psi4/Cfour interface, a Psi4 input file; can simply “wrap” a ZMAT file and execute xcfour. This is; illustrated in the following example:; cfour {; UHF-SCF energy calculation; N; H 1 R; H 1 R 2 A. R=1.008; A=105.0. *ACES2(CALC=HF,BASIS=qz2p; MULT=2,REF=UHF; OCCUPATION=3-1-1-0/3-0-1-0; SCF_CONV=12; MEMORY=20000000); }. energy('cfour'). Here, the contents of the cfour {...} block are written directly to a; ZMAT file. This is joined by a default GENBAS file; (psi4/share/basis/GENBAS). To preferentially use your own GENBAS,; place it in PATH or PSIPATH. The line calling; energy() with argument 'cfour' invokes; xcfour.; After execution of the energy('cfour') line completes, Cfour results; are read back into Psi4 format and are thereafter accessible for; further processing in the input file. See Output for; details. This storage of results in variables and arrays in memory for; the duration of the Psi4 instance (as opposed to solely in files); is the only advantage thus far incurred by the P4C4 interface. We’ll call; this mode of basic utility the “sandwich” mode.; Molecule specification in Psi4 allows Cartesians, Z-matrices, mixed; Cartesian/Z-matrix, negation of variables, delayed specification of; variables, specification of fragments, etc., all in a whitespace-tolerant; format. See Molecule and Geometry Specification for details and; cfour/mints5 for examples. When a Psi4-style molecule is; supplied, its geometry is written to ZMAT in Cartesian form and the; CFOUR_COORDINATES=CARTESIAN, CFOUR_UNITS=ANGSTROM,; CFOUR_CHARGE, and CFOUR_MULTIPLICITY keywords are set; appropriately in the *CFOUR(...) directive. Warning; There exist molecules (e.g., allene) where the; inertial frame is no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:3694,access,accessible,3694,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['access'],['accessible']
Security,"e,; always_return_iutau=False,; ):; molinit = {}. if name is not None:; molinit[""name""] = name. if comment is not None:; molinit[""comment""] = comment. def validate_provenance(dicary):; expected_prov_keys = [""creator"", ""routine"", ""version""]; try:; prov_keys = sorted(dicary.keys()); except AttributeError:; raise ValidationError(""Provenance entry is not dictionary: {}"".format(dicary)). if prov_keys == expected_prov_keys:; if not isinstance(dicary[""creator""], str):; raise ValidationError(; """"""Provenance key 'creator' should be string of creating program's name: {}"""""".format(; dicary[""creator""]; ); ); if not re.fullmatch(VERSION_PATTERN, dicary[""version""], re.VERBOSE):; raise ValidationError(; """"""Provenance key 'version' should be a valid PEP 440 string: {}"""""".format(dicary[""version""]); ); if not isinstance(dicary[""routine""], str):; raise ValidationError(; """"""Provenance key 'routine' should be string of creating function's name: {}"""""".format(; dicary[""routine""]; ); ); return True; else:; raise ValidationError(""Provenance keys ({}) incorrect: {}"".format(expected_prov_keys, prov_keys)). if provenance is None:; molinit[""provenance""] = {}; else:; if validate_provenance(provenance):; molinit[""provenance""] = deepcopy(provenance). if connectivity is not None:; conn = []; try:; for (at1, at2, bondorder) in connectivity:; if not (float(at1)).is_integer() or at1 < 0: # or at1 >= nat:; raise ValidationError(""""""Connectivity first atom should be int [0, nat): {}"""""".format(at1)); if not (float(at2)).is_integer() or at2 < 0: # or at2 >= nat:; raise ValidationError(""""""Connectivity second atom should be int [0, nat): {}"""""".format(at2)); if bondorder < 0 or bondorder > 5:; raise ValidationError(""""""Connectivity bond order should be float [0, 5]: {}"""""".format(bondorder)); conn.append((int(min(at1, at2)), int(max(at1, at2)), float(bondorder))); conn.sort(key=lambda tup: tup[0]); molinit[""connectivity""] = conn; except ValueError:; raise ValidationError(; ""Connectivity entry is not of form [(at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:13264,Validat,ValidationError,13264,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"e. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:62986,access,accesses,62986,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['access'],['accesses']
Security,"e. >>> H2OH2O.save_xyz('h2o.xyz'). """"""; outfile = open(filename, 'w'); outfile.write(self.save_string_xyz(save_ghosts)); outfile.close(). [docs] def save_to_checkpoint(self, chkpt, prefix=""""):; """""" **NYI** Save information to checkpoint file; (method name in libmints is save_to_chkpt). """"""; raise FeatureNotImplemented('Molecule::save_to_checkpoint') # FINAL. # <<< Methods for Symmetry >>>. [docs] def has_symmetry_element(self, op, tol=DEFAULT_SYM_TOL):; """""" **NYI** Whether molecule satisfies the vector symmetry; operation *op*. Not used by libmints. """"""; raise FeatureNotImplemented('Molecule::has_symmetry_element') # FINAL; for i in range(self.natom()):; result = naivemult(self.xyz(i), op); atom = self.atom_at_position(result, tol). if atom != -1:; if not self.atoms[atom].is_equivalent_to(self.atoms[i]):; return False; else:; return False; return True. [docs] def point_group(self):; """"""Returns the point group (object) if set""""""; if self.pg is None:; raise ValidationError(""Molecule::point_group: Molecular point group has not been set.""); return self.pg. [docs] def set_point_group(self, pg):; """"""Set the point group to object *pg* """"""; self.pg = pg; # Call this here, the programmer will forget to call it, as I have many times.; self.form_symmetry_information(). [docs] def set_full_point_group(self, tol=FULL_PG_TOL):; """"""Determine and set FULL point group. self.PYfull_pg_n is highest; order n in Cn. 0 for atoms or infinity. """"""; verbose = 1 # TODO; # Get cartesian geometry and put COM at origin; geom = self.geometry(); com = self.center_of_mass(); for at in range(self.natom()):; geom[at][0] += -com[0]; geom[at][1] += -com[1]; geom[at][2] += -com[2]. # Get rotor type; rotor = self.rotor_type(tol); if verbose > 2:; print("""""" Rotor type : %s"""""" % (rotor)). # Get the D2h point group from Jet and Ed's code: c1 ci c2 cs d2 c2v c2h d2h; # and ignore the user-specified subgroup in this case.; pg = self.find_highest_point_group(tol); d2h_subgroup = pg.symbol(); if verbose > 2:; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html:61990,Validat,ValidationError,61990,psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"e.IntegralTransform.FrozenOrbitals attribute, [1]. visualization, [1]. VMDPATH. vmfc. ; setting keywords. vv10_b() psi4.core.SuperFunctional method, [1], [2]. vv10_c() psi4.core.SuperFunctional method, [1], [2]. Vvals() psi4.core.OEProp method, [1], [2]. W. w() psi4.core.BlockOPoints method, [1], [2]. WABEI_LOWDISK (CCHBAR). Wavefunction class in psi4.core, [1]. WebMO. WFN (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (CCTRIPLES). (DETCI). (GLOBALS). (SCF). WFN_SYM (MCSCF). (PSIMRCC). WFN_TYPE (DFOCC). (OCC). with_traceback() psi4.driver.ConvergenceError method. psi4.driver.CSXError method. psi4.driver.Dftd3Error method. psi4.driver.ManagedMethodError method. psi4.driver.OptimizationConvergenceError method. psi4.driver.ParsingError method. psi4.driver.PastureRequiredError method. psi4.driver.PsiException method. psi4.driver.PsiImportError method. psi4.driver.SCFConvergenceError method. psi4.driver.TestComparisonError method. psi4.driver.ValidationError method. wK() psi4.core.JK method, [1], [2]. psi4.core.MemDFJK method, [1]. write() psi4.core.CIVector method, [1], [2]. psi4.core.FCHKWriter method, [1], [2]. psi4.core.MOWriter method, [1], [2]. psi4.core.MoldenWriter method, [1], [2]. psi4.core.NBOWriter method, [1], [2]. write_eigenvalues() in module psi4.driver. WRITE_NOS (CCDENSITY). write_scratch_file() psi4.core.IOManager method, [1], [2]. WRITER_FILE_LABEL (GLOBALS). X. x() psi4.core.BlockOPoints method, [1], [2]. X() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. x() psi4.core.Molecule method, [1], [2]. X() psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. x_alpha() psi4.core.SuperFunctional method, [1], [2]. x_beta() psi4.core.SuperFunctional method, [1], [2]. x_functional() psi4.core.SuperFunctional method, [1], [2]. x_function",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:149160,Validat,ValidationError,149160,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['Validat'],['ValidationError']
Security,"e.Vector`; Pointers to which Psi4 core class should be used in the construction.; copy : bool, optional; Copy the data if `True`, return a view otherwise; dense : bool, optional; Converts irreped Psi4 objects to diagonally blocked dense arrays if `True`. Returns a list of arrays otherwise. Returns; -------; array : ndarray or list of ndarray; Returns either a list of np.array's or the base array depending on options. Notes; -----; This is a generalized function to convert a Psi4 object to a NumPy array. Examples; --------. >>> data = psi4.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]; """"""; if matrix.nirrep() > 1:. # We will copy when we make a large matrix; if dense:; copy = False. matrix_views = _get_raw_views(matrix, copy=copy). # Return the list of arrays; if dense is False:; return matrix_views. # Build the dense matrix; if isinstance(matrix, core.Vector):; ret_type = '1D'; elif isinstance(matrix, core.Matrix):; ret_type = '2D'; else:; raise ValidationError(""Array_to_Matrix: type '%s' is not recognized."" % type(matrix)). dim1 = []; dim2 = []; for h in matrix_views:; # Ignore zero dim irreps; if 0 in h.shape:; dim1.append(0); dim2.append(0); else:; dim1.append(h.shape[0]); if ret_type == '2D':; dim2.append(h.shape[1]). ndim1 = np.sum(dim1); ndim2 = np.sum(dim2); if ret_type == '1D':; dense_ret = np.zeros(shape=(ndim1)); start = 0; for d1, arr in zip(dim1, matrix_views):; if d1 == 0: continue; dense_ret[start:start + d1] = arr; start += d1; else:; dense_ret = np.zeros(shape=(ndim1, ndim2)); start1 = 0; start2 = 0; for d1, d2, arr in zip(dim1, dim2, matrix_views):; if (d1 == 0) or (d2 == 0): continue. dense_ret[start1:start1 + d1, start2:start2 + d2] = arr; start1 += d1; start2 += d2. return dense_ret. else:; return _get_raw_views(matrix, copy=copy)[0]. @property; def _np_shape(self):; """"""; Shape of the Psi4 data object; """"""; view_data = _get_raw_views(self); if self.nirrep() > 1:; return tuple(view_data[x].shape for x in range(self.nir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html:6621,Validat,ValidationError,6621,psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/numpy_helper.html,2,['Validat'],['ValidationError']
Security,"e.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:99021,Validat,ValidationError,99021,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Validat'],['ValidationError']
Security,"e.append(prop); elif prop in twoel_properties:; two.append(prop); elif prop in response_properties:; response.append(prop); elif prop in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(""""""CC property name %s not recognized"""""" % name.upper()). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:78273,Validat,ValidationError,78273,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"e.natom() > 1) or core.get_option('SCF', 'SAD_FRAC_OCC')):; core.set_local_option('SCF', 'GUESS', 'SAD'); elif core.get_option('SCF', 'REFERENCE') in ['ROHF', 'ROKS', 'UHF', 'UKS']:; core.set_local_option('SCF', 'GUESS', 'GWH'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') == '':; if name == 'hf3c':; core.set_global_option('BASIS', 'minix'); elif name == 'pbeh3c':; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast or do_broken:; # Cast or broken are special cases; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); ref_wfn = scf_wavefunction_factory(core.get_option('SCF', 'REFERENCE'), base_wfn); core.set_legacy_wavefunction(ref_wfn). # Compute dftd3; if ""_disp_functor"" in dir(ref_wfn):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variables(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # broken clean-up; if do_broken:; raise ValidationError(""Broken Symmetry computations are temporarily disabled.""); scf_molecule.set_multiplicity(1); core.set_local_option('SCF', 'GUESS', 'READ'); core.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); core.print_out('\n'). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). # Set to read and project, and reset bases to final ones; optstash2.restore(); core.set_local_option('SCF', 'GUESS', 'READ'). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'). # EFP preparation; efp = core.get_active_efp(); if efp.nfragments() > 0:; core.set_legacy_molecule(scf_molecule); core.set_global_option('QMEFP', True) # apt to go haywire if set locally to efp; core.efp_set_options(); efp.set_qm_atoms(); efp.print_out(). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:33564,Validat,ValidationError,33564,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"e.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:83711,Validat,ValidationError,83711,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"e.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]; def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html:9789,Validat,ValidationError,9789,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs_helper.html,3,['Validat'],['ValidationError']
Security,"e.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float or ndarray; Eponymous function applied to input zetas and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html:9739,Validat,ValidationError,9739,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"e.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""; cbsscheme += name_str + ':'; cbsscheme += "" "" * (18 - len(name_str)); cbsscheme += """"""% 16.12f\n\n"""""" % value; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. elif isinstance(valueLO, np.ndarray):. beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose > 2:; cbsscheme = f""""""\n ==> Truhlar 2-point power SCF extrapolation for method: {functionname.upper()} <==\n""""""; cbsscheme += f""""""\n LO-zeta ({zLO}) Data\n""""""; cbsscheme += nppp(valueLO); cbsscheme += f""""""\n HI-zeta ({zHI}) Data\n""""""; cbsscheme += nppp(valueHI). cbsscheme += f""""""\n Alpha (exponent) Value: {alpha:16.8f}""""""; cbsscheme += f""""""\n Beta Data\n""""""; cbsscheme += nppp(beta); cbsscheme += f""""""\n Extrapolated Data\n""""""; cbsscheme += nppp(value); cbsscheme += ""\n""; core.print_out(cbsscheme); logger.debug(cbsscheme). return value. else:; raise ValidationError(f""scf_xtpl_truhlar_2: datatype is not recognized '{type(valueLO)}'.""). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: Extrapolatable, zHI: int, valueHI: Extrapolatable, verbose: int = 1, alpha: Optional[float] = None) -> Extrapolatable:; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.driver.cbs`. Parameters; ----------; functionname; Name of the CBS component (e.g., 'HF') used in summary printing.; zLO; Zeta number of the smaller basis set in 2-point extrapolation.; valueLO; Energy, gradient, or Hessian value at the smaller basis set in 2-point; extrapolation.; zHI; Zeta number of the larger basis set in 2-point extrapolation; Must be `zLO + 1`.; valueHI; Energy, gradient, or Hessian value at the larger basis set in 2-point; extrapolation.; verbose; Controls volume of printing.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float or ~numpy.ndarray; Eponymous function applied to in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html:9781,Validat,ValidationError,9781,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs_helper.html,1,['Validat'],['ValidationError']
Security,"e2 = '.dftd3par.local' # new mainline name; with open(paramfile2, 'w') as handle:; handle.write(paramcontents). # Write dftd3_geometry file that supplies geometry to dispersion calc; numAtoms = self.natom(); geom = self.save_string_xyz(); reals = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; numAtoms -= 1; else:; reals.append(line). geomtext = str(numAtoms) + '\n\n'; for line in reals:; geomtext += line.strip() + '\n'; geomfile = './dftd3_geometry.xyz'; with open(geomfile, 'w') as handle:; handle.write(geomtext); # TODO somehow the variations on save_string_xyz and; # whether natom and chgmult does or doesn't get written; # have gotten all tangled. I fear this doesn't work; # the same btwn libmints and qcdb or for ghosts. # Call dftd3 program; command = ['dftd3', geomfile]; if dertype != 0:; command.append('-grad'); try:; dashout = subprocess.Popen(command, stdout=subprocess.PIPE, env=lenv); except OSError as e:; raise ValidationError('Program dftd3 not found in path. %s' % e); out, err = dashout.communicate(). # Parse output (could go further and break into E6, E8, E10 and Cn coeff); success = False; for line in out.splitlines():; if re.match(' Edisp /kcal,au', line):; sline = line.split(); dashd = float(sline[3]); if re.match(' normal termination of dftd3', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful run. Possibly -D variant not available in dftd3 version.""""""). # Parse grad output; if dertype != 0:; derivfile = './dftd3_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program dftd3 gradient file has %d atoms- %d expected.' % \; (le",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html:7244,Validat,ValidationError,7244,psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/interface_dftd3.html,1,['Validat'],['ValidationError']
Security,"e:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optki",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:71123,Validat,ValidationError,71123,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Validat'],['ValidationError']
Security,"e:; pass; else:; psi4.set_local_option('SCF','REFERENCE','UHF'); return optstash. [docs]def dft_set_reference_local(name):; """"""; Figures out the correct DFT reference to set locally; """""". optstash = p4util.OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'REFERENCE'],; ['SCF', 'SCF_TYPE'],; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'). psi4.set_local_option('SCF', 'DFT_FUNCTIONAL', name). user_ref = psi4.get_option('SCF', 'REFERENCE'); if (user_ref == 'RHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; psi4.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'). return optstash. [docs]def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES',; 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MAYER_INDICES',; 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI',; 'NO_OCCUPATIONS']. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)); . [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on input SCF type.; """""". if scf_type in ['DF', 'CD', 'PK', 'DIRECT']:; mints = psi4.MintsHelper(wfn.basisset(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html:3311,Validat,Validations,3311,psi4manual/1.0.0/_modules/procedures/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc_util.html,1,['Validat'],['Validations']
Security,e:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation and counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CPRLX; RXNM = database.RXNM_CPRLX; elif no.match(str(db_cp)):; try:; database.ACTV_RLX; except AttributeError:; raise ValidationError('Deformation correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_RLX; elif no.match(str(db_rlxd)):; pass; else:; raise ValidationError('Deformation correction mode \'%s\' not valid.' % (db_rlxd)). # Option zero-point-correction- whether for thermochem databases jobs are corrected by zpe; db_zpe = 'no'; if 'zpe' in kwargs:; db_zpe = kwargs['zpe']. if yes.match(str(db_zpe)):; raise ValidationError('Zero-point-correction mode \'yes\' not yet implemented.'); elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:33753,Validat,ValidationError,33753,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,3,['Validat'],['ValidationError']
Security,"e; if isinstance(self, Molecule):; # called on a qcdb.Molecule; pass; elif isinstance(self, core.Molecule):; # called on a python export of a psi4.core.Molecule (py-side through Psi4's driver); self.create_psi4_string_from_molecule(); elif isinstance(self, basestring):; # called on a string representation of a psi4.Molecule (c-side through psi4.Dispersion); self = Molecule(self); else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); self.update_geometry(). # # Validate arguments; # dashlvl = dashlvl.lower(); # dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; # if dashlvl not in dashcoeff.keys():; # raise ValidationError(""""""-D correction level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; # elif der2nd.match(str(dertype)):; # raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]; # else:; # raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); # else:; # func = func.lower(); # if func not in dashcoeff[dashlvl].keys():; # raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); # if dashparam ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html:3407,Validat,ValidationError,3407,psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,2,['Validat'],['ValidationError']
Security,"e>.*cc-.*|def2-|.*pcs+eg-|.*)\[(?P<zeta>[dtq2345678,s1]*)\](?P<post>.*z.*|)$', re.IGNORECASE); pc_basis = re.compile(r'.*pcs+eg-$', re.IGNORECASE); def2_basis = re.compile(r'def2-', re.IGNORECASE); zapa_basis = re.compile(r'.*zapa.*', re.IGNORECASE). if legit_compound_basis.match(basisstring):; basisname = legit_compound_basis.match(basisstring); # handle def2-svp* basis sets as double-zeta; if def2_basis.match(basisname.group('pre')):; bn_gz = basisname.group('zeta').replace(""s"", ""d""); # handle pc-n basis set polarisation -> zeta conversion; elif pc_basis.match(basisname.group('pre')):; bn_gz = basisname.group('zeta').replace(""4"", ""5"").replace(""3"", ""4"").replace(""2"", ""3"").replace(""1"", ""2""); else:; bn_gz = basisname.group('zeta'); # filter out commas and be forgiving of e.g., t5q or 3q; zetas = [z for z in zeta_values if (z in bn_gz or str(zeta_values.index(z) + 2) in bn_gz)]; for b in zetas:; if ZSET and (int(ZSET[len(ZSET) - 1]) - zeta_values.index(b)) != 1:; raise ValidationError(""""""Basis set '%s' has skipped zeta level '%s'."""""" %; (basisstring, _zeta_val2sym[_zeta_sym2val[b] - 1])); # reassemble def2-svp* properly instead of def2-dzvp*; if def2_basis.match(basisname.group('pre')) and b == ""d"":; BSET.append(basisname.group('pre') + ""s"" + basisname.group('post')[1:]); # reassemble pc-n basis sets properly; elif pc_basis.match(basisname.group('pre')):; BSET.append(basisname.group('pre') + ""{0:d}"".format(_zeta_sym2val[b] - 1)); # assemble nZaPa basis sets; elif zapa_basis.match(basisname.group('post')):; bzapa = b.replace(""d"", ""2"").replace(""t"", ""3"").replace(""q"", ""4""); BSET.append(basisname.group('pre') + bzapa + basisname.group('post')); else:; BSET.append(basisname.group('pre') + b + basisname.group('post')); ZSET.append(zeta_values.index(b) + 2); elif re.match(r'.*\[.*\].*$', basisstring, flags=re.IGNORECASE):; raise ValidationError(; """"""Basis series '%s' invalid. Specify a basis series matching""""""; """""" '*cc-*[dtq2345678,]*z*'. or 'def2-[sdtq]zvp*' or '*pcs[s]eg-[12",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:3965,Validat,ValidationError,3965,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,7,['Validat'],['ValidationError']
Security,"eLO)). [docs]def scf_xtpl_karton_2(functionname: str, zLO: int, valueLO: float, zHI: int, valueHI: float, verbose: bool = True, alpha: float = None):; r""""""Extrapolation scheme using root-power form for reference energies with two adjacent; zeta-level bases. Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname; Name of the CBS component.; zLO; Lower zeta level.; valueLO; Lower value used for extrapolation.; zHI; Higher zeta level. Should be equal to zLO + 1.; valueHI; Higher value used for extrapolation.; alpha; Overrides the default :math:`\alpha = 6.3`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [3]_:; :math:`E_{total}^X = E_{total}^{\infty} + \beta e^{-\alpha\sqrt{X}}, \alpha = 6.3`. References; ----------. .. [3] Karton, Martin, Theor. Chem. Acc. 115 (2006) 330-333,; DOI: 10.1007/s00214-005-0028-6. """""". if type(valueLO) != type(valueHI):; raise ValidationError(; ""scf_xtpl_karton_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 6.30. beta_division = 1 / (math.exp(-1 * alpha) * (math.exp(math.sqrt(zHI)) - math.exp(math.sqrt(zLO)))); beta_mult = math.exp(-1 * alpha * math.sqrt(zHI)). if isinstance(valueLO, float):; beta = (valueHI - valueLO) * beta_division; value = valueHI - beta * beta_mult. if verbose:; # Output string with extrapolation parameters; cbsscheme = ''; cbsscheme += """"""\n ==> Karton 2-point power form SCF extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % (alpha); cbsscheme += """""" Beta (coefficient) Value: % 16.12f\n\n"""""" % (beta). name_str = ""%s/(%s,%s)"" % (functionname.upper(), _zeta_val2sym[zLO].upper(), _zeta_val2sym[zHI].upper()); cbsscheme += """""" @Extrapolated """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:14416,Validat,ValidationError,14416,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,2,['Validat'],['ValidationError']
Security,"e[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}_basis"" in kwargs:; # either both *_wfn and *_basis have to be specified; stage = {""wfn"": kwargs[f""{sn}_wfn""], ""basis"": kwargs[f""{sn}_basis""]}; elif sn == ""scf"" and f""{sn}_basis"" in kwargs:; # or we're at a scf stage which can be implied with a provided scf_basis; stage = {""wfn"": ""hf"", ""basis"": kwargs[f""{sn}_basis""]}; else:; # otherwise go to the next possible stage; continue; # if we made it here, stage exists - parse other keywords; if f""{sn}_scheme"" in kwargs:; stage[""scheme""] = kwargs[f""{sn}_scheme""]; if f""{sn}_wfn_lesser"" in kwarg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html:32427,validat,validate,32427,psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_cbs.html,4,"['Validat', 'validat']","['ValidationError', 'validate']"
Security,"e[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(metadata) == 0:; stage[""stage""] = ""scf""; elif len(metadata) == 1:; stage[""stage""] = ""corl""; else:; stage[""stage""] = f""delta{len(metadata) - 1}""; stage[""scheme""] = item.get(""scheme"", _get_default_xtpl(len(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({}) and low ({}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); stage[""options_lo""] = item.get(""options_lo"", False); metadata.append(stage); return metadata. def _process_cbs_kwargs(kwargs: Dict) -> CBSMetadata:; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs; kwargs containing the CBS function specification. Returns; -------; cbs_metadata; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationError(""Delta function supplied without corl_wfn defined.""); if ""delta2_wfn"" in kwargs and ""delta_wfn"" not in kwargs:; raise ValidationError(""Second delta function supplied without delta_wfn defined.""); cbs_metadata = []; possible_stages = [""scf"", ""corl""]; while len(possible_stages) > 0:; sn = possible_stages.pop(0); if f""{sn}_wfn"" in kwargs and f""{sn}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:19850,validat,validation,19850,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,5,['validat'],['validation']
Security,"e__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re; import numpy as np. from psi4 import extras; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.p4util.exceptions import *; from psi4.driver.molutil import *. from .roa import *; from . import proc_util; from . import empirical_dispersion; from . import dft_functional; from . import mcscf. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:2371,validat,validation,2371,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['validat'],['validation']
Security,"e__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners). try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; optstash.restore(); return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies); ; # The last item in the list is the reference energy, return it; optstash.restore(); return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:40267,Validat,ValidationError,40267,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"e__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from each displaced geometry output file and save in energies array; elif (opt_mode.lower() == 'reap'):; E = 0.0; exec(banners). try:; freagent = open('%s.out' % (rfile), 'r'); except IOError:; ValidationError('Aborting upon output file \'%s.out\' not found.\n' % (rfile)); return 0.0; else:; while 1:; line = freagent.readline(); if not line:; if E == 0.0:; ValidationError('Aborting upon output file \'%s.out\' has no %s RESULT line.\n' % (rfile, 'GRADIENT')); break; s = line.split(); if (len(s) != 0) and (s[0:3] == ['GRADIENT', 'RESULT:', 'computation']):; if int(s[3]) != opt_linkage:; raise ValidationError('Output file \'%s.out\' has linkage %s incompatible with master.in linkage %s.'; % (rfile, str(s[3]), str(opt_linkage))); if s[6] != str(n + 1):; raise ValidationError('Output file \'%s.out\' has nominal affiliation %s incompatible with item %s.'; % (rfile, s[6], str(n + 1))); if (s[8:10] == ['electronic', 'energy']):; E = float(s[10]); PsiMod.print_out('%s RESULT: electronic energy = %20.12f\n' % ('GRADIENT', E)); freagent.close(); energies.append(E). # S/R: Quit sow after writing files; if (opt_mode.lower() == 'sow'):; return 0.0. if (opt_mode.lower() == 'reap'):; PsiMod.set_variable('CURRENT ENERGY', energies[-1]). # Obtain the gradient; PsiMod.fd_1_0(energies). # The last item in the list is the reference energy, return it; return energies[-1]. [docs]def property(name, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present handles property functions only for CC methods.; Consult the keywords sections for other modules for further property capabilities. +--------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:31824,Validat,ValidationError,31824,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Validat'],['ValidationError']
Security,"e_full). PsiMod.print_out(""\n""); banner(""CP Computation: Results.""); PsiMod.print_out(""\n""). banner(""Hartree"", 2); PsiMod.print_out(""\n""). PsiMod.print_out(str(cp_table)). PsiMod.print_out(""\n""); banner(""kcal*mol^-1"", 2); PsiMod.print_out(""\n""). cp_table.scale(). PsiMod.print_out(str(cp_table)); return e_full. ## Aliases ##; counterpoise_correct = cp; counterpoise_correction = cp. #################; ## End of cp ##; #################. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour| ; distribution, add the path to the directory containing the database ; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:23171,access,accessible,23171,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['access'],['accessible']
Security,"e_list`. Keys are _f_fields. Formerly JOBS_EXT.; trove: List[Dict[str, Any]] = []. # Minimal (enlightened) list of jobs to run to satisfy full CBS. Keys are _f_fields. Formerly JOBS.; compute_list: List[Dict[str, Any]] = []. # One-to-One list of AtomicComputer-s corresponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested lesser {delta[""treament""]} method '{delta[""wfn_lo""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ). self.cbsrec, self.compute_list, self.trove = _build_cbs_compute(self.metameta, self.metadata). for job in self.compute_list:; keywords = copy.deepcopy(self.metameta['kwargs']['keywords']); if job[""f_options""] is not False:; stage_keywords = dict(job[""f_options""].items()); keywords = {**keywords, **stage_keywords}; task = AtomicComputer(; **{; ""molecule"": self.molecule,; ""driver"": self.driver,; ""method"": job[""f_wfn""],; ""bas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:53879,Validat,ValidationError,53879,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"e_psimrcc. [docs]def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """""". run_scf(name, **kwargs); PsiMod.psimrcc(); e_psimrcc = PsiMod.get_variable(""Current Energy""); return e_psimrcc. [docs]def run_mp2c(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a coupled MP2 calculation. """"""; optstash = OptionsState(; ['DF_BASIS_MP2']). molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Dimer DFMP2'); PsiMod.print_out('\n'); e_dimer_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer A DFMP2'); PsiMod.print_out('\n');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:30334,Validat,ValidationError,30334,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Validat'],['ValidationError']
Security,"ec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the difference and; # (2) return the from_arrays filled-in values; # * from.arrays is expecting speclabel ""Co_userlbl"" for elbl, but we're; # sending ""_userlbl"", hence speclabel=False; forgive = ['elea']. # * from_arrays and comparison lines below are quite unnecessary to; # to_dict, but is included as a check. in practice, only fills in mass; # numbers and heals user chgmult.; try:; validated_molrec = molparse.from_arrays(speclabel=False, verbose=0, domain='qm', **molrec); except ValidationError as err:; # * this can legitimately happen if total chg or mult has been set; # independently b/c fragment chg/mult not reset. so try again.; print('Have you been meddling with chgmult?'); molrec['fragment_charges'] = [None] * len(fragments); molrec['fragment_multiplicities'] = [None] * len(fragments); validated_molrec = molparse.from_arrays(speclabel=False, verbose=0, domain='qm', **molrec); forgive.append('fragment_charges'); forgive.append('fragment_multiplicities'); compare_molrecs(validated_molrec, molrec, 6, 'to_dict', forgive=forgive, verbose=0). if not np_out:; validated_molrec = unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, molrec, verbose=1):. mol = cls(); mol._internal_from_dict(molrec=molrec, verbose=verbose); return mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html:50063,Validat,ValidationError,50063,psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/qcdb/molecule.html,1,['Validat'],['ValidationError']
Security,"ection energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('delta5_basis')). # Establish treatment for scf energy (validity check useless since python will catch it long before here); if (len(BSTR) == 3) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_3; elif (len(BSTR) == 2) and ('scf_basis' in kwargs):; cbs_scf_scheme = scf_xtpl_helgaker_2; elif (len(BSTR) == 1) and ('scf_basis' in kwargs):; cbs_scf_scheme = xtpl_highest_1; elif 'scf_basis' in kwargs:; raise ValidationError(""""""SCF basis sets of number %d cannot be handled."""""" % (len(BSTR))); elif do_corl:; cbs_scf_scheme = xtpl_highest_1; BSTR = [BSTC[-1]]; ZETR = [ZETC[-1]]; if 'scf_scheme' in kwargs:; cbs_scf_scheme = kwargs['scf_scheme']. # Establish treatment for correlation energy; if do_corl:; if len(BSTC) == 2:; cbs_corl_scheme = corl_xtpl_helgaker_2; elif len(BSTC) > 2:; raise ValidationError(""""""Cannot extrapolate correlation with %d basis sets. Use highest 2."""""" % (len(BSTC))); else:; cbs_corl_scheme = xtpl_highest_1; if 'corl_scheme' in kwargs:; cbs_corl_scheme = kwargs['corl_scheme']. # Establish treatment for delta correction energy; if do_delta:; if len(BSTD) == 2:; cbs_delta_scheme = corl_xtpl_helgaker_2; else:; cbs_delta_scheme = xtpl_highest_1; if 'delta_scheme' in kwargs:; cbs_delta_scheme = kwargs['delta_scheme']. # Establish treatment for delta2 correction energy; if do_delta2:; if len(BSTD2) == 2:; cbs_delta2_scheme = corl_xtpl_helgaker_2; else:; cbs_delta2_scheme = xtpl_highest_1; if 'delta2_scheme' in kwargs:; cbs_delta2_scheme = kwargs['delta2_scheme']. # # Establish treatment for delta3 correction energy; # if do_delta3:; # if len(BSTD3) == 2:; # cbs_delta3_scheme = corl_xtpl_helgaker_2; # else:; # cbs_delta3_scheme = xtpl_highest_1; # if 'delta3_scheme' in kwargs:; # cbs_delta3_scheme = kwargs['delta3_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:47345,Validat,ValidationError,47345,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ection level %s is not available. Choose among %s."""""" % (dashlvl, dashcoeff.keys())). if dertype is None:; dertype = -1; elif der0th.match(str(dertype)):; dertype = 0; elif der1st.match(str(dertype)):; dertype = 1; # elif der2nd.match(str(dertype)):; # raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)); else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for run_dftd3.' % (dertype)). # if func is None:; # if dashparam is None:; # # defunct case; # raise ValidationError(""""""Parameters for -D correction missing. Provide a func or a dashparam kwarg.""""""); # else:; # # case where all param read from dashparam dict (which must have all correct keys); # func = 'custom'; # dashcoeff[dashlvl][func] = {}; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]; # else:; # raise ValidationError(""""""Parameter %s is missing from dashparam dict %s."""""" % (key, dashparam)); # else:; # func = func.lower(); # if func not in dashcoeff[dashlvl].keys():; # raise ValidationError(""""""Functional %s is not available for -D level %s."""""" % (func, dashlvl)); # if dashparam is None:; # # (normal) case where all param taken from dashcoeff above; # pass; # else:; # # case where items in dashparam dict can override param taken from dashcoeff above; # dashparam = dict((k.lower(), v) for k, v in dashparam.iteritems()); # for key in dashcoeff[dashlvl]['b3lyp'].keys():; # if key in dashparam.keys():; # dashcoeff[dashlvl][func][key] = dashparam[key]. # TODO temp until figure out paramfile; allowed_funcs = ['HF/MINIS', 'DFT/MINIS', 'HF/MINIX', 'DFT/MINIX',; 'HF/SV', 'DFT/SV', 'HF/def2-SV(P)', 'DFT/def2-SV(P)', 'HF/def2-SVP',; 'DFT/def2-SVP', 'HF/DZP', 'DFT/DZP', 'HF/def-TZVP', 'DFT/def-TZVP',; 'HF/def2-TZVP', 'DFT/def2-TZVP', 'HF/631Gd', 'DFT/631Gd',; 'HF/def2-TZVP', 'DFT/def2-TZVP',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html:4153,Validat,ValidationError,4153,psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/qcdb/interface_gcp.html,2,['Validat'],['ValidationError']
Security,"ector; docstring. CIWavefunction; docstring. CUHF; docstring. CdSalc; Cartesian displacement SALC. CdSalcList; Class for generating symmetry adapted linear combinations of Cartesian displacements. CharacterTable; Contains the character table of the point group. CompositeJK; docstring. CorrelationFactor; docstring. CorrelationTable; Provides a correlation table between two point groups. CubeProperties; docstring. DFEP2Wavefunction; A density-fitted second-order Electron Propagator Wavefunction. DFHelper; docstring. DFSOMCSCF; docstring. DFTGrid; docstring. DFTensor; docstring. Deriv; Computes gradients of wavefunctions. DerivCalcType; Members:. DiagonalizeOrder; Defines ordering of eigenvalues after diagonalization. Dimension; Initializes and defines Dimension Objects. DipoleInt; Computes dipole integrals. DirectJK; docstring. DiskSOMCSCF; docstring. Dispersion; docstring. ERI; Computes normal two electron repulsion integrals. ERISieve; docstring. ESPPropCalc; ESPPropCalc gives access to routines calculating the ESP on a grid. ElectricFieldInt; Computes electric field integrals. ElectrostaticInt; Computes electrostatic integrals. ExternalPotential; Stores external potential field, computes external potential matrix. FCHKWriter; Extracts information from a wavefunction object, and writes it to an FCHK file. FDDS_Dispersion; docstring. FISAPT; A Fragment-SAPT Wavefunction. FittedSlaterCorrelationFactor; docstring. FittingMetric; docstring. FragmentType; Fragment activation status. Functional; docstring. GaussianShell; Class containing information about basis functions. GaussianType; 0 if Cartesian, 1 if Pure. GeometryUnits; The units used to define the geometry. HF; docstring. IO; docstring. IOManager; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation. IntVector; Class handling vectors with integer values. IntegralFactory; Computes integrals. IntegralTransform; IntegralTransform transforms one- and two",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:11751,access,access,11751,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,2,['access'],['access']
Security,"ecule(LibmintsMolecule):; """"""Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. """""". def __init__(self, psi4molstr=None):; """"""Initialize Molecule object from LibmintsMolecule""""""; LibmintsMolecule.__init__(self, psi4molstr). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.save_string_for_psi4(); return text. @classmethod; [docs] def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False):; """"""Pull information from an XYZ file. No fragment info detected.; Charge, multiplicity, tagline pulled from second line if available. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_xyz: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). xyz1 = re.compile(r""^\s*(\d+)\s*(bohr|au)?\s*$"", re.IGNORECASE); xyz2 = re.compile(r'^\s*(-?\d+)\s+(\d+)\s+(.*)\s*$'); xyzN = re.compile(r""(?:\s*)([A-Z](?:[a-z])?)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s+)(-?\d+\.\d+)(?:\s*)"", re.IGNORECASE). # Try to match the first line; if xyz1.match(text[0]):; fileNatom = int(xyz1.match(text[0]).group(1)); if xyz1.match(text[0]).group(2) == None:; fileUnits = 'Angstrom'; else:; fileUnits = 'Bohr'; else:; raise ValidationError(""Molecule::init_with_xyz: Malformed first line\n%s"" % (text[0])). # Try to match the second line; if xyz2.match(text[1]):; instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); instance.tagline =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:1376,Validat,ValidationError,1376,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,3,['Validat'],['ValidationError']
Security,"ecule_for_input"",; ""format_options_for_input"",; ""get_psifile"",; ""getattr_ignorecase"",; ""hold_options_state"",; ""import_ignorecase"",; ""kwargs_lower"",; ""mat2arr"",; ""prepare_options_for_modules"",; ""prepare_options_for_set_options"",; ""provenance_stamp"",; ""state_to_atomicinput"",; ]. import collections; import os; import warnings; from contextlib import contextmanager; from types import ModuleType; from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Union. import numpy as np; from qcelemental.models import AtomicInput. from psi4 import core; from psi4.metadata import __version__. from . import p4regex; from .exceptions import ValidationError. [docs]; def kwargs_lower(kwargs: Dict[str, Any]) -> Dict[str, Any]:; """"""Function to rebuild and return *kwargs* dictionary sanitized. Should be; called by every function that could be called directly by the user. Parameters; ----------; kwargs; Input kwargs for any user-facing function. Returns; -------; lowered : Dict[str, Any]; Sanitized kwargs with all keys made lowercase. Also turns boolean-like; values into actual booleans. Also turns values lowercase if sensible. """"""; caseless_kwargs = {}; for key, value in kwargs.items():; lkey = key.lower(); if lkey in ['subset', 'banner', 'restart_file', 'write_orbitals']: # only kw for which case matters; lvalue = value; else:; try:; lvalue = value.lower(); except (AttributeError, KeyError):; lvalue = value. if lkey in ['irrep', 'check_bsse', 'linkage', 'bsse_type']:; caseless_kwargs[lkey] = lvalue. elif 'dertype' in lkey:; if p4regex.der0th.match(str(lvalue)):; caseless_kwargs[lkey] = 0; elif p4regex.der1st.match(str(lvalue)):; caseless_kwargs[lkey] = 1; elif p4regex.der2nd.match(str(lvalue)):; caseless_kwargs[lkey] = 2; else:; raise KeyError(f'Derivative type key {key} was not recognized'). elif lvalue is None:; caseless_kwargs[lkey] = None. elif p4regex.yes.match(str(lvalue)):; caseless_kwargs[lkey] = True. elif p4regex.no.match(str(lvalue)):; caseless_kwargs[lkey] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/procutil.html:2268,Sanitiz,Sanitized,2268,psi4manual/1.9.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/procutil.html,2,['Sanitiz'],['Sanitized']
Security,"ed a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:10292,Validat,ValidationError,10292,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,7,['Validat'],['ValidationError']
Security,"ed a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:10609,Validat,ValidationError,10609,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,3,['Validat'],['ValidationError']
Security,"ed a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'); user_reference = psi4.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = kwargs.get('symm', True). symmetry_override = 0; if db_symm is False:; symmetry_override = 1; elif db_symm is True:; pass; else:; raise ValidationError(""""""Symmetry mode '%s' not valid."""""" % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; db_mode = kwargs.pop('db_mode', kwargs.pop('mode', 'continuous')).lower(); kwargs['db_mode'] = db_mode. if db_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:10489,Validat,ValidationError,10489,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['Validat'],['ValidationError']
Security,"ed from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". import os; import re; import sys; import warnings; from typing import Union. from psi4 import core; from psi4.driver.procrouting import *; from .exceptions import ValidationError; from .prop_util import *. [docs]def oeprop(wfn: core.Wavefunction, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: str; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn, **kwargs):; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html:1328,Validat,ValidationError,1328,psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/util.html,2,['Validat'],['ValidationError']
Security,"ed from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". import os; import re; import sys; import warnings; from typing import Union. from psi4 import core; from psi4.driver.procrouting import *; from .exceptions import ValidationError; from .prop_util import *. [docs]def oeprop(wfn: core.Wavefunction, *args, **kwargs):; """"""Evaluate one-electron properties. :returns: None. :param wfn: set of molecule, basis, orbitals from which to compute properties. How to specify args, which are actually the most important. :type title: str; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop); ; # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn) . oe.compute(). [docs]def cubeprop(wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/util.html:1328,Validat,ValidationError,1328,psi4manual/1.6.x/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/util.html,1,['Validat'],['ValidationError']
Security,"ed method %s' % (name)). set_cholesky_from(corl_type). # conventional vs. optimized orbitals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'a-ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name change",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:57294,Validat,ValidationError,57294,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"ed n-body energy analysis. Presently used by multi to suppress output. Candidate for removal from class once in-class/out-of-class functions sorted.""). task_list: Dict[str, SubTaskComputers] = {}. # Note that validation of user fields happens through typing and validator functions, so no class __init__ needed. @validator(""bsse_type"", pre=True); def set_bsse_type(cls, v):; if not isinstance(v, list):; v = [v]; # emulate ordered set; return list(dict.fromkeys([bt.lower() for bt in v])). @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. @validator(""nfragments"", always=True); def set_nfragments(cls, v, values):; return values[""molecule""].nfragments(). @validator(""max_nbody"", always=True); def set_max_nbody(cls, v, values):; if v == -1:; return values[""nfragments""]; else:; return min(v, values[""nfragments""]). @validator(""embedding_charges""); def set_embedding_charges(cls, v, values):; if len(v) != values[""nfragments""]:; raise ValueError(""embedding_charges dict should have entries for each 1-indexed fragment.""). return v. @validator(""return_total_data"", always=True); def set_return_total_data(cls, v, values):; if v is not None:; rtd = v; elif values[""driver""] in [""gradient"", ""hessian""]:; rtd = True; else:; rtd = False. if values.get(""embedding_charges"", False) and rtd is False:; raise ValueError(""Cannot return interaction data when using embedding scheme.""). return rtd. [docs] def build_tasks(self, mb_computer: SubTaskComputers, mc_level_idx: int, **kwargs: Dict[str, Any]) -> int:; """"""Adds to the task_list as many new unique tasks as necessary to treat a single model chemistry level at one or several n-body levels.; New tasks are of type *mb_computer* with model chemistry level specified in *kwargs* and n-body levels accessed through *mc_level_idx*. Parameters; ----------; mb_computer; Class of TaskComputers to instantiate and add to self.task_list. Usually AtomicComputer but may be other w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:35086,validat,validator,35086,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['validat'],['validator']
Security,"ed warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import print_function; from __future__ import absolute_import; import os; import re; import math; import pickle; import collections. from psi4.driver import constants; from psi4.driver.driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_RGT`` and ``DB_RXN``. .. note:: It is very easy to make a database from a collection of xyz files; using the script :source:`share/scripts/ixyz2database.py`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedde",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html:1710,access,access,1710,psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,1,['access'],['access']
Security,"ed yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specific",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:19049,Validat,ValidationError,19049,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"ed yet.\n"" % (line, entries[3])); if aTo == rTo:; raise ValidationError(""Atom used multiple times on line %s."" % (line)); rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:19229,Validat,ValidationError,19229,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"ed('Molecule::set_basis_by_number') # FINAL. [docs] def set_basis_by_label(self, label, name, type=""BASIS""):; """""" **NYI** Assigns basis *name* to all atoms with *label*.""""""; raise FeatureNotImplemented('Molecule::set_basis_by_label') # FINAL. [docs] def nfrozen_core(self, depth=False):; """"""Number of frozen core for molecule given freezing state. >>> print H2OH2O.nfrozen_core(); 2. """"""; if depth == False or depth.upper() == 'FALSE':; return 0. elif depth == True or depth.upper() == 'TRUE':; # Freeze the number of core electrons corresponding to the; # nearest previous noble gas atom. This means that the 4p block; # will still have 3d electrons active. Alkali earth atoms will; # have one valence electron in this scheme.; nfzc = 0; for A in range(self.natom()):; if self.Z(A) > 2:; nfzc += 1; if self.Z(A) > 10:; nfzc += 4; if self.Z(A) > 18:; nfzc += 4; if self.Z(A) > 36:; nfzc += 9; if self.Z(A) > 54:; nfzc += 9; if self.Z(A) > 86:; nfzc += 16; if self.Z(A) > 108:; raise ValidationError(""Invalid atomic number""); return nfzc. else:; raise ValidationError(""Frozen core '%s' is not supported, options are {true, false}."" % (depth)). # <<< Involved Methods for Frame >>>. [docs] def translate(self, r):; """"""Translates molecule by r. >>> H2OH2O.translate([1.0, 1.0, 0.0]). """"""; temp = [None, None, None]; for at in range(self.nallatom()):; temp = scale(self.full_atoms[at].compute(), self.input_units_to_au); temp = add(temp, r); temp = scale(temp, 1.0 / self.input_units_to_au); self.full_atoms[at].set_coordinates(temp[0], temp[1], temp[2]). [docs] def center_of_mass(self):; """"""Computes center of mass of molecule (does not translate molecule). >>> H2OH2O.center_of_mass(); [-0.12442647346606871, 0.00038657002584110707, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_m = 0.0. for at in range(self.natom()):; m = self.mass(at); ret = add(ret, scale(self.xyz(at), m)); total_m += m. ret = scale(ret, 1.0 / total_m); return ret. [docs] def move_to_com(self):; """"""Moves molecule to center of mass. """"",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html:49686,Validat,ValidationError,49686,psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/libmintsmolecule.html,1,['Validat'],['ValidationError']
Security,"ed, if not last defined.; omega_convergence; Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter; Maximum number of iterations towards omega convergence. Returns; -------; float; Optimal omega parameter. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'DFT_OMEGA'],; ['DOCC'],; ['SOCC']). kwargs = p4util.kwargs_lower(kwargs). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. if core.get_option('SCF', 'REFERENCE') != 'UKS':; core.print_out("""""" Requested procedure `ip_fitting` runs further calculations with UKS reference.\n""""""); core.set_local_option('SCF', 'REFERENCE', 'UKS'). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molecular_charge() != 0:; raise ValidationError(""""""IP Fitting requires neutral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `ip_fitting` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # How many electrons are there?; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). # Work in the ot namespace for this procedure; core.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""); E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Burn-in', **kwargs); cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:15966,Validat,ValidationError,15966,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,4,['Validat'],['ValidationError']
Security,"ed, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:120352,Validat,ValidationError,120352,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Validat'],['ValidationError']
Security,"ed,; rotated, flipped, and otherwise badgered into coincidence, then the same; manipulations are applied to the gradient in GRD, the result of which; is printed below and passed on to Optking.; //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//; // Cfour c4-scf Gradient Results //; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//. ... Irrep: 1 Size: 4 x 3. 1 2 3. 1 0.0000000 -0.0122978 0.0000000; 2 -0.0051192 0.0040993 -0.0088667; 3 -0.0051192 0.0040993 0.0088667; 4 0.0102384 0.0040993 0.0000000. CFOUR scratch file GRD has been read; 4 0.0000000000; 7.0000000000 -0.0880964705 0.0000000000 0.0000000000; 1.0000000000 0.4080144050 -0.9178691296 -1.5897959670; 1.0000000000 0.4080144050 -0.9178691296 1.5897959670; 1.0000000000 0.4080144050 1.8357382590 0.0000000001; 7.0000000000 -0.0122978407 0.0000000000 0.0000000000; 1.0000000000 0.0040992802 -0.0051191833 -0.0088666856; 1.0000000000 0.0040992802 -0.0051191833 0.0088666856; 1.0000000000 0.0040992802 0.0102383666 0.0000000000. The gradient can also be accessed from the input file as a; psi4.Matrix object through; psi4.get_gradient().; Cfour Files; The contents of all files associated with Cfour are accessible from the; input file through the Python dictionary P4C4_INFO. That is,; P4C4_INFO['zmat'] returns a string of the input file sent to Cfour.; Accessible arguments are zmat, output, and any that have been; produced of grd. For example, to print to the screen if CC convergence; is reached, the following could be placed in the Psi4 input file.; energy('c4-ccsd'); print 'miracle?', 'miracle' in P4C4_INFO['output']. Scratch Files; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:22327,access,accessed,22327,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['access'],['accessed']
Security,"ed_irreps != 0x1 else ""symmetric "",; n_salc); info += f"" Translations projected? {t_project:d}. Rotations projected? {r_project:d}.\n""; core.print_out(info); logger.info(info). # TODO: Replace with a generator from a stencil to a set of points.; # Diagonal displacements differ between the totally symmetric irrep, compared to all others.; # Off-diagonal displacements are the same for both.; pts_dict = {; 3: {; ""sym_irr"": ((-1, ), (1, )),; ""asym_irr"": ((-1, ), ),; ""off"": ((1, 1), (-1, -1)); },; 5: {; ""sym_irr"": ((-2, ), (-1, ), (1, ), (2, )),; ""asym_irr"": ((-2, ), (-1, )),; ""off"": ((-1, -2), (-2, -1), (-1, -1), (1, -1), (-1, 1), (1, 1), (2, 1), (1, 2)); }; }. try:; disps = pts_dict[stencil_size]; except KeyError:; raise ValidationError(f""FINDIF: Number of points ({stencil_size}) not among {pts_dict.keys()}!""). # Convention: x_pi means x_per_irrep. The ith element is x for irrep i, with Cotton ordering.; salc_indices_pi = [[] for h in range(n_irrep)]. # Validate that we have an irrep matching the user-specified irrep, if any.; try:; salc_indices_pi[freq_irrep_only]; except (TypeError, IndexError):; if freq_irrep_only != -1:; raise ValidationError(; f""FINDIF: 0-indexed Irrep value ({freq_irrep_only}) not in valid range: <{len(salc_indices_pi)}.""). # Populate salc_indices_pi for all irreps.; # * Python error if iterate through `salc_list`; for i in range(len(salc_list)):; salc_indices_pi[salc_list[i].irrep_index()].append(i). # If the method allows more than one irrep, print how the irreps partition the SALCS.; if print_lvl and method_allowed_irreps != 0x1 and verbose:; info = "" Index of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; tmp = ("" {:d} "" * len(salc_indices_pi[h])).format(*salc_indices_pi[h]); info += "" {:d} : "".format(h + 1) + tmp + ""\n""; info += "" Number of SALCs per irrep:\n""; for h in range(n_irrep):; if print_lvl > 1 or freq_irrep_only in {h, -1}:; info += "" Irrep {:d}: {:d}\n"".format(h + 1, len(salc_indice",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:9964,Validat,Validate,9964,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['Validat'],['Validate']
Security,"ee Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import numpy as np. from psi4 import core; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting.dft import functionals, build_superfunctional_from_dictionary. def scf_set_reference_local(name, is_dft=False):; """"""; Figures out the correct SCF reference to set locally; """""". optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['SCF', 'REFERENCE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Alter reference name if needed; user_ref = core.get_option('SCF', 'REFERENCE'). sup = build_superfunctional_from_dictionary(functionals[name], 1, 1, True)[0]; if sup.needs_xc() or is_dft:; if (user_ref == 'RHF'):; core.set_local_option('SCF', 'REFERENCE', 'RKS'); elif (user_ref == 'UHF'):; core.set_local_option('SCF', 'REFERENCE', 'UKS'); elif (user_ref == 'ROHF'):; raise ValidationError('ROHF reference for DFT is not available.'); elif (user_ref == 'CUHF'):; raise ValidationError('CUHF reference for DFT is not available.'); # else we are doing HF and nothing needs to be overloaded. return optstash. def oeprop_validator(prop_list):; """"""; Validations a list of OEProp computations. Throws if not found. """"""; oeprop_methods = core.OEProp.valid_methods. if not len(prop_list):; raise ValidationnError(""OEProp: No properties specified!""). for prop in prop_list:; prop = prop.upper(). if 'MULTIPOLE(' in prop: continue. if prop not in oeprop_methods:; alt_method_name = p4util.text.find_approximate_string_matches(prop,; oeprop_methods, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""OEProp: Feature '%s' is not recognized. %s"" % (prop, alternatives)). [docs]def check_iwl_file_from_scf_type(scf_type, wfn):; """"""; Ensures that a IWL file has been written based on in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html:1996,Validat,ValidationError,1996,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc_util.html,1,['Validat'],['ValidationError']
Security,"ee Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions used by several Python functions."""""". __all__ = [; ""all_casings"",; ""drop_duplicates"",; ""expand_psivars"",; ""format_molecule_for_input"",; ""format_options_for_input"",; ""get_psifile"",; ""getattr_ignorecase"",; ""hold_options_state"",; ""import_ignorecase"",; ""kwargs_lower"",; ""mat2arr"",; ""prepare_options_for_modules"",; ""prepare_options_for_set_options"",; ""provenance_stamp"",; ""state_to_atomicinput"",; ]. import collections; import os; import warnings; from contextlib import contextmanager; from types import ModuleType; from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Union. import numpy as np; from qcelemental.models import AtomicInput. from psi4 import core; from psi4.metadata import __version__. from . import p4regex; from .exceptions import ValidationError. [docs]; def kwargs_lower(kwargs: Dict[str, Any]) -> Dict[str, Any]:; """"""Function to rebuild and return *kwargs* dictionary sanitized. Should be; called by every function that could be called directly by the user. Parameters; ----------; kwargs; Input kwargs for any user-facing function. Returns; -------; lowered : Dict[str, Any]; Sanitized kwargs with all keys made lowercase. Also turns boolean-like; values into actual booleans. Also turns values lowercase if sensible. """"""; caseless_kwargs = {}; for key, value in kwargs.items():; lkey = key.lower(); if lkey in ['subset', 'banner', 'restart_file', 'write_orbitals']: # only kw for which case matters; lvalue = value; else:; try:; lvalue = value.lower(); except (AttributeError, KeyError):; lvalue = value. if lkey in ['irrep', 'check_bsse', 'linkage', 'bsse_type']:; caseless_kwargs[lkey] = lvalue. elif 'dertype' in lkey:; if p4regex.der0th.match(str(lvalue)):; caseless_kwargs[lkey] = 0; elif p4regex.der1st.match(str(lvalue)):; caseless_kwargs[lkey] = 1; elif p4regex.der2nd.match(str(lvalue)):; caseless_kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/procutil.html:2059,sanitiz,sanitized,2059,psi4manual/1.9.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/procutil.html,2,['sanitiz'],['sanitized']
Security,"ef corl_xtpl_helgaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True, alpha=None):; r""""""Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by :py:func:`~psi4.cbs`. Parameters; ----------; functionname : str; Name of the CBS component.; zLO : int; Lower zeta level.; valueLO : float; Lower value used for extrapolation.; zHI : int; Higher zeta level. Should be equal to zLO + 1.; valueHI : float; Higher value used for extrapolation.; alpha : float, optional; Overrides the default :math:`\alpha = 3.0`. Returns; -------; float; Returns :math:`E_{total}^{\infty}`, see below. Notes; -----; The extrapolation is calculated according to [5]_:; :math:`E_{corl}^X = E_{corl}^{\infty} + \beta X^{-alpha}`. References; ----------. .. [5] Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson,; Chem. Phys. Lett. 286 (1998) 243-252,; DOI: 10.1016/S0009-2614(99)00179-7. """"""; if type(valueLO) != type(valueHI):; raise ValidationError(; ""corl_xtpl_helgaker_2: Inputs must be of the same datatype! (%s, %s)"" % (type(valueLO), type(valueHI))). if alpha is None:; alpha = 3.0. if isinstance(valueLO, float):; value = (valueHI * zHI**alpha - valueLO * zLO**alpha) / (zHI**alpha - zLO**alpha); beta = (valueHI - valueLO) / (zHI**(-alpha) - zLO**(-alpha)). # final = valueSCF + value; final = value; if verbose:; # Output string with extrapolation parameters; cbsscheme = """"""\n\n ==> Helgaker 2-point correlated extrapolation for method: %s <==\n\n"""""" % (; functionname.upper()); # cbsscheme += """""" HI-zeta (%1s) SCF Energy: % 16.12f\n"""""" % (str(zHI), valueSCF); cbsscheme += """""" LO-zeta (%s) Energy: % 16.12f\n"""""" % (str(zLO), valueLO); cbsscheme += """""" HI-zeta (%s) Energy: % 16.12f\n"""""" % (str(zHI), valueHI); cbsscheme += """""" Alpha (exponent) Value: % 16.12f\n"""""" % alpha; cbsscheme += """""" Extrapolated Energy: % 16.12f\n\n"""""" % value; #cbsscheme += """""" LO-zeta (%s) Correlation Energy: % 16.12f\n"""""" % (str(zLO), valueLO); #cbsscheme += """""" HI-zeta (%s) Cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:20509,Validat,ValidationError,20509,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"ef rotation(self, theta):; """"""Set equal to a clockwise rotation by 2pi/n or theta degrees. """"""; if isinstance(theta, int):; theta = 2.0 * math.pi if theta == 0 else 2.0 * math.pi / theta. ctheta = math.cos(theta); stheta = math.sin(theta); c2theta = math.cos(2 * theta); s2theta = math.sin(2 * theta). self.zero(); if self.n == 1:; self.d[0][0] = 1.0. elif self.n == 3:; self.d[0][0] = ctheta; self.d[0][1] = stheta; self.d[1][0] = -stheta; self.d[1][1] = ctheta; self.d[2][2] = 1.0. elif self.n == 2 or self.n == 4:; self.d[0][0] = ctheta; self.d[0][1] = stheta; self.d[1][0] = -stheta; self.d[1][1] = ctheta. # this is ok since d is hardwired; self.d[2][2] = c2theta; self.d[2][3] = -s2theta; self.d[3][2] = s2theta; self.d[3][3] = c2theta. elif self.n == 5:; self.d[0][0] = 1.0. self.d[1][1] = c2theta; self.d[1][2] = s2theta; self.d[2][1] = -s2theta; self.d[2][2] = c2theta. self.d[3][3] = ctheta; self.d[3][4] = -stheta; self.d[4][3] = stheta; self.d[4][4] = ctheta. else:; raise ValidationError(""SymRep::rotation(): n > 5""). [docs]class IrreducibleRepresentation(object):; """"""The IrreducibleRepresentation class provides information associated; with a particular irreducible representation of a point group. This; includes the Mulliken symbol for the irrep, the degeneracy of the; irrep, the characters which represent the irrep, and the number of; translations and rotations in the irrep. The order of the point group; is also provided (this is equal to the number of characters in an; irrep). """""". def __init__(self, *args):; """"""Constructor"""""". # the order of the group; self.g = 0 # int really self?; # the degeneracy of the irrep; self.degen = 0 # int really self?; # the number of rotations in this irrep; self.PYnrot = 0 # int; # the number of translations in this irrep; self.PYntrans = 0 # int; # true if this irrep has a complex representation; self.PYcomplex = 0; # mulliken symbol for this irrep; self.symb = 0 # str; # mulliken symbol for this irrep w/o special characters; self.csym",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:15486,Validat,ValidationError,15486,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['Validat'],['ValidationError']
Security,"efault', failoninc=True, verbose=False)[source]¶; For all data or modelchem subset mcset, computes raw reaction; errors between modelchem and benchmark model chemistries.; Returns error if model chemistries are missing for any reaction in; subset unless failoninc set to False, whereupon returns partial.; Returns dictionary of reaction labels and error forms. plot(benchmark='default', mcset='default', failoninc=True, verbose=False, color='sapt', xlimit=4.0, labeled=True, view=True, mousetext=None, mouselink=None, mouseimag=None, mousetitle=None, mousediv=None, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Computes individual errors over model chemistries in mcset (which; may be default or an array or a function generating an array) versus; benchmark. Thread color can be ‘rgb’ for old coloring, a color; name or ‘sapt’ for spectrum coloring.; saveas conveys directory (‘/’) and/or filename for saving the; resulting plot. File extension is not accessible, but graphicsformat; array requests among ‘png’, ‘pdf’, and ‘eps’ formats. relpath; forces paths to saved files to be relative to current directory,; rather than absolute paths for returned code and file dictionary.; Prepares thread diagram instructions and either executes them if; matplotlib available (Canopy or Anaconda) or prints them. Returns a; dictionary of all saved plot filenames. If any of mousetext, mouselink,; or mouseimag is specified, htmlcode will be returned with an image map of; slats to any of text, link, or image, respectively. class ReactionDatum(dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, doi=None, comment=None)[source]¶; Piece of quantum chemical information that describes a qcdb.Reaction object. classmethod library_modelchem(dbse, rxn, method, mode, basis, value, units='kcal/mol', citation=None, doi=None, comment=None)[source]¶; Constructor when method and basis are strings corresponding to; qcdb.Method and qcdb.BasisSet already defined in methods and base",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:44332,access,accessible,44332,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['access'],['accessible']
Security,"efficient) Value: %16.8f\n"""""" % (beta); psi4.print_out(cbsscheme). return energypiece. [docs]def validate_scheme_args(functionname, **largs):; r""""""Function called by each extrapolation scheme in :py:func:`~wrappers.complete_basis_set`.; Checks that all the input arguments are present and suitable so that; the scheme function can focus on defining the extrapolation. """"""; mode = ''; NEED = []; wfnname = ''; BSET = []; ZSET = []. # Mode where function fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scft",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:101087,Validat,ValidationError,101087,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"efmt.format('total', 'CBS', '', '', '', finalenergy, ''); tables += delimit. return tables. [docs]class CompositeComputer(BaseComputer):. molecule: Any; basis: str = ""(auto)""; method: str = ""(auto)""; driver: DriverEnum; keywords: Dict[str, Any] = {}; metadata: Any; metameta: Dict[str, Any] = {}. verbose: int = 1. # List of model chemistries with extrapolation scheme applied. Can reconstruct CBS. Keys are d_fields. Formerly GRAND_NEED.; cbsrec: List[Dict[str, Any]] = []. # Maximal list of model chemistries extractable from running `compute_list`. Keys are _f_fields. Formerly JOBS_EXT.; trove: List[Dict[str, Any]] = []. # Minimal (enlightened) list of jobs to run to satisfy full CBS. Keys are _f_fields. Formerly JOBS.; compute_list: List[Dict[str, Any]] = []. # One-to-One list of AtomicComputer-s corresponding to `compute_list`.; task_list: List[AtomicComputer] = []. # One-to-One list of QCSchema corresponding to `task_list`.; results_list: List[Any] = []. [docs] @validator('molecule'); def set_molecule(cls, mol):; mol.update_geometry(); mol.fix_com(True); mol.fix_orientation(True); return mol. def __init__(self, **data):; data = p4util.kwargs_lower(data); data[""metadata""] = _process_cbs_kwargs(data); BaseComputer.__init__(self, **data). self.metameta = {; 'kwargs': data,; 'ptype': self.driver,; 'verbose': self.verbose,; 'label': None,; 'molecule': self.molecule,; }; # logger.debug(""METAMETA\n"" + pp.pformat(self.metameta)). if data['metadata']:; if data['metadata'][0][""wfn""] not in VARH.keys():; raise ValidationError(; """"""Requested SCF method '%s' is not recognized. Add it to VARH in driver_cbs.py to proceed."""""" %; (metadata[0][""wfn""])). if len(self.metadata) > 1:; for delta in self.metadata[1:]:; if delta[""wfn""] not in VARH.keys():; raise ValidationError(; f""""""Requested higher {delta[""treatment""]} method '{delta[""wfn""]}' is not recognized. Add it to VARH in driver_cbs.py to proceed.""""""; ); if delta[""wfn_lo""] not in VARH.keys():; raise ValidationError(; f""""""Requested l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:53543,validat,validator,53543,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['validat'],['validator']
Security,"efp_set_options(); efp.set_qm_atoms(); efp.print_out(). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n"");; core.print_out("" "" + banner.center(58));. scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE')); core.set_legacy_wavefunction(scf_wfn). fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(scf_molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); read_filename = os.path.join(psi_scratch, fname + "".180.npz""). if (core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename):; data = np.load(read_filename); Ca_occ = core.Matrix.np_read(data, ""Ca_occ""); Cb_occ = core.Matrix.np_read(data, ""Cb_occ""); symmetry = str(data[""symmetry""]); basis_name = str(data[""BasisSet""]). if symmetry != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if basis_name == scf_wfn.basisset().name():; core.print_out("" Reading orbitals from file 180, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out("" Reading orbitals from file 180, projecting to new basis.\n\n""). puream = int(data[""BasisSet PUREAM""]). if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). old_basis = core.BasisSet.build(scf_molecule, ""ORBITAL"", basis_name, puream=puream); core.print_out("" Computing basis projection from %s to %s\n\n"" % (basis_name, base_wfn.basisset().name())). nalphapi = core.Dimension.from_list(data[""nalphapi""]); nbetapi = core.Dimension.from_list(data[""nbetapi""]); pCa = scf_wfn.basis_projection(Ca_occ, nalphapi, old_basis, base_wfn.basisset()); pCb = scf_wfn.basis_projection(Cb_occ, nbetapi, old_basis, base_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Strip off headers to only get R, RO, U, CU; old_ref = s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:36332,Validat,ValidationError,36332,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,"efunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html:40699,Validat,ValidationError,40699,psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/python_helpers.html,2,['Validat'],['ValidationError']
Security,"egrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file.; So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(). core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '&FCI\n'; header += 'NORB={:d},\n'.format(nbf); header += 'NELEC={:d},\n'.format(nelectron); header += 'MS2={:d},\n'.format(wfn.nalpha() - wfn.nbeta()); header += 'UHF=.{}.,\n'.format(not wfn.same_a_b_orbs()).upper(); orbsym = ''; for h in range(active_mopi.n()):; for n in range(frzcpi[h], frzcpi[h] + active_mopi[h]):; orbsym += '{:d},'.format(h + 1); if not wfn.same_a_b_orbs():; orbsym += '{:d},'.for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:2656,Validat,ValidationError,2656,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['Validat'],['ValidationError']
Security,"egrals, including orbital energies, can also be saved.; This latter format can be used with the HANDE QMC code but is not standard. :returns: None. :raises: ValidationError when SCF wavefunction is not RHF. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, basis, orbitals from which to generate cube files; :param fname: name of the integrals file, defaults to INTDUMP; :param oe_ints: list of additional one-electron integrals to save to file.; So far only EIGENVALUES is a valid option. :examples:. >>> # [1] Save one- and two-electron integrals to standard FCIDUMP format; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn). >>> # [2] Save orbital energies, one- and two-electron integrals.; >>> E, wfn = energy('scf', return_wfn=True); >>> fcidump(wfn, oe_ints=['EIGENVALUES']). """"""; # Get some options; reference = core.get_option('SCF', 'REFERENCE'); ints_tolerance = core.get_global_option('INTS_TOLERANCE'); # Some sanity checks; if reference not in ['RHF', 'UHF']:; raise ValidationError('FCIDUMP not implemented for {} references\n'.format(reference)); if oe_ints is None:; oe_ints = []. molecule = wfn.molecule(); docc = wfn.doccpi(); frzcpi = wfn.frzcpi(); frzvpi = wfn.frzvpi(); active_docc = docc - frzcpi; active_socc = wfn.soccpi(); active_mopi = wfn.nmopi() - frzcpi - frzvpi. nbf = active_mopi.sum() if wfn.same_a_b_orbs() else 2 * active_mopi.sum(); nirrep = wfn.nirrep(); nelectron = 2 * active_docc.sum() + active_socc.sum(); irrep_map = _irrep_map(wfn). wfn_irrep = 0; for h, n_socc in enumerate(active_socc):; if n_socc % 2 == 1:; wfn_irrep ^= h. core.print_out('Writing integrals in FCIDUMP format to ' + fname + '\n'); # Generate FCIDUMP header; header = '&FCI\n'; header += 'NORB={:d},\n'.format(nbf); header += 'NELEC={:d},\n'.format(nelectron); header += 'MS2={:d},\n'.format(wfn.nalpha() - wfn.nbeta()); header += 'UHF=.{}.,\n'.format(not wfn.same_a_b_orbs()).upper(); orbsym = ''; for h in range(active_mopi.n()):; for n in range(f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html:2688,Validat,ValidationError,2688,psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,1,['Validat'],['ValidationError']
Security,"el, including detailed dict at atomicresult.extras[""cbs_record""]. * convert result to psi4.core.Matrix (non-energy). _cbs_schema_to_wfn(); --------------------; * build wfn from cbs mol and basis (always def2-svp) and module (if present); * push qcvars to P::e and wfn. * return e/g/h and wfn. """""". import math; import re; import sys; import copy; import pprint; from typing import Any, Callable, Dict, List, Optional, Tuple, Union, TYPE_CHECKING; pp = pprint.PrettyPrinter(width=120, compact=True, indent=1); import logging. import numpy as np; from pydantic import Field, validator; from qcelemental.models import AtomicResult, DriverEnum. from psi4 import core; from psi4.driver import driver_util, p4util, pp; from psi4.driver import qcdb; from psi4.driver.driver_cbs_helper import composite_procedures, register_composite_function, register_xtpl_function, xtpl_procedures # lgtm[py/unused-import]; from psi4.driver.driver_util import UpgradeHelper; from psi4.driver.p4util.exceptions import ValidationError; from psi4.driver.procrouting.interface_cfour import cfour_psivar_list; from psi4.driver.task_base import AtomicComputer, BaseComputer, EnergyGradientHessianWfnReturn. if TYPE_CHECKING:; import qcportal. logger = logging.getLogger(__name__). zeta_values = 'dtq5678'; _zeta_val2sym = {k + 2: v for k, v in enumerate(zeta_values)}; _zeta_sym2val = {v: k for k, v in _zeta_val2sym.items()}; _addlremark = {'energy': '', 'gradient': ', GRADIENT', 'hessian': ', HESSIAN'}; _f_fields = ['f_wfn', 'f_basis', 'f_zeta', 'f_options', 'f_energy', 'f_gradient', 'f_hessian', 'f_dipole', 'f_dipder']; _lmh_labels = {; 1: ['HI'],; 2: ['LO', 'HI'],; 3: ['LO', 'MD', 'HI'],; 4: ['LO', 'MD', 'M2', 'HI'],; 5: ['LO', 'MD', 'M2', 'M3', 'HI']; }; CBSMetadata = List[Dict[str, Any]]. # remove in 1.8; # these get input files to the point where they raise an UpgradeHelper; def xtpl_highest_1():; pass. def scf_xtpl_helgaker_2():; pass. def scf_xtpl_truhlar_2():; pass. def scf_xtpl_karton_2():; pass. def scf_x",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:5475,Validat,ValidationError,5475,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"el-psi4-dir}¶; Take a quiz to find the best version of the codebase for; your needs, be it binary, tarball, or version-controlled repository. Or,; select outright among:. Binary Installer; Clone from GitHub Repository (read-only unless core developer); Fork from GitHub Repository; Tarball from GitHub Repository; Psi3 from SourceForge. Find-the-code Quiz¶. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base.; Provided I still get good, threaded BLAS/LAPACK, I’m willing to; sacrifice processor architecture tuning to avoid compiling it myself.; I’m on Linux or Mac or Windows with Ubuntu Bash Shell.; I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself for best performance on my computer.; I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4.; In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub. I really like parentheses and/or DBOC, so I want Psi3. —; Goto Psi3-from-SourceForge. Binary Installer¶. Get Initially; Just go to http://www.psicode.org/downloads.html and follow the; instructions there. Build; Not applicable as binary is pre-built. Get Updates directions; >>> conda update psi4. Contribute Back; Not applicable as not under git control. Clone from GitHub Repository¶. Get Initially; The PSI4 repository at https://github.com/psi4/psi4 works like; every other GitHub repo.; Locally, clone as below.; # use https or ssh; >>> git clone https://github.com/psi4/psi4.git; >>> cd psi4; # this is your",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_obtaining-1.html:1214,access,access,1214,psi4manual/1.1.0/build_obtaining-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_obtaining-1.html,2,['access'],['access']
Security,el_Hx() psi4.core.HF method. TwoElectronInt class in psi4.core. U. U psi4.core.Localizer attribute. UHF class in psi4.core. UHF_NOONS (SCF). UKSFunctions class in psi4.core. UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify() psi4.core.FISAPT method. unit() psi4.core.SymmetryOperation method. units. ; molecule. units() psi4.core.Molecule method. Unnormalized psi4.core.PrimitiveType attribute. up psi4.driver.p4util.InPsight attribute. UPDATE (DETCI). update() psi4.core.SOMCSCF method. update_density() psi4.core.TwoBodyAOInt method. update_geometry() psi4.core.Molecule method. psi4.driver.p4util.InPsight method. update_orbitals() psi4.core.IntegralTransform method. UpgradeHelper. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). V. v2rdm_casscf. ; plugin. V_potential() psi4.core.HF method. Va() psi4.core.HF method. VAL_EX_LEVEL (DETCI). valid_methods psi4.core.OEProp attribute. validate_diis() psi4.core.HF method. validate_options() psi4.core.Options method. ValidationError. value psi4.core.DerivCalcType attribute. psi4.core.DiagonalizeOrder attribute. psi4.core.FragmentType attribute. psi4.core.GaussianType attribute. psi4.core.GeometryUnits attribute. psi4.core.PrimitiveType attribute. psi4.core.PsiReturnType attribute. psi4.core.SaveType attribute. value() psi4.core.SuperFunctional method. values() psi4.core.SuperFunctional method. variable() in module psi4.core. psi4.core.Wavefunction method. variables() in module psi4.core. psi4.core.Wavefunction method. Vb() psi4.core.HF method. VBase class in psi4.core. vdot() psi4.core.CIVector method. VECS_CC3 (CCEOM). VECS_PER_ROOT (CCEOM). Vector class in psi4.core. Vector3 class in psi4.core. vector_axpy() psi4.driver.p4util.SolverEngine method. vector_copy() psi4.driver.p4util.SolverEngine method. vector_dot() psi4.core.Matrix method. psi4.core.Vector method. psi4.driver.p4util.SolverEngine static method. vector_multiply() psi4.core.CIVector method. vector_scale() psi4.driver.p4util.SolverEngine metho,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:124828,Validat,ValidationError,124828,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,1,['Validat'],['ValidationError']
Security,"eld basis: str = '(auto)'¶. field bsse_type: List[BsseEnum] = [<BsseEnum.cp: 'cp'>]¶; Requested BSSE treatments. First in list determines which interaction or total energy/gradient/Hessian returned. Validated by:. set_bsse_type. field driver: DriverEnum [Required]¶; The computation driver; i.e., energy, gradient, hessian. field embedding_charges: Dict[int, List[float]] = {}¶; Atom-centered point charges to be used on molecule fragments whose basis sets are not included in the computation. Keys: 1-based index of fragment. Values: list of atom charges for that fragment. Validated by:. set_embedding_charges. field keywords: Dict[str, Any] = {}¶; The computation keywords/options. field max_nbody: int = -1¶; Maximum number of bodies to include in the many-body treatment. Possible: max_nbody <= nfragments. Default: max_nbody = nfragments. Validated by:. set_max_nbody. field method: str = '(auto)'¶. field molecule: Any [Required]¶; The target molecule, if not the last molecule defined. Validated by:. set_molecule. field nbodies_per_mc_level: List[List[Union[int, Literal['supersystem']]]] = []¶; Distribution of active n-body levels among model chemistry levels. All bodies in range [1, self.max_nbody] must be present exactly once. Number of items in outer list is how many different modelchems. Each inner list specifies what n-bodies to be run at the corresponding modelchem (e.g., [[1, 2]] has max_nbody=2 and 1-body and 2-body contributions computed at the same level of theory; [[1], [2]] has max_nbody=2 and 1-body and 2-body contributions computed at different levels of theory. An entry ‘supersystem’ means all higher order n-body effects up to the number of fragments. The n-body levels are effectively sorted in the outer list, and any ‘supersystem’ element is at the end. field nfragments: int = -1¶; Number of distinct fragments comprising full molecular supersystem. Validated by:. set_nfragments. field quiet: bool = False¶; Whether to print/log formatted n-body energy analysi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/nbody.html:13383,Validat,Validated,13383,psi4manual/1.7.x/nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/nbody.html,1,['Validat'],['Validated']
Security,"elem(dict_row, dict_col):; """"""Return merge of index dictionaries *dict_row* and *dict_col* (precedence) with error string from serrors appended at key 'matelem'.""""""; kw = dict(dict_row, **dict_col); errpiece = serrors['-'.join([kw[bit] for bit in ['mtd', 'opt', 'bas']])][kw['sset']][kw['dbse']]; kw['matelem'] = errpiece[kw['err']]; if 'tgtcnt' in errpiece:; kw['count'] = errpiece['tgtcnt']; if 'misscnt' in errpiece and errpiece['misscnt'] != 0 and 'tgtcnt' in errpiece:; kw['footnote'] = r""""""\footnotemark{Missing %d of %d reactions.}"""""" % (errpiece['misscnt'], errpiece['tgtcnt']); else:; kw['footnote'] = ''; return kw. # avoid misunderstandings; keysincolumnplan = set(sum([col[-1].keys() for col in columnplan], [])); for key in ['dbse', 'sset', 'mtd', 'opt', 'bas', 'err']:; if len(locals()[key]) > 1:; if key not in rowplan and key not in keysincolumnplan:; print(""""""Warning: non-first values in argument '{0}' won't """"""; """"""get used. Add '{0}' to rowplan to iterate over """"""; """"""the values or add to columnplan to access""""""; """"""different values."""""".format(key)); sys.exit(). # form LaTeX reference tag; tag = []; for key in ['dbse', 'sset', 'mtd', 'opt', 'bas', 'err']:; if len(locals()[key]) == 1 or (key == rowplan[0] and not subjoin):; tag.append(key); tag = set(tag); for col in columnplan:; tag -= set(col[4].keys()). # form column headers; start = 1; stop = 1; head0 = ''; for index in range(2, len(columnplan)):; if columnplan[index][1] == columnplan[index - 1][1]:; stop = index; else:; head0 += r""""""\cline{%d-%d}"""""" % (start + 1, stop + 1); start = index; stop = index; if index + 1 == len(columnplan):; head0 += r""""""\cline{%d-%d}"""""" % (start + 1, stop + 1). abbr = ''.join([col[0] for col in columnplan]); h1 = [(k, len(list(g))) for k, g in itertools.groupby([col[1] for col in columnplan])]; head1 = ' & '.join([r""""""\multicolumn{%d}{c}{\textbf{%s}}"""""" % (repeat, label) for (label, repeat) in h1]) + r"""""" \\ """"""; h2 = [(k, len(list(g))) for k, g in itertools.groupby([col[2] fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html:6395,access,access,6395,psi4manual/1.0.0/_modules/qcdb/textables.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/textables.html,1,['access'],['access']
Security,"elf.get_coord_value(entries[4]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval)). # handle fourth line of Zmat; elif len(entries) == 7:; tempfrag.append(iatom). rTo = self.get_anchor_atom(entries[1], line); if rTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[1])); aTo = self.get_anchor_atom(entries[3], line); if aTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[3])); dTo = self.get_anchor_atom(entries[5], line); if dTo >= iatom:; raise ValidationError(""Error on geometry input line %s. Atom %s has not been defined yet.\n"" % (line, entries[5])); if aTo == rTo or rTo == dTo or aTo == dTo: # for you star wars fans; raise ValidationError(""Atom used multiple times on line %s"" % (line)). rval = self.get_coord_value(entries[2]); aval = self.get_coord_value(entries[4]); dval = self.get_coord_value(entries[6]). if self.full_atoms[rTo].symbol() == 'X':; rval.set_fixed(True); if self.full_atoms[aTo].symbol() == 'X':; aval.set_fixed(True); if self.full_atoms[dTo].symbol() == 'X':; dval.set_fixed(True). self.full_atoms.append(ZMatrixEntry(iatom, zVal, charge, \; el2masses[atomSym], atomSym, atomLabel, \; self.full_atoms[rTo], rval, \; self.full_atoms[aTo], aval, \; self.full_atoms[dTo], dval)). else:; raise ValidationError('Illegal geometry specification line : %s. \; You should provide either Z-Matrix or Cartesian input' % (line)). iatom += 1. self.fragments.append([tempfrag[0], tempfrag[-1]]); self.fragment_types.append('Real'). [docs] def init_with_checkpoint(self, chkpt):; """""" **NYI** Pull information from the *chkpt* object passed; (method name in libmints is init_with_chkpt). """"""; raise ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html:19414,Validat,ValidationError,19414,psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/libmintsmolecule.html,2,['Validat'],['ValidationError']
Security,"elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_basis(kwargs['scf_basis'].lower()); else:; if do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError('SCF basis sets through keyword \'%s\' are required. Or perhaps you forgot the \'%s\'.' % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = validate_bracketed_basis(kwargs['delta_basis'].lower()); else:; raise ValidationError('DELTA basis sets through keyword \'%s\' are required.' % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = validate_bracketed_basis(kwargs['delta2_basis'].lower()); else:; raise ValidationError('DELTA2 basis sets through keyword \'%s\' are required.' % ('delta2_basis')). # Es",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:75430,Validat,ValidationError,75430,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"elif name in ['mp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccsd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); elif name in ['ccsd(t)']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); corl_type = core.get_global_option('CC_TYPE'); else:; raise ValidationError('Unidentified method %s' % (name)). if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd', 'ccsd(t)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); if corl_type not in [""DF"", ""CD""]:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC""""""). core.set_global_option('DERTYPE', 'FIRST'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:60582,Validat,ValidationError,60582,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['Validat'],['ValidationError']
Security,"elif no.match(str(db_zpe)):; pass; else:; raise ValidationError('Zero-point-correction \'mode\' %s not valid.' % (db_zpe)). # Option benchmark- whether error statistics computed wrt alternate reference energies; db_benchmark = 'default'; if 'benchmark' in kwargs:; db_benchmark = kwargs['benchmark']. if (db_benchmark.lower() == 'default'):; pass; else:; BIND = getattr_ignorecase(database, 'BIND_' + db_benchmark); if BIND is None:; raise ValidationError('Special benchmark \'%s\' not available for database %s.' % (db_benchmark, db_name)). # Option tabulate- whether tables of variables other than primary energy method are formed; db_tabulate = []; if 'tabulate' in kwargs:; db_tabulate = kwargs['tabulate']. # Option subset- whether all of the database or just a portion is run; db_subset = HRXN; if 'subset' in kwargs:; db_subset = kwargs['subset']. if isinstance(db_subset, basestring):; if (db_subset.lower() == 'small'):; try:; database.HRXN_SM; except AttributeError:; raise ValidationError('Special subset \'small\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_SM; elif (db_subset.lower() == 'large'):; try:; database.HRXN_LG; except AttributeError:; raise ValidationError('Special subset \'large\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_LG; elif (db_subset.lower() == 'equilibrium'):; try:; database.HRXN_EQ; except AttributeError:; raise ValidationError('Special subset \'equilibrium\' not available for database %s.' % (db_name)); else:; HRXN = database.HRXN_EQ; else:; HRXN = getattr_ignorecase(database, db_subset); if HRXN is None:; HRXN = getattr_ignorecase(database, 'HRXN_' + db_subset); if HRXN is None:; raise ValidationError('Special subset \'%s\' not available for database %s.' % (db_subset, db_name)); else:; temp = []; for rxn in db_subset:; if rxn in HRXN:; temp.append(rxn); else:; raise ValidationError('Subset element \'%s\' not a member of database %s.' % (str(rxn), db_name)); HRXN = temp. temp = []; for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:35508,Validat,ValidationError,35508,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Validat'],['ValidationError']
Security,"ell molecule:. runs MP2 with default DF with default implementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. ccsd(at); CC_TYPE. CCENERGY; D. DETCI. DFMP2. FNOCC. OCC. D; D. cisd; CI_TYPE. CCENERGY. DETCI; Y. D. DFMP2. FNOCC; D. OCC. adc(2); MP_TYPE. ADCC; Y. D. BUILTIN; D. Footnotes. 1; Algorithm type selection keyword below. Values to the right: conventional CONV (here abbreviated CV), density-fitted DF, and Cholesky-decomposed CD. 2(1,2); Also available for KS reference. 3(1,2); Conditions have no default module (computationally inefficient) and can only be accessed by specifying QC_MODULE. table of contents. Notes on Options; Alternate Implementations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/notes_c-1.html:3557,access,accessed,3557,psi4manual/1.4.0/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/notes_c-1.html,2,['access'],['accessed']
Security,"else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(cls: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array QCVariable *key* to *val* on *cls*."""""". if isinstance(val, core.Matrix):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if cls.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; cls.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if cls.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; cls.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array QCVariable *key* from global memory if present."""""". if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(cls: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array QCVariable *key* from *cls* if present."""""". if cls.has_scalar_variable(key):; cls.del_scalar_variable(key); elif cls.has_array_variable(key):; cls.del_array_variable(key). def _core_variables(include_deprecated_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html:31641,Validat,ValidationError,31641,psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/python_helpers.html,1,['Validat'],['ValidationError']
Security,"else:; raise ValidationError(""""""CORL basis sets through keyword '%s' are required."""""" % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 basis sets through keyword \'%s\' are required.' % ('delta3_basis')); #; # # Establish list of valid basis sets for fourth delta correction energy; # if do_delta4:; # if 'delta4_basis' in kwargs:; # BSTD4, ZETD4 = validate_bracketed_basis(kwargs['delta4_basis'].lower()); # else:; # raise ValidationError('DELTA4 basis sets through keyword \'%s\' are required.' % ('delta4_basis')); #; # # Establish list of valid basis sets for fifth delta correction energy; # if do_delta5:; # if 'delta5_basis' in kwargs:; # BSTD5, ZETD5 = validate_bracketed_basis(kwargs['delta5_basis'].lower()); # else:; # raise ValidationError('DELTA5 basis sets through keyword \'%s\' are required.' % ('del",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:37025,Validat,ValidationError,37025,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"else:; scf[""wfn""] = ""hf""; scf[""basis""] = ([stage[""basis""][0][-1]], [stage[""basis""][1][-1]]); scf[""treatment""] = ""scf""; scf[""stage""] = ""scf""; scf[""scheme""] = _get_default_xtpl(len(scf[""basis""][1]), scf[""treatment""]); scf[""alpha""] = None; scf[""options""] = False; metadata.append(scf); # 2c) keep processing current stage; stage[""treatment""] = item.get(""treatment"", ""scf"" if len(metadata) == 0 else ""corl""); stage[""stage""] = item.get(""stage"", False); if not stage[""stage""]:; if len(metadata) == 0:; stage[""stage""] = ""scf""; elif len(metadata) == 1:; stage[""stage""] = ""corl""; else:; stage[""stage""] = ""delta{0:d}"".format(len(metadata) - 1); stage[""scheme""] = item.get(""scheme"", _get_default_xtpl(len(stage[""basis""][1]), stage[""treatment""])); if len(metadata) > 0:; stage[""wfn_lo""] = item.get(""wfn_lo"", metadata[-1].get(""wfn"")).lower(); stage[""basis_lo""] = _expand_bracketed_basis(item.get(""basis_lo"", item[""basis""]).lower(), molecule); if len(stage[""basis""][0]) != len(stage[""basis_lo""][0]):; raise ValidationError(""""""Number of basis sets inconsistent; between high ({0:d}) and low ({1:d}) levels."""""".format(; len(stage[""basis""][0]), len(stage[""basis_lo""][0]))); stage[""alpha""] = item.get(""alpha"", None); stage[""options""] = item.get(""options"", False); metadata.append(stage); return (metadata). def _process_cbs_kwargs(kwargs):; """""" A helper function which translates supplied kwargs into the; ``cbs_metadata`` format and passes it for validation. Parameters; ----------; kwargs : dict; kwargs containing the CBS function specification. Returns; -------; list; List of dictionaries, with each item consisting of an extrapolation; stage. All validation takes place here.; """""". molecule = kwargs.get('molecule', core.get_active_molecule()). if ""cbs_metadata"" in kwargs:; # if we passed in a dict, validate it right away; cbs_metadata = kwargs[""cbs_metadata""]; else:; # if we passed in options, check for consecutive correlations first; if ""delta_wfn"" in kwargs and ""corl_wfn"" not in kwargs:; raise ValidationE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:31105,Validat,ValidationError,31105,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,1,['Validat'],['ValidationError']
Security,"elta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; # pass; #elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; # pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = _expand_bracketed_basis(kwargs['corl_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""CORL basis sets through keyword '%s' are required."""""" % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = _expand_bracketed_basis(kwargs['scf_basis'].lower(), molecule=molstr); elif do_corl:; BSTR = BSTC[:]; ZETR = ZETC[:]; else:; raise ValidationError(""""""SCF basis sets through keyword '%s' are required. Or perhaps you forgot the '%s'."""""" % ('scf_basis', 'corl_wfn')). # Establish list of valid basis sets for delta correction energy; if do_delta:; if 'delta_basis' in kwargs:; BSTD, ZETD = _expand_bracketed_basis(kwargs['delta_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA basis sets through keyword '%s' are required."""""" % ('delta_basis')). # Establish list of valid basis sets for second delta correction energy; if do_delta2:; if 'delta2_basis' in kwargs:; BSTD2, ZETD2 = _expand_bracketed_basis(kwargs['delta2_basis'].lower(), molecule=molstr); else:; raise ValidationError(""""""DELTA2 basis sets through keyword '%s' are required."""""" % ('delta2_basis')). # # Establish list of valid basis sets for third delta correction energy; # if do_delta3:; # if 'delta3_basis' in kwargs:; # BSTD3, ZETD3 = validate_bracketed_basis(kwargs['delta3_basis'].lower()); # else:; # raise ValidationError('DELTA3 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:36369,Validat,ValidationError,36369,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,3,['Validat'],['ValidationError']
Security,"elta5_wfn in VARH.keys()):; raise ValidationError('Requested DELTA5 method \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn)). if 'delta5_wfn_lesser' in kwargs:; cbs_delta5_wfn_lesser = kwargs['delta5_wfn_lesser'].lower(); else:; cbs_delta5_wfn_lesser = 'mp2'; if not (cbs_delta5_wfn_lesser in VARH.keys()):; raise ValidationError('Requested DELTA5 method lesser \'%s\' is not recognized. Add it to VARH in wrapper.py to proceed.' % (cbs_delta5_wfn_lesser)). # Check that user isn't skipping steps in scf + corl + delta + delta2 sequence; if do_scf and not do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and not do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and not do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and not do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and not do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and not do_delta5:; pass; elif do_scf and do_corl and do_delta and do_delta2 and do_delta3 and do_delta4 and do_delta5:; pass; else:; raise ValidationError('Requested scf (%s) + corl (%s) + delta (%s) + delta2 (%s) + delta3 (%s) + delta4 (%s) + delta5 (%s) not valid. These steps are cummulative.' %; (do_scf, do_corl, do_delta, do_delta2, do_delta3, do_delta4, do_delta5)). # Establish list of valid basis sets for correlation energy; if do_corl:; if 'corl_basis' in kwargs:; BSTC, ZETC = validate_bracketed_basis(kwargs['corl_basis'].lower()); else:; raise ValidationError('CORL basis sets through keyword \'%s\' are required.' % ('corl_basis')). # Establish list of valid basis sets for scf energy; if 'scf_basis' in kwargs:; BSTR, ZETR = validate_bracketed_b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:75011,Validat,ValidationError,75011,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"em"": np.array(E),; ""mass"": np.array(mass, dtype=float),; ""real"": np.array(real, dtype=bool),; ""elbl"": np.array(label),; }. def validate_and_fill_fragments(nat, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None):; """"""Check consistency of fragment specifiers wrt type and length. For; charge & multiplicity, scientific defaults are not computed or applied;; rather, missing slots are filled with `None` for later processing. """"""; if fragment_separators is None:; if fragment_charges is None and fragment_multiplicities is None:; frs = [] # np.array([], dtype=int) # if empty, needs to be both ndarray and int; frc = [None]; frm = [None]; else:; raise ValidationError(; """"""Fragment quantities given without separation info: sep ({}), chg ({}), and mult ({})"""""".format(; fragment_separators, fragment_charges, fragment_multiplicities; ); ); else:; trial_geom = np.zeros((nat, 3)); try:; split_geom = np.split(trial_geom, fragment_separators, axis=0); except TypeError:; raise ValidationError(; """"""fragment_separators ({}) unable to perform trial np.split on geometry."""""".format(fragment_separators); ); if any(len(f) == 0 for f in split_geom):; if nat != 0:; raise ValidationError(; """"""fragment_separators ({}) yields zero-length fragment(s) after trial np.split on geometry."""""".format(; split_geom; ); ); if sum(len(f) for f in split_geom) != nat:; raise ValidationError(; """"""fragment_separators ({}) yields overlapping fragment(s) after trial np.split on geometry, possibly unsorted."""""".format(; split_geom; ); ); frs = fragment_separators; nfr = len(split_geom). if fragment_charges is None:; frc = [None] * nfr; else:; try:; frc = [(f if f is None else float(f)) for f in fragment_charges]; except TypeError:; raise ValidationError(""""""fragment_charges not among None or float: {}"""""".format(fragment_charges)). if fragment_multiplicities is None:; frm = [None] * nfr; elif all(f is None or (isinstance(f, (int, np.integer)) and f >= 1) for f in fragment_multiplicities):; f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html:20873,Validat,ValidationError,20873,psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molparse/from_arrays.html,3,['Validat'],['ValidationError']
Security,"ementation DFMP2; energy('mp2'). runs MP2 with CONV with default implementation OCC; set mp2_type conv; energy('mp2'). runs MP2 with default DF with implementation OCC; set qc_module occ; energy('mp2'). Overlapping capabilities of PSI4. “Y” is available; “D” is default.¶. name; _; type select 1. QC_MODULE; REFERENCE; _. energy(); gradient(). RHF; UHF; ROHF; RHF; UHF; ROHF. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. mp2; MP2_TYPE. CCENERGY. DETCI; Y. Y. DFMP2. D 2. D 2. D. D. FNOCC; Y. OCC; D; Y; D; D; Y; Y; D; Y; D; D; Y. D; D. mp3; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; Y. OCC; D; D; D; D; D; D. D; D. D; D. mp2.5; MP_TYPE. CCENERGY. DETCI. DFMP2. FNOCC. OCC; D; D; D; D; D; D. D; D. D; D. mp4; MP_TYPE. CCENERGY. DETCI; Y. Y 3. DFMP2. FNOCC; D. OCC. lccd; CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC; Y; D; D; D; D; D. D; D. D; D. lccsd, cepa(0); CC_TYPE. CCENERGY. DETCI. DFMP2. FNOCC; D. OCC. ccsd; CC_TYPE. CCENERGY; D. D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. D. ccsd(t); CC_TYPE. CCENERGY; D. D. D. D. D. DETCI. DFMP2. FNOCC; Y; D; D. OCC. Y; Y. a-ccsd(t) 4; CC_TYPE. CCENERGY; D. DETCI. DFMP2. FNOCC. OCC. D; D. cisd; CI_TYPE. CCENERGY. DETCI; Y. D. DFMP2. FNOCC; D. OCC. adc(2); MP_TYPE. ADCC; Y. D. BUILTIN; D. Footnotes. 1; Algorithm type selection keyword below. Values to the right: conventional CONV (here abbreviated CV), density-fitted DF, and Cholesky-decomposed CD. 2(1,2); Also available for KS reference. 3(1,2); Conditions have no default module (computationally inefficient) and can only be accessed by specifying QC_MODULE. 4; Also known as CCSD(AT), Lambda-CCSD(T), CCSD(T)_L. table of contents. Notes on Options; Alternate Implementations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; Notes on Options. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/notes_c-1.html:3560,access,accessed,3560,psi4manual/1.5.0/notes_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/notes_c-1.html,2,['access'],['accessed']
Security,"en optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. extern4; External potential calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to validate the gradient on the charges. tdscf-7; TD-HF test variable access. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mom-h2o-3; MOM excitation from LUMO HOMO+3. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. fsapt-ext-abc; FSAPT with external charge on trimer. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:17313,access,access,17313,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['access'],['access']
Security,"ence geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (freq_mode.lower() == 'sow'):; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """"""# to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """"""# has produced a number of input files (FREQ-*.in) for individual components\n""""""; instructionsO += """"""# and a single input file (FREQ-master.in) with a frequency(mode='reap') command.\n""""""; instructionsO += """"""# These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """"""# rather than normal input. Follow the instructions below (repeated in FREQ-master.in)\n""""""; instructionsO += """"""# to continue.\n#\n""""""; instructionsO += """"""# Alternatively, a single-job execution of the hessian may be accessed through\n""""""; instructionsO += """"""# the frequency wrapper option mode='continuous'.\n#\n""""""; psi4.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this frequency computation.\n#\n""""""; instructionsM += """"""# (1) Run all of the FREQ-*.in input files on any variety of computer architecture.\n""""""; instructionsM += """"""# The output file names must be as given below (these are the defaults when executed\n""""""; instructionsM += """"""# as `psi4 FREQ-1.in`, etc.).\n#\n""""""; for rgt in range(ndisp):; pre = 'FREQ-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# FREQ-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the frequency computation in its output file.\n#\n""""""; instructionsM += """"""# psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:66837,access,accessed,66837,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['access'],['accessed']
Security,"ence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']) # yes, this really must be global, not local to SCF. # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if ref_wfn.basisset().has_ECP():; raise ValidationError('DF-MP2 gradients with an ECP are not yet available. Use dertype=0 to select numerical gradients.'). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:66088,Validat,ValidationError,66088,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['Validat'],['ValidationError']
Security,enceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; libint2_configuration; libint2_print_out; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energies_from_fcidump; expand_psivars; fcidump; fcidump_from_file; find_approximate_string_matches; format_molecule_for_input; format_options_for_input; free_atom_volumes; Gaussian; get_memory; get_psifile; getattr_ignorecase; hamiltonian_solver; hold_options_state; import_ignorecase; InPsight; kwargs_lower; levenshtein; libint2_configuration; libint2_print_out; Lineshape; Lorentzian; mat2arr; message_box; oeprop; OptionsState; OptionsStateCM; OptionState; pcm_helper; plump_qcvar; prefactor_ecd; prefactor_opa; prepare_options_for_modules; prepare_options_for_set_options; provenance_stamp; sanitize_method; set_memory; set_module_options; set_options; SolverEngine; spectrum; state_to_atomicinput; ParsingError; PastureRequiredError; pcm_helper; process_input; prop; properties; PsiException; compare_vibinfos; filter_nonvib; filter_omega_to_real; harmonic_analysis; hessian_symmetrize; print_molden_vibs; print_vibs; thermo; QMMM; QMMMbohr; sanitize_method; sanitize_name; scf_helper; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_module_options; set_options; tdscf; TDSCFConvergenceError; TestComparisonError; UpgradeHelper; ValidationError; vibanal_wfn.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1739451,Validat,ValidationError,1739451,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,3,['Validat'],['ValidationError']
Security,"encies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples:. >>> # [1] Frequency cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.frequencies-1.html:1087,access,accesses,1087,psi4manual/1.3.2/api/psi4.driver.frequencies-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.frequencies-1.html,2,['access'],['accesses']
Security,"encies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:1065,access,accesses,1065,psi4manual/1.1.0/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html,3,['access'],['accesses']
Security,"end('-grad'); try:; #print('command', command); dashout = subprocess.Popen(command, stdout=subprocess.PIPE, env=lenv); except OSError as e:; raise ValidationError('Program gcp not found in path. %s' % e); out, err = dashout.communicate(). # Parse output; success = False; for line in out.splitlines():; line = line.decode('utf-8'); if re.match(' Egcp:', line):; sline = line.split(); dashd = float(sline[1]); if re.match(' normal termination of gCP', line):; success = True. if not success:; os.chdir(current_directory); raise Dftd3Error(""""""Unsuccessful gCP run.""""""). # Parse grad output; if derint != 0:; derivfile = './gcp_gradient'; dfile = open(derivfile, 'r'); dashdderiv = []; for line in geom.splitlines():; lline = line.split(); if len(lline) != 4:; continue; if lline[0] == 'Gh':; dashdderiv.append([0.0, 0.0, 0.0]); else:; dashdderiv.append([float(x.replace('D', 'E')) for x in dfile.readline().split()]); dfile.close(). if len(dashdderiv) != self.natom():; raise ValidationError('Program gcp gradient file has %d atoms- %d expected.' % \; (len(dashdderiv), self.natom())). # Prepare results for Psi4; if isP4regime and derint != 0:; core.set_variable('GCP CORRECTION ENERGY', dashd); psi_dashdderiv = core.Matrix.from_list(dashdderiv). # Print program output to file if verbose; if not verbose and isP4regime:; verbose = True if core.get_option('SCF', 'PRINT') >= 3 else False; if verbose:. text = '\n ==> GCP Output <==\n'; text += out.decode('utf-8'); if derint != 0:; with open(derivfile, 'r') as handle:; text += handle.read().replace('D', 'E'); text += '\n'; if isP4regime:; core.print_out(text); else:; print(text). # # Clean up files and remove scratch directory; # os.unlink(paramfile1); # os.unlink(paramfile2); # os.unlink(geomfile); # if derint != 0:; # os.unlink(derivfile); # if defmoved is True:; # os.rename(defaultfile + '_hide', defaultfile). # clean up files and remove scratch directory; os.chdir('..'); try:; shutil.rmtree(gcp_tmpdir); except OSError as err:; raise OSEr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html:8813,Validat,ValidationError,8813,psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/qcdb/interface_gcp.html,1,['Validat'],['ValidationError']
Security,"energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. # CSXError ceased to be used by v1.4. Class removed by v1.7; # class CSXError(PsiException):. [docs]; class MissingMethodError(ValidationError):; """"""Error called when requested level or theory or derivative level are not; available. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; ValidationError.__init__(self, msg); self.message = '\nMissingMethodError: %s\n\n' % msg. [docs]; class ManagedMethodError(PsiException):; """"""Error called when a requested level of theory and derivative level are; nominally available but not for the particular conditions (e.g., reference,; algorithm, active orbitals, QC module, etc.) requested. Parameters; ----------; circs; List providing calling function name, level of theory, algorithm,; reference, QC module, and frozen-core/all-electron requested conditions. Attributes; ----------; message; Human readable string describing the exception.; stats; Dictionary of conditions for which method request was made.; Keys are:. - driver : {""energy"", ""gradient"", ""hessian"", ""properties""}; - derivative_int : {0, 1, 2, ""prop""}, integer representation of driver; - method : str, model/method/level-of-theory; - link : str, link address to table in docs; - method_type : (str, str), raw value and str repr of governing variable and algorithm; - ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:9918,Validat,ValidationError,9918,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,3,['Validat'],['ValidationError']
Security,"engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:63452,Validat,ValidationError,63452,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['Validat'],['ValidationError']
Security,enshell_override = 1; psi4.print_out('\nSome reagents in database %s require an open-shell reference; will be reset to UHF/UKS as needed.\n' % (db_name)). # Configuration based upon database keyword options; # Option symmetry- whether symmetry treated normally or turned off (currently req'd for dfmp2 & dft); db_symm = 'yes'; if 'symm' in kwargs:; db_symm = kwargs['symm']. symmetry_override = 0; if no.match(str(db_symm)):; symmetry_override = 1; elif yes.match(str(db_symm)):; pass; else:; raise ValidationError('Symmetry mode \'%s\' not valid.' % (db_symm)). # Option mode of operation- whether db run in one job or files farmed out; if not('db_mode' in kwargs):; if ('mode' in kwargs):; kwargs['db_mode'] = kwargs['mode']; del kwargs['mode']; else:; kwargs['db_mode'] = 'continuous'; db_mode = kwargs['db_mode']. if (db_mode.lower() == 'continuous'):; pass; elif (db_mode.lower() == 'sow'):; pass; elif (db_mode.lower() == 'reap'):; if 'linkage' in kwargs:; db_linkage = kwargs['linkage']; else:; raise ValidationError('Database execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Database execution mode \'%s\' not valid.' % (db_mode)). # Option counterpoise- whether for interaction energy databases run in bsse-corrected or not; db_cp = 'no'; if 'cp' in kwargs:; db_cp = kwargs['cp']. if yes.match(str(db_cp)):; try:; database.ACTV_CP; except AttributeError:; raise ValidationError('Counterpoise correction mode \'yes\' invalid for database %s.' % (db_name)); else:; ACTV = database.ACTV_CP; elif no.match(str(db_cp)):; pass; else:; raise ValidationError('Counterpoise correction mode \'%s\' not valid.' % (db_cp)). # Option relaxed- whether for non-frozen-monomer interaction energy databases include deformation correction or not?; db_rlxd = 'no'; if 'rlxd' in kwargs:; db_rlxd = kwargs['rlxd']. if yes.match(str(db_rlxd)):; if yes.match(str(db_cp)):; try:; database.ACTV_CPRLX; database.RXNM_CPRLX; except AttributeError:; raise ValidationError('Deformation ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:33506,Validat,ValidationError,33506,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Validat'],['ValidationError']
Security,"ensity matrices. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. serial-wfn; A simple hf/cc-pvdz water calculation. The resulting wavefunction is written to a file, and then a new wavefunction is generated from that file. The member variables of both wavefunctions should be identical in value. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-upcast-custom-basis; test scf castup with custom basis sets. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:3666,validat,validate,3666,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['validat'],['validate']
