quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"rix:; # moldict['zmat'] = self.zmat; # TODO zmat, geometry_variables. nat = self.natom(); geom = np.array(self.geometry()) # [a0]; if molrec['units'] == 'Angstrom':; geom *= constants.bohr2angstroms #self.input_units_to_au(); molrec['geom'] = geom.reshape((-1)). molrec['elea'] = np.array([self.mass_number(at) for at in range(nat)]); molrec['elez'] = np.array([qcel.periodictable.to_Z(self.symbol(at)) for at in range(nat)]); molrec['elem'] = np.array([self.symbol(at).capitalize() for at in range(nat)]); molrec['mass'] = np.array([self.mass(at) for at in range(nat)]); molrec['real'] = np.array([bool(self.Z(at)) for at in range(nat)]); molrec['elbl'] = np.array([self.label(at)[len(self.symbol(at)):].lower() for at in range(nat)]). fragments = [x[:] for x in self.get_fragments()]; fragment_charges = [float(f) for f in self.get_fragment_charges()]; fragment_multiplicities = [m for m in self.get_fragment_multiplicities()]. # do trimming not performed in Molecule class b/c fragment_* member data never directly exposed; for ifr, fr in reversed(list(enumerate(self.get_fragment_types()))):; if fr == 'Ghost':; fragment_charges[ifr] = 0.; fragment_multiplicities[ifr] = 1; elif fr == 'Absent':; del fragment_charges[ifr]; del fragment_multiplicities[ifr]; # readjust atom indices for subsequent fragments; renum = fragments[ifr][0]; for iffr, ffr in enumerate(fragments):; if iffr <= ifr:; continue; lenfr = ffr[1] - ffr[0]; fragments[iffr] = [renum, renum + lenfr]; renum += lenfr; del fragments[ifr]. molrec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the diffe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html:51022,perform,performed,51022,psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/qcdb/molecule.html,2,['perform'],['performed']
Performance,"rize( (Matrix)arg1) -> None :; | docstring; | ; | clone(...); | clone( (Matrix)arg1) -> Matrix :; | docstring; | ; | coldim(...); | coldim( (Matrix)arg1) -> Dimension :; | docstring; | ; | cols(...); | cols( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | copy_lower_to_upper(...); | copy_lower_to_upper( (Matrix)arg1) -> None :; | docstring; | ; | copy_upper_to_lower(...); | copy_upper_to_lower( (Matrix)arg1) -> None :; | docstring; | ; | diagonalize(...); | diagonalize( (Matrix)arg1, (Matrix)arg2, (Vector)arg3, (DiagonalizeOrder)arg4) -> None :; | docstring; | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | project_out(...); | project_out( (Matrix)arg1, (Matrix)arg2) -> None :; | docstring; | ; | remove_symmetry(...); | remove_symmetry( (Matrix)arg1, (Matrix)arg2, (Matrix)arg3) -> None :; | docstring; | ; | rms(...); | rms( (Matrix)arg1) -> float :; | docstring; | ; | rowdim(...); | rowdim( (Matrix)arg1) -> Dimension :; | docstring; | ; | rows(...); | rows( (Matrix)arg1, (int)arg2) -> int :; | docstring; | ; | save(...); | save( (Matrix)arg1, (str)arg2, (bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:41230,load,load,41230,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,8,['load'],['load']
Performance,"rizes current DCT code features:. Method; Available algorithms; Energy; Gradient; Reference. ODC-06; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-12; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-13; SIMULTANEOUS, QC; Y; Y; UHF. \(\mbox{ODC-12$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. \(\mbox{ODC-13$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE RHF is only available for; ALGORITHM SIMULTANEOUS. To compute \((\lambda_3)\) correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dct'). The energy('dct') call to energy() executes the DCT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dct'). The optimize('dct') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases whe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dct.html:13450,perform,perform,13450,psi4manual/master/dct.html,https://psicode.org,https://psicode.org/psi4manual/master/dct.html,9,['perform'],['perform']
Performance,"rked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57283,Optimiz,Optimization,57283,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,14,"['Optimiz', 'optimiz']","['Optimization', 'optimizer']"
Performance,"rlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-cbs1; Various basis set extrapolation tests. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. opt2; SCF DZ allene geometry optimzation, with Cartesian input. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc54; CCSD dipole with user-specified basis set. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:10626,optimiz,optimization,10626,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['optimiz'],['optimization']
Performance,"rload on pointer types and/or use pointer types with templates,; use nullptr to signal the null pointer. The correct overload/template; parameter will then be deduced. Using nullptr also makes the code more; readable, especially if auto is used consistently throughout.; Reference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:. // Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Ensures exception safety and prevents resource leaks.; Improves efficiency:. // Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:. std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:. int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:. std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); // might not be correct on some compiler/machines; auto size = v.size(); // size is ALWAYS of the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_style_c.html:1273,Perform,Performs,1273,psi4manual/master/prog_style_c.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_style_c.html,9,['Perform'],['Performs']
Performance,"rm IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number \(N\).; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:23320,tune,tuned,23320,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,2,['tune'],['tuned']
Performance,rm a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3opatm. b3lyp-d3zero2b. b3lyp-d3zeroatm. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Fu,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:3327,optimiz,optimized,3327,psi4manual/1.8.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html,3,['optimiz'],['optimized']
Performance,rm a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3zero2b. b3lyp-d3zeroatm. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:4016,optimiz,optimized,4016,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,9,['optimiz'],['optimized']
Performance,"rms IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number .; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; memory 512 MB. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # FRAC jobs must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do all kinds of weird stuff; basis aug-cc-pvdz # Augmented functions are very important on the anion side; scf_type df; dft_functional wb97; }. # Argument is the molecule object.; # Many optional arguments are available, see the python file; frac_traverse(h2o). The other macro is frac_nuke(), which strips several electrons out of the; system to gather information on the MSIE over a range of orbitals. The input is; identical to the above, except that the frac_traverse() call is substituted; for something lik",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dft-1.html:20308,perform,perform,20308,psi4manual/4.0b3/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dft-1.html,8,['perform'],['perform']
Performance,"rms IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. Psi4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number .; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # FRAC jobs must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do all kinds of weird stuff; basis aug-cc-pvdz # Augmented functions are very important on the anion side; scf_type df; dft_functional wb97; }. # Argument is the molecule object.; # Many optional arguments are available, see the python file; frac_traverse(h2o). The other macro is frac_nuke(), which strips several electrons out of the; system to gather information on the MSIE over a range of orbitals. The input is; identical to the above, except that the frac_traverse() call is substitute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:20656,perform,perform,20656,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['perform'],['perform']
Performance,"rms a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; freq. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.freq.html:2777,optimiz,optimize,2777,psi4manual/1.6.x/api/psi4.driver.freq.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.freq.html,1,['optimiz'],['optimize']
Performance,"rms both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. pywrap-cbs1; Various basis set extrapolation tests. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. scf3; File retention, docc, socc, and bond distances specified explicitly. mbis-2; MBIS calculation on OH- (Expanded Arr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:6983,perform,performed,6983,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"rms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:9605,optimiz,optimizations,9605,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,7,['optimiz'],['optimizations']
Performance,"rn wfn. core.Wavefunction.build = _core_wavefunction_build. def _core_wavefunction_get_scratch_filename(self: core.Wavefunction, filenumber: int) -> str:; """"""Return canonical path to scratch file `filenumber` based on molecule on `self`. Parameters; ----------; self; Wavefunction instance.; filenumber; Scratch file number from :source:`psi4/include/psi4/psifiles.h`. """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data laid out like; :meth:`~psi4.core.Wavefunction.to_file`. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to; :py:func:`numpy.load` to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmoni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:8146,load,load,8146,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['load'],['load']
Performance,"rnal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:19221,optimiz,optimization,19221,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"rnal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:19607,optimiz,optimization,19607,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"rname, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:44734,perform,perform,44734,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['perform'],['perform']
Performance,"rname, molecule, **kwargs); logger.debug('GRADIENT PLAN'); logger.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:38047,perform,perform,38047,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['perform'],['perform']
Performance,"rning the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM —. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR —. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA —. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT —. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 —. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 —. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM —. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (MP2); MP2 — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:6833,CACHE,CACHELEVEL,6833,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"roach employed in this code; is similar to the “model Hessian plus RF method” described and tested by Bakken and; Helgaker [Bakken:2002:9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC follo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optking-1.html:1794,Optimiz,Optimizing,1794,psi4manual/4.0b4/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html,4,['Optimiz'],['Optimizing']
Performance,"robe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc. func = None; if reference",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:14098,perform,performance,14098,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"rocedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:. Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmitted to the child jobs.; Function intercalls (e.g., db(opt())) are not tested with sow/reap procedures. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Embarrassing Parallelism. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sowreap.html:1479,Optimiz,Optimization,1479,psi4manual/master/sowreap.html,https://psicode.org,https://psicode.org/psi4manual/master/sowreap.html,2,"['Optimiz', 'optimiz']","['Optimization', 'optimize']"
Performance,"rocedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:22959,Optimiz,Optimize,22959,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"rocedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end="""");",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:25428,Optimiz,Optimize,25428,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"rocedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:32939,Optimiz,Optimize,32939,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/kw-1; testing best practices options, part i. cfour/kw-6; Basis set spherical/Cartesian wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html:2814,optimiz,optimization,2814,psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,2,['optimiz'],['optimization']
Performance,rom the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/UHF/RKS/UKS. The orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. omp3; Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp3; A special version of SCS-OMP3 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/UHF/RKS/UKS. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to deter,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:5109,Optimiz,Optimized,5109,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,2,['Optimiz'],['Optimized']
Performance,"ron integrals; and computing the terms that involve these integrals in the AO; basis. In order to do that one needs to set the AO_BASIS option to; DISK. For more recommendations on the choice of the algorithm see; Recommendations section. Analytic Gradients¶; Analytic gradients are available for the DC-06 method. Gradients are only; available if the ALGORITHM option is set to TWOSTEP or SIMULTANEOUS for; the energy computation. In addition, AO_BASIS option must be set to NONE; (default). Evaluation of the analytic gradients requires the solution of the; coupled response equations. Two algorithms are available for their iterative; solution: two-step (default) and simultaneous. These algorithms are similar to those; described for the orbital and cumulant updates in the Iterative Algorithms; section and usually exhibit the similar efficiency. The choice of the algorithm can; be made using the RESPONSE_ALGORITHM option. For the DC-12 method the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:9907,perform,perform,9907,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"ron properties computed for dimer and one monomer. cc12; Single point energies of multiple excited states with EOM-CCSD. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. mp2-h; check that methods can act on single atom. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-dipole; 6-31G H2O Test FCI Energy Point. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:18416,perform,performs,18416,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"ronic structure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/methods-1.html:1146,Optimiz,Optimized,1146,psi4manual/4.0b3/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods-1.html,2,['Optimiz'],['Optimized']
Performance,"rons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. mrcc1; CCSDT cc-pVDZ energy for the H2O molecule using MRCC. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:6110,optimiz,optimization,6110,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['optimiz'],['optimization']
Performance,"rors. Thanks to; natural orbital methods [Parrish:2013:174102], the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as in the following examples; energy('sapt2+(ccd)'); energy('sapt2+(3)(ccd)'); energy('sapt2+3(ccd)'). The \(\delta_{MP2}\) corrections can also be computed automatically; by appending dmp2 to the name of the method, with or without CCD dispersion; energy('sapt2+dmp2'); energy('sapt2+(3)dmp2'); energy('sapt2+3dmp2'); energy('sapt2+(ccd)dmp2'); energy('sapt2+(3)(ccd)dmp2'); energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold \(3o^2v^2+v^2N_{aux}\) arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an EC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:28950,perform,performed,28950,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,9,['perform'],['performed']
Performance,"rough triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC;  . 2; CC(n-1)[n];  . 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a;  . 6; CC(n)-1b;  . 7; CCn;  . 8; CC(n)-3;  . table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/mrcc-1.html:3924,optimiz,optimize,3924,psi4manual/1.1.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/mrcc-1.html,4,['optimiz'],['optimize']
Performance,"rray; Default: No Default. CIS_TOPDM_STATES (CPHF); CPHF — Which states to save AO transition OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. COLLAPSE_SIZE (DETCI); DETCI — Gives the number of vectors to retain when the Davidson subspace is collapsed (see MAX_NUM_VECS). If greater than one, the collapsed subspace retains the best estimate of the CI vector for the previous n iterations. Defaults to 1. Type: integer; Default: 1. COLLAPSE_WITH_LAST (CCEOM); CCEOM — Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC); PSIMRCC — Do include the terms that couple the reference determinants?. Type: boolean; Default: true. COVALENT_CONNECT (OPTKING); OPTKING — When determining connectivity, a bond is assigned if interatomic distance is less than (this number) * sum of covalent radii. Type: double; Default: 1.3. CPH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:18408,perform,perform,18408,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"rray; Default: No Default. DMRG_UNITARY_WRITE (DMRG); DMRG — Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_QQR_SIEVE (CPHF); CPHF — Do we do the QQR integral sieve of Maurer et al. When false, just uses * the Schwarz sieve. Type: boolean; Default: false. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:111795,perform,perform,111795,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,4,['perform'],['perform']
Performance,"rray_variable(key); Is the Matrix QCVariable key (case-insensitive) set? Prefer has_variable(). has_global_option_changed(key); Whether keyword key value has been touched at global (all-module) scope. has_local_option_changed(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. libint2_solid_harmonics_ordering(); The solid harmonics setting of Libint2 currently active for Psi4. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:6960,optimiz,optimized,6960,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,2,['optimiz'],['optimized']
Performance,"rrectly. Now also testing that CSX harvesting PSI variables correctly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. scf3; File retention, docc, socc, and bond distances specified explicitly. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft1; DFT Functional Test. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. Previous topic; DMRG; Next topic; DFT Functionals. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Test Suite and Sample Inputs ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:32030,perform,performs,32030,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,2,['perform'],['performs']
Performance,"rrep() psi4.core.CdSalc method. irrep_index() psi4.core.CdSalc method. irrep_labels() psi4.core.Molecule method. is_c_hybrid() psi4.core.SuperFunctional method. is_c_lrc() psi4.core.SuperFunctional method. is_c_scs_hybrid() psi4.core.SuperFunctional method. is_cartesian() psi4.core.GaussianShell method. is_done() psi4.core.AOShellCombinationsIterator method. is_gga() psi4.core.Functional method. psi4.core.SuperFunctional method. is_inverted() psi4.core.FittingMetric method. is_libxc_func() psi4.core.SuperFunctional method. is_lrc() psi4.core.Functional method. is_meta() psi4.core.Functional method. psi4.core.SuperFunctional method. is_poisson() psi4.core.FittingMetric method. is_pure() psi4.core.GaussianShell method. is_variable() psi4.core.Molecule method. is_x_hybrid() psi4.core.SuperFunctional method. is_x_lrc() psi4.core.SuperFunctional method. ISA. ; MBIS. Isotopes. ISOTROPIC_POL (PE). ISTOP (DETCI). iteration psi4.driver.ConvergenceError attribute. psi4.driver.OptimizationConvergenceError attribute. psi4.driver.SCFConvergenceError attribute. psi4.driver.TDSCFConvergenceError attribute. iteration_ psi4.core.HF attribute. iterations() psi4.core.HF method. J. J() psi4.core.JK method. JK class in psi4.core. jk() psi4.core.HF method. JOBTYPE (CCLAMBDA). K. K() psi4.core.JK method. keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. keywords psi4.driver.AtomicComputer attribute. psi4.driver.driver_cbs.CompositeComputer attribute. psi4.driver.driver_nbody.ManyBodyComputer attribute. KIND (ADC). kinetic() psi4.core.FISAPT method. kinetic_grad() psi4.core.MintsHelper method. KineticInt class in psi4.core. kwargs_lower() in module psi4.driver.p4util. L. L psi4.core.Localizer attribute. label() psi4.core.Molecule method. psi4.core.MOSpace method. lagrangian() psi4.core.Wavefunction method. LaplaceDenom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:66105,Optimiz,OptimizationConvergenceError,66105,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['Optimiz'],['OptimizationConvergenceError']
Performance,"rresponds to a value of 1.0. Type: double; Default: 0.5. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert SAD Guess Algorithm¶. DF_BASIS_SAD¶. Fitting SAD basis. Type: string; Possible Values: basis string; Default: SAD-FIT. SAD_CHOL_TOLERANCE¶. Auxiliary basis for the SAD guess. Type: conv double; Default: 1e-7. SAD_FRAC_OCC¶. Auxiliary basis for the SAD guess. Type: boolean; Default: false. SAD_MAXITER¶. Maximum number of SAD guess iterations. Type: integer; Default: 50. SAD_PRINT¶. The amount of SAD information to print to the output. Type: integer; Default: 0. SAD_SCF_TYPE¶. SCF type of SAD guess. Type: string; Possible Values: DIRECT, DF; Default: DF. Expert DFT¶. DFT_BLOCK_MAX_POINTS¶. The maximum number of grid points per evaluation block. Type: integer; Default: 5000. DFT_BLOCK_MAX_RADIUS¶. The maximum radius to terminate subdivision of an octree block [au]. Type: double; Default: 3.0. DFT_BLOCK_MIN_POINTS¶. The minimum number of grid points per evaluation block. Type: integer; Default: 1000. DFT_BLOCK_SCHEME¶. The blocking scheme for DFT. Ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html:13764,LOAD,LOAD,13764,psi4manual/1.1.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html,2,['LOAD'],['LOAD']
Performance,"rresponds to a value of 1.0. Type: double; Default: 0.5. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert SAD Guess Algorithm¶. DF_BASIS_SAD¶. Fitting SAD basis. Type: string; Possible Values: basis string; Default: SAD-FIT. SAD_CHOL_TOLERANCE¶. Auxiliary basis for the SAD guess. Type: conv double; Default: 1e-7. SAD_FRAC_OCC¶. Do force an even distribution of occupations across the last partially occupied orbital shell?. Type: boolean; Default: false. SAD_MAXITER¶. Maximum number of SAD guess iterations. Type: integer; Default: 50. SAD_PRINT¶. The amount of SAD information to print to the output. Type: integer; Default: 0. SAD_SCF_TYPE¶. SCF type of SAD guess. Type: string; Possible Values: DIRECT, DF; Default: DF. Expert DFT¶. DFT_BLOCK_MAX_POINTS¶. The maximum number of grid points per evaluation block. Type: integer; Default: 256. DFT_BLOCK_MAX_RADIUS¶. The maximum radius to terminate subdivision of an octree block [au]. Type: double; Default: 3.0. DFT_BLOCK_MIN_POINTS¶. The minimum number of grid points per evaluation block. Type: integer; Defau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__scf-1.html:14068,LOAD,LOAD,14068,psi4manual/1.2.1/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__scf-1.html,2,['LOAD'],['LOAD']
Performance,"rridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/plugins.html:6342,load,loaded,6342,psi4manual/master/plugins.html,https://psicode.org,https://psicode.org/psi4manual/master/plugins.html,15,['load'],['loaded']
Performance,"rrill.; Reference energies from Bozkaya and Sherrill. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. S66by8¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries and reference interaction energies from Rezac et al. JCTC 7 2427 (2011).; Note that the S66by8-N-1.0 members are not quite the same geometries as S66-N. cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'equilibrium'; 'HB' eight-point (0.9, 0.95, 1.0, 1.05, 1.1, 1.25, 1.5, 2.0) \(\times R_{eq}\) dissociation curve hydrogen-bonded systems; 'MX' eight-point (0.9, 0.95, 1.0, 1.05, 1.1, 1.25, 1.5, 2.0) \(\times R_{eq}\) dissociation curve mixed-influence systems; 'DD' eight-point (0.9, 0.95, 1.0, 1.05, 1.1, 1.25, 1.5, 2.0) \(\times R_{eq}\) dissociation curve dispersion-dominated systems. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. A24¶. Database (Hobza) of interaction energies for bimolecular complexes.; Geometries from <Reference>.; Reference interaction energies from Rezac and Hobza, JCTC (in press). cp 'off' <erase this comment and after unless on is a valid option> || 'on'; rlxd 'off' <erase this comment and after unless on is valid option> || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. O24by",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_available_databases.html:1253,optimiz,optimize,1253,psi4manual/1.8.x/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_available_databases.html,2,['optimiz'],['optimize']
Performance,"rror if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant funct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html:1415,perform,performs,1415,psi4manual/1.3.2/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html,4,['perform'],['performs']
Performance,"rror if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:1415,perform,performs,1415,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,4,['perform'],['performs']
Performance,"rror:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-1]); basis = lmc[-1]. df = handle['pdie'][mc]; for dbrxn in df.index[df.notnull()].values:; [dbse, rxn] = dbrxn.split('-', 1); if intrxn:; rxn = int(rxn); self.hrxn[rxn].data[mc] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]). [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; return False; else:; return True. @staticmethod; [docs] def load_pickled(dbname, path=None):; """""". """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; picklefile = psiutil.findfile_ignorecase(dbname,; pre=os.path.abspath(path) + os.sep, post='_WDb.pickle'); if not picklefile:; raise ValidationError(""Pickle file for loading database data from file %s does not exist"" % (; os.path.abspath(path) + os.sep + dbname + '.pickle')); # with open('/var/www/html/bfdb_devel/bfdb/scratch/ASDFlogfile.txt', 'a') as handle:; # handle.write('<!-- PICKLE %s\n' % (picklefile)); with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:41202,load,loading,41202,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loading']
Performance,"rs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__ccresponse.html:3781,CACHE,CACHELEVEL,3781,psi4manual/1.6.x/autodir_options_c/module__ccresponse.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__ccresponse.html,1,['CACHE'],['CACHELEVEL']
Performance,"rs); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for -systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: doubl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:9666,optimiz,optimization,9666,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['optimiz'],['optimization']
Performance,"rs. Compiler requirements are primarily; C++17 compliance (now GCC version 7.0 or above).; For some architectures, a precompiled binary is available. See Compiling and Installing for details. PythonPSI4 1.1 and 1.2 are supported on Python 2.7, 3.5,; and 3.6. After 1.2, only Python 3 will be supported; in accordance with other scientific software projects).; PSI4 1.3 supports Python 3.6 and 3.7.; PSI4 1.4 supports Python 3.6, 3.7, 3.8, and 3.9.; PSI4 1.5 supports Python 3.7, 3.8, and 3.9.; PSI4 1.6 supports Python 3.8, 3.9, and 3.10.; The future plan is to support the two or three latest Python versions.; The current master supports 3.8, 3.9, and 3.10. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Energy (CFOUR), Gradient,; Gradient (CFOUR), and Frequency. Summary of theoretical methods available in PSI4¶. Method; Energy; Gradient; Parallelism; Variants. Reference; Type; Reference; Type; OO 9; FNO 1; DLPNO. HF, HF-3c; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF/ROHF; CONV/DF; threaded. DFT, PBEh-3c; RKS/UKS; CONV/DF/CD 7; RKS/UKS; DF 4; threaded. EFP 5; RHF. —; —. DCT; RHF/UHF; CONV/DF; RHF/UHF; CONV; partially threaded. MP2 10; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G. E. MP3 10; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G; E. MP2.5 10; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G. MP4 10; RHF; CONV; —; —; threaded 3. E. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/introduction.html:23403,perform,perform,23403,psi4manual/1.6.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html,1,['perform'],['perform']
Performance,"rs; ----------; input_string; String of which to permute the case. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module: str, attr: str):; """"""Extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Parameters; ----------; module; Object on which to seek `attr`.; attr; Name of attribute with uncertain case. Returns; -------; attribute : Any; Module attribute returned if available. None if not. """"""; obj_attr = None; for permutation in list(all_casings(attr)):; try:; getattr(module, permutation); except AttributeError:; pass; else:; obj_attr = getattr(module, permutation); break. return obj_attr. [docs]def import_ignorecase(module: str) -> ModuleType:; """"""Import loader for *module* in any possible lettercase permutation. Parameters; ----------; module; Name of module with uncertain case. Returns; -------; types.ModuleType; Module object. """"""; modobj = None; for permutation in list(all_casings(module)):; try:; modobj = __import__(permutation); except ImportError:; pass; else:; break. return modobj. _modules = [; # Psi4 Modules; ""CCENERGY"",; ""CCEOM"",; ""CCDENSITY"",; ""CCLAMBDA"",; ""CCHBAR"",; ""CCRESPONSE"",; ""CCTRANSORT"",; ""CCTRIPLES"",; ""CPHF"",; ""DCT"",; ""DETCI"",; ""DFEP2"",; ""DFMP2"",; ""DFOCC"",; ""DLPNO"",; ""DMRG"",; ""EFP"",; ""FINDIF"",; ""FISAPT"",; ""FNOCC"",; ""GDMA"",; ""MCSCF"",; ""MINTS"",; ""MRCC"",; ""OCC"",; ""OPTKING"",; ""PCM"",; ""PE"",; ""PSIMRCC"",; ""RESPONSE"",; ""SAPT"",; ""SCF"",; ""THERMO"",; # External Modules; ""CFOUR"",; ]. [docs]@contextmanager; def hold_options_state() -> Iterator[None]:; """"""Return a context manager that will collect the current state of; ``Process:environment.options`` on entry to the with-statement and clear; and restore the collected keywords",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:8788,load,loader,8788,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,1,['load'],['loader']
Performance,rse users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. omp2.5; Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. olccd; Orbital-Optimized Linear CCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE CONV. Density-Fitted Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE DF. Cholesky-Decomposed Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; —; CC_TYPE CD. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobas,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:9964,Optimiz,Optimized,9964,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,11,['Optimiz'],['Optimized']
Performance,"rt i. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; CFOUR. © Copyright 2007-2024, The Psi4 Project.; Last updated on T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html:4202,optimiz,optimization,4202,psi4manual/1.9.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"rt re; import physconst; from molutil import *; from text import *; from procutil import *; from basislist import *; from functional import *; from optproc import *; # never import driver, wrappers, or aliases into this file. [docs]def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """"""; optstash = OptionsState(; ['REFERENCE']). # DCFT module should probably take a REFERENCE keyword with only UHF allowed value; PsiMod.set_global_option('REFERENCE', 'UHF'); PsiMod.scf(); returnvalue = PsiMod.dcft(). optstash.restore(); return returnvalue. [docs]def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; optstash = OptionsState(; ['REFERENCE'],; ['GLOBALS', 'DERTYPE']). PsiMod.set_global_option('DERTYPE', 'FIRST'); run_dcft(name, **kwargs); PsiMod.deriv(). optstash.restore(). [docs]def run_omp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. """"""; oldref = PsiMod.get_global_option('REFERENCE'); PsiMod.set_global_option('REFERENCE', 'UHF'); PsiMod.scf(); return PsiMod.omp2(); PsiMod.set_global_option('REFERENCE', oldref). [docs]def run_omp3(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an orbital-optimized MP3 computation. """"""; oldref = PsiMod.get_global_option('REFERENCE'); PsiMod.set_global_option('REFERENCE', 'UHF'); PsiMod.scf(); return PsiMod.omp3(); PsiMod.set_global_option('REFERENCE', oldref). [docs]def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. """"""; lowername = name.lower(). optstash = OptionsState(; ['SCF', 'DFT_FUNCTIONAL'],; ['SCF', 'SCF_TYPE'],; ['SCF', 'REFERENCE']). if lowername == 'df-scf':; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'); elif lowername == 'hf':; if PsiMod.get_option('SCF', 'REFERENCE') == 'RKS':; PsiMod.set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:1449,optimiz,optimized,1449,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['optimiz'],['optimized']
Performance,"rt the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. RESTART (CCLAMBDA); CCLAMBDA — Do restart the coupled-cluster iterations from old and amplitudes?. Type: boolean; Default: false. RESTART (CCRESPONSE); CCRESPONSE — Do restart from on-disk amplitudes?. Type: boolean; Default: true. RESTART (DETCI); DETCI — Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk. Type: boolean; Default: false. RESTART_EOM_CC3 (CCEOM); CCEOM — Do restart from on-disk?. Type: boolean; Default: false. RESTRICTED_DOCC (GLOBALS); GLOBALS — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (GLOBALS); GLOBALS — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RFO_FOLLOW_ROOT (OPTKING); OPTKING — Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX (OPTKING); OPTKING — Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT (OPTKING); OPTKING — Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RHF_TRIPLETS (CCEOM); CCEOM — Do form a triplet state from RHF reference?. Type: boolean; Default: false. RMS_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units). Type: conv d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:196096,optimiz,optimized,196096,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,"rted into the geometry; specification using Python 3 string; formatting. In [4]:. #! Sample UHF/6-31G** CH2 Computation. R = 1.075; A = 133.93. ch2 = psi4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimizati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:6358,Optimiz,Optimization,6358,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['Optimiz'],['Optimization']
Performance,"rtesian depending on basis set design,; and syntax to set different basis sets to different classes of atoms; without listing each atom. All of these features are available to Cfour by; using the BASIS keyword instead of CFOUR_BASIS; (accompanied, of course, by specifying the molecule PSI4-style).; Internally, PSI4 processes the basis set as usual, then translates; the basis set format and writes out a GENBAS file with an entry for; each atom. The P4C4 interface sets keyword CFOUR_BASIS=SPECIAL; and CFOUR_SPHERICAL as appropriate, then writes the basis section; necessary for SPECIAL below the *CFOUR(...) block. (I’m sorry that the; name of the basis doesn’t appear in ZMAT, but the combination of the; ~14 character basis name limit and the absence of a comment line marker; rather precludes that helpful label.); The input below employs a PSI4 library basis set and also introduces; the final stage of conversion toward PSI4 format. Instead of the; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call PSI4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:11264,optimiz,optimize,11264,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['optimiz'],['optimize']
Performance,"rtesian depending on basis set design,; and syntax to set different basis sets to different classes of atoms; without listing each atom. All of these features are available to Cfour by; using the BASIS keyword instead of CFOUR_BASIS; (accompanied, of course, by specifying the molecule PSI4-style).; Internally, PSI4 processes the basis set as usual, then translates; the basis set format and writes out a GENBAS file with an entry for; each atom. The P4C4 interface sets keyword CFOUR_BASIS=SPECIAL; and CFOUR_SPHERICAL as appropriate, then writes the basis section; necessary for SPECIAL below the *CFOUR(...) block. (I’m sorry that the; name of the basis doesn’t appear in ZMAT, but the combination of the; ~14 character basis name limit and the absence of a comment line marker; rather precludes that helpful label.); The input below employs a PSI4 library basis set and also introduces; the final stage of conversion toward PSI4 format. Instead of the; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call PSI4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:11035,optimiz,optimize,11035,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,9,['optimiz'],['optimize']
Performance,"rtesian depending on basis set design,; and syntax to set different basis sets to different classes of atoms; without listing each atom. All of these features are available to Cfour by; using the BASIS keyword instead of CFOUR_BASIS; (accompanied, of course, by specifying the molecule Psi4-style).; Internally, Psi4 processes the basis set as usual, then translates; the basis set format and writes out a GENBAS file with an entry for; each atom. The P4C4 interface sets keyword CFOUR_BASIS=SPECIAL; and CFOUR_SPHERICAL as appropriate, then writes the basis section; necessary for SPECIAL below the *CFOUR(...) block. (I’m sorry that the; name of the basis doesn’t appear in ZMAT, but the combination of the; ~14 character basis name limit and the absence of a comment line marker; rather precludes that helpful label.); The input below employs a Psi4 library basis set and also introduces; the final stage of conversion toward Psi4 format. Instead of the; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call Psi4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:11039,optimiz,optimize,11039,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['optimiz'],['optimize']
Performance,"rtesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-alpha; Extrapolated water energies. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. soscf-large; Second-order SCF convergnece: Benzene. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc12; Single point energies of multiple excited states with EOM-CCSD. dft2; DFT Functional Test. cc8b; ROHF-CCSD cc-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:30546,Optimiz,Optimize,30546,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['Optimiz'],['Optimize']
Performance,"rtet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry¶; The pairs within each block are optimized for efficiency. First, they are; screened during the integral object’s creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry¶; In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if any integrals in the batch are needed, which is implemented by; asking the integral engine where to start looping in the ket via the call to; eri->first_RS_shell_block(PQpair_idx). This is followed by a more fine; grained check within the loops to filter individual integrals in the case where; bra and ket have the same angular momentum and there’s a possibility of a; handful of integrals coming from the ket that are redundant. Note that the bra; is not batched in any of our engines currently: only the ket is. For this; reason, density fitting integrals should be written as (A0|PQ) rather than; (PQ|A0) where possible, because we want the ket to contain more function",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_integrals.html:8242,perform,performed,8242,psi4manual/master/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_integrals.html,9,['perform'],['performed']
Performance,"rth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. >>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; >>> cmake --install . 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it.; See psi4/codedeps.yaml for a structured listing and history of dependencies. C++ and C Compilers (C++17 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.8+) https://www.python.org/; CMake (3.15+) https://cmake.org/download/; NumPy (needed at runtime and buildtime) https://numpy.org/; System utilities: GNU make and GNU install or Ninja, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. gau2grid — [what is gau2grid?] [gau2grid min version]; Libint — [what is Libint?] [Libint min version] (Libint2 as of Nov 2020; added by v1.4). Eigen https://eigen.tuxfamily.org/index.php?title=Main_Page; Boost https://www.boost.org/ header-only preprocessor library. Libxc — [what is Libxc?] [Libxc min version]; pybind11 — [what is Pybind11?] [Pybind11 min version]; QCElemental — [what is QCElemental?]; QCEngine — [what is QCEngine?] (March 2019; added by v1.4); optking — [what is optking] (runtime dependency, required at build-time). Additionally, there are runtime-o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_planning.html:4987,Optimiz,Optimized,4987,psi4manual/1.9.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_planning.html,1,['Optimiz'],['Optimized']
Performance,"rth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. >>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; >>> cmake --install . 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it.; See psi4/codedeps.yaml for a structured listing and history of dependencies. C++ and C Compilers (C++20 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.8+) https://www.python.org/; CMake (3.15+) https://cmake.org/download/; NumPy (needed at runtime and buildtime) https://numpy.org/; System utilities: GNU make and GNU install or Ninja, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. gau2grid — [what is gau2grid?] [gau2grid min version]; Libint — [what is Libint?] [Libint min version] (Libint2 as of Nov 2020; added by v1.4). Eigen https://eigen.tuxfamily.org/index.php?title=Main_Page; Boost https://www.boost.org/ header-only preprocessor library. Libxc — [what is Libxc?] [Libxc min version]; pybind11 — [what is Pybind11?] [Pybind11 min version]; QCElemental — [what is QCElemental?]; QCEngine — [what is QCEngine?] (March 2019; added by v1.4); optking — [what is optking] (runtime dependency, required at build-time). Additionally, there are runtime-o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:4994,Optimiz,Optimized,4994,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,1,['Optimiz'],['Optimized']
Performance,"rties. Type: string; Default: LENGTH. INTS_TOLERANCE¶. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. ONEPDM¶. Do compute one-particle density matrix?. Type: boolean; Default: false. ONEPDM_GRID_CUTOFF¶. Cutoff (e/A^3) for printing one-particle density matrix values on a grid. Type: double; Default: 1.0e-30. ONEPDM_GRID_DUMP¶. Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. ONEPDM_GRID_STEPSIZE¶. Step size (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: false. PROP_ALL¶. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. XI¶. Do compute Xi?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. AEL¶. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: SCF. XI_CONNECT¶. Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. table of contents. CCDENSITY; General; AO_BASIS; CACHELEVEL; GAUGE; INTS_TOLERANCE; ONEPDM; ONEPDM_GRID_CUTOFF; ONEPDM_GRID_DUMP; ONEPDM_GRID_STEPSIZE; OPDM_RELAX; PROP_ALL; PROP_ROOT; PROP_SYM; REFERENCE; ROOTS_PER_IRREP; XI; ZETA. Expert; AEL; WFN; XI_CONNECT. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__ccdensity-1.html:2088,CACHE,CACHELEVEL,2088,psi4manual/1.1.0/autodir_options_c/module__ccdensity-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__ccdensity-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"rts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. Expert¶. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_MBPT_DISP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. Table Of Contents. SAPT; General; AIO_CPHF; AIO_DF_INTS; BASIS; CCD_E_CONVERGENCE; CCD_MAXITER; CCD_T_CONVERGENCE; DENOMINATOR_ALGORITHM; DENOMINATOR_DELTA; DF_BASIS_ELST; DF_BASIS_SAPT; D_CONVERGENCE; E_CONVERGENCE; FREEZE_CORE; INTS_TOLERANCE; MAXITER; MAX_CCD_DIISVECS; MIN_CCD_DIISVECS; NAT_ORBS_T2; NAT_ORBS_T3; NAT_ORBS_V4; NO_RESPONSE; OCC_TOLERANCE; PRINT; SAPT_LEVEL; SAPT_MEM_CHECK; SAPT_MEM_SAFETY; SAPT_OS_SCALE; SAPT_SS_SCALE. Expert; DO_CCD_DISP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__sapt-1.html:4591,perform,performed,4591,psi4manual/4.0b5/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__sapt-1.html,2,['perform'],['performed']
Performance,"rtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. fci-coverage; 6-31G H2O Test for coverage. scf-occ; force occupations in scf. scf7; Tests SCF gradient in the presence of a dipole field. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_.. tuple. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dft-custom-hyb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:36354,optimiz,optimization,36354,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['optimiz'],['optimization']
Performance,"rtype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is prett",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:22866,Optimiz,Optimize,22866,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"rtype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:25335,Optimiz,Optimize,25335,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"rtype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:32846,Optimiz,Optimize,32846,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"rtype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). import optking. Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Constrained Optimizations¶. Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond dista",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:4851,optimiz,optimization,4851,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['optimiz'],['optimization']
Performance,"rtype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). import optking. Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶; Optking currently has two transition state algorithms. The current default is the; newer RS_I_RFO algorithm [Besalu:1998:265] . The old algorithm can be used by setting; STEP_TYPE P_RFO for OPT_TYPE TS. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Constrained Optimizations¶. Optimize a geometry (HOOH) at a frozen dihedral ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:4870,optimiz,optimization,4870,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['optimiz'],['optimization']
Performance,"rue. [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2:; TestComparisonError(""Input shapes do not match.""). tol = 10 ** (-digits); if not np.allclose(expected, computed, atol=tol):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label); return True. [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; message = (""\t%s: computed cube file does not match expected cube file."" % label); raise TestComparisonError(message); else:; message = (""\t%s: computed cube file does not match expected cube file."" % (label, computed, expected)); raise TestComparisonError(message); success(label); return True. # Uncomment and use if compare_arrays above is inadequate; #def compare_lists(expected, computed, digits, label):; # """"""Function to compare two Python lists. Prints :py:func:`util.success`; # when elements of vector *computed* match elements of vector *expected* to; # number of *digits*. Performs a system exit on failure to match symmetry; # structure, dimension, or element values. Used in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:12308,Perform,Performs,12308,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['Perform'],['Performs']
Performance,"run in the appropriate point group. The same syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. basis {; assign cc-pVDZ-RI df_basis_mp2; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; basis {; assign C aug-cc-pVDZ-RI df_basis_mp2; }. When Dunning’s correlation consistent basis sets (cc-pV*X*Z), and core-valence; and diffuse variants thereof, are being used the SCF and DF-MP2 codes will; chose the appropriate auxiliary basis set automatically, unless instructed; otherwise by setting the auxiliary basis set in the input. Finally, we note; that the basis block may also be used for defining basis sets, as; detailed in Sec. User-Defined Basis Sets. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; memory 2 Gb. or. memory 2000 Mb. or. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a memory; command in the ~/.psi4rc file, as detailed in Sec. Scratch Files and the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:18960,perform,perform,18960,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,2,['perform'],['perform']
Performance,"run multiple instances of DETCI in a single input, without an intervening clean() call. cc13d; Tests analytic CC2 gradients. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. fnocc6; Test method/basis with disk_df. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cepa1; cc-pvdz H2O Test CEPA(1) Energy. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. scf-response2; Compute the dipole polarizability for water with custom basis set. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. cc52; CCSD Response for H2O2. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). casscf-sa-sp; Ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:39029,optimiz,optimization,39029,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"run them in sandwich mode and; then run them as translated into PSI4 format. Note; PSI4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in PSI4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; --------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:7010,optimiz,optimize,7010,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,9,['optimiz'],['optimize']
Performance,"run them in sandwich mode and; then run them as translated into Psi4 format. Note; Psi4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in Psi4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; Psi4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; --------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:7014,optimiz,optimize,7014,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['optimiz'],['optimize']
Performance,"run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:30136,perform,performance,30136,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"run_sapt,; 'sapt2+3' : run_sapt,; 'sapt0-ct' : run_sapt_ct,; 'sapt2-ct' : run_sapt_ct,; 'sapt2+-ct' : run_sapt_ct,; 'sapt2+(3)-ct' : run_sapt_ct,; 'sapt2+3-ct' : run_sapt_ct,; 'mp2c' : run_mp2c,; 'ccenergy' : run_ccenergy, # full control over ccenergy; 'ccsd' : run_ccenergy,; 'ccsd(t)' : run_ccenergy,; 'cc2' : run_ccenergy,; 'cc3' : run_ccenergy,; 'mrcc' : run_mrcc, # interface to Kallay's MRCC program; 'bccd' : run_bccd,; 'bccd(t)' : run_bccd_t,; 'eom-ccsd' : run_eom_cc,; 'eom-cc2' : run_eom_cc,; 'eom-cc3' : run_eom_cc,; 'eom_ccsd' : run_eom_cc,; 'eom_cc2' : run_eom_cc,; 'eom_cc3' : run_eom_cc,; 'detci' : run_detci, # full control over detci; 'mp' : run_detci, # arbitrary order mp(n); 'zapt' : run_detci, # arbitrary order zapt(n); 'cisd' : run_detci,; 'cisdt' : run_detci,; 'cisdtq' : run_detci,; 'ci' : run_detci, # arbitrary order ci(n); 'fci' : run_detci,; 'adc' : run_adc,; 'cphf' : run_libfock,; 'cis' : run_libfock,; 'tdhf' : run_libfock,; 'cpks' : run_libfock,; 'tda' : run_libfock,; 'tddft' : run_libfock,; 'psimrcc' : run_psimrcc,; 'psimrcc_scf' : run_psimrcc_scf,; 'hf' : run_scf,; 'rhf' : run_scf,; 'uhf' : run_scf,; 'rohf' : run_scf,; 'rscf' : run_scf,; 'uscf' : run_scf,; 'roscf' : run_scf,; 'df-scf' : run_scf,; # Upon adding a method to this list, add it to the docstring in energy() below; },; 'gradient' : {; 'scf' : run_scf_gradient,; 'ccsd' : run_cc_gradient,; 'ccsd(t)' : run_cc_gradient,; 'mp2' : run_mp2_gradient,; 'eom-ccsd' : run_eom_cc_gradient,; 'dcft' : run_dcft_gradient; # Upon adding a method to this list, add it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; 'eom_cc2' : run_cc_property,; 'eom_ccsd' : run_cc_property; # Upon adding a method to this list, add it to the docstring in property() below; }}.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:2412,optimiz,optimize,2412,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['optimiz'],['optimize']
Performance,"rwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶; Optking currently has two transition state algorithms. The current default is the; newer RS_I_RFO algorithm [Besalu:1998:265] . The old algorithm can be used by setting; STEP_TYPE P_RFO for OPT_TYPE TS. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Constrained Optimizations¶. Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:5452,optimiz,optimize,5452,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['optimiz'],['optimize']
Performance,"ry = total_memory * 0.1. if collocation_memory > collocation_size:; collocation_memory = collocation_size. # Set constants; self.iteration_ = 0; self.memory_jk_ = int(total_memory - collocation_memory); self.memory_collocation_ = int(collocation_memory). # Print out initial docc/socc/etc data; if self.get_print():; core.print_out("" ==> Pre-Iterations <==\n\n""); self.print_preiterations(). if self.get_print():; core.print_out("" ==> Integral Setup <==\n\n""). # Initialize EFP; efp_enabled = hasattr(self.molecule(), 'EFP'); if efp_enabled:; # EFP: Set QM system, options, and callback. Display efp geom in [A]; efpobj = self.molecule().EFP; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). efpptc, efpcoords, efpopts = get_qm_atoms_opts(self.molecule()); efpobj.set_point_charges(efpptc, efpcoords); efpobj.set_opts(efpopts, label='psi', append='psi'). efpobj.set_electron_density_field_fn(field_fn). # Initilize all integratals and perform the first guess; if self.attempt_number_ == 1:; mints = core.MintsHelper(self.basisset()); if core.get_global_option('RELATIVISTIC') in ['X2C', 'DKH']:; mints.set_rel_basisset(self.get_basisset('BASIS_RELATIVISTIC')). mints.one_electron_integrals(); self.initialize_jk(self.memory_jk_, jk=jk); if self.V_potential():; self.V_potential().build_collocation_cache(self.memory_collocation_). core.timer_on(""HF: Form core H""); self.form_H(); core.timer_off(""HF: Form core H""). if efp_enabled:; # EFP: Add in permanent moment contribution and cache; core.timer_on(""HF: Form Vefp""); verbose = core.get_option('SCF', ""PRINT""); Vefp = modify_Fock_permanent(self.molecule(), mints, verbose=verbose-1); Vefp = core.Matrix.from_array(Vefp); self.H().add(Vefp); Horig = self.H().clone(); self.Horig = Horig; core.print_out("" QM/EFP: iterating Total Energy including QM/EFP Induction\n""); core.timer_off(""HF: Form Vefp""). core.timer_on(""HF: Form S/X""); self.form_Shalf(); core.timer_off(""HF: Form S/X""). co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:6027,perform,perform,6027,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['perform'],['perform']
Performance,"ry large amounts of debugging information. Type: integer; Default: 1. PRINT_NOONS¶. How many NOONS to print – used in libscf_solver/uhf.cc and libmints/oeprop.cc. Type: string; Default: 3. PROPERTIES¶. List of properties to compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_MODULE¶. When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK; Default: PK. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__globals-1.html:6332,optimiz,optimized,6332,psi4manual/1.3.2/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__globals-1.html,2,['optimiz'],['optimized']
Performance,"ry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR); CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. CFOUR_GIAO (CFOUR); CFOUR — Specifies whether gauge-including atomic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:48483,optimiz,optimization,48483,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,8,['optimiz'],['optimization']
Performance,"ry plane of the molecule. fci-h2o-2; 6-31G H2O Test FCI Energy Point. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. mom-h2o-4; MOM excitation from LUMO HOMO+4. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. mp2-1; All-electron MP2 6-31G** geometry optimization of water. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:4894,optimiz,optimization,4894,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"ry problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:9407,CACHE,CACHELEVEL,9407,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,12,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"ry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-reference; MP2 with a PBE0 reference computation. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. linK-1; RHF Linear Exchange Algorithm test for water. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. mp2-h; check that methods can act on single atom. linK-2; RKS Linear Exchange Algorithm test for benzene. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. fsapt-ext-abc2; FSAPT with external charge on dimer. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:28024,optimiz,optimization,28024,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"ryOperation.c2_y()¶; Python Library Documentation: method c2_y; c2_y(...) unbound psi4.SymmetryOperation method. c2_y( (SymmetryOperation)arg1) -> None :. Set equal to C2 about the y axis; C++ signature :. void c2_y(N3psi17SymmetryOperationE {lvalue}). psi4.SymmetryOperation.c2_z()¶; Python Library Documentation: method c2_z; c2_z(...) unbound psi4.SymmetryOperation method. c2_z( (SymmetryOperation)arg1) -> None :. Set equal to C2 about the z axis; C++ signature :. void c2_z(N3psi17SymmetryOperationE {lvalue}). psi4.SymmetryOperation.i()¶; Python Library Documentation: method i; i(...) unbound psi4.SymmetryOperation method. i( (SymmetryOperation)arg1) -> None :. Set equal to an inversion; C++ signature :. void i(N3psi17SymmetryOperationE {lvalue}). psi4.SymmetryOperation.operate()¶; Python Library Documentation: method operate; operate(...) unbound psi4.SymmetryOperation method. operate( (SymmetryOperation)arg1, (SymmetryOperation)arg2) -> SymmetryOperation :. Performs the operation arg2 * arg1; C++ signature :. N3psi17SymmetryOperationE operate(N3psi17SymmetryOperationE {lvalue},N3psi17SymmetryOperationE). psi4.SymmetryOperation.rotate_n()¶; Python Library Documentation: method rotate_n; rotate_n(...) unbound psi4.SymmetryOperation method. rotate_n( (SymmetryOperation)arg1, (int)arg2) -> None :. Set equal to a clockwise rotation by 2pi/n; C++ signature :. void rotate_n(N3psi17SymmetryOperationE {lvalue},i). psi4.SymmetryOperation.rotate_theta()¶; Python Library Documentation: method rotate_theta; rotate_theta(...) unbound psi4.SymmetryOperation method. rotate_theta( (SymmetryOperation)arg1, (float)arg2) -> None :. Set equal to a clockwise rotation by theta; C++ signature :. void rotate_theta(N3psi17SymmetryOperationE {lvalue},d). psi4.SymmetryOperation.sigma_xy()¶; Python Library Documentation: method sigma_xy; sigma_xy(...) unbound psi4.SymmetryOperation method. sigma_xy( (SymmetryOperation)arg1) -> None :. Set equal to reflection in xy plane; C++ signature :. void",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:342430,Perform,Performs,342430,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['Perform'],['Performs']
Performance,"ryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. E(self: psi4.core.SymmetryOperation) → None; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None; Set equal to an inversion. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None; Zero out the symmetry operation. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.symmetryoperation.html:4186,Perform,Performs,4186,psi4manual/1.1.0/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.symmetryoperation.html,2,['Perform'],['Performs']
Performance,ry_psivariables.txt; index.txt; intercalls.txt; interfacing.txt; introduction.txt; libefp.txt; methods.txt; molden.txt; mrcc.txt; mrcc_table_energy.txt; nbody.txt; notes_c.txt; notes_py.txt; occ.txt; oeprop.txt; opt.txt; optionshandling.txt; optking.txt; pcmsolver.txt; pep0001.txt; plugins.txt; proc_py.txt; prog_basissets.txt; programming.txt; prop.txt; psimrcc.txt; psipep.txt; psithonfunc.txt; psithoninput.txt; psithonmol.txt; quickaddalias.txt; quickadddatabase.txt; relativistic.txt; sapt.txt; scf.txt; sowreap.txt; testsuite.txt; thermo.txt; tutorial.txt. /_static; ; basic.css; doctools.js; favicon-psi4.ico; jquery.cookie.js; jquery.js; psi4.css; pygments.css; searchtools.js; toggle_codeprompt.js; toggle_sections.js; toggle_sidebar.js; underscore.js. ADC: Ab Initio Polarization Propagator — Psi4 [1.0.0 6a9a71b] Docs; ADC: Ab Initio Polarization Propagator — Psi4 [1.0.0 6a9a71b] Docs; Appendices — Psi4 [1.0.0 6a9a71b] Docs; Appendices — Psi4 [1.0.0 6a9a71b] Docs. /autodir_options_c; ; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; MEMORY — Psi4 [1.0.0 6a9a71b] Docs; NEWTON_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; NORM_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; POLE_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; PR — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [1.0.0 6a9a71b] Docs; SEM_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; AEL — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; GAUGE — Psi4 [1.0.0 6a9a71b] Docs; INTS_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_DUMP — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_STEPSIZE — Psi4 [1.0.0 6a9a71b] Docs; OPDM_RELAX — Psi4 [1.0.0 6a9a71b] Docs; PROP_ALL — Psi4 [1.0.0 6a9a71b] Docs; PROP_ROOT — Psi4 [1.0.0 6a9a71b] Docs; PROP_SYM — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:181696,CACHE,CACHELEVEL,181696,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['CACHE'],['CACHELEVEL']
Performance,"ry” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. rasci-h2o; RASCI/6-31G** H2O Energy Point. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. mbis-3; MBIS calculation on OH radical. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. fnocc4; Test FNO-DF-CCSD(T) energy. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. fsapt-ext-abc2; FSAPT with external charge on dimer. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:44800,optimiz,optimization,44800,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"r–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). 1; 2; 3; 4; 5; 6; 7; 8>>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:12859,perform,perform,12859,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,28,"['Optimiz', 'optimiz', 'perform']","['OptimizationConvergenceError', 'optimization', 'optimize', 'perform']"
Performance,"s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter; Maximum number of iterations towards omega convergence. Returns; -------; float; Optimal omega parameter. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'DFT_OMEGA'],; ['DOCC'],; ['SOCC']). kwargs = p4util.kwargs_lower(kwargs). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. if core.get_option('SCF', 'REFERENCE') != 'UKS':; core.print_out("""""" Requested procedure `ip_fitting` runs further calculations with UKS referenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:14755,optimiz,optimized,14755,psi4manual/1.8.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html,3,['optimiz'],['optimized']
Performance,"s (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table of the different R values and the CP-corrected CCSD(T) energies, converted from atomic units (Hartree) to kcal mol\(^{-1}\) by multiplying by the automatically-defined conversion factor psi4.constants.hartree2kcalmol. Psi4 provides several built-in physical constants and conversion factors, as described in the Psi4 manual section Physical; Constants. The table can be printed either to the screen, by using standard Python ``print()` syntax <https://docs.python.org/3/whatsnew/3.0.html#print-is-a-function>`__, or to the designated output file output.dat using Psi4’s built-in function psi4.core.print_out() :psicode:[API] <psi4manual/master/api/psi4.core.print_out> (C style printing).; As we’ve seen so far, the combination of Psi4 and Python creates a unique, interactive approach to quantum chemistry. The next section will explore this synergistic relationship in greater detail, describing how even very complex tasks can be done very easily with Psi4. [ ]:. table of contents. PsiAPI Tutorial: Using Psi4 as a Python Module; I. Basic Input Structure; II. Running a Basic Hartree-Fock Calculation; III. Geometry Optimization and Vibrational Frequency Analysis; IV. Analysis of Intermolecular Interactions; V. Potential Surface Scans and Counterpoise Correction Made Easy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psiapi.html:23589,Optimiz,Optimization,23589,psi4manual/1.8.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psiapi.html,1,['Optimiz'],['Optimization']
Performance,"s (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.0227753",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:7495,perform,perform,7495,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['perform'],['perform']
Performance,"s (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step; (in principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734908 -76.026632734908 0.01523518 0.01245755 0.02742222 0.02277530 ~; 2 -76.027022666011 -0.000389931104 0.00178779 0.00142946 0.01008137 0.0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:7376,perform,perform,7376,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,2,['perform'],['perform']
Performance,"s (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. charge_method (str) – scf/6-31g || b3lyp/6-31g* || etc; Method to compute point charges for monomers. Overridden by embedding_charges; if both are provided. charge_type (str) – MULLIKEN_CHARGES || LOWDIN_CHARGES; Default is MULLIKEN_CHARGES. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Basis Set Superposition Corrections. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/nbody-1.html:3808,optimiz,optimization,3808,psi4manual/1.4.0/nbody-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/nbody-1.html,2,['optimiz'],['optimization']
Performance,"s (dict) – {1: 'ccsd(t)', 2: 'mp2', 'supersystem': 'scf'} || {1: 2, 2: 'ccsd(t)', 3: 'mp2'} || etc; Dictionary of different levels of theory for different levels of expansion; Note that method_string is not used in this case. supersystem computes; all higher order n-body effects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment. charge_method (str) – scf/6-31g || b3lyp/6-31g* || etc; Method to compute point charges for monomers. Overridden by embedding_charges; if both are provided. charge_type (str) – MULLIKEN_CHARGES || LOWDIN_CHARGES; Default is MULLIKEN_CHARGES. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Basis Set Superposition Corrections. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/nbody-1.html:3808,optimiz,optimization,3808,psi4manual/1.5.0/nbody-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/nbody-1.html,2,['optimiz'],['optimization']
Performance,"s (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; _nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; complete_basis_set() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any combination; of Psi4 and Cfour computational methods and Psi4 basis sets.; Example: cfour/pywrap-cbs1. Not Yet Implemented. Ground state CI energies and optimizations; Excited state energies and optimizations; Properties are not yet regex-ed, transformed into input frame, and; stowed in PSI Variables.; Property calls that required extra computation not yet translated into; property() computation command; Frequencies. Energy methods available through P4C4 interface. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Moller-Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Moller-Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Gradient methods available through P4C4 interface. name; calls method in Stanton a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:26895,optimiz,optimizations,26895,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,4,['optimiz'],['optimizations']
Performance,"s = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; if name in ['mp2', 'mp2.5', 'mp3', 'lccd', 'ccsd', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:62875,optimiz,optimized,62875,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['optimiz'],['optimized']
Performance,"s = kwargs['neutral_guess']. # By default, burn-in with UHF first, if UKS; hf_guess = False; if PsiMod.get_global_option('REFERENCE') == 'UKS':; hf_guess = True; if kwargs.has_key('hf_guess'):; hf_guess = kwargs['hf_guess']. # By default, re-guess at each N ; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.appen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:2974,LOAD,LOAD,2974,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,2,['LOAD'],['LOAD']
Performance,"s = kwargs['neutral_guess']. # By default, burn-in with UHF first, if UKS; hf_guess = False; if PsiMod.get_global_option('REFERENCE') == 'UKS':; hf_guess = True; if kwargs.has_key('hf_guess'):; hf_guess = kwargs['hf_guess']. # By default, re-guess at each N ; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = PsiMod.get_global_option(""DF_INTS_IO""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = PsiMod.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm); ; # => Burn the anion in with hf, if requested <= #; if (hf_guess):; PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:2971,LOAD,LOAD,2971,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,1,['LOAD'],['LOAD']
Performance,"s a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:1743,perform,performed,1743,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,4,['perform'],['performed']
Performance,"s a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:2651,Optimiz,Optimizations,2651,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['Optimiz'],['Optimizations']
Performance,"s also comparable to the pseudospectral method of Friesner.; sn-LinK and COSX have a number of significant differences in implementation details in PSI4, however.; First and foremost, the COSX implementation is contained within PSI4 itself, and is thus always available; for execution. On the other hand, the sn-LinK implementation in PSI4 is tied to the GauXC standalone; library discussed in [Williams-Young:2023:234104]; thus, the PSI4-GauXC interface must be built; for sn-LinK to be used. Second, the GauXC sn-LinK interface is more; efficient than the PSI4 COSX code on multiple levels. For CPU execution, GauXC’s sn-LinK uses highly-optimized; kernels for the contraction of the analytic integrals, whereas PSI4’s COSX uses a less-optimized, more; general contraction kernel. Additionally, GauXC’s sn-LinK code supports execution on GPUs, allowing for; GPU-enabled construction of the Exchange matrix, while PSI4’s COSX does not. In general,; sn-LinK will provide better runtime performance for hitting a desired accuracy; threshold compared to PSI4’s COSX. Third, some low-level implementation details differ between the two.; For example, PSI4’s COSX uses a dual-grid scheme similar to that originally proposed by Neese,; converging the SCF on a small grid, then running a number of SCF iterations,; equal to the value set by the COSX_MAXITER_FINAL, on a larger grid.; In contrast, sn-LinK only uses a single-grid scheme, simply converging the SCF on one grid.; As another example, while the COSX grid defaults are selected to emphasize speed over accuracy,; the defaults for sn-LinK are selected to achieve higher accuracy (~0.1 kcal/mol error for interaction/conformer energies).; To control compilation and linking of the optional GauXC dependency required for the sn-LinK algorithm,; here are the list of compile-time options provided. ENABLE_gauxc: Compile Psi4 with support for GauXC.; gauxc_DIR: Location of the external GauXC install to compile Psi4 with, if using an external GauXC ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:41988,perform,performance,41988,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,1,['perform'],['performance']
Performance,"s are available. The choice of the algorithm is controlled using the; ALGORITHM option. SIMULTANEOUS [Default]; In the simultaneous algorithm the DCFT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. The macroiterations are repeated until the simultaneous; convergence of the cumulant and orbitals is achieved.; Convergence of the simultaneous algorithm is accelerated using the; DIIS extrapolation technique.; TWOSTEP; In the two-step algorithm each macroiteration consists of two sets of; microiterations. In the first set, the density cumulant equations are solved; iteratively, while the orbitals are kept fixed. After the density cumulant is; converged, the second set of microiterations is performed for the; self-consistent update of the orbitals with the fixed density cumulant. Each; macroiteration is completed by performing the orbital transformation of the; integrals. As in the simultaneous algorithm, the DIIS; extrapolation is used to accelerate convergence. Two-step algorithm is; only available for the DC-06 and DC-12 methods.; QC; In the quadratically-convergent algorithm, the; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dcft-1.html:9438,perform,performing,9438,psi4manual/1.1.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dcft-1.html,6,['perform'],['performing']
Performance,"s are bulleted below. CFOUR; CHEMPS2; COOKBOOK; DFTD3; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/testsuite-1.html:1601,optimiz,optimization,1601,psi4manual/1.2.1/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/testsuite-1.html,2,['optimiz'],['optimization']
Performance,"s are not available for the three-particle energy; correction \((\lambda_3)\). Methods Summary¶; The table below summarizes current DCFT code features:. Method; Available algorithms; Energy; Gradient; Reference. ODC-06; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-12; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-13; SIMULTANEOUS, QC; Y; Y; UHF. \(\mbox{ODC-12$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. \(\mbox{ODC-13$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE RHF is only available for; ALGORITHM SIMULTANEOUS. To compute \((\lambda_3)\) correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dcft-1.html:13846,perform,perform,13846,psi4manual/1.1.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dcft-1.html,6,['perform'],['perform']
Performance,"s completed by performing the orbital transformation of the; integrals. As in the simultaneous algorithm, the DIIS; extrapolation is used to accelerate convergence. Two-step algorithm is; only available for the DC-06 and DC-12 methods.; 3) Quadratically-convergent algorithm (set ALGORITHM to QC). The; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the cumulant will be solved using a standard Jacobi update.; If requested by the user (set QC_COUPLING to TRUE), the electronic Hessian can include; matrix elements that couple the orbitals and the density cumulant.; The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below .; The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensive integral transformations, the simultaneous; algorithm benefits from a smaller number of expensive ; cumulant updates. As a result, for small closed-shell systems the two-step; algorithm is usually preferred, while for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:9468,perform,perform,9468,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['perform'],['perform']
Performance,"s for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional. from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and outpu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/exceptions.html:1256,Optimiz,OptimizationConvergenceError,1256,psi4manual/1.9.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/exceptions.html,2,['Optimiz'],['OptimizationConvergenceError']
Performance,"s for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]; class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]; class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]; class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:1256,Optimiz,OptimizationConvergenceError,1256,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,1,['Optimiz'],['OptimizationConvergenceError']
Performance,"s for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with non-generic exceptions classes."""""". __all__ = [; ""ConvergenceError"",; ""MissingMethodError"",; ""ManagedMethodError"",; ""OptimizationConvergenceError"",; ""ParsingError"",; ""PastureRequiredError"",; ""PsiException"",; ""SCFConvergenceError"",; ""TDSCFConvergenceError"",; ""TestComparisonError"",; ""UpgradeHelper"",; ""ValidationError"",; ""docs_table_link"",; ""sanitize_method"",; ]. from typing import Any, Dict, List, Optional; from psi4 import core, extras. [docs]class PsiException(Exception):; """"""Error class for |PSIfour|. Flags success as False (triggering coffee).""""""; extras._success_flag_ = False; pass. [docs]class ValidationError(PsiException):; """"""Input specification has problems. Error message *msg* directed both to standard output stream and to outfile. Parameters; ----------; msg; Human readable string describing the exception. Attributes; ----------; message; Human readable string describing the exception. """"""; message: str. def __init__(self, msg: str):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % repr(msg). [docs]class ParsingError(PsiException):; """"""Error called for problems parsing a text file. Prints error message; *msg* to standard output stream and outpu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html:1254,Optimiz,OptimizationConvergenceError,1254,psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,1,['Optimiz'],['OptimizationConvergenceError']
Performance,"s functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [E_h] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized linearized coupled cluster; doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2 level of theory. OMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2.5 level of theory. OMP2.5 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP3 level of theory. OMP3 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP3 level of theory. OREMP2 TOTAL ENERGY¶. OREMP2 CORRELATION ENERGY¶; The ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:42702,optimiz,optimized,42702,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,4,['optimiz'],['optimized']
Performance,"s gcp; from psi4.driver.qcdb.dashparam import get_dispersion_aliases; from psi4.driver.qcdb.dashparam import get_default_dashparams; from psi4.driver import p4util; #import numpy as np. [docs]class EmpericalDispersion(object):; def __init__(self, alias, dtype, **kwargs):; # 1) Functional name processing:; # 1a) Cleave out base functional from alias:; for dash in [""-"" + name.lower() for name in get_dispersion_aliases()]:; if dash == alias.lower()[-len(dash):]:; alias = alias[:-len(dash)]. # 1b) Alias must be lowercase; self.alias = alias.lower(). # 2) Figure out dispersion type:; # 2a) Strip ""-"" from dtype; if dtype[0] == ""-"":; dtype = dtype[1:]. # 2b) Un-alias and capitalise dtype for printing; if dtype.lower() in get_dispersion_aliases():; self.dtype = ""-"" + get_dispersion_aliases()[dtype.lower()]; else:; self.dtype = ""-"" + dtype.lower(). # 3) Get dispersion parameters:; # 3a) Set defaults; self.dash_params = get_default_dashparams(dtype). # 3b) Load passed variables from dictionary or from functional type; tuple_params = kwargs.pop('tuple_params', None); if ""dashparams"" in kwargs:; self.dash_params.update(kwargs.pop(""dashparams"")); elif dtype in dftd3.dashcoeff:; self.dash_params.update(dftd3.dash_server(alias, dtype)); else:; self.dash_params = {'s6': 1.0}. # 4) Dispersion class build process:; # 4a) Build coefficients for dftd3; if self.dtype in [""-d2gr"", ""-d3zero"", ""-d3bj"", ""-d3mzero"", ""-d3mbj""]:; self.dtype = self.dtype.replace('-d2gr', '-d2'); self.disp_type = 'gr'. # Odd tuple syntax favored by psi; if (tuple_params is not None):; self.tuple_params = None; self.dash_params['s6'] = tuple_params[0]. if len(tuple_params) > 1:; if ""d2"" in self.dtype:; self.dash_params[""alpha6""] = tuple_params[1]; elif (""zero"" in self.dtype) or (""bj"" in self.dtype):; self.dash_params[""s8""] = tuple_params[1]. if len(tuple_params) > 2:; if ""zero"" in self.dtype:; self.dash_params[""sr6""] = tuple_params[2]; elif ""bj"" in self.dtype:; self.dash_params[""a1""] = tuple_params[2]. if len(tup",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/empirical_dispersion.html:2290,Load,Load,2290,psi4manual/1.2.1/_modules/psi4/driver/procrouting/empirical_dispersion.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/empirical_dispersion.html,1,['Load'],['Load']
Performance,"s given. Possible choices are INTEGERWORDS (default), kB, MB, GB, and TB. Psi4 Interface: Keyword set from memory input command when given, always MB. Type: string; Possible Values: INTEGERWORDS, KB, MB, GB, TB; Default: INTEGERWORDS. CFOUR_METHOD¶. Specifies the geometry optimization strategy. Four values are permitted: NR (=0) – Straightforward Newton-Raphson search for minimum; RFA (=1) – Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. CFOUR_MRCC¶. Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY¶. Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING¶. Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:37899,optimiz,optimizations,37899,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,34,['optimiz'],"['optimizations', 'optimizer']"
Performance,"s goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print(info). # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to freque",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:50686,Load,Load,50686,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Load'],['Load']
Performance,"s greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundanci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:2871,optimiz,optimized,2871,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,15,['optimiz'],['optimized']
Performance,"s in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:8664,CACHE,CACHELEVEL,8664,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['CACHE'],['CACHELEVEL']
Performance,"s in scf. cdoremp-energy2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. aediis-2; EDIIS test case from 10.1063/1.1470195. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). fci-coverage; 6-31G H2O Test for coverage. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. mbis-4; MBIS calculation on NaCl. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. pywrap-cbs1; Various basis set extrapolation tests. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. dct10; The multiple guesses for DCT amplitudes for ODC-12. mom-h2o-3; MOM excitation from LUMO HOMO+3. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:35858,optimiz,optimization,35858,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"s in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CALC_S_SQUARED (DETCI); DETCI — Do calculate the value of for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CC (DETCI); DETCI — Do coupled-cluster computation?. Type: boolean; Default: false. CC3_FOLLOW_ROOT (CCEOM); CCEOM — Do turn on root following for CC3. Type: boolean; Default: false. CC_A_RAS3_MAX (DETCI); DETCI — maximum number of alpha electrons in RAS III, for CC. Type: integer; Default: -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:10937,CACHE,CACHETYPE,10937,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,"['CACHE', 'cache']","['CACHETYPE', 'cached']"
Performance,"s into a Psi4 Matrix (irreped if list). from_list(x). from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm(self, transa, transb, alpha, a, b, beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. partial_cholesky_factorize(self, delta, …); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha, cutoff); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self, RMRoutfile); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:2794,Load,Loads,2794,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,2,['Load'],['Loads']
Performance,"s into a Psi4 Matrix (irreped if list). from_list(x). from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm(self, transa, transb, alpha, a, b, beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in ir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.matrix.html:2824,Load,Loads,2824,psi4manual/1.5.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.matrix.html,2,['Load'],['Loads']
Performance,"s is essentially the same input as for F-SAPT, except that the molecular; system is now divided into three moieties – subsystems A and B whose; intramolecular interaction we wish to compute, and a linking unit C. This file; runs a DF-HF computation on the full system using PSI4‘s existing SCF code.; At the start of the FISAPT code, the occupied orbitals are localized and divided; by charge considerations into A, B, C, and link sets. By default, linking sigma; bonds are assigned to C (this can be changed by the FISAPT_LINK_ASSIGNMENT; options). Then, non-interacting Hartree–Fock solutions for A and B are optimized; in the embedding field of the linking moiety C. At this point, A and B are not; interacting with each other, but have any potential covalent links or other; interactions with C built in by the embedding. A standard F-SAPT0 computation; is then performed between A and B, yielding the I-SAPT interaction energy. Any; F-SAPT considerations are also possible when I-SAPT is performed – F and I are; completely direct-product-separable considerations. Cube File Visualization with PyMol¶; Setting FISAPT_DO_PLOT true above generates a set of .cube files; containing the densities and ESPs of the various subsystems in the I-SAPT; embedding procedure. These can be used to gain a detailed understanding of the; intermolecular partition and the polarization between non-interacting and; Hartree–Fock-interacting moieties. We have developed a set of template; .pymol scripts to help with this process. These can be obtained by running:; 1>>> copy_pymol2.py. and then in PyMol:; 1>>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. F/I-SAPT Keyword",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fisapt-1.html:10917,perform,performed,10917,psi4manual/1.1.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fisapt-1.html,2,['perform'],['performed']
Performance,"s is essentially the same input as for F-SAPT, except that the molecular; system is now divided into three moieties – subsystems A and B whose; intramolecular interaction we wish to compute, and a linking unit C. This file; runs a DF-HF computation on the full system using PSI4‘s existing SCF code.; At the start of the FISAPT code, the occupied orbitals are localized and divided; by charge considerations into A, B, C, and link sets. By default, linking sigma; bonds are assigned to C (this can be changed by the FISAPT_LINK_ASSIGNMENT; options). Then, non-interacting Hartree–Fock solutions for A and B are optimized; in the embedding field of the linking moiety C. At this point, A and B are not; interacting with each other, but have any potential covalent links or other; interactions with C built in by the embedding. A standard F-SAPT0 computation; is then performed between A and B, yielding the I-SAPT interaction energy. Any; F-SAPT considerations are also possible when I-SAPT is performed – F and I are; completely direct-product-separable considerations. Cube File Visualization with PyMol¶; Setting FISAPT_DO_PLOT true above generates a set of .cube files; containing the densities and ESPs of the various subsystems in the I-SAPT; embedding procedure. These can be used to gain a detailed understanding of the; intermolecular partition and the polarization between non-interacting and; Hartree–Fock-interacting moieties. We have developed a set of template; .pymol scripts to help with this process. These can be obtained by running:; >>> copy_pymol2.py. and then in PyMol:; >>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Adding Point Charg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/fisapt.html:11143,perform,performed,11143,psi4manual/master/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/master/fisapt.html,9,['perform'],['performed']
Performance,"s is essentially the same input as for F-SAPT, except that the molecular; system is now divided into three moieties – subsystems A and B whose; intramolecular interaction we wish to compute, and a linking unit C. This file; runs a DF-HF computation on the full system using PSI4’s existing SCF code.; At the start of the FISAPT code, the occupied orbitals are localized and divided; by charge considerations into A, B, C, and link sets. By default, linking sigma; bonds are assigned to C (this can be changed by the FISAPT_LINK_ASSIGNMENT; options). Then, non-interacting Hartree–Fock solutions for A and B are optimized; in the embedding field of the linking moiety C. At this point, A and B are not; interacting with each other, but have any potential covalent links or other; interactions with C built in by the embedding. A standard F-SAPT0 computation; is then performed between A and B, yielding the I-SAPT interaction energy. Any; F-SAPT considerations are also possible when I-SAPT is performed – F and I are; completely direct-product-separable considerations. Cube File Visualization with PyMol¶; Setting FISAPT_DO_PLOT true above generates a set of .cube files; containing the densities and ESPs of the various subsystems in the I-SAPT; embedding procedure. These can be used to gain a detailed understanding of the; intermolecular partition and the polarization between non-interacting and; Hartree–Fock-interacting moieties. We have developed a set of template; .pymol scripts to help with this process. These can be obtained by running:; 1>>> copy_pymol2.py. and then in PyMol:; 1>>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. F/I-SAPT Keyword",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/fisapt-1.html:11286,perform,performed,11286,psi4manual/1.2.1/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/fisapt-1.html,4,['perform'],['performed']
Performance,"s is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:7573,Load,Load,7573,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,4,['Load'],['Load']
Performance,"s is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin.; By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/plugins.html:7323,Load,Load,7323,psi4manual/master/plugins.html,https://psicode.org,https://psicode.org/psi4manual/master/plugins.html,11,['Load'],['Load']
Performance,"s means that D_CONVERGENCE = 11 is overkill and will approach machine precision.) See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indice",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html:4661,perform,performed,4661,psi4manual/4.0b3/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html,2,['perform'],['performed']
Performance,s method. set_tei_already_presorted() psi4.core.IntegralTransform method. set_title() psi4.core.OEProp method. set_tpdm_already_presorted() psi4.core.IntegralTransform method. set_tpdm_presorted() psi4.core.Deriv method. set_tweak() psi4.core.LibXCFunctional method. set_units() psi4.core.Molecule method. set_variable() in module psi4.core. psi4.core.Molecule method. psi4.core.Wavefunction method. set_view() psi4.driver.p4util.InPsight method. set_vv10_b() psi4.core.SuperFunctional method. set_vv10_c() psi4.core.SuperFunctional method. set_wcombine() psi4.core.JK method. set_write_dpd_so_tpdm() psi4.core.IntegralTransform method. set_x_alpha() psi4.core.SuperFunctional method. set_x_beta() psi4.core.SuperFunctional method. set_x_omega() psi4.core.SuperFunctional method. setName() psi4.core.ExternalPotential method. setting. ; keywords anharmonicity(). keywords cbs(). keywords cp. keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords properties(). keywords vmfc. SF_RESTRICT (DETCI). shallow_copy() psi4.core.Wavefunction method. shape psi4.core.Matrix attribute. psi4.core.Vector attribute. shared_object() psi4.core.IO static method. psi4.core.IOManager static method. shell() psi4.core.BasisSet method. shell_extents() psi4.core.BasisExtents method. shell_on_center() psi4.core.BasisSet method. shell_significant() psi4.core.ERISieve method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. shell_to_ao_function() psi4.core.BasisSet method. shell_to_basis_function() psi4.core.BasisSet method. shell_to_center() psi4.core.BasisSet method. ShellInfo class in psi4.core. shells_iterator() psi4.core.IntegralFactory method. shells_local_to_global() psi4.core.BlockOPoints method. sherrill_gold_standard() in module psi4.driver.aliases. shift() psi4.core.CIVector method. sigma() psi4.core.CIWavefunction method. SIGMA_OVERLAP (DETCI). sigma_xy() psi4.core.SymmetryOperation method. sigma_xz() psi4.c,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:113772,optimiz,optimize,113772,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,1,['optimiz'],['optimize']
Performance,"s molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:75702,optimiz,optimized,75702,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimized']
Performance,"s of gradients. opt2; SCF DZ allene geometry optimzation, with Cartesian input. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc54; CCSD dipole with user-specified basis set. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. scf3; are specified explicitly. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:11330,perform,performing,11330,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['perform'],['performing']
Performance,"s of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. DO_LEVEL_SHIFT¶. Do apply level shifting to aid convergence. Type: boolean; Default: false. DO_SCS¶. Do perform spin-component-scaled OMP3 (SCS-OMP3)? In all computation, SCS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP3, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SOS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. HESS_TYPE¶. Type Hessian matrix will be used in orbital optimization procedure. Type: string; Possible Values: NONE; Default: NONE. LEVEL_SHIFT¶. Level shift parameter. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html:1485,perform,perform,1485,psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"s of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. Expert¶. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_MBPT_DISP¶. Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. Table Of Contents. SAPT; General; AIO_CPHF; AIO_DF_INTS; BASIS; CCD_E_CONVERGENCE; CCD_MAXITER; CCD_T_CONVERGENCE; DENOMINATOR_ALGORITHM; DENOMINATOR_DELTA; DF_BASIS_ELST; DF_BASIS_SAPT; D_CONVERGENCE; E_CONVERGENCE; FREEZE_CORE; INTS_TOLERANCE; MAXITER; MAX_CCD_DIISVECS; MIN_CCD_DIISVECS; NAT_ORBS_T2; NAT_ORBS_T3; NAT_ORBS_V4; NO_RESPONSE; OCC_TOLERANCE; PRINT; SAPT_LEVEL; SAPT_MEM_CHECK; SAPT_MEM_SAFETY; SAPT_OS_SCALE; SAPT_SS_SCALE. Expert; DO_CCD_DISP; DO_MBPT_DISP; DO_THIRD_ORDER. Previous topic; ZERO_INTERNAL_AMPS; Next topic; AIO_CPHF; This Page. Show Source. Quick search. Enter search terms or a modu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__sapt-1.html:4747,perform,performed,4747,psi4manual/4.0b5/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__sapt-1.html,2,['perform'],['performed']
Performance,"s of the rigid molecule that only interchange identical atoms. rotor_type(self: psi4.core.Molecule) → str¶; Returns rotor type, e.g. ‘RT_ATOM’ or ‘RT_SYMMETRIC_TOP’. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False)¶; Compute dispersion correction using Grimme’s DFTD3 executable.; Function to call Grimme’s dftd3 program to compute the -D correction; of level dashlvl using parameters for the functional func.; dashparam can supply a full set of dispersion parameters in the; absence of func or individual overrides in the presence of func.; The DFTD3 executable must be independently compiled and found in; PATH or PSIPATH. Parameters:; mol (qcdb.Molecule or psi4.core.Molecule or str) – Molecule on which to run dispersion calculation. Both qcdb and; psi4.core Molecule classes have been extended by this method, so; either allowed. Alternately, a string that can be instantiated; into a qcdb.Molecule.; func (str or None) – Density functional (Psi4, not Turbomole, names) for which to; load parameters from dashcoeff[dashlvl][func]. This is not; passed to DFTD3 and thus may be a dummy or None. Any or all; parameters initialized can be overwritten via dashparam.; dashlvl ({'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}) – Flavor of a posteriori dispersion correction for which to load; parameters and call procedure in DFTD3. Must be a keys in; dashcoeff dict (or a key in dashalias that resolves to one).; dashparam (dict, optional) – Dictionary of the same keys as dashcoeff[dashlvl] used to; override any or all values initialized by; dashcoeff[dashlvl][func].; dertype ({None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional) – Maximum derivative level at which to run DFTD3. For large; mol, energy-only calculations can be significantly more; efficient. Also controls return values, see below.; verbose (bool, optional) – When True, additionally include DFTD3 output in output. Returns:; energy (float, optional) – When de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html:24405,load,load,24405,psi4manual/1.2.1/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.molecule.html,3,['load'],['load']
Performance,"s one coordinate of single atom.; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE displace_atom(N5boost10shared_ptrIN3psi6MatrixEEE,i,i,i,d); ; dmrg(...); dmrg( (Wavefunction)arg1) -> Wavefunction :; Runs the DMRG code.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE dmrg(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; efp_init(...); efp_init() -> EFP :; Initializes the EFP library and returns an EFP object.; ; C++ signature :; N5boost10shared_ptrIN3psi3efp3EFPEEE efp_init(); ; efp_set_options(...); efp_set_options() -> None :; Set EFP options from environment options object.; ; C++ signature :; void efp_set_options(); ; fd_1_0(...); fd_1_0( (Molecule)arg1, (list)arg2) -> Matrix :; Performs a finite difference gradient computation, from energy points.; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE fd_1_0(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE); ; fd_freq_0(...); fd_freq_0( (Molecule)arg1, (list)arg2, (int)arg3) -> Matrix :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE fd_freq_0(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE,i); ; fd_freq_1(...); fd_freq_1( (Molecule)arg1, (list)arg2, (int)arg3) -> Matrix :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE fd_freq_1(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE,i); ; fd_geoms_1_0(...); fd_geoms_1_0( (Molecule)arg1) -> matrix_vector :; Gets list of displacements needed for a finite difference gradient computation, from energy points.; ; C++ signature :; St6vectorIN5boost10shared_ptrIN3psi6MatrixEEESaIS4_EE fd_geoms_1_0(N5boost10shared_ptrIN3psi8MoleculeEEE); ; fd_geoms_freq_0(...); fd_geoms_freq_0( (Molecule)arg1, (int)arg2) -> matrix_vector :; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a gi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:680140,Perform,Performs,680140,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['Perform'],['Performs']
Performance,"s only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * omp2; * omp3; * ocepa; * cepa0; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-df-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-df-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:54729,perform,performed,54729,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,1,['perform'],['performed']
Performance,"s performed to validate forces. scf-level-shift-uhf; SCF level shift on a UHF computation. linK-2; RKS Linear Exchange Algorithm test for benzene. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. sapt11; sapt example with orbital freezing with alkali metal and dMP2. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cbs-delta-energy; Extrapolated energies with delta correction. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc1; RHF-CCSD 6-31G** all-electron optimizatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:8068,optimiz,optimized,8068,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimized']
Performance,"s performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfmp2_2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mp2_1; All-electron MP2 6-31G** geometry optimization of water. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dcft1; DCFT-06 calculation for the He dimer. This p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:15613,optimiz,optimization,15613,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"s provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4 1.4: Open-Source Software for High-Throughput Quantum Chemistry”,; D. G. A. Smith, L. A. Burns, A. C. Simmonett, R. M. Parrish, M. C.; Schieber, R. Galvelis, P. Kraus, H. Kruse, R. Di Remigio, A. Alenaizan, A.; M. James, S. Lehtola, J. P. Misiewicz, M. Scheurer, R. A. Shaw, J. B.; Schriber, Y. Xie, Z. L. Glick, D. A. Sirianni, J. S. O’Brien, J. M.; Waldrop, A. Kumar, E. G. Hohenstein, B. P. Pritchard, B. R. Brooks, H. F.; Schaefer III, A. Yu. Sokolov, K. Patkowski, A. E. DePrince III, U.; Bozkaya, R. A. King, F. A. Evangelista, J. M. Turney, T. D. Crawford, C.; D. Sherrill, J. Chem. Phys. (2020).; (doi: 10.1063/5.0006002). The following citation covers PSI4 early stable releases:. “Psi4 1.1: An Open-Source Electronic Structure Program Emphasizing; Automation, Advanced Libraries, and Interoperability”, R. M. Parrish, L.; A. Burns, D. G. A. Smith, A. C. Simmonett, A. E. DePrince III, E. G.; Hohenstein, U. Bozkaya, A. Yu. Sokolov, R. Di Remigio, R. M. Richard, J.; F. Gonthier, A. M. James, H. R. McAlexander, A. Kumar, M. Sa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:3161,Throughput,Throughput,3161,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,9,['Throughput'],['Throughput']
Performance,"s provided in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories starting with the name adc. The most; important keyword is ROOTS_PER_IRREP, which is an array; giving the number of excited states desired for each irreducible; representation. Implementation¶; Some very essential points are emphasized for understanding of the; nature and the limitations of the theory. The ADC(2) response matrix,; denoted as , is expanded in the single (S) and double (D); excitation manifolds as. where the superscript on each matrix block indicates the order of; the fluctuation. Instead of solving the above equation explicitly,; the large D manifold is treated effectively as. This form of the ADC(2) equation requires 7 – 10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than contruction of one $sigma$-vector with respect to the effective response matrix. The non-iterative excitation energy stated above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. where and denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/src/bin/adc/sigma.pdf. Table Of Contents. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Previous topic; SAPT: Symmetry-Adapted Perturbation Theory; Next topic; Geometry Optimization; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/adc-1.html:6692,Optimiz,Optimization,6692,psi4manual/4.0b4/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/adc-1.html,2,['Optimiz'],['Optimization']
Performance,"s provided in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories starting with the name adc. The most; important keyword is ROOTS_PER_IRREP, which is an array; giving the number of excited states desired for each irreducible; representation. Implementation¶; Some very essential points are emphasized for understanding of the; nature and the limitations of the theory. The ADC(2) response matrix,; denoted as , is expanded in the single (S) and double (D); excitation manifolds as. where the superscript on each matrix block indicates the order of; the fluctuation. Instead of solving the above equation explicitly,; the large D manifold is treated effectively as. This form of the ADC(2) equation requires 7 – 10 iterations for; convergence on only one root. But thanks to Newton-Raphson; acceleration,. the computational time reduces to shorter than half of the simple iterative; procedure. Construction of the denominator of the second term in the above; equation is less computationally expensive than contruction of one $sigma$-vector with respect to the effective response matrix. The non-iterative excitation energy stated above is calculated as a diagonal element of the Davidson mini-Hamiltonian matrix in the SEM as,. where and denote the CIS; excitation energy and wave function, respectively. The explicit form of the; σ-vector is provided in a note accompanying the source code,; in the file psi4/src/bin/adc/sigma.pdf. Table Of Contents. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Previous topic; SAPT: Symmetry-Adapted Perturbation Theory; Next topic; Geometry Optimization; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/adc-1.html:6692,Optimiz,Optimization,6692,psi4manual/4.0b5/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/adc-1.html,2,['Optimiz'],['Optimization']
Performance,"s provided with the Cfour download to install the; executable or to build the source. To by used by PSI4, the program; binary (xcfour) must be found in your PATH or; PSIPATH. The GENBAS file containing basis sets in Cfour; format is not necessary for this interface, but if you prefer to access; basis sets the “Cfour way” using a custom GENBAS file (the distributed; one is included with the interface), it, too, must be in PATH or; PSIPATH. If PSI4 is unable to execute the binary, an error; will be reported. Caution; The p4c4 interface hasn’t been fully adapted for the new March 2014 version. Cfour for PSI4 Users¶. Set memory as usual; Set molecule as usual; Set basis set as usual (Cfour only cares about orbital basis, no fitting; bases); Set the task as usual, indicating Cfour as the intended code by; prepending “c4-” to the method argument. So energy('scf') becomes; energy('c4-scf') and optimize('ccsd(t)') becomes; optimize('c4-ccsd(t)'). Find available methods for; energy() at Energy (CFOUR); and for optimize() at Gradient (CFOUR).; Generally, the p4c4 interface will handle best practices for path of; execution: vcc/ecc, derivative type, etc. The user is still; responsible for setting convergence, frozen core, guess, diis, etc.; For the moment, so-called “best-practices” keywords are summarized at; Best Practices.; For the type of computation intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through PSI4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like PSI4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; PSI4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:1623,optimiz,optimize,1623,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,15,['optimiz'],['optimize']
Performance,"s provided with the Cfour download to install the; executable or to build the source. To by used by Psi4, the program; binary (xcfour) must be found in your PATH or; PSIPATH. The GENBAS file containing basis sets in Cfour; format is not necessary for this interface, but if you prefer to access; basis sets the “Cfour way” using a custom GENBAS file (the distributed; one is included with the interface), it, too, must be in PATH or; PSIPATH. If Psi4 is unable to execute the binary, an error; will be reported. Caution; The p4c4 interface hasn’t been fully adapted for the new March 2014 version. Cfour for Psi4 Users¶. Set memory as usual; Set molecule as usual; Set basis set as usual (Cfour only cares about orbital basis, no fitting; bases); Set the task as usual, indicating Cfour as the intended code by; prepending “c4-” to the method argument. So energy('scf') becomes; energy('c4-scf') and optimize('ccsd(t)') becomes; optimize('c4-ccsd(t)'). Find available methods for; energy() at Energy (CFOUR); and for optimize() at Gradient (CFOUR).; Generally, the p4c4 interface will handle best practices for path of; execution: vcc/ecc, derivative type, etc. The user is still; responsible for setting convergence, frozen core, guess, diis, etc.; For the moment, so-called “best-practices” keywords are summarized at; Best Practices.; For the type of computation intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through Psi4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like Psi4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE when used in; Psi4.); In limited trial cases, keywords nominally directed at non-Cfour modules; are t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:1625,optimiz,optimize,1625,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['optimiz'],['optimize']
Performance,"s string; Default: No Default. DF_BASIS_SCF (SCF)¶SCF — Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_BUMP_R0 (SCF)¶SCF — Bump function min radius. Type: double; Default: 0.0. DF_BUMP_R1 (SCF)¶SCF — Bump function max radius. Type: double; Default: 0.0. DF_DOMAINS (SCF)¶SCF — FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. DF_FITTING_CONDITION (SCF)¶SCF (Expert) — Fitting Condition, i.e. eigenvalue threshold for RI basis. Analogous to S_TOLERANCE. Type: double; Default: 1.0e-10. DF_INTS_IO (DFMP2)¶DFMP2 (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_IO (SCF)¶SCF (Expert) — IO caching for CP corrections, etc. Changing this selects Disk_DF over Mem_DF. Note that setting this forces DiskDFJK when SCF_TYPE=DF. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_NUM_THREADS (DFMP2)¶DFMP2 — Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. DF_INTS_NUM_THREADS (SCF)¶SCF — Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. DF_METRIC (SCF)¶SCF — FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. DF_SCF_GUESS (SCF)¶SCF — Do a density fitting SCF calculation to converge the orbitals before switching to the use of exact integrals in a SCF_TYPE DIRECT calculation. Type: boolean; Default: true. DF_THETA (SCF)¶SCF — FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. DFCC (FNOCC)¶FNOCC — Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. DFMP2_MEM_FACTOR (DFMP2)¶DFMP2 — % of memory for DF-MP2 three-ind",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:105120,LOAD,LOAD,105120,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['LOAD'],['LOAD']
Performance,"s strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; ind",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:13266,perform,performed,13266,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['perform'],['performed']
Performance,"s that all energy methods can run with a minimal input and set symmetry. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). cc51; EOM-CC3/cc-pVTZ on H2O. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. opt3; SCF cc-pVDZ geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:6716,optimiz,optimization,6716,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"s that computed identically between cfour and psi4. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/kw-1; testing best practices options, part i. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/mints5; geometries from a variety of input formats. references from psi4, tes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html:1333,optimiz,optimization,1333,psi4manual/1.8.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"s the number of vectors to retain when the Davidson subspace is collapsed (see MAX_NUM_VECS). If greater than one, the collapsed subspace retains the best estimate of the CI vector for the previous n iterations. Defaults to 1. Type: integer; Default: 1. COLLAPSE_WITH_LAST (CCEOM); CCEOM — Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. COMPUTE_MP4_TRIPLES (FNOCC); FNOCC (Expert) — Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES (FNOCC); FNOCC (Expert) — Do compute triples contribution?. Type: boolean; Default: true. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC); PSIMRCC — Do include the terms that couple the reference determinants?. Type: boolean; Default: true. COVALENT_CONNECT (OPTKING); OPTKING — When determining connectivity, a bond is assigned if interatomic distance is less than (this number) * sum of covalent radii. Type: double; Default: 1.3. CPH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:19354,perform,perform,19354,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['perform'],['perform']
Performance,"s the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args, **kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self, arg0); Sets the internal density. set_debug(self, arg0); Sets the debug level of the object. set_print(self, arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; Returns internal AO density. basis(self: psi4.core.VBase) → psi4.core.BasisSet¶; Returns the internal basis set. build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str) → psi4.core.VBase¶. build_collocation_cache(self: psi4.core.VBase, arg0: int) → None¶; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase) → None¶; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; doctsring. compute_Vx(self: psi4.core.VBase, arg0: List[psi4.core.Matrix], arg1: List[psi4.core.Matrix]) → None¶; doctsring. compute_gradient(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs)¶; Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase) → psi4.core.SuperFunctional¶; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int) → psi::BlockOPoints¶; Returns the requested BlockOPoints. get_np_xyzw()¶; Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self: psi4.core.VBase) → psi::DFTGrid¶; Returns the grid object. initialize(*args, **kwargs)¶; Ove",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vbase.html:1902,cache,cache,1902,psi4manual/1.3.2/api/psi4.core.vbase.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vbase.html,1,['cache'],['cache']
Performance,"s to 0.2 bohr each. Type: array; Default: No Default. CUTOFF (DFOCC); DFOCC — Cutoff value for numerical procedures. Type: integer; Default: 8. CUTOFF (OCC); OCC — Cutoff value for numerical procedures. Type: integer; Default: 14. D_CONVERGENCE (FISAPT); FISAPT — Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. D_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for density. Type: conv double; Default: 1e-6. D_CONVERGENCE (SAPT); SAPT — Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. D_CONVERGENCE (SCF); SCF — Convergence criterion for SCF density, which is defined as the RMS value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. DAMPING_CONVERGENCE (SCF); SCF — The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE (DCFT); DCFT (Expert) — The amount (percentage) of damping to apply to the orbital update procedure: 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DAMPING_PERCENTAGE (PSIMRCC); PSIMRCC — The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:92185,perform,performed,92185,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"s to be frozen. Type: string; Default: No Default. FROZEN_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be frozen. Type: string; Default: No Default. FROZEN_DOCC (GLOBALS); GLOBALS — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_DOCC (PSIMRCC); PSIMRCC — The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC (GLOBALS); GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. FROZEN_UOCC (PSIMRCC); PSIMRCC — The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING); OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM); CCEOM — Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. FZC_A_FILE (TRANSQT); TRANSQT — Alpha-spin frozen-core file. Type: integer; Default: PSIF_OEI. FZC_B_FILE (TRANSQT); TRANSQT — Beta-spin frozen-core file. Type: integer; Default: PSIF_OEI. FZC_FILE (TRANSQT); TRANSQT — Frozen-core file. Type: integer; Default: PSIF_OEI. G_CONVERGENCE (OPTKING); OPTKING — Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:50111,optimiz,optimization,50111,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"s to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); #nolongerpredictable psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; driver_loc = os.path.dirname(os.path.abspath(__file__)); dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath + \; ':' + driver_loc # so the databases can ""import qcdb"". sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:9992,load,loading,9992,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['load'],['loading']
Performance,"s to use in SMP parallel computations.; C++ signature :. i nthread(). psi4.nuclear_dipole()¶; Python Library Documentation: built-in function nuclear_dipole in module psi4; nuclear_dipole(...). nuclear_dipole( (Molecule)arg1) -> Vector :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE nuclear_dipole(N5boost10shared_ptrIN3psi8MoleculeEEE). psi4.occ()¶; Python Library Documentation: built-in function occ in module psi4; occ(...). occ( (Wavefunction)arg1) -> Wavefunction :. Runs the orbital optimized CC codes.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE occ(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.opt_clean()¶; Python Library Documentation: built-in function opt_clean in module psi4; opt_clean(...). opt_clean() -> None :. Cleans up the optimizer’s scratch files.; C++ signature :. void opt_clean(). psi4.optking()¶; Python Library Documentation: built-in function optking in module psi4; optking(...). optking() -> int :. Runs the geometry optimization / frequency analysis code.; C++ signature :. i optking(). psi4.outfile_name()¶; Python Library Documentation: built-in function outfile_name in module psi4; outfile_name(...). outfile_name() -> str :. Returns the name of the output file.; C++ signature :. Ss outfile_name(). psi4.plugin()¶; Python Library Documentation: built-in function plugin in module psi4; plugin(...). plugin( (str)arg1, (Wavefunction)arg2) -> Wavefunction :. docstring; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE plugin(Ss,N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.plugin_close()¶; Python Library Documentation: built-in function plugin_close in module psi4; plugin_close(...). plugin_close( (str)arg1) -> None :. docstring; C++ signature :. void plugin_close(Ss). psi4.plugin_close_all()¶; Python Library Documentation: built-in function plugin_close_all in module psi4; plugin_close_all(...). plugin_close_all() -> None :. docstring; C++ signature :. void plugin_close_all(). psi4.plugin_load()¶;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:35233,optimiz,optimization,35233,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['optimiz'],['optimization']
Performance,"s used. Often extremely; accurate, particularly for closed-shell systems. This is the default for; systems of more than one atom. SADNONatural orbitals from Superposition of Atomic Densities. Similar; to the above, but it forms natural orbitals from the SAD density; matrix to get proper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]. GWHA generalized Wolfsberg-Helmholtz modification of the core; Hamiltonian matrix. Usually less accurate than the core guess: the; latter is exact for one-electron systems, GWH is not; see; [Lehtola:2019:1593]). HUCKELAn extended Hückel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]. READRead the previous orbitals from a wfn file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations. SAPSuperposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]; and [Lehtola:2020:012516]. The guess and its implementation have; been described in [Lehtola:2019:1593]. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]. SAPGAUSuperposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]. The main difference to the SAP guess; discussed above [Lehtola:2019:25945] is that the SA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:18359,optimiz,optimizations,18359,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,1,['optimiz'],['optimizations']
Performance,"s used. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). fcidump; test FCIDUMP functionality for rhf/uhf. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). fsapt-ext; Quick test of external potenti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:19717,optimiz,optimized,19717,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimized']
Performance,"s when using a zmatrix for; molecular input is not supported. Freezing or constraining Cartesian coordinates; requires Cartesian molecule input. If numerical errors results in symmetry; breaking, while Cartesian constraints are active, symmetrization cannot occur and; an error will be raised, prompting you to restart the job. As a shortcut, the entire set of dihedral angles can be frozen. A subset can then be unfrozen if desired. set {; freeze_all_dihedrals true; unfreeze_dihedrals ""1 2 3 4""; }. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. lower_bound = [99.99, 109.99, 119.99, 129.99, 149.99]; upper_bound = [100, 110, 120, 130, 140, 150]; PES = []. for lower, upper in zip(lower_bound, upper_bound):; my_string = f""1 2 3 4 {lower} {upper}""; set optking ranged_dihedral = $my_string; E = optimize('scf'); PES.append((upper, E)). print(""\n\tcc-pVDZ SCF energy as a function of phi\n""); for point in PES:; print(""\t%5.1f%20.10f"" % (point[0], point[1])). To scan the potential energy surface without the RANGED_DIHEDRAL keyword, a zmatrix; can be used. Warning; Rotating dihedrals in large increments without allowing the molecule to relax; in between increments can lead to unphysical geometries with overlapping functional groups in larger molecules,; which may prevent successful constrained optimzations. Furthermore, such a relaxed scan of the PES does; not always procude a result close to an IRC, or even a reaction path along which the energy changes in a; continuous way. molecule hooh {; 0 1; H; O 1 0.95; O 2 1.39 1 103; H 3 0.95 2 103 1 D. D = 99. units ang; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; frozen_dihedral ("" 1 2 3 4 ""); }. dihedrals = [100, 110, 120, 130, 140, 150]; PES = []. for phi in dihedrals:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:7912,optimiz,optimize,7912,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['optimiz'],['optimize']
Performance,"s with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]; class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]; class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.; d_conv; RMS change in density for last iteration. Attributes; ----------; message; Human readable string describing the exception.; iteration; Itera",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html:6008,optimiz,optimization,6008,psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/exceptions.html,3,['optimiz'],['optimization']
Performance,"s with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Defau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:9860,CACHE,CACHELEVEL,9860,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,"['CACHE', 'Cache']","['CACHELEVEL', 'Cacheing']"
Performance,"s"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). Note; As of October 2018, only two explicit `deltaN_[wfn,basis,scheme]` sets of options are active; if more delta functions are required, use the `cbs_metadata` interface. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cbs.html:17691,perform,performed,17691,psi4manual/master/cbs.html,https://psicode.org,https://psicode.org/psi4manual/master/cbs.html,5,['perform'],['performed']
Performance,"s': xlines,; 'xlimit': xlimit,; 'ialimit': ialimit}; rowplan, columnplan, landscape, footnotes, \; suggestedtitle, suggestedtheme = tableplan(**kwargs); #suggestedtitle, suggestedtheme = tableplan(plotpath=plotpath, subjoin=subjoin). # make figure files write themselves; autothread = {}; autoliliowa = {}; if plotpath == 'autogen':; for col in columnplan:; if col[3].__name__ == 'flat':; if col[4] and autothread:; print('TODO: merge not handled'); elif col[4] or autothread:; autothread.update(col[4]); else:; autothread = {'dummy': True}; elif col[3].__name__ == 'liliowa':; autoliliowa = {'dummy': True}. # negotiate some defaults; dbse = [self.dbse] if dbse is None else dbse; theme = suggestedtheme if theme is None else theme; title = suggestedtitle if title is None else title; indextitle = title if indextitle is None else indextitle; opttarget = {'default': ['']} if opttarget is None else opttarget. def unify_options(orequired, opossible):; """"""Perform a merge of options tags in *orequired* and *opossible* so; that the result is free of duplication and has the mode at the end. """"""; opt_combos = []; for oreq in orequired:; for opos in opossible:; pieces = sorted(set(oreq.split('_') + opos.split('_'))); if '' in pieces:; pieces.remove(''); for mode in ['CP', 'unCP', 'SA']:; if mode in pieces:; pieces.remove(mode); pieces.append(mode); pieces = '_'.join(pieces); opt_combos.append(pieces); return opt_combos. # gather list of model chemistries for table; mcs = ['-'.join(prod) for prod in itertools.product(mtd, opt, bas)]; mc_translator = {}; for m, o, b in itertools.product(mtd, opt, bas):; nominal_mc = '-'.join([m, o, b]); for oo in unify_options([o], opttarget['default']):; trial_mc = '-'.join([m, oo, b]); try:; perr = self.compute_statistics(trial_mc, benchmark=benchmark, sset='default', # prob. too restrictive by choosing subset; failoninc=False, verbose=False, returnindiv=False); except KeyError as e:; continue; else:; mc_translator[nominal_mc] = trial_mc; break; else:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:96646,Perform,Perform,96646,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Perform'],['Perform']
Performance,"s() -> float :; Runs the coupled cluster (T) energy code.; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; compute_shell(...); compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> None :; docstring; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:156072,Perform,Performs,156072,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['Perform'],['Performs']
Performance,"s(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_efp(); Returns the currently active EFP object. get_active_molecule(); Returns the currently active molecule object. get_array_variable(arg0); Returns one of the PSI variables set internally by the modules or python driver (see manual for full listing of variables available). get_array_variables(); Returns dictionary of the PSI variables set internally by the modules or python driver. get_atomi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:242999,Perform,Performs,242999,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['Perform'],['Performs']
Performance,"s(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" %; (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (opt_mode == 'continuous') and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.get_variable('CURRENT ENERGY'). # Compute the gradient; G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.get_variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). # S/R: Quit after getting new displacements or if forming gradient fails; if o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:61221,optimiz,optimize,61221,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"s) [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. sos-pi-omp3; A special version of SOS-OMP3 for pi systems [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual]. fno-aqcc; AQCC with frozen natural orbitals [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual]. fno-qcisd; QCISD with frozen natural orbitals [manual]. lccd; Linear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. a-ccsd(t); CCSD with asymmetric perturbative triples (A-CCSD(T)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html:4097,optimiz,optimized,4097,psi4manual/1.4.0/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html,10,['optimiz'],['optimized']
Performance,"s) [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. sos-pi-omp3; A special version of SOS-OMP3 for pi systems [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual]. fno-aqcc; AQCC with frozen natural orbitals [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual]. fno-qcisd; QCISD with frozen natural orbitals [manual]. lccd; Linear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. ccsd(at); CCSD with asymmetric perturbative triples (CCSD(AT)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy module. dfocc; expert full control over dfocc module. cisd; configuration interaction (CI) singles and doubles (CISD) [manual] [details]. fno-cisd; CISD with frozen natural orbitals [manual]. cisdt;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:3662,optimiz,optimized,3662,psi4manual/1.1.0/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html,13,['optimiz'],['optimized']
Performance,"s) or HTML table link (replace underscore in returned string by dash). sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an input dictionary. tdscf(wfn, **kwargs). temp_circular_import_blocker(). vibanal_wfn(wfn[, hess, irrep, molecule, ...]); Function to perform analysis of a hessian or hessian block, specifically. Classes¶. AtomicComputer; Computer for analytic single-geometry computations. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs); Error called when a requested level of theory and derivative level are nominally available but not for the particular conditions (e.g., reference, algorithm, active orbitals, QC module, etc.) requested. MissingMethodError(msg); Error called when requested level or theory or derivative level are not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:20750,perform,perform,20750,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,2,['perform'],['perform']
Performance,"s). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Previous topic; Notes on Options; Next topic; Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:19844,optimiz,optimized,19844,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['optimiz'],['optimized']
Performance,"s). adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/testsuite-1.html:17589,optimiz,optimization,17589,psi4manual/4.0b3/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"s):; if(expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; psi4.print_out(""The computed vector\n""); computed.print_out(); psi4.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label). [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2: ; TestComparisonError(""Input shapes do not match.""). if not np.allclose(expected, computed, atol=digits):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label). [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fabs(evec[n]-cvec[n]) > 1.0e-4):; m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:8768,Perform,Performs,8768,psi4manual/1.0.0/_modules/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html,1,['Perform'],['Performs']
Performance,"s):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-De",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/quickaddalias-1.html:2487,optimiz,optimizations,2487,psi4manual/4.0b3/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/quickaddalias-1.html,6,['optimiz'],['optimizations']
Performance,"s, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",target=""_top""];; ""Vector3"" [URL=""#psi4.core.Vector3"",fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",target=""_top""];; ""VectorMatrix"" [URL=""#psi4.core.VectorMatrix"",fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",target=""_top""];; ""View"" [URL=""#psi4.core.View"",fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",target=""_top""];; ""Wavefunction"" [URL=""#psi4.core.Wavefunction"",fontname=""Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans"",fontsize=10,height=0.25,shape=box,style=""setlinewidth(0.5)"",target=""_top""];; }. psi4.driver Package¶. Functions¶. BFS(self); Perform a breadth-first search (BFS) on the real atoms in molecule, returning an array of atom indices of fragments. activate(mol); Function to set molecule object mol as the current active molecule. ancestor(dir[, n]); Get the nth ancestor of a directory. banner(text[, type, width, strNotOutfile]); Function to print text to output file in a banner of minimum width width and minimum three-line height for type = 1 or one-line height for type = 2. basis_helper(block[, name, key, set_option]); For PsiAPI mode, forms a basis specification function from block and associates it with keyword key under handle name. cbs(func, label, **kwargs); Function to define a multistage energy method from combinations of basis set extrapolations and delta corrections and condense the components into a minimum number of calculations. compare_arrays(expected, computed, digits, label); Function to compare two numpy arrays. compare_csx(); Function to validate energies in CSX files against PSIvariables. compare_cubes(expected, computed, label); Function to compa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:195218,Perform,Perform,195218,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['Perform'],['Perform']
Performance,"s, PAOs,; and auxiliary basis functions.; Solving the iterative local MP2 equations in the LMO/PAO basis requires large PAO; domains to achieve reasonable accuracy. Instead, the virtual space is transformed; into the much more compact pair natural orbital representation. The (approximate); PNOs diagonalize the virtual-virtual block of the (approximate) MP2 density matrix:. (7)¶\[D_{ij}^{ab} = \frac{1}{1 + \delta_{ij}}[\tilde{t}_{ij}^{\dagger}t_{ij} + \tilde{t}_{ij}t_{ij}^{\dagger}]^{ab}\]; which is constructed from semicanonical amplitudes:. (8)¶\[\begin{split}t_{ij}^{ab} &= - \frac{(iajb)}{\epsilon_{a} + \epsilon_{b} - \epsilon_{i} - \epsilon_{j}}, \\; \tilde{t}_{ij}^{ab} &= 2t_{ij}^{ab} - t_{ij}^{ba}.\end{split}\]; PNOs with small occupation numbers are discarded, and the local MP2 equations are; solved in the LMO/PNO basis. Recommendations¶; Some practical notes on running the code:. DLPNO-MP2 is not a drop-in replacement for DF-MP2. Instead, it should be used for; large calculations that cannot reasonably be performed with DF-MP2. The crossover; point between DF-MP2 and DLPNO-MP2 depends on details of both the calculation and; the hardware, but can be as low as 2,000 basis functions.; The accuracy of DLPNO-MP2 (relative to DF-MP2) can be controlled with the; PNO_CONVERGENCE keyword according to recommendation by Liakos et al.; [Liakos:2015:1525]. For non-covalent interactions TIGHT is highly recommended.; The greater the spatial sparsity of a molecular system, the smaller the pair; domains and consequently the faster the calculation. DLPNO-MP2 is much faster; for linear alkanes than for globular proteins, all else constant.; Similar to molecular sparsity, the sparsity of the orbital basis affects runtime.; Diffuse functions increase the size of the pair domains and therefore lead to; longer calculations.; All aspects of DLPNO-MP2 run in core; no disk is required. As a result, the; code exhibits very good intra-node parallelism, and benefits from many threads.; T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dlpnomp2.html:6749,perform,performed,6749,psi4manual/master/dlpnomp2.html,https://psicode.org,https://psicode.org/psi4manual/master/dlpnomp2.html,7,['perform'],['performed']
Performance,"s, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. GAUGE¶. Specifies the choice of representation of the electric dipole operator. For polarizability, this keyword is ignored and LENGTH gauge is computed. For optical rotation and raman optical activity, this keyword is active, and acceptable values are LENGTH for the usual length-gauge representation, VELOCITY``(default) for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or ``BOTH. Note that, for optical rotation and raman optical activity calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: VELOCITY. table of contents. CC: Coupled Cluster Theory; Basic Keywords; REFERENCE; R_CONVERGENCE; MAXITER; BRUECKNER_ORBS_R_CONVERGENCE; RESTART; CACHELEVEL; CACHETYPE; NUM_AMPS_PRINT; MP2_AMPS_PRINT. Larger Calculations; Excited State Coupled Cluster Calculations; ROOTS_PER_IRREP; E_CONVERGENCE; SINGLES_PRINT; SCHMIDT_ADD_RESIDUAL_TOLERANCE; EOM_GUESS. Linear Response (CCLR) Calculations; PROPERTY; OMEGA; GAUGE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; CC: Coupled Cluster Theory. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cc.html:12874,CACHE,CACHELEVEL,12874,psi4manual/1.7.x/cc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cc.html,2,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"s, the cost of their; construction has increased. Although significantly cheaper than computing; integrals themselves, construction of integral objects can be non-negligible,; especially if many threads are used. For example, this pattern can be found in; old versions of the code:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; }. This builds many objects and the cost can add up. With the new scheme,; integral objects are forced to implement a clone() member that can be used as; follows:; std::vector<std::shared_ptr<TwoBodyAOInt>> ints;; ints.push_back(std::shared_ptr<TwoBodyAOInt>(factory->eri()));; for (int thread = 1; thread < num_threads; thread++) {; ints.push_back(std::shared_ptr<TwoBodyAOInt>(ints[0]->clone()));; }. This method only incurs the cost of creating a single integral object, and; performs much cheaper cloning operations to create the other objects for each; thread. Moreover, if integral objects are created only in the initialization; of each code that uses them, and stored persistently, the cost of integral; object creation is further reduced. One Electron Integrals in PSI4¶; After version 1.5, we started transitioning the one electron integral code over to; use Libint2 instead of the old handwritten Obara-Saika code. There are a; number of reasons motivating this switch. For methods requiring; potentials and fields evaluated at many external sites, such as PCM and; polarizable embedding, the efficiency of the one electron integrals can be rate; limiting. We also started to introduce integral screening, and it is important; to balance the screening used for one- and two-electron terms carefully, so this; is a good opportunity to re-evaluate the code. Finally, given the complexity; of the OS recursion code, the switch to an external library leaves a more; compact cod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_integrals.html:10404,perform,performs,10404,psi4manual/master/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_integrals.html,5,['perform'],['performs']
Performance,"s. The choices for this; keyword are case sensitive and must match the database python file; * ``[1,2,5]`` || ``['1','2','5']`` || ``['BzMe-3.5', 'MeMe-5.0']`` || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. :examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); #hartree2kcalmol = 627.509469 # consistent with perl SETS scripts. # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:28384,Optimiz,Optimize,28384,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,"['Optimiz', 'optimiz']","['Optimize', 'optimize']"
Performance,"s. The psi label should always be added, but the other labels are test-specific. The method tested should always be included, and this is often sufficient. If adding a test for an already existing module, the labels for other tests of the module will suggest other labels to add.; Labels have been added as developers needed, so they are not systematic or thorough. If you see labels to add or rename, please do.; A test requiring over 15 minutes should be labeled longtests. A short test under 30 seconds used for general bug checking should be labeled quicktests. A test that confirms PSI4 is operational should be labeled smoketests.; If a test needs extra input files like grid.dat or extra reference files for checking against, like fchk, specify these in the CMakeLists.txt as shown above. Such tests must be run through ctest and don’t usually work when run “by hand” from the objdir via stage/bin/psi4 ../tests/directory_name/input.dat.; If a test is multiple minutes long, load-balancing a parallel CTest run requires the test to be started early. Use the COST line as shown above to set a weighting to about the number of seconds the test takes. input.dat¶; The other necessary file is the input file itself, input.dat. The input file should be just a simple input file to run the test, with small additions.; #! RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxiliary basis.; #! Also a bit more to force a second line. nucenergy = 8.801466202085710 #TEST; refenergy = -76.05098402733282 #TEST. molecule h2o {; symmetry c1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pVTZ; scf_type df; df_basis_scf cc-pVTZ-RI; e_convergence 10; }. thisenergy = energy(""hf""). compare_values(nucenergy, h2o.nuclear_repulsion_energy(), 9, ""Nuclear repulsion energy"") #TEST; compare_values(refenergy, thisenergy, 9, ""Reference energy"") #TEST; compare_values(refenergy, variable('scf total energy'), 9, ""Reference energy"") #TEST. Of those small modifications, first, note the special c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/add_tests.html:6568,load,load-balancing,6568,psi4manual/master/add_tests.html,https://psicode.org,https://psicode.org/psi4manual/master/add_tests.html,5,['load'],['load-balancing']
Performance,"s. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_QQR_SIEVE (CPHF); CPHF — Do we do the QQR integral sieve of Maurer et al. When false, just uses * the Schwarz sieve. Type: boolean; Default: false. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:113678,perform,perform,113678,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"s. scf-cholesky-basis; incremental Cholesky filtered SCF. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. soscf-large; Second-order SCF convergnece: Benzene. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. scf7; Tests SCF gradient in the presence of a dipole field. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dft1-alt; DFT Functional Test. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:32633,optimiz,optimization,32633,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"s. shallow_copy(self, arg0); Copies the pointers to the internal data. soFeff(self); Returns the effective Fock matrix in the orthogonalized SO basis. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. to_file([filename]); Converts a Wavefunction object to a base class. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters. basis (str) – {‘SO’, AO’}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str) – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html:12560,perform,performed,12560,psi4manual/1.5.0/api/psi4.core.rohf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.rohf.html,1,['perform'],['performed']
Performance,"s.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n ------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:58400,optimiz,optimizer,58400,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimizer']
Performance,"s.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sherrill Group Gold Standard'; return driver_cbs.cbs(func, label, **kwargs). [docs]def allen_focal_point(func, label, **kwargs):; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; :py:func:`~psi4.driver.cbs` to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:4701,perform,performed,4701,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html,2,['perform'],['performed']
Performance,"s; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'); }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'); }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'); }. return [scf, corl, delta]. [docs]def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """""". if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). scf = { # HF; 'wfn': 'hf',; 'basis': kwargs.pop",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html:4556,perform,performed,4556,psi4manual/1.6.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html,1,['perform'],['performed']
Performance,"s; By default, a separate subdirectory for each Cfour call is created within; the job’s scratch directory. To explicitly specify the location of the; Cfour scratch, execute with, for example, energy('cfour',; path='/full/path/to/cfour/scratch'). Regardless of whether the location; is specified or default, whether to preserve the scratch directory after; the computation can be specified with energy('cfour', keep=True) or; (the default) energy('cfour', keep=False). path and keep are; keyword arguments that get interpreted by the; run_cfour() function documented below. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into PSI4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; complete_basis_set() for computation of compound methods involving; basis set extrapolations and/or delta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:24637,optimiz,optimize,24637,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['optimiz'],['optimize']
Performance,"s; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/kw-1; testing best practices options, part i. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/kw-2; testing best practices options, part ii. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .   ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html:4072,optimiz,optimization,4072,psi4manual/1.6.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,s; WFN — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; EOM_REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; INTS_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; KEEP_OEIFILE — Psi4 [1.0.0 6a9a71b] Docs; KEEP_TEIFILE — Psi4 [1.0.0 6a9a71b] Docs; LOCAL — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CORE_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CPHF_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_DOMAIN_MAG — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_DOMAIN_POLAR — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_DOMAIN_SEP — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_FILTER_SINGLES — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_METHOD — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_PAIRDEF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_WEAKP — Psi4 [1.0.0 6a9a71b] Docs; OMEGA — Psi4 [1.0.0 6a9a71b] Docs; PROPERTY — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; SEMICANONICAL — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; DELETE_TEI — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; SEMICANONICAL — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; CC_NUM_THREADS — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; SEMICANONICAL — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_ABCDTYPE — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_ACTIVE_ORBI — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_ANH_ALGORITHM — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_ANH_DERIVATIVES — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_ANH_STEPSIZE — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_ANH_SYMMETRY — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_ANHARMONIC — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_AO_LADDERS — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_AV_SCF — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_BRUCK_CONV — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_BRUECKNER — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_CACHE_RECS — Psi4 [1.0.0 6a9a71b] Docs; CFOUR_CALC_LEVEL — Psi4 [1.0.0 6a9a71b] Docs; CFO,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:45729,CACHE,CACHELEVEL,45729,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,"s; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In PSI4, the only external instability; that can be checked at present is the RHF \(\rightarrow\) UHF one.; Currently, two algorithms exist in PSI4 for stability analysis: the original; Direct Inversion and the newly implemented Davidson algorithms. We will first describe; options common to both algorithms. To request a stability analysis at the end of the SCF,; set the keyword STABILITY_ANALYSIS. Value CHECK only computes the electronic; Hessian eigenvalue and checks if an actual SCF minimum has been found, while value FOLLOW; rotates the converged orbitals along the lowest eigenvector, then invokes the SCF; procedure again to lower the energy. In case the minimization does not succeed; or ends up on the same unstable solution, you can tune the scale factor for the orbital; rotation through the keyword FOLLOW_STEP_SCALE.; The rotation angle is \(\frac{\pi}{2}\mbox{ } \cdot\) (FOLLOW_STEP_SCALE). The default value of; 0.5 usually provides a good guess, and modification is only recommended in difficult cases.; The default behavior for the stability code is to stop after trying to reoptimize the orbitals once; if the instability still exists. For more attempts, set MAX_ATTEMPTS;; the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification; of FOLLOW_STEP_SCALE is recommended over increasing MAX_ATTEMPTS. Note; Setting the option STABILITY_ANALYSIS to FOLLOW is only avalible for UHF. When using; RHF and ROHF instabilities can be checked, but not followed. If you want to attempt to find a lower energy solution; you should re-run the calculation with REFERENCE set to UHF. The main algorithm available in PSI4 is the Direct Inversion algorithm. It can only; work with SCF_TYPE PK, and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:48234,tune,tune,48234,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,13,['tune'],['tune']
Performance,"s; can check whether a lower SCF solution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In PSI4, the only external instability; that can be checked at present is the RHF \(\rightarrow\) UHF one.; Currently, two algorithms exist in PSI4 for stability analysis: the original; Direct Inversion and the newly implemented Davidson algorithms. We will first describe; options common to both algorithms. To request a stability analysis at the end of the SCF,; set the keyword STABILITY_ANALYSIS. Value CHECK only computes the electronic; Hessian eigenvalue and checks if an actual SCF minimum has been found, while value FOLLOW; rotates the converged orbitals along the lowest eigenvector, then invokes the SCF; procedure again to lower the energy. In case the minimization does not succeed; or ends up on the same unstable solution, you can tune the scale factor for the orbital; rotation through the keyword FOLLOW_STEP_SCALE.; The rotation angle is \(\frac{\pi}{2}\mbox{ } \cdot\) (FOLLOW_STEP_SCALE). The default value of; 0.5 usually provides a good guess, and modification is only recommended in difficult cases.; The default behavior for the stability code is to stop after trying to reoptimize the orbitals once; if the instability still exists. For more attempts, set MAX_ATTEMPTS;; the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification; of FOLLOW_STEP_SCALE is recommended over increasing MAX_ATTEMPTS.; The main algorithm available in PSI4 is the Direct Inversion algorithm. It can only; work with SCF_TYPE PK, and it explicitly builds the full electronic Hessian; matrix before explicitly inverting it. As such, this algorithm is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available.; The Davidson ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:27372,tune,tune,27372,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,2,['tune'],['tune']
Performance,s; compare_fcidumps; compare_fcidumps; ConvergenceError; copy_file_from_scratch; copy_file_from_scratch; copy_file_to_scratch; copy_file_to_scratch; create_plugin; create_plugin; CSXError; cubeprop; cubeprop; Dftd3Error; dynamic_variable_bind; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energies_from_fcidump; energy; energy; fchk; fchk; fchkfile_to_string; fchkfile_to_string; fcidump; fcidump; fcidump_from_file; fcidump_from_file; find_approximate_string_matches; find_approximate_string_matches; free_atom_volumes; free_atom_volumes; freq; freq; frequencies; frequencies; frequency; frequency; gdma; gdma; geometry; geometry; get_memory; get_memory; gradient; gradient; hessian; hessian; ipi_broker; ipi_broker; join_path; join_path; levenshtein; levenshtein; ManagedMethodError; mdi_run; mdi_run; message_box; message_box; MissingMethodError; molden; molden; molecule_get_attr; molecule_get_attr; molecule_set_attr; molecule_set_attr; oeprop; oeprop; opt; opt; OptimizationConvergenceError; optimize; optimize; optimize_geometric; optimize_geometric; ParsingError; PastureRequiredError; pcm_helper; pcm_helper; print_stderr; print_stderr; print_stdout; print_stdout; process_input; process_input; prop; prop; properties; properties; PsiException; PsiImportError; compare_vibinfos; compare_vibinfos; filter_nonvib; filter_nonvib; filter_omega_to_real; filter_omega_to_real; harmonic_analysis; harmonic_analysis; hessian_symmetrize; hessian_symmetrize; print_molden_vibs; print_molden_vibs; print_vibs; print_vibs; thermo; thermo; QMMM; sanitize_name; sanitize_name; scf_helper; scf_helper; scf_wavefunction_factory; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_memory; set_module_options; set_module_options; set_options; set_options; Table; tdscf; tdscf; TDSCFConvergenceError; temp_circular_import_blocker; temp_circular_import_blocker; TestComparisonError; UpgradeHelper; ValidationError; vibanal_wfn; vibanal_wfn; write_eigenvalues; write_eigenvalues.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:552552,Optimiz,OptimizationConvergenceError,552552,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,12,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimize']"
Performance,"s; object before the SCF code is told about its existence on the last line. The; calls to addCharge take the atomic charge, x coordinate, y coordinate, and; z coordinate in that order. The atomic charge is specified in atomic units,; and the coordinates always use the same units as the geometry specification in; the regular QM region. Additional MM molecules may be specified by adding; extra calls to addCharge to describe the full MM region. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2](1, 2) This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defined; according to the quantu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf.html:30916,optimiz,optimization,30916,psi4manual/1.0.0/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf.html,2,['optimiz'],['optimization']
Performance,"s['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); user_df_basis_scf = psi4.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = psi4.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = psi4.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = psi4.get_global_option('DF_BASIS_ELST'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). b_user_reference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERENCE'); user_memory = psi4.get_memory(). user_molecule = psi4.get_active_molecule(). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if re.mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:31036,load,loading,31036,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['load'],['loading']
Performance,"s['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; # print(""about to generate displacements""); displacements = core.fd_geoms_1_0(moleculeclone); # print(displacements); ndisp = len(displacements); # print(""generated displacments""). # This version is pretty dependent on the reference geometry being last (as it is now); print("""""" %d displacements needed ..."""""" % (ndisp), end=''); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if opt_mode == 'sow':; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; core.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:38983,optimiz,optimization,38983,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['optimiz'],['optimization']
Performance,"s[k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter; Maximum number of iterations towards omega convergence. Returns; -------; float; Optimal omega parameter. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'DFT_OMEGA'],; ['DOCC'],; ['SOCC']). kwargs = p4util.kwargs_lower(kwargs). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. if core.get_option('SCF', 'REFERENC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:14585,Optimiz,Optimize,14585,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,1,['Optimiz'],['Optimize']
Performance,"s_set(). Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/share/python/aliases.py; (source location) or psi4/share/psi/python/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). Table Of Contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Previous topic; RSE42; Next topic; <no title>. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:17060,optimiz,optimization,17060,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"s_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = { 'energy' : step_energies ,; 'gradient' : step_gradients ,; 'coordinates' : step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); if (core.get_option('OPTKING', 'KEEP_INTCOS') == Fals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:64570,optimiz,optimize,64570,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"s_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_wfn:; return (thisenergy, wfn); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displaceme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:62187,optimiz,optimize,62187,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"s_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; psi4.set_legacy_molecule(moleculeclone); optking_rval = psi4.optking(); moleculeclone = psi4.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == psi4.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if psi4.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); psi4.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if psi4.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if psi4.get_option('OPTKING', 'KEEP_INTCOS') == False:; psi4.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); psi4.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; psi4.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_wfn:; return (thisenergy, wfn); else:; return thisenergy. elif optking_rval == psi4.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); if (psi4.get_option('OPTKING', 'KEEP_INTCOS') == False):; psi4.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); psi4.clean(); optstash.restore(); return thisenergy. psi4.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displaceme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:60345,optimiz,optimize,60345,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimize']
Performance,"sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR)¶CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. CFOUR_GIAO (CFOUR)¶CFOUR — Specifies whether gauge-including atomic orbitals are used (ON) or not (OFF). Default: ON for CFOUR_PROPS =NMR and =MAGNETIC, otherwise OFF. Type: string; Possible Values: ON, OFF; Default: No Default. CFOUR_GRID (CFOUR)¶CFOUR — Keyword used to control type of grid calculation (see later section in this manual). Options are OFF (=0), no grid calculation; CARTESIAN (=1), steps are in Cartesian coordinates (which must be run with CFOUR_COORDINATES =CARTESIAN); INTERNAL (=2), steps are in Z-matrix internal coordinates; QUADRATURE (=3) steps are chosen for an integration based on Gauss-Hermite quadrature. (Default: OFF). Type: string; Possible Values: OFF, CARTESIAN, INTERNAL, QUADRATURE; Default: OFF. CFOUR_GUESS (CFOUR)¶CFOUR — Where the initial SCF eigenvectors are read from. MOREAD means to read from the disk (the JOBARC file",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:49465,optimiz,optimized,49465,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['optimiz'],['optimized']
Performance,"sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). if (core.get_option('SCF', 'REFERENCE') != 'RHF') and (name.upper() != ""SAPT0""):; raise ValidationError('Only SAPT0 supports a reference different from \""reference rhf\"".'). do_delta_mp2 = True if name.endswith('dmp2') else False. # raise Exception(""""). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs). # Delta MP2; if do_delta_mp2:; select_mp2(name, ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable('SAPT MP2 CORRELATION ENERGY', mp2_corl_i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:100492,LOAD,LOAD,100492,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['LOAD'],['LOAD']
Performance,"save AO OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. CIS_TOPDM_STATES (CPHF); CPHF — Which states to save AO transition OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. COLLAPSE_SIZE (DETCI); DETCI — Gives the number of vectors to retain when the Davidson subspace is collapsed (see MAX_NUM_VECS). If greater than one, the collapsed subspace retains the best estimate of the CI vector for the previous n iterations. Defaults to 1. Type: integer; Default: 1. COLLAPSE_WITH_LAST (CCEOM); CCEOM — Do ?. Type: boolean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM —. Type: conv double; Default: 1e-12. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_REFERENCE (PSIMRCC); PSIMRCC — Reference wavefunction type used in MRCC computations. Type: string; Possible Values: RHF, ROHF, TCSCF, MCSCF, GENERAL; Default: GENERAL. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC); PSIMRCC — Do include the terms that couple the reference determinants?. Type: boolean; Default: true. COVALENT_CONNECT (OPT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:13531,perform,perform,13531,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"save configuration settings for a future compilation; What is the directory layout of the installed or staged Psi4; How to run Psi4 as executable after compilation; How to solve ModuleNotFoundError: No module named 'psi4'; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to get a Psi4 logo file; How to use a local Add-On repository in the Psi4 build. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Installation and Runtime Configuration. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:57064,queue,queue,57064,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['queue'],['queue']
Performance,"scale(Factor=627.5095)[source]¶; Function to apply a scaling factor Factor to the; data of the Table object. banner(text, type=1, width=35)[source]¶; Function to print text to output file in a banner of; minimum width width and minimum three-line height for; type = 1 or one-line height for type = 2. print_stderr(stuff)[source]¶; Function to print stuff to standard error stream. print_stdout(stuff)[source]¶; Function to print stuff to standard output stream. Module with utility functions for use in input files. compare_integers(expected, computed, label)[source]¶; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_strings(expected, computed, label)[source]¶; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. compare_values(expected, computed, digits, label)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits.; Performs a system exit on failure. Used in input files in the test suite. compare_vectors(expected, computed, digits, label)[source]¶; Function to compare two vectors. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. copy_file_from_scratch(filename, prefix, namespace, unit, move=False)[source]¶; Fu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:34912,Perform,Performs,34912,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['Perform'],['Performs']
Performance,"scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. mom-h2o-4; MOM excitation from LUMO HOMO+4. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. mp2-1; All-electron MP2 6-31G** geometry optimization of water. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. freq-masses; check nonphysical masses possible. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. scf6; Tests RHF/ROHF/UHF SCF gradients. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. scf1; RHF cc-pVQZ energy fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:5445,perform,performs,5445,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1469,optimiz,optimization,1469,psi4manual/1.1.0/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html,8,['optimiz'],['optimization']
Performance,"scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important \(t_1\) and \(t_2\) amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with PSI4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user should not specify the entire; physical memory of the system, or swapping is likely. However, for especially large; calculations, it is better to set the memory keyword to a value less than 16 GB.; Set the CACHELEVEL keyword to 0.; This will turn off cacheing, which, for very large calculations, can; lead to heap fragmentation and memory faults, even when sufficient; physical memory exists.; Set the PRINT keyword to 2. This; will help narrow where memory bottlenecks or other errors exist in the; event of a crash. Excited State Coupled Cluster Calculations¶; A complete list of keywords related to; coupled cluster linear response is provided in Appendix CCEOM.; The most important keywords associated with EOM-CC calculations are:. ROOTS_PER_IRREP¶. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. SINGLES_PRINT¶. Do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cc.html:9311,CACHE,CACHELEVEL,9311,psi4manual/master/cc.html,https://psicode.org,https://psicode.org/psi4manual/master/cc.html,15,['CACHE'],['CACHELEVEL']
Performance,"script, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); The and terms take into; account higher-order induction effects and are included in the definition; of SAPT terms. They are computed from the Hartree-Fock supermolecular interaction energy; and are only available in dimer-centered basis SAPT; computations, which is the default (see below for monomer-centered basis; computations). They are defined by:. (6). (7); Additionally, high-order coupling between induction and dispersion can be; extracted from the supermolecular MP2 interaction energy:. where is the correlation part of the supermolecular MP2; interaction energy. and also improve the; description of electrostatically dominated complexes. ; can be applied to SAPT2+ or SAPT2+(3) energies whereas ; should be applied to SAPT2+3 energies.; A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs],; and a systematic study of the accuracy of these truncations (with and; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in Psi4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. The S2 approximation and scaling¶; All exchange terms in SAPT arise from the antisymmetrization; of the wavefunctions of monomers A and B. Taking into account exchange of all possible; electron pairs between the two monomers yields to complicated formulae.; For this reason, exchange terms are often evaluated in the ; approximation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:3459,perform,performance,3459,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['performance']
Performance,"sd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:68941,perform,perform,68941,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"sd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. gdma1; Water RHF/cc-pVTZ distributed multipole analysis. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:23202,optimiz,optimization,23202,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"se ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:6719,Queue,Queue,6719,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,2,['Queue'],['Queue']
Performance,"se ValueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:58144,optimiz,optimizer,58144,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimizer']
Performance,"se calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/kw-1; testing best practices options, part i. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/kw-2; testing best practices options, part ii. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs; CFOUR. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html:4503,optimiz,optimization,4503,psi4manual/1.6.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html,3,['optimiz'],['optimization']
Performance,"se can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:2169,optimiz,optimization,2169,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,2,['optimiz'],['optimization']
Performance,"se that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the Psi4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to Psi4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in Psi4; Next topic; Best Practices for Python Functions. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Contributions: Intro to Programming in Psi4 ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:7870,load,loaded,7870,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['load'],['loaded']
Performance,"se. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. INTS_TOLERANCE¶. Screening threshold for the chosen screening method (SCHWARZ, CSAM, DENSITY) Absolute value below which TEI are neglected. Type: conv double; Default: 1e-12. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ORBITALS_WRITE¶. File name (case sensitive) to which to serialize Wavefunction orbital data. Type: string; Default: No Default. PRINT_BASIS¶. Do print the basis set?. Type: boolean; Default: false. PRINT_MOS¶. Do print the molecular orbitals?. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAPGAU_BASIS¶. The potential basis set used for the SAPGAU guess. Type: string; Default: sap_helfem_large. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. S_CHOLESKY_TOLERANCE¶. Tolerance for partial Cholesky decomposition of overlap matrix. Type: conv double; Default: 1e-8. S_ORTHOGONALIZATION¶. SO orthogonalization: automatic, symmetric, or canonical?. Type: string; Possible Values: AUTO, SYMMETRIC, CANONICAL, PARTIALCHOLESKY; Default: AUTO. S_TOLERANCE¶. Minimum S matrix eigenvalue to al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__scf.html:2328,perform,perform,2328,psi4manual/1.8.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__scf.html,3,['perform'],['perform']
Performance,"se. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. INTS_TOLERANCE¶. Screening threshold for the chosen screening method (SCHWARZ, CSAM, DENSITY) Absolute value below which TEI are neglected. Type: conv double; Default: 1e-12. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ORBITALS_WRITE¶. File name (case sensitive) to which to serialize Wavefunction orbital data. Type: string; Default: No Default. PRINT_BASIS¶. Do print the basis set?. Type: boolean; Default: false. PRINT_MOS¶. Do print the molecular orbitals?. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. S_CHOLESKY_TOLERANCE¶. Tolerance for partial Cholesky decomposition of overlap matrix. Type: conv double; Default: 1e-8. S_ORTHOGONALIZATION¶. SO orthogonalization: automatic, symmetric, or canonical?. Type: string; Possible Values: AUTO, SYMMETRIC, CANONICAL, PARTIALCHOLESKY; Default: AUTO. S_TOLERANCE¶. Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. Convergence Control/Stabiliza",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__scf-1.html:2501,perform,perform,2501,psi4manual/1.5.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__scf-1.html,4,['perform'],['perform']
Performance,"second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. LOCAL_WEAKP (CCLAMBDA); CCLAMBDA — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique available option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE); CCRESPONSE — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique available option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS); GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_ATTEMPTS (SCF); SCF (Expert) — When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. MAX_CCD_DIISVECS (SAPT); SAPT — Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MAX_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:153796,perform,performed,153796,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['perform'],['performed']
Performance,"sed down to one vector per root. Type: boolean; Default: false. RESTART_EOM_CC3 (CCEOM); CCEOM — Do ?. Type: boolean; Default: false. RESTRICTED_DOCC (DETCI); DETCI — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_DOCC (PSIMRCC); PSIMRCC — The number of doubly occupied orbitals per irrep. Type: array; Default: No Default. RESTRICTED_DOCC (TRANSQT); TRANSQT — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (DETCI); DETCI — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (TRANSQT); TRANSQT — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RFO_FOLLOW_ROOT (OPTKING); OPTKING — Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_ROOT (OPTKING); OPTKING — Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RHF_TRIPLETS (CCEOM); CCEOM — Do ?. Type: boolean; Default: false. RMS_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. RMS_FORCE_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: rms force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. RMS_MOGRAD_CONVERGENCE (OMP2); OMP2 —. Type: conv double; Default: 1e-5. ROOTS_PER_IRREP (ADC); ADC — The poles per irrep vector. Type: array; Default: No Default. ROOTS_PER_IRREP (CCDENSITY); CCDENSITY — The ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:84424,optimiz,optimized,84424,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,"sed for this keyword is identical to that used in CFOUR_OCCUPATION For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. CFOUR_ESTATE_TRANS¶. Specifies whether just the excitation energies (OFF, =0) or in addition transition moments (EXPECTATION, =1) are calculated. Note that this keyword should not be used in excited-state calculations involving analytic gradients and that transition moments are essentially only available for EOM-CCSD/CCSD-LR. Type: string; Possible Values: OFF, EXPECTATION; Default: OFF. CFOUR_EVAL_HESS¶. Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. CFOUR_EXCITATION¶. Specifies in CC calculations using mrcc the excitation level if the calculation level has been chosen as CC(n), CI(n), or CCn(n). Type: integer; Default: 0. CFOUR_EXCITE¶. Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. CFOUR_FC_FIELD¶. Specifies the strength of a Fermi-Contact perturbation as required for f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cfour-1.html:21562,optimiz,optimization,21562,psi4manual/1.2.1/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cfour-1.html,13,['optimiz'],['optimization']
Performance,"sed to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL (CFOUR)¶CFOUR — Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead. Type: string; Possible Values: ABORT, SWITCH, RFA; Default: ABORT. CFOUR_NEWNORM (CFOUR)¶CFOUR — All components of spherical AO’s are normalized to 1. This feature can help with numerical convergence issues if AO integrals are involved. Currently only working for single-point energy calculations. Type: boolean; Default: false. CFOUR_NONHF (CFOUR)¶CFOUR — Specifies whether the reference function used in the correlation energy calculation satisfies the (spin-orbital) HF equations or not. Usually there is no need to set this parameter (OFF = 0 and ON =1), since standard non-HF reference functions (QRHF and ROHF) set this flag automatically. Type: boolean; Default: false. CFOUR_NTOP_TAMP (CFOUR)¶CFOUR — Specifies how many t amplitudes will be printed for each spin case and excitation level. For =N, The largest N amplitudes for each spin case and excitation level will be printed. Type: integer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:58013,optimiz,optimizations,58013,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,18,['optimiz'],"['optimizations', 'optimizer']"
Performance,"sed until all the fragments are connected (directly or indirectly). Type: double; Default: 1.8. INTERFRAG_DIST_INV¶. Do use for the stretching coordinate between fragments? Otherwise, use . Type: boolean; Default: false. INTERFRAG_HESS¶. Model Hessian to guess interfragment force constants. Type: string; Possible Values: DEFAULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE¶. When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, INTERFRAGMENT; Default: FIXED. Misc.¶. FINAL_GEOM_WRITE¶. Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. INTCO_FIXED_EQ_FORCE_CONSTANT¶. In constrained optimizations, for internal coordinates with user-specified equilibrium values, this is the force constant (in au) used to apply an additional force to each coordinate. If the user is only concerned to satify the desired constraint, then the user need only ensure that this value is sufficiently large. Alternatively, the user may specify this value to apply a force of a particular magnitude, in which case the given equilibrium value may or may not be reached by the optimization. Type: double; Default: 2.0. KEEP_INTCOS¶. Keep internal coordinate definition file. Type: boolean; Default: false. LINESEARCH_STATIC_MAX¶. If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.100. LINESEARCH_STATIC_MIN¶. If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.001. LINESEARCH_STATIC_N¶. If doing a static line search, scan this many points. Type: integer; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__optking-1.html:6885,optimiz,optimizations,6885,psi4manual/4.0b4/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__optking-1.html,2,['optimiz'],['optimizations']
Performance,"sed; by Ochsenfeld in [Laqua:2020:1456], improves efficiency of the K construction process by; decomposing computation of the ERI tensor into a series of contractions involving grid-computed basis; function components and analytic 3-center integrals. As a “semi-numerical” Exchange construction method,; sn-LinK is also comparable to the pseudospectral method of Friesner.; sn-LinK and COSX have a number of significant differences in implementation details in PSI4, however.; First and foremost, the COSX implementation is contained within PSI4 itself, and is thus always available; for execution. On the other hand, the sn-LinK implementation in PSI4 is tied to the GauXC standalone; library discussed in [Williams-Young:2023:234104]; thus, the PSI4-GauXC interface must be built; for sn-LinK to be used. Second, the GauXC sn-LinK interface is more; efficient than the PSI4 COSX code on multiple levels. For CPU execution, GauXC’s sn-LinK uses highly-optimized; kernels for the contraction of the analytic integrals, whereas PSI4’s COSX uses a less-optimized, more; general contraction kernel. Additionally, GauXC’s sn-LinK code supports execution on GPUs, allowing for; GPU-enabled construction of the Exchange matrix, while PSI4’s COSX does not. In general,; sn-LinK will provide better runtime performance for hitting a desired accuracy; threshold compared to PSI4’s COSX. Third, some low-level implementation details differ between the two.; For example, PSI4’s COSX uses a dual-grid scheme similar to that originally proposed by Neese,; converging the SCF on a small grid, then running a number of SCF iterations,; equal to the value set by the COSX_MAXITER_FINAL, on a larger grid.; In contrast, sn-LinK only uses a single-grid scheme, simply converging the SCF on one grid.; As another example, while the COSX grid defaults are selected to emphasize speed over accuracy,; the defaults for sn-LinK are selected to achieve higher accuracy (~0.1 kcal/mol error for interaction/conformer energie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:41642,optimiz,optimized,41642,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,2,['optimiz'],['optimized']
Performance,"select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Consid",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:13138,perform,performance,13138,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"self.nfragments() != 1:; print 'Molecule already fragmented so no further action by auto_fragments().'; return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; #'H': 1.001 / 1.5, # JMol; 'HE': 1.012 / 1.5, # JMol; 'LI': 0.825 / 1.5, # JMol; 'BE': 1.408 / 1.5, # JMol; #'B': 1.485 / 1.5, # JMol; #'C': 1.452 / 1.5, # JMol; #'N': 1.397 / 1.5, # JMol; #'O': 1.342 / 1.5, # JMol; #'F': 1.287 / 1.5, # JMol; 'NE': 1.243 / 1.5, # JMol; 'NA': 1.144 / 1.5, # JMol; 'MG': 1.364 / 1.5, # JMol; 'AL': 1.639 / 1.5, # JMol; #'SI': 1.716 / 1.5, # JMol; #'P': 1.705 / 1.5, # JMol; #'S': 1.683 / 1.5, # JMol; #'CL': 1.639 / 1.5, # JMol; 'AR': 1.595 / 1.5, # JMol. 'H': 1.06 / 1.5, # Bondi JPC 68 441 (1964); 'B': 1.65 / 1.5, # Bondi JPC 68 441 (1964); 'C': 1.53 / 1.5, # Bondi JPC 68 441 (1964); 'N': 1.46 / 1.5, # Bondi JPC 68 441 (1964); 'O': 1.42 / 1.5, # Bondi JPC 68 441 (1964); 'F': 1.40 / 1.5, # Bondi JPC 68 441 (1964); 'SI': 1.93 / 1.5, #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:10052,Perform,Perform,10052,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Perform'],['Perform']
Performance,"self.nfragments() != 1:; print 'Molecule already fragmented so no further action by auto_fragments().'; return self. flist = self.BFS(). # form new molecule through a string since self may contain; # dummies or zmatrix specs that mayn't be valid with atom shuffling; new_geom = '\n'. if self.PYcharge_specified or self.PYmultiplicity_specified:; new_geom = """"""\n %d %d\n"""""" % (self.molecular_charge(), self.multiplicity()). for fr in range(len(flist)):; new_geom += """" if fr == 0 else "" --\n""; for at in flist[fr]:; geom = self.atoms[at].compute(); new_geom += """"""%-4s """""" % (("""" if self.Z(at) else ""@"") + self.symbol(at)); for j in range(3):; new_geom += """""" %17.12f"""""" % (geom[j]); new_geom += ""\n""; new_geom += "" units %s\n"" % (self.units()); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) >",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:6093,Perform,Perform,6093,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,2,['Perform'],['Perform']
Performance,"self.trove:; if ((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. def get_results(self, client: Optional[""FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta * 2 + 1; qcvars[f""CBS {self.cbsrec[dc]['d_stage'].upper()} TOTAL ENERGY""] = self.cbsrec[dc][""d_energy""] - self.cbsrec[dc + 1][""d_energy""]. G0 = assembled_results[""gradient""]; if np.count_nonzero(G0):; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessian""]; if np.count_nonzero(H0):; qcvars[""CURRENT HESSIAN""] = H0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:58381,load,load,58381,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['load'],['load']
Performance,"self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None¶; Print the matrix with atom labels, assuming it is an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:105704,Load,Loads,105704,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['Load'],['Loads']
Performance,"self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:11181,Load,Loads,11181,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['Load'],['Loads']
Performance,"self: psi4.core.OrbitalSpace) → psi4.core.Vector¶; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace) → str¶; Unique identifier. integral(self: psi4.core.OrbitalSpace) → psi4.core.IntegralFactory¶; The integral factory used to create C. name(self: psi4.core.OrbitalSpace) → str¶; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace) → int¶; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace) → None¶; Print information about the orbital space to the output file. class psi4.core.OverlapInt¶; Bases: psi4.core.OneBodyAOInt; Computes overlap integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.PMLocalizer¶; Bases: psi4.core.Localizer; Performs Pipek-Mezey orbital localization. L¶; Localized orbital coefficients. U¶; Orbital rotation matrix. build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix) → psi4.core.Localizer¶; Build the localization scheme. converged¶; Did the localization procedure converge?. localize(self: psi4.core.Localizer) → None¶; Perform the localization procedure. class psi4.core.PetiteList¶; Bases: pybind11_builtins.pybind11_object; Handles symmetry transformations. aotoso(self: psi4.core.PetiteList) → psi4.core.Matrix¶; Return the AO->SO coefficient matrix. print(self: psi4.core.PetiteList, arg0: str) → None¶; Print to outfile. sotoao(self: psi4.core.PetiteList) → psi4.core.Matrix¶; Return the SO->AO coefficient matrix. class psi4.core.PointFunctions¶; Bases: psi4.core.BasisFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::Bl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:155197,Perform,Performs,155197,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,['Perform'],['Performs']
Performance,"serial()¶; Converts serialized data to the correct Psi4 data type. Parameters:. self – Pointer to which class to be constructed.; json_data (Dict[str, Any]) – Serialization of class. See to_serial() for data layout. Return type:; Union[Matrix, Vector]. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice) → psi4.core.Vector¶; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension) → None¶; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Load the vector from disk. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Save the vector to disk. scale(self: psi4.core.Vector, sc: flo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Vector.html:5411,load,load,5411,psi4manual/master/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Vector.html,1,['load'],['load']
Performance,"ses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_METHOD (DFOCC)¶DFOCC — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC)¶OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. OPT_TYPE (OPTKING)¶OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC)¶DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC)¶OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (DFOCC)¶DFOCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORB_RESP_SOLVER (OCC)¶OCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:183124,optimiz,optimize,183124,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['optimiz'],['optimize']
Performance,"ses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals we can simply use “reference rohf” option. For DFT orbitals one should use “reference uks” and “dft_functional b3lyp” options. Of; course users can use any DFT functional available in Psi4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; Psi4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through ‘type select’ values; see rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. omp2.5; Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. olccd; Orbital-Optimized Linear CCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE CONV. Density-Fitted Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE DF. Cholesky-Decomposed Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; —; CC_TYPE CD. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:6858,Optimiz,Optimized,6858,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['Optimiz'],['Optimized']
Performance,"ses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/detci-1.html:10413,optimiz,optimized,10413,psi4manual/4.0b3/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/detci-1.html,6,['optimiz'],['optimized']
Performance,"ses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/detci-1.html:10390,optimiz,optimized,10390,psi4manual/4.0b2/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/detci-1.html,2,['optimiz'],['optimized']
Performance,"ses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/detci.html:14617,optimiz,optimized,14617,psi4manual/master/detci.html,https://psicode.org,https://psicode.org/psi4manual/master/detci.html,15,['optimiz'],['optimized']
Performance,"ses the Wigner (2n+1) rule by default; (MPN_WIGNER = TRUE); and figures out what order of wavefunction is; necessary to reach the desired order in the energy. The program then; sets MAX_NUM_VECS to the required order in the; wavefunction.; By default, the requested n-th order energy is saved as the current; energy to the process environment. ZAPTN works essentially the same; way for an ROHF reference. Arbitrary Order Coupled-Cluster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which Psi4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:10900,optimiz,optimized,10900,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,2,['optimiz'],['optimized']
Performance,"set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The various orbital-optimized methods supported by the OCC/DFOCC; modules in PSI4 are summarized in Table OCC OO; Methods and detailed in Table OCC; OO Capabilities. Note that while two; separate libraries OCC (conventional integrals CONV) and DFOCC; (density-fitted DF and Cholesky-decomposed CD) together provide; the methods described on this page, they are controlled through one; QC_MODULE value OCC. Without set qc_module occ,; these methods may default to implementations in other modules based on efficiency considerations. Orbital-optimized theoretical methods accessible through OCC/DFOCC¶. name; calls method; OO. omp2; orbital-optimized second-order MP perturbation theory; E/G. omp2.5; orbital-optimized average of MP2 and MP3; E/G. omp3; orbital-optimized third-order MP perturbation theory; E/G. oremp2; orbital-optimized second-order REMP hybrid PT; E/G. olccd; orbital-optimized linear coupled cluster doubles; E/G. Detailed orbital-optimized capabilities of the OCC module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[1] ↓ →; FREEZE_CORE[2]→. QC_MODULE=OCC Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. omp2[4]; MP2_TYPE; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. omp2.5[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. omp3[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:10612,optimiz,optimized,10612,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['optimiz'],['optimized']
Performance,"set to CEPA0 (coupled electron; pair approximation zero, equivalent to linearized coupled cluster doubles; method, LCCD). CEPA0 can be considered as a particular case of the DC-06 and DC-12; methods in the limit of zero non-idempotency of . This option has a limited; functionality and should only be used for test purposes. For the production-level CEPA0 code, see the; description of the OCC section of the manual. The DCFT code can also be used to; compute the energy correction that perturbatively accounts; for three-particle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computation of the correction can be; requested by setting the THREE_PARTICLE option to PERTURBATIVE. A; combination of the ODC-13 functional with the correction; [denoted as ] has been shown to provide highly; accurate results for open-shell molecules near equilibrium geometries.; At the present moment, all of the DCFT methods support unrestricted reference; orbitals (REFERENCE = UHF), which can be used to perform energy and; gradient computations for both closed- and open-shell molecules. In addition,; the ODC-06 and ODC-12 methods support restricted reference orbitals; (REFERENCE = RHF) for the energy and gradient computations of; closed-shell molecules. Note that in this case restricted reference orbitals; are only available for ALGORITHM = SIMULTANEOUS. Iterative Algorithms¶; As explained in the Theory section, in order to obtain the DCFT energy one; needs to solve a system of coupled equations for orbitals and density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option.; 1) Simultaneous algorithm (ALGORITHM = SIMULTANEOUS, currently the default).; In this algorithm the DCFT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:6802,perform,perform,6802,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['perform'],['perform']
Performance,"set to TRUE, and HD_AVG must be set to orb_ener; these should happen by default for MPN = TRUE. Type: boolean; Default: false. MPN_ORDER_SAVE (DETCI); DETCI (Expert) — If 0, save the MPn energy; if 1, save the MP(2n-1) energy (if available from MPN_WIGNER = true); if 2, save the MP(2n-2) energy (if available from MPN_WIGNER = true). Type: integer; Default: 0. MPN_SCHMIDT (DETCI); DETCI (Expert) — Do employ an orthonormal vector space rather than storing the kth order wavefunction?. Type: boolean; Default: false. MPN_WIGNER (DETCI); DETCI (Expert) — Do use Wigner formulas in the series?. Type: boolean; Default: true. MRCC_LEVEL (MRCC); MRCC — Maximum excitation level. This is used ONLY if it is explicity set by the user. Single-reference case: all excitations up to this level are included, e.g., 2 for CCSD, 3 for CCSDT, 4 for CCSDTQ, etc. This becomes ex.lev (option #1) in fort.56. Type: integer; Default: 2. MRCC_METHOD (MRCC); MRCC (Expert) — If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56 .. table:: MRCC methods +——-+————–+————————————————————-+ + Value + Method + Description + +=======+==============+=============================================================+ + 1 + CC + + +——-+————–+————————————————————-+ + 2 + CC(n-1)[n] + + +——-+————–+————————————————————-+ + 3 + CC(n-1)(n) + (CC(n-1)[n] energy is also calculated) + +——-+————–+————————————————————-+ + 4 + CC(n-1)(n)_L + (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) + +——-+————–+————————————————————-+ + 5 + CC(n)-1a + + +——-+————–+————————————————————-+ + 6 + CC(n)-1b + + +——-+————–+————————————————————-+ + 7 + CCn + + +——-+————–+————————————————————-+ + 8 + CC(n)-3 + + +——-+————–+————————————————————-+. Type: integer; Default: 1. MRCC_NUM_DOUBLET_ROOTS (MRCC); MRCC — Number of root in case of open",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:81483,perform,performed,81483,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"set to TRUE, and HD_AVG must be set to orb_ener; these should happen by default for MPN = TRUE. Type: boolean; Default: false. MPN_ORDER_SAVE (DETCI); DETCI (Expert) — If 0, save the MPn energy; if 1, save the MP(2n-1) energy (if available from MPN_WIGNER = true); if 2, save the MP(2n-2) energy (if available from MPN_WIGNER = true). Type: integer; Default: 0. MPN_SCHMIDT (DETCI); DETCI (Expert) — Do employ an orthonormal vector space rather than storing the kth order wavefunction?. Type: boolean; Default: false. MPN_WIGNER (DETCI); DETCI (Expert) — Do use Wigner formulas in the series?. Type: boolean; Default: true. MRCC_LEVEL (MRCC); MRCC — Maximum excitation level. This is used ONLY if it is explicity set by the user. Single-reference case: all excitations up to this level are included, e.g., 2 for CCSD, 3 for CCSDT, 4 for CCSDTQ, etc. This becomes ex.lev (option #1) in fort.56. Type: integer; Default: 2. MRCC_METHOD (MRCC); MRCC (Expert) — If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56 .. table:: MRCC methods +——-+————–+————————————————————-+ + Value + Method + Description + +=======+==============+=============================================================+ + 1 + CC + + +——-+————–+————————————————————-+ + 2 + CC(n-1)[n] + + +——-+————–+————————————————————-+ + 3 + CC(n-1)(n) + (CC(n-1)[n] energy is also calculated) + +——-+————–+————————————————————-+ + 4 + CC(n-1)(n)_L + (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) + +——-+————–+————————————————————-+ + 5 + CC(n)-1a + + +——-+————–+————————————————————-+ + 6 + CC(n)-1b + + +——-+————–+————————————————————-+ + 7 + CCn + + +——-+————–+————————————————————-+ + 8 + CC(n)-3 + + +——-+————–+————————————————————-+. Type: integer; Default: 1. MRCC_NUM_SINGLET_ROOTS (MRCC); MRCC — Number of singlet roots. (Stri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:82884,perform,performed,82884,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"set to TRUE, and HD_AVG must be set to orb_ener; these should happen by default for MPN = TRUE. Type: boolean; Default: false. MPN_ORDER_SAVE (DETCI); DETCI (Expert) — If 0, save the MPn energy; if 1, save the MP(2n-1) energy (if available from MPN_WIGNER = true); if 2, save the MP(2n-2) energy (if available from MPN_WIGNER = true). Type: integer; Default: 0. MPN_SCHMIDT (DETCI); DETCI (Expert) — Do employ an orthonormal vector space rather than storing the kth order wavefunction?. Type: boolean; Default: false. MPN_WIGNER (DETCI); DETCI (Expert) — Do use Wigner formulas in the series?. Type: boolean; Default: true. MRCC_LEVEL (MRCC); MRCC — Maximum excitation level. This is used ONLY if it is explicity set by the user. Single-reference case: all excitations up to this level are included, e.g., 2 for CCSD, 3 for CCSDT, 4 for CCSDTQ, etc. This becomes ex.lev (option #1) in fort.56. Type: integer; Default: 2. MRCC_METHOD (MRCC); MRCC (Expert) — If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56 | begin{tabular}{ccc} | Value & Method & Description \ | hline | 1 & CC & \ | 2 & CC(n-1)[n] & \ | 3 & CC(n-1)(n) & (CC(n-1)[n] energy is also calculated) \ | 4 & CC(n-1)(n)_L & (CC(n-1)[n] and CC(n-1)(n) energies are also calculated) \ | 5 & CC(n)-1a & \ | 6 & CC(n)-1b & \ | 7 & CCn & \ | 8 & CC(n)-3 & \ | end{tabular}. Type: integer; Default: 1. MRCC_NUM_SINGLET_ROOTS (MRCC); MRCC — Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC); MRCC — Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SIN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:62267,perform,performed,62267,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,4,['perform'],['performed']
Performance,"set to TRUE, and HD_AVG must be set to orb_ener; these should happen by default for MPN = TRUE. Type: boolean; Default: false. MPN_ORDER_SAVE (DETCI); DETCI (Expert) — If 0, save the MPn energy; if 1, save the MP(2n-1) energy (if available from MPN_WIGNER = true); if 2, save the MP(2n-2) energy (if available from MPN_WIGNER = true). Type: integer; Default: 0. MPN_SCHMIDT (DETCI); DETCI (Expert) — Do employ an orthonormal vector space rather than storing the kth order wavefunction?. Type: boolean; Default: false. MPN_WIGNER (DETCI); DETCI (Expert) — Do use Wigner formulas in the series?. Type: boolean; Default: true. MRCC_LEVEL (MRCC); MRCC — Maximum excitation level. This is used ONLY if it is explicity set by the user. Single-reference case: all excitations up to this level are included, e.g., 2 for CCSD, 3 for CCSDT, 4 for CCSDTQ, etc. This becomes ex.lev (option #1) in fort.56. Type: integer; Default: 2. MRCC_METHOD (MRCC); MRCC (Expert) — If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_NUM_DOUBLET_ROOTS (MRCC); MRCC — Number of root in case of open shell system. This becomes ndoub (option #13) int fort.56. Type: integer; Default: 0. MRCC_NUM_SINGLET_ROOTS (MRCC); MRCC — Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS (MRCC); MRCC — Number of triplet roots. (Strictly speaking number of of roots with and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS. This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. MRCC_OMP_NUM_THREADS (MRCC); MRCC (Expert) — Sets ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:166766,perform,performed,166766,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"set_global_option('CART_HESS_READ', True); elif ((full_hess_every == -1) and (psi4.get_global_option('CART_HESS_READ')) and (n == 1)):; pass; # Do nothing; user said to read existing hessian once; else:; psi4.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # print 'cart_hess_read', psi4.get_global_option('CART_HESS_READ'); # Take step; if psi4.optking() == psi4.PsiReturnType.EndLoop:; print('Optimizer: Optimization complete!'); psi4.print_out('\n Final optimized geometry and variables:\n'); psi4.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (psi4.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False):; psi4.opt_clean(); psi4.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(). optstash.restore(); return thisenergy; psi4.print_out('\n Structure for next step:\n'); psi4.get_active_molecule().print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = p4util.get_psifile(1); kwargs['mode'] = 'sow'. n += 1. psi4.print_out('\tOptimizer: Did not converge!'). optstash.restore(); return 0.0. ## Aliases ##; opt = optimize. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """"""; namelower = name.lower(). # matches 'mrccsdt(q)'; if namelower.startswith('mrcc'):; # grabs 'sdt(q)'; ccfullname = namelower[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method' : 1, 'order' : 2, 'fullname' : 'CCSD' },; 'sdt' : { 'method' : 1, 'order' : 3, 'fullname' : 'CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:54055,Optimiz,Optimization,54055,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Optimiz'],['Optimization']
Performance,"set_title(kwargs['title']); for prop in args:; oe.add(prop); oe.compute(). [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; psi4.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return psi4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html:2172,Perform,Performs,2172,psi4manual/4.0b5/_modules/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/util.html,1,['Perform'],['Performs']
Performance,set_units() psi4.core.Molecule method. set_variable() in module psi4.core. psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.Molecule method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. set_vector_size() psi4.core.DIISManager method. set_vv10_b() psi4.core.SuperFunctional method. set_vv10_c() psi4.core.SuperFunctional method. set_wcombine() psi4.core.DirectJK method. psi4.core.JK method. psi4.core.MemDFJK method. set_write_dpd_so_tpdm() psi4.core.IntegralTransform method. set_x_alpha() psi4.core.SuperFunctional method. set_x_beta() psi4.core.SuperFunctional method. set_x_omega() psi4.core.SuperFunctional method. setName() psi4.core.ExternalPotential method. setting. ; keywords anharmonicity(). keywords cbs(). keywords cp. keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords properties(). keywords vmfc. SF_RESTRICT (DETCI). shallow_copy() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. shape psi4.core.Matrix attribute. psi4.core.Vector attribute. shared_object() psi4.core.IO static method. psi4.core.IOManager static method. shell() psi4.core.BasisSet method. shell_extents() psi4.core.BasisExtents method. shell_on_center() psi4.core.BasisSet method. shell_significant() psi4.core.ERI method. psi4.core.ERISieve method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. shell_to_ao_function() psi4.core.BasisSet method. shell_to_basis_function() psi4.core.BasisSet method. shell_to_center() psi4.core.BasisSet method. ShellInfo class in psi4.core. shells_iterator() psi4.core.IntegralFactory method. shells_local_to_global() psi4.core.Block,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:137232,optimiz,optimize,137232,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['optimiz'],['optimize']
Performance,"setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. kinetic_grad() psi4.core.MintsHelper method, [1], [2]. KineticInt class in psi4.core, [1]. L. L psi4.core.BoysLocalizer attribute, [1]. psi4.core.Localizer attribute, [1], [2]. psi4.core.PMLocalizer attribute, [1]. label() psi4.core.Molecule method, [1], [2]. psi4.core.MOSpace method, [1], [2]. LaplaceDenominator class in psi4.core, [1]. LCC2(+LMP2)TOTALENERGY. LCCSD. LCCSD(+LMP2)TOTALENERGY. legacy_wavefunction() in module psi4.core, [1]. LEVEL_SHIFT (DFOCC). (MCSCF). (OCC). levenshtein() in module psi4.driver. LIBEFP. libfock() in module psi4.core, [1]. Libint. Libxc. LibXCFunctional class in psi4.core, [1]. license. LINEAR (CCRESPONSE). LINEQ_SOLVER (DFOCC). (OCC). LINESEARCH_STATIC_MAX (OPTKING). LINESEARCH_STATIC_MIN (OPTKING). LINESEARCH_STATIC_N (OPTKING). LITERAL_CFOUR (GLOBALS). load() psi4.core.Matrix method, [1], [2]. load_mpqc() psi4.core.Matrix method, [1], [2]. LOCAL (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_CONVERGENCE (FISAPT). (SCF). LOCAL_CPHF_CUTOFF (CCENERGY). (CCLAMBDA). (CCRESPONSE). LOCAL_CUTOFF (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_DO_SINGLES (CCEOM). LOCAL_FILTER_SINGLES (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_GHOST (CCEOM). LOCAL_IBO_CONDITION (FISAPT). LOCAL_IBO_POWER (FISAPT). LOCAL_IBO_STARS (FISAPT). LOCAL_IBO_STARS_COMPLETENESS (FISAPT). LOCAL_IBO_USE_STARS (FISAPT). LOCAL_MAXITER (FISAPT). (SCF). LOCAL_METHOD (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_PAIRDEF (CCENERGY). (CCLAMBDA). (CCRESPONSE). LOCAL_PRECONDITIONER (CCEOM). LOCAL_USE_GHOSTS (FISAPT). LOCAL_WEAKP (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). localize() psi4.core.BoysLocalizer method, [1]. psi4.core.Localizer method, [1], [2]. psi4.core.PMLocalizer method, [1]. Localizer class in psi4.core, [1]. LOCK_SINGLET (PSIMRCC). LowerTriangle psi4.c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:71313,load,load,71313,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['load'],['load']
Performance,"sformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the cumulant will be solved using a standard Jacobi update.; If requested by the user (set QC_COUPLING to TRUE), the electronic Hessian can include; matrix elements that couple the orbitals and the density cumulant.; The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below \(10^{-7}\). The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensive \({\cal O}(N^5)\) integral transformations, the simultaneous; algorithm benefits from a smaller number of expensive \({\cal O}(N^6)\); cumulant updates. As a result, for small closed-shell systems the two-step; algorithm is usually preferred, while for larger systems and molecules with; open-shell character it is recommended to use the simultaneous algorithm.; Efficiency of the simultaneous algorithm can be greatly increased by avoiding; the transformation of the four-index virtual two-electron integrals; \((vv|vv)\) and computing the terms that involve these integrals in the AO; basis. In order to do that one needs to set the AO_BASIS option to; DISK (currently used by default). For more recommendations on the choice",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dct.html:10418,optimiz,optimized,10418,psi4manual/master/dct.html,https://psicode.org,https://psicode.org/psi4manual/master/dct.html,15,['optimiz'],['optimized']
Performance,"share/scripts/ixyz2database.py.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a Psi4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || 'off' ; Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || 'off' ; Ind",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:1817,optimiz,optimize,1817,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,4,"['optimiz', 'perform']","['optimize', 'performed']"
Performance,"shold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES¶. The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS¶. The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. TAU_SQUARED¶. Controls whether to compute the DCFT energy with the Tau^2 correction to Tau. Type: boolean; Default: false. TPDM¶. Controls whether to compute unrelaxed two-particle density matrix at the end of the energy computation. Type: boolean; Default: false. Table Of Contents. DCFT; General; ALGORITHM; AO_BASIS; DAMPING_PERCENTAGE; DIIS_MAX_VECS; DIIS_MIN_VECS; DIIS_START_CONVERGENCE; LAMBDA_MAXITER; MAXITER; RESPONSE_ALGORITHM; R_CONVERGENCE; SCF_MAXITER; TIKHONOW_OMEGA. Expert; CACHELEVEL; DCFT_GUESS; IGNORE_TAU; INTS_TOLERANCE; LOCK_OCC; MO_RELAX; QC_COUPLING; RELAX_GUESS_ORBITALS; RELAX_TAU; STABILITY_ADD_VECTORS; STABILITY_AUGMENT_SPACE_TOL; STABILITY_CHECK; STABILITY_CONVERGENCE; STABILITY_MAX_SPACE_SIZE; STABILITY_N_EIGENVALUES; STABILITY_N_GUESS_VECTORS; TAU_SQUARED; TPDM. Previous topic; TDHF_MEM_SAFETY_FACTOR; Next topic; ALGORITHM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__dcft-1.html:6295,CACHE,CACHELEVEL,6295,psi4manual/4.0b3/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__dcft-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"should cite the; following publications: [Patkowski:2018:164110]. Second-Order Exchange Terms without Single-Exchange Approximation¶; Recently, the SAPT second-order exchange terms have been derived without; the \(S^{2}\) approximation in the works [Schaffer:2012:1235] and; [Schaffer:2013:2570]. These new terms can be computed with the following; settings:; set SAPT_DFT_FUNCTIONAL HF; set DO_IND_EXCH_SINF true # calculate Exch-Ind20 (S^inf); set SAPT_DFT_MP2_DISP_ALG fisapt; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'). These calculations are performed with the atomic orbital and; density-fitting scheme of [J. M. Waldrop et al., to be published]. S^inf Keywords¶. DO_IND_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Induction terms. Type: boolean; Default: false. DO_DISP_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Dispersion terms. Type: boolean; Default: false. SAPT0-D¶; In SAPT0, the computation of \(E_{disp}^{(20)} + E_{exch-disp}^{(20)}\) represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; Grimme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:45176,bottleneck,bottleneck,45176,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,4,['bottleneck'],['bottleneck']
Performance,"si4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by Psi4, ensure that the program binary (dmrcc) can be; found in your PATH. If Psi4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in Psi4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs Psi4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, Psi4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Note that perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are not available with REFERENCE ROHF. name; calls method in Kallay’s MRCC program [manual]. mrccsd; CC through doubles. mrccsdt; CC through triples. mrccsdtq; CC through quadruples. mrccsdtqp; CC through quintuples. mrccsdtqph; CC through sextuples. mrccsd(t); CC through doubles with perturbative triples. mrccsdt(q); CC through triples with perturbative quadruples. mrccsdtq(p); CC through quadruples with pertubative quintuples. mrccsdtqp(h); CC through quintuples with pertubative sextuples. mrccsd(t)_l;  . mrccsdt(q)_l;  . mrccsdtq(p)_l;  . mrccsdtqp(h)_l;  . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/mrcc-1.html:1332,perform,perform,1332,psi4manual/1.0.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/mrcc-1.html,4,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"si4 executable.; Please use the ~/.psi4rc file sparingly. If using the environment variable PSI_SCRATCH is inconvenient,; or if some psi4_io commands must be present in all input files,; the ~/.psi4rc resource file can be used (example psi4/samples/example_psi4rc_file).; All the commands mentioned in section Scratch Files can be used in this file.; To set up the scratch path:; psi4_io.set_default_path('/scratch/user'). To set up the scratch path from a variable $MYSCRATCH:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). To set up a specific path for the internal coordinate file and instruct PSI4 not to delete it:; psi4_io.set_specific_path(12, './'); psi4_io.set_specific_retention(12, True). # equivalent to above; psi4_io.set_specific_path(PSIF_INTCO, './'); psi4_io.set_specific_retention(PSIF_INTCO, True). The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instructions in the ~/.psi4rc file. During; execution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed.; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and C++; std::thread for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external.html:10977,perform,performing,10977,psi4manual/master/external.html,https://psicode.org,https://psicode.org/psi4manual/master/external.html,9,['perform'],['performing']
Performance,"si4.core.PseudospectralInt method. psi4.core.QuadrupoleInt method. psi4.core.ThreeCenterOverlapInt method. psi4.core.TracelessQuadrupoleInt method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. compute_spin_contamination() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. compute_state_transfer() psi4.core.CIWavefunction method. COMPUTE_TRIPLES (FNOCC). compute_V() psi4.core.VBase method. compute_Vx() psi4.core.VBase method. computeExternExternInteraction() psi4.core.ExternalPotential method. computeNuclearEnergy() psi4.core.ExternalPotential method. computePotentialMatrix() psi4.core.ExternalPotential method. CONDA_PREFIX, [1]. connectivity() psi4.core.Molecule method. CONSECUTIVE_BACKSTEPS (OPTKING). construct_from_pydict() psi4.core.BasisSet static method. contact. converged psi4.core.BoysLocalizer attribute. psi4.core.Localizer attribute. psi4.core.PMLocalizer attribute. convergence criteria. ; geometry optimization. ConvergenceError. copy() psi4.core.CIVector method. psi4.core.Matrix method. psi4.core.Vector method. psi4.driver.Table method. copy_file_from_scratch() in module psi4.driver. copy_file_to_scratch() in module psi4.driver. copy_lower_to_upper() psi4.core.Matrix method. copy_upper_to_lower() psi4.core.Matrix method. core_hamiltonian_grad() psi4.core.MintsHelper method. corl_xtpl_helgaker_2() in module psi4.driver.driver_cbs. CORR_ANSATZ (PSIMRCC). CORR_CCSD_T (PSIMRCC). CORR_CHARGE (PSIMRCC). CORR_MULTP (PSIMRCC). CORR_WFN (PSIMRCC). Correlated psi4.core.DerivCalcType attribute. CorrelationFactor class in psi4.core. CorrelationTable class in psi4.core. Cotton-ordering. coulomb() psi4.core.FISAPT method. count() psi4.core.BSVec method. counterpoise correction. COUPLED_INDUCTION (SAPT). COUPLING (PSIMRCC). COUPLING_TERMS (PSIMRCC). COVALENT_CONNECT (OPTKING). cp. ; setting keywords. CP-CORRECTED 2-BODY INTERACTION ENERGY. cphf_converged() psi4.core.CUHF method. psi4.core.HF me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:34427,optimiz,optimization,34427,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,4,['optimiz'],['optimization']
Performance,"si4.core.SuperFunctional method. ISA. ; MBIS. Isotopes. ISOTROPIC_POL (PE). ISTOP (DETCI). iteration_ psi4.core.CUHF attribute. psi4.core.HF attribute. psi4.core.RHF attribute. psi4.core.ROHF attribute. psi4.core.UHF attribute. iterations() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. J. J() psi4.core.DFJCOSK method. psi4.core.DirectJK method. psi4.core.JK method. psi4.core.MemDFJK method. JK class in psi4.core. jk() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. JOBTYPE (CCLAMBDA). join_path() in module psi4.driver. json() psi4.driver.AtomicComputer method. K. K() psi4.core.DFJCOSK method. psi4.core.DirectJK method. psi4.core.JK method. psi4.core.MemDFJK method. KEEP_INTCOS (OPTKING). keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. KIND (ADC). kinetic() psi4.core.FISAPT method. kinetic_grad() psi4.core.MintsHelper method. KineticInt class in psi4.core. L. L psi4.core.BoysLocalizer attribute. psi4.core.Localizer attribute. psi4.core.PMLocalizer attribute. label qcelemental.datum.Datum attribute. label() psi4.core.Molecule method. psi4.core.MOSpace method. lagrangian() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. LaplaceDenominator class in psi4.core. LCC2 (+LMP2) TOTAL ENERGY. LCCD CORRELATION ENERGY. LCCD DOUBLES ENERGY. LCCD OPPOSITE-SPIN CORRELATION ENERGY. LCCD SAME-SPIN CORRELATION ENERGY. LCCD SINGLES ENERGY. LCCD TOTAL ENERGY. LCCSD. (+LMP2). LCCSD CORRELATION ENERGY. LCCSD DOUBLES ENERGY. LCCSD OPPOSITE-SPIN CORRELATION ENERGY. LCCSD SAME-SPIN CORRELATION ENERGY.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:84106,optimiz,optimize,84106,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['optimiz'],['optimize']
Performance,"si4.core.SuperFunctional method. c_functionals() psi4.core.SuperFunctional method. C_left_add() psi4.core.JK method. psi4.core.MemDFJK method. c_omega() psi4.core.SuperFunctional method. c_os_alpha() psi4.core.SuperFunctional method. C_right_add() psi4.core.JK method. psi4.core.MemDFJK method. c_ss_alpha() psi4.core.SuperFunctional method. Ca() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.SADGuess method. psi4.core.UHF method. psi4.core.Wavefunction method. Ca_subset() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. CACHELEVEL (ADC). (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (DCT). (OCC). CACHETYPE (CCENERGY). (CCEOM). CALC_S_SQUARED (DETCI). CANONICALIZE_ACTIVE_FAVG (MCSCF). CANONICALIZE_INACTIVE_FAVG (MCSCF). CART_HESS_READ (OPTKING). Cartesian psi4.core.GaussianType attribute. Cb() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.SADGuess method. psi4.core.UHF method. psi4.core.Wavefunction method. Cb_subset() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. CBS CORRELATION ENERGY. CBS REFERENCE ENERGY. CBS TOTAL ENERGY. cbs(). ; extrapolation schemes. output. setting keywords. theory, [1], [2]. cbs() in module psi4.driver. CC. ; theory. CC (DETCI). CC CORRELATION ENERGY. CC D1 DIAGNOSTIC. CC D2 DIAGNOSTIC. CC DIPOLE. CC DIPOLE X. CC DI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:16502,CACHE,CACHETYPE,16502,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['CACHE'],['CACHETYPE']
Performance,"si4.geometry(""""""; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). [4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:6493,perform,perform,6493,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,22,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"si4/lib/scripts/ixyz2database.pl.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/lib/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || 'off' ; Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || 'off' ; Ind",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/db-1.html:1783,optimiz,optimize,1783,psi4manual/4.0b5/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/db-1.html,4,"['optimiz', 'perform']","['optimize', 'performed']"
Performance,"si4/psi4/driver/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/quickaddalias.html:2559,optimiz,optimizer,2559,psi4manual/master/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/master/quickaddalias.html,9,['optimiz'],['optimizer']
Performance,"sian input. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. cubeprop; RHF orbitals and density for water. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dfcasscf-sp; CASSCF/6-31G** energy point. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:17782,optimiz,optimization,17782,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"sian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. mints3; Test individual integral objects for correctness. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. pywrap-db2; Database calculation, run in sow/reap mode. cbs-xtpl-func; optimization with method defined via cbs. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. adc1; ADC/6-31G** on H2O. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. psithon2; Accesses basis sets, databases, plugins, and executabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:29726,perform,performed,29726,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['perform'],['performed']
Performance,"sian""].values()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs] def get_results(self, client: Optional[""FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results = self.prepare_results(client=client); ret_energy = results.pop(""ret_energy""); ret_ptype = results.pop(""ret_ptype""); ret_gradient = results.pop(""ret_gradient"", None). # load QCVariables; qcvars = {; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; 'NBODY NUMBER': len(self.task_list),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": ret_energy,; }. for k, val in results.items():; qcvars[k] = val. qcvars['CURRENT ENERGY'] = ret_energy; if self.driver == 'gradient':; qcvars['CURRENT GRADIENT'] = ret_ptype; properties[""return_gradient""] = ret_ptype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties':",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html:89367,load,load,89367,psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_nbody.html,1,['load'],['load']
Performance,"sible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. CFOUR_MRCC¶. Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY¶. Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING¶. Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL¶. Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead. Type: string; Possible Values: ABORT, SWITCH, RFA; Default: ABORT. CFOUR_NEWNORM¶. All components of spherical AO’s are normalized to 1. This feature can help with numerical convergence issues if AO integrals are involved. Currently only working for single-point energy calculations. Type: boolean; Default: false. CFOUR_NONHF¶. Specifies whether the reference function used in the correlation energy calculation satisfies the (spin-orbital) HF equatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:39147,optimiz,optimization,39147,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,17,['optimiz'],['optimization']
Performance,"sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC); FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Caching level for libdpd governing the storage of amplitudes, in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:7197,cache,cache,7197,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,12,['cache'],['cache']
Performance,"sing MRCC. pywrap_alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. pywrap_all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. sapt3; SAPT2+3 aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. pubch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:12677,optimiz,optimize,12677,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['optimiz'],['optimize']
Performance,"sing RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-delta-energy; Extrapolated energies with delta correction. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:11931,perform,performs,11931,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['perform'],['performs']
Performance,"sing a Psi4.Dimension object. Returns:matrix – Returns the given Psi4 object. Return type:Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; 1; 2>>> data = np.random.rand(20); >>> vector = array_to_matrix(data). 1; 2; 3; 4>>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = array_to_matrix(irrep_data); >>> print matrix.rowspi().to_tuple(); (2, 0, 4). classmethod from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm(self: psi4.core.Matrix, arg0: bool, arg1: bool, arg2: float, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix, arg5: float) → None; docstring. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int) -> float. docstring. get(self: psi4.core.Matrix, arg0: int, arg1: int) -> float. docstring. identity(self: psi4.core.Matrix) → None; docstring. invert(self: psi4.core.Matrix) → None; docstring. load(self: psi4.core.Matrix, arg0: str) → None; docstring. load_mpqc(self: psi4.core.Matrix, arg0: str) → None; docstring. name; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int; docstring. np; View without only one irrep. classmethod np_read(filename, prefix=''). np_write(filename=None, prefix=''). nph; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, arg0: float, arg1: bool) → psi4.core.Matrix; docstring. power(self: psi4.core.Matrix, arg0: float, arg1: float) → psi4.core.Dimension; docstring. print_out(self: psi4.core.Matrix) → None; docstring. project_out(self: psi4.core.Matrix, arg0: psi4.core.Matrix) → None; docstring. remove_symmetry(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → None; docstring. rms(self: psi4.core.Matrix) → float; docstring. rotate_columns(self: psi4.core.Matrix, arg0: int, arg1: int, arg2: int, arg3: float) → None; docstring. rowdim(self: psi4.core.Matrix) → psi4.core.Dimension; docstring. r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:13125,load,load,13125,psi4manual/1.1.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"sing the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc12; Single point energies of multiple excited states with EOM-CCSD. dft2; DFT Functional Test. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:28499,optimiz,optimization,28499,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,8,['optimiz'],['optimization']
Performance,"sing the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc12; Single point energies of multiple excited states with EOM-CCSD. dft2; DFT Functional Test. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. nbo; Generation of NBO file. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxid",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:33644,optimiz,optimization,33644,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"sing.; SOLVER_MAX_SUBSPACE: Maximum size of the subspace. Default within this context: 12. In case convergence problems are encountered during the Davidson procedure,; it is recommended to first increase SOLVER_MAX_SUBSPACE, especially if you solve; for a large number of roots. This will result in a higher computational cost of each iteration, but should; make the solver better behaved. However, note that SOLVER_MAX_SUBSPACE should never be larger than; the full subspace minus the number of desired roots to avoid adding artificial zero eigenvalues.; This may happen in minimal basis sets, especially with symmetry, but the code automatically adjusts; SOLVER_MAX_SUBSPACE if it is too large.; If the solver seems to converge on the wrong eigenvalue, try increasing SOLVER_N_GUESS.; Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing; SOLVER_MAXITER. External potentials and QM/MM¶; In addition to the implementation of EFP for accurate QM/MM; computations, PSI4 can perform more rudimentary QM/MM procedures via the; EXTERN keyword. The following snippet, extracted from the; extern1 test case, demonstrates its use for a TIP3P external potential:; 1; 2; 3; 4; 5Chrgfield = QMMM(); Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.356023604706); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN', Chrgfield.extern). First a QMMM object is created, then three separate particles are added to this; object before the SCF code is told about its existence on the last line. The; calls to addCharge take the atomic charge, x coordinate, y coordinate, and; z coordinate in that order. The atomic charge is specified in atomic units,; and the coordinates always use the same units as the geometry specification in; the regular QM region. Additional MM molecules may be specified by adding; extra calls",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:31402,perform,perform,31402,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,2,['perform'],['perform']
Performance,"sing.; SOLVER_MAX_SUBSPACE: Maximum size of the subspace. Default within this context: 12. In case convergence problems are encountered during the Davidson procedure,; it is recommended to first increase SOLVER_MAX_SUBSPACE, especially if you solve; for a large number of roots. This will result in a higher computational cost of each iteration, but should; make the solver better behaved. However, note that SOLVER_MAX_SUBSPACE should never be larger than; the full subspace minus the number of desired roots to avoid adding artificial zero eigenvalues.; This may happen in minimal basis sets, especially with symmetry, but the code automatically adjusts; SOLVER_MAX_SUBSPACE if it is too large.; If the solver seems to converge on the wrong eigenvalue, try increasing SOLVER_N_GUESS.; Otherwise, if the solver is almost converged but reaches the maximum number of iterations, try increasing; SOLVER_MAXITER. External potentials and QM/MM¶; In addition to the implementation of EFP for accurate QM/MM; computations, Psi4 can perform more rudimentary QM/MM procedures via the; EXTERN keyword. The following snippet, extracted from the; extern1 test case, demonstrates its use for a TIP3P external potential:; Chrgfield = QMMM(); Chrgfield.extern.addCharge(-0.834, 1.649232019048, 0.0, -2.356023604706); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN',Chrgfield.extern). First a QMMM object is created, then three separate particles are added to this; object before the SCF code is told about its existence on the last line. The; calls to addCharge take the atomic charge, x coordinate, y coordinate, and; z coordinate in that order. The atomic charge is specified in atomic units,; and the coordinates always use the same units as the geometry specification in; the regular QM region. Additional MM molecules may be specified by adding; extra calls to addCharge ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf.html:29364,perform,perform,29364,psi4manual/1.0.0/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf.html,2,['perform'],['perform']
Performance,"sing; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; CI: Configuration Interaction; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/mrcc-1.html:2279,optimiz,optimize,2279,psi4manual/4.0b3/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/mrcc-1.html,4,['optimiz'],['optimize']
Performance,"single-point MP4/qz2p on NH2. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/kw-1; testing best practices options, part i. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html:4105,perform,performed,4105,psi4manual/1.9.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html,1,['perform'],['performed']
Performance,"sion Corrections; Recommendations; Advanced Functional Use and Manipulation. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. DF-MP2: Density-Fitted 2nd-Order Møller–Plesset Perturbation Theory; Introduction; Theory; Recommendations. CC: Coupled Cluster Theory; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Frozen natural orbitals (FNO); QCISD(T), CCSD(T), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; Advanced OCC Keywords; Basic DFOCC Keywords; Advanced DFOCC Keywords; Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Computations with Mid-bonds; Interpreting SAPT Results; Spin-Flip SAPT. F/I-SAPT: Functional Group and/or Intramolecular SAPT; F-SAPT: A Representative Example; Order-1 Visualization with PyMol; Difference F-SAPT Analysis; I-SAPT: A Representative Example; Cube File Visualization with PyMol; F/I-SAPT Keywords; Additional Notes. ADC: Ab Initio Polarization Propagator; Partial Renor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/methods-1.html:1928,Optimiz,Optimized,1928,psi4manual/1.2.1/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/methods-1.html,4,['Optimiz'],['Optimized']
Performance,"sion of the molecular orbitals into various subspaces such as; RAS spaces, or frozen vs. active orbitals, etc., needs to be clear not; only to detci, but also at least to the transformation program; (and in the case of MCSCF, to other programs as well). Thus, orbital; subspace keywords such as RAS1,; RAS2, RAS3, FROZEN_DOCC,; FROZEN_UOCC,; ACTIVE, etc., should be set; in the global section of input so they may also be read by other modules.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-refernce CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specifed by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:4730,perform,performed,4730,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,2,['perform'],['performed']
Performance,"sion of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/detci-1.html:12673,perform,perform,12673,psi4manual/1.3.2/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/detci-1.html,2,['perform'],['perform']
Performance,"sis Frozen-Core Operator'; moH = core.Matrix(PSIF_MO_FZC, wfn.nmopi(), wfn.nmopi()); moH.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC = moH.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = mo_idx(il[0][index] + offset); col = mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_A = moH_A.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_A.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = alpha_mo_idx(il[0][index] + offset); col = alpha_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; PSIF_MO_B_FZC = 'MO-basis Beta Frozen-Core Oper'; moH_B = core.Matrix(PSIF_MO_B_FZC, wfn.nmopi(), wfn.nmopi()); moH_B.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_B = moH_B.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html:6234,load,load,6234,psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html,1,['load'],['load']
Performance,"sis sets can be found in their; definition files at psi4/psi4/share/psi4/basis in the source. For basis set availability by; element and the default value for keyword PUREAM, consult; Appendix Basis Sets by Element.; PSI4 uses the angular momentum convention below that; skips the letter J. Note that Gaussian94 convention is; not to skip this letter.; PSI4 can use either convention for .gbs import (assuming; angular momentum levels are not skipped), but it will always output; in the HIK sequence. Another portion of the G94 format, labeling; angular momentum with L=l syntax is newly (August 2020); implemented, and this is preferred for L=7 and above to; avoid ambiguity.; L: 0123456789...; Psi4: SPDFGHIKLM...; G94: SPDFGHIJKL... Mixing Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis “block” can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms for the primary/orbital basis. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizarre example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectively omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from \(D_{6h}\) to \(C_{2v}\); PSI4 will detect this; aut",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/basissets.html:3025,perform,performs,3025,psi4manual/master/basissets.html,https://psicode.org,https://psicode.org/psi4manual/master/basissets.html,9,['perform'],['performs']
Performance,"sis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon: Structuring an Input File. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:14440,perform,perform,14440,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,1,['perform'],['perform']
Performance,"sis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (CPHF); CPHF — Auxiliary basis for SCF. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (SCF); SCF — Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_BUMP_R0 (SCF); SCF — Bump function min radius. Type: double; Default: 0.0. DF_BUMP_R1 (SCF); SCF — Bump function max radius. Type: double; Default: 0.0. DF_DOMAINS (SCF); SCF — FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. DF_FITTING_CONDITION (SCF); SCF (Expert) — Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO (DFMP2); DFMP2 (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_IO (SCF); SCF (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_NUM_THREADS (DFMP2); DFMP2 — Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. DF_INTS_NUM_THREADS (SCF); SCF — Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. DF_LMP2 (CCENERGY); CCENERGY — Do use density fitting? Turned on with specification of fitting basis. Type: boolean; Default: true. DF_METRIC (SCF); SCF — FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. DF_SCF_GUESS (SCF); SCF — Use DF integrals tech to converge the SCF before switching to a conventional tech. Type: boolean; Default: true. DF_THETA (SCF); SCF — FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. DFCC (FNOCC); FNOCC — Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:26479,LOAD,LOAD,26479,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['LOAD'],['LOAD']
Performance,"sis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (CPHF); CPHF — Auxiliary basis for SCF. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (SCF); SCF — Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_BUMP_R0 (SCF); SCF — Bump function min radius. Type: double; Default: 0.0. DF_BUMP_R1 (SCF); SCF — Bump function max radius. Type: double; Default: 0.0. DF_DOMAINS (SCF); SCF — FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. DF_FITTING_CONDITION (SCF); SCF (Expert) — Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO (DFMP2); DFMP2 (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_IO (SCF); SCF (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_NUM_THREADS (DFMP2); DFMP2 — Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. DF_INTS_NUM_THREADS (SCF); SCF — Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. DF_METRIC (SCF); SCF — FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. DF_SCF_GUESS (SCF); SCF — Use DF integrals tech to converge the SCF before switching to a conventional tech in a SCF_TYPE DIRECT calculation. Type: boolean; Default: true. DF_THETA (SCF); SCF — FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. DFCC (FNOCC); FNOCC — Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. DFMP2_MEM_FACTOR (DFMP2); DFMP2 — % of memory for DF-MP2 three-index buffers. Type: do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:98947,LOAD,LOAD,98947,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,4,['LOAD'],['LOAD']
Performance,"sis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (CPHF); CPHF — Auxiliary basis for SCF. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (SCF); SCF — Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_BUMP_R0 (SCF); SCF — Bump function min radius. Type: double; Default: 0.0. DF_BUMP_R1 (SCF); SCF — Bump function max radius. Type: double; Default: 0.0. DF_DOMAINS (SCF); SCF — FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. DF_FITTING_CONDITION (SCF); SCF (Expert) — Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO (DFMP2); DFMP2 (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_IO (SCF); SCF (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_NUM_THREADS (DFMP2); DFMP2 — Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. DF_INTS_NUM_THREADS (SCF); SCF — Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. DF_METRIC (SCF); SCF — FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. DF_SCF_GUESS (SCF); SCF — Use DF integrals tech to converge the SCF before switching to a conventional tech in a |scf__scf_type| DIRECT calculation. Type: boolean; Default: true. DF_THETA (SCF); SCF — FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. DFCC (FNOCC); FNOCC — Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. DFMP2_MEM_FACTOR (DFMP2); DFMP2 — % of memory for DF-MP2 three-index buffers. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:99248,LOAD,LOAD,99248,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,2,['LOAD'],['LOAD']
Performance,"sis...; # ...until the user explicitly provides a DF basis.; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSet.zero_ao_basis_set()); return wfn. core.Wavefunction.build = _core_wavefunction_build. def _core_wavefunction_get_scratch_filename(self, filenumber):; """""" Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data):; """"""Summary. Parameters; ----------; wfn_data : str or dict; If a str reads a Wavefunction from a disk otherwise, assumes the data; is passed in. Returns; -------; Wavefunction; A deserialized Wavefunction object; """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:4437,load,load,4437,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['load'],['load']
Performance,sis_by_label() LibmintsMolecule method. set_basis_by_number() LibmintsMolecule method. set_basis_by_symbol() LibmintsMolecule method. set_com_fixed() LibmintsMolecule method. set_coordinates() CartesianEntry method. ZMatrixEntry method. set_fixed() CoordValue method. set_full_geometry() LibmintsMolecule method. set_full_point_group() LibmintsMolecule method. set_geometry() LibmintsMolecule method. set_ghost_fragment() LibmintsMolecule method. set_ghost_fragments() LibmintsMolecule method. set_ghosted() CoordEntry method. set_memory() in module util. set_molecular_charge() LibmintsMolecule method. set_multiplicity() LibmintsMolecule method. set_name() LibmintsMolecule method. set_num_threads() in module util. set_point_group() LibmintsMolecule method. set_units() LibmintsMolecule method. set_variable() LibmintsMolecule method. setting; . keywords C-side. keywords cbs(). keywords cp(). keywords database(). keywords diatomic_anharmonicity(). keywords energy(). keywords molecule. keywords optimize(). keywords property(). SF_RESTRICT (DETCI). sherrillgroup_gold_standard() in module aliases. show() in module qcdb.vecutil. SIGMA_OVERLAP (DETCI). single-point. SINGLES_PRINT (CCEOM). SMALL_CUTOFF (PSIMRCC). SO_S_FILE (TRANSQT). SO_T_FILE (TRANSQT). SO_TEI_FILE (TRANSQT). SO_V_FILE (TRANSQT). SOCC (GLOBALS). (MCSCF). SOLVER_CONVERGENCE (CPHF). SOLVER_EXACT_DIAGONAL (CPHF). SOLVER_MAX_SUBSPACE (CPHF). SOLVER_MAXITER (CPHF). SOLVER_MIN_SUBSPACE (CPHF). SOLVER_N_GUESS (CPHF). SOLVER_N_ROOT (CPHF). SOLVER_NORM (CPHF). SOLVER_PRECONDITION (CPHF). SOLVER_PRECONDITION_MAXITER (CPHF). SOLVER_PRECONDITION_STEPS (CPHF). SOLVER_QUANTITY (CPHF). SOLVER_TYPE (CPHF). SORTED_TEI_FILE (TRANSQT). SOS_SCALE (OMP2). (OMP3). SOS_SCALE2 (OMP2). (OMP3). SOS_TYPE (OMP2). (OMP3). SPINADAPT_ENERGIES (CCENERGY). split_menial() in module wrappers. SS_E_CONVERGENCE (CCEOM). SS_R_CONVERGENCE (CCEOM). SS_SKIP_DIAG (CCEOM). SS_VECS_PER_ROOT (CCEOM). STABILITY_ADD_VECTORS (DCFT). STABILITY_ANALYSIS (SCF). ST,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/genindex.html:40109,optimiz,optimize,40109,psi4manual/4.0b3/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/genindex.html,1,['optimiz'],['optimize']
Performance,sis_by_label() LibmintsMolecule method. set_basis_by_number() LibmintsMolecule method. set_basis_by_symbol() LibmintsMolecule method. set_com_fixed() LibmintsMolecule method. set_coordinates() CartesianEntry method. ZMatrixEntry method. set_fixed() CoordValue method. set_full_geometry() LibmintsMolecule method. set_full_point_group() LibmintsMolecule method. set_geometry() LibmintsMolecule method. set_ghost_fragment() LibmintsMolecule method. set_ghost_fragments() LibmintsMolecule method. set_ghosted() CoordEntry method. set_memory() in module util. set_molecular_charge() LibmintsMolecule method. set_multiplicity() LibmintsMolecule method. set_name() LibmintsMolecule method. set_num_threads() in module util. set_point_group() LibmintsMolecule method. set_units() LibmintsMolecule method. set_variable() LibmintsMolecule method. setting; . keywords C-side. keywords cbs(). keywords cp(). keywords database(). keywords diatomic_anharmonicity(). keywords energy(). keywords molecule. keywords optimize(). keywords property(). SF_RESTRICT (DETCI). sherrillgroup_gold_standard() in module aliases. show() in module qcdb.vecutil. SIGMA_OVERLAP (DETCI). single-point. SINGLES_PRINT (CCEOM). SMALL_CUTOFF (PSIMRCC). SO_S_FILE (TRANSQT). SO_T_FILE (TRANSQT). SO_TEI_FILE (TRANSQT). SO_V_FILE (TRANSQT). SOCC (GLOBALS). (MCSCF). SOLVER_CONVERGENCE (CPHF). SOLVER_EXACT_DIAGONAL (CPHF). SOLVER_MAX_SUBSPACE (CPHF). SOLVER_MAXITER (CPHF). SOLVER_MIN_SUBSPACE (CPHF). SOLVER_N_GUESS (CPHF). SOLVER_N_ROOT (CPHF). SOLVER_NORM (CPHF). SOLVER_PRECONDITION (CPHF). SOLVER_PRECONDITION_MAXITER (CPHF). SOLVER_PRECONDITION_STEPS (CPHF). SOLVER_QUANTITY (CPHF). SOLVER_TYPE (CPHF). SORTED_TEI_FILE (TRANSQT). SOS_TYPE (OCC). SPINADAPT_ENERGIES (CCENERGY). split_menial() in module wrappers. SS_E_CONVERGENCE (CCEOM). SS_R_CONVERGENCE (CCEOM). SS_SKIP_DIAG (CCEOM). SS_VECS_PER_ROOT (CCEOM). STABILITY_ADD_VECTORS (DCFT). STABILITY_ANALYSIS (SCF). STABILITY_AUGMENT_SPACE_TOL (DCFT). STABILITY_CHECK (DCFT). STAB,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:42404,optimiz,optimize,42404,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['optimiz'],['optimize']
Performance,"sithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:; Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmitted to the child jobs.; Function intercalls (e.g., db(opt())) are not tested with sow/reap procedures. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/sowreap-1.html:1446,Optimiz,Optimization,1446,psi4manual/1.3.2/sowreap-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/sowreap-1.html,4,"['Optimiz', 'optimiz']","['Optimization', 'optimize']"
Performance,"ski:1994:1887].; Several truncations of the SAPT expansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligable errors into the SAPT energy and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/sapt-1.html:2478,perform,perform,2478,psi4manual/4.0b3/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/sapt-1.html,6,['perform'],['perform']
Performance,"slates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_COUPLING (DCFT); DCFT — Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS); GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. QMEFP_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation?. Type: boolean; Default: true. QMEFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. R4S (DETCI); DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:187745,perform,perform,187745,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"slates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_COUPLING (DCFT); DCFT — Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS); GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. QMEFP_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation?. Type: boolean; Default: true. QMEFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. R4S (DETCI); DETCI (Expert) — Do restrict strings with in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:188070,perform,perform,188070,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"slates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_COUPLING (DCFT); DCFT — Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS); GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. R4S (DETCI); DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (CCLAMBDA); CCLAMBDA — Convergence criterion for wavefunction (change) in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:190488,perform,perform,190488,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['perform'],['perform']
Performance,"so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/mints5; geometries from a variety of input formats. references from psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html:1554,optimiz,optimization,1554,psi4manual/1.7.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_H(self: psi4.core.HF) → None¶; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF) → None¶; Forms the S^1/2 matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF) → None¶; Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self: psi4.core.HF) → None¶; Forms the initial F matrix. frac_performed_¶; Frac performed current iteration?. frac_renormalize(self: psi4.core.HF) → None¶; docstring. frequencies()¶. static from_file(wfn_data)¶; Summary. Parameters:wfn_data (str or dict) – If a str reads a Wavefunction from a disk otherwise, assumes the data; is passed in. Returns:A deserialized Wavefunction object. Return type:Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(key)¶. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self: psi4.core.HF, arg0: str) → ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html:8428,perform,performed,8428,psi4manual/1.3.2/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.cuhf.html,14,['perform'],['performed']
Performance,"some architectures, a precompiled binary is available. See Compiling and Installing for details. PythonPSI4 1.1 and 1.2 are supported on Python 2.7, 3.5,; and 3.6. After 1.2, only Python 3 will be supported; in accordance with other scientific software projects).; PSI4 1.3 supports Python 3.6 and 3.7.; PSI4 1.4 supports Python 3.6, 3.7, 3.8, and 3.9.; PSI4 1.5 supports Python 3.7, 3.8, and 3.9.; PSI4 1.6 supports Python 3.8, 3.9, and 3.10.; PSI4 1.7 supports Python 3.8, 3.9, 3.10, and 3.11 (no binary packages for 3.11).; The future plan is to support the approximately three latest Python versions.; The current master supports 3.8, 3.9, 3.10, and 3.11. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties.; For more tables with capabilities details:. Full Capabilities (first below) lists all methods; Capabilities Breakdown (second below) lists selected methods by reference, etc.; Module Capabilities lists selected methods by implementation; Energy, Energy (DFT), Energy (MRCC), Energy (CFOUR) fully list energy target methods; Gradient, Gradient (CFOUR) fully list gradient target methods; Frequency fully lists",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/introduction.html:23192,perform,perform,23192,psi4manual/1.7.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/introduction.html,1,['perform'],['perform']
Performance,"source]; Function to compute various properties. Aliases; prop(). Returns; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (Lis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prop-1.html:1149,optimiz,optimized,1149,psi4manual/1.4.0/prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prop-1.html,5,['optimiz'],['optimized']
Performance,"sp) + '\n'. if shortlong:; for at in range(nat):; text += """"""{:{presp}}{:5d} {:{width}}"""""".format('',; at + 1,; atom_lbl[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/qcdb/vib.html:30736,Perform,Perform,30736,psi4manual/1.6.x/_modules/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/qcdb/vib.html,5,['Perform'],['Perform']
Performance,"sp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:6350,Queue,Queue,6350,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,2,['Queue'],['Queue']
Performance,"specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.0000848",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:7729,Optimiz,Optimization,7729,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['Optimiz'],['Optimization']
Performance,"specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step; (in principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734908 -76.026632734908 0.01523518 0.01245755 0.02742222 0.02277530 ~; 2 -76.027022666011 -0.000389931104 0.00178779 0.00142946 0.01008137 0.00594928 ~; 3 -76.027032729374 -0.000010063363 0.00014019 0.00008488 0.00077463 0.00044738 ~; -------------------------------------------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:7610,Optimiz,Optimization,7610,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,2,['Optimiz'],['Optimization']
Performance,"spherical/Cartesian with basis and cfour_spherical. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/kw-1; testing best practices options, part i. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-rhf-ccs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_cfour.html:3848,optimiz,optimization,3848,psi4manual/master/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"ss in qcdb.libmintscoordentry. nunique() LibmintsMolecule method. O. OCC_ORBS_PRINT (OCC). OCC_TOLERANCE (FNOCC). (SAPT). OCEPA; . setting keywords. theory. OCEPA(0)CORRELATIONENERGY. OCEPA(0)TOTALENERGY. OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OEProp. theory. oeprop() in module p4util.util. OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (CPHF). (DETCI). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (CPHF). (DFMP2). opt(); . see optimize(); . OPT_METHOD (OCC). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in p4util.optproc. OptionState class in p4util.optproc. ORB_OPT (OCC). ORB_RESP_SOLVER (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OCEPA. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OCC). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). p4const module. p4const.__init__ module. p4const.physconst module. p4const.psifiles module. p4regex module. p4util module. p4util.__init__ module. p4util.basislist module. p4util.basislistdunning module. p4util.basislistother module. p4util.optproc module. p4util.procutil module. p4util.text module. p4util.util module. PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module dri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:33450,optimiz,optimize,33450,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['optimiz'],['optimize']
Performance,"ss print_level =0. Return type:; str. psi4.driver.frac.ip_fitting(name, omega_l=0.05, omega_r=2.5, omega_convergence=0.001, maxiter=20, **kwargs)[source]¶; Optimize DFT omega parameter for molecular system. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l (float) – Minimum omega to be considered during fitting.; omega_r (float) – Maximum omega to be considered during fitting.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence (float) – Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter (int) – Maximum number of iterations towards omega convergence. Returns:; Optimal omega parameter. Return type:; float. psi4.driver.frac.frac_traverse(name, **kwargs)[source]¶; Scan electron occupancy from +1 electron to -1. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult (Optional[int]) – Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult (Optional[int]) – Multiplicity of anion, if not neutral multiplicity + 1.; frac_start (Optional[int]) – Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs (Optional[List]) – Occupations to step through for cation, by default [1 - 0.1 * x for x in range(11)].; LUMO_occs (Optional[List]) – Occupations to step through for anion, by default [1 - 0.1 * x for x in range(11)].; HOMO (Optional[int]) – Index of HOMO.; LUMO (Optional[int]) – Index of LUMO.; frac_diis (Optional[bool]) – Do use DIIS for non-1.0-occupied points?; neutral_guess (Optional[bool]) – Do use neutral orbitals as guess for the anion?; hf_guess (Optional[bool]) – Do use UHF guess before UKS?; continuous",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external_apis.html:4033,optimiz,optimized,4033,psi4manual/master/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/master/external_apis.html,4,['optimiz'],['optimized']
Performance,"ss_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:71969,optimiz,optimized,71969,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['optimiz'],['optimized']
Performance,"ssage); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if (abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10**(-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected.get(irrep, row, col),; computed.get(irrep, row, col))); failed = 1; break. if (failed):; print(""Check your output file for reporting of the matrices.""); core.print_out(""The Failed Test Matrices\n""); core.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); core.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); raise TestComparisonError(""\n""); success(label); return True. [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(),; computed.nirrep())); raise TestComparisonError(message); nirreps = expected.nirrep(); for irrep in range(nirreps):; if (expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" %; (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if (abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10**(-digits)):; failed = 1; break. if (failed):; core.print_out(""The computed vector\n""); computed.print_out(); core.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry),;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:10665,Perform,Performs,10665,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['Perform'],['Performs']
Performance,"ssage); rows = expected.rows(irrep); cols = expected.cols(irrep ^ symmetry); failed = 0; for row in range(rows):; for col in range(cols):; if (abs(expected.get(irrep, row, col) - computed.get(irrep, row, col)) > 10**(-digits)):; print(""\t%s: computed value (%s) does not match (%s)."" %; (label, expected.get(irrep, row, col), computed.get(irrep, row, col))); failed = 1; break. if (failed):; print(""Check your output file for reporting of the matrices.""); core.print_out(""The Failed Test Matrices\n""); core.print_out(""Computed Matrix (2nd matrix passed in)\n""); computed.print_out(); core.print_out(""Expected Matrix (1st matrix passed in)\n""); expected.print_out(); raise TestComparisonError(""\n""); success(label); return True. [docs]def compare_vectors(expected, computed, digits, label):; """"""Function to compare two vectors. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" %; (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); nirreps = expected.nirrep(); for irrep in range(nirreps):; if (expected.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" %; (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if (abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10**(-digits)):; failed = 1; break. if (failed):; core.print_out(""The computed vector\n""); computed.print_out(); core.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" %; (label, computed.get(irrep, entry),",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html:10566,Perform,Performs,10566,psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,1,['Perform'],['Performs']
Performance,"sses for DCT amplitudes for ODC-12. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mbis-4; MBIS calculation on NaCl. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. fsapt-ext-abc; FSAPT with external charge on trimer. cdoremp-energy2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. stability3; Test LDA stability analysis against QChem. scf-level-shift-cuhf; SCF level shift on a CUHF computation. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. mints-benchmark; run some BLAS benchmarks. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fsaptd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:41348,optimiz,optimization,41348,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"sset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix – Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction) – gradient and wavefunction when return_wfn ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:4118,perform,perform,4118,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,2,['perform'],['perform']
Performance,"ssian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using finite differences of energies instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). import optking. Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:4130,optimiz,optimize,4130,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['optimiz'],['optimize']
Performance,"ssian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using finite differences of energies instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). import optking. Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶; Optking currently has two transition state algorithms. The current default is the; newer RS_I_RFO algorithm [Besalu:1998:265] . The old algorithm can be used by setting; STEP_TYPE P_RFO for OPT_TYPE ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:4149,optimiz,optimize,4149,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['optimiz'],['optimize']
Performance,"ssible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BCCD_MAXITER¶. Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CPHF_CUTOFF¶. Cutoff value for l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__ccenergy-1.html:1297,cache,cache,1297,psi4manual/1.1.0/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__ccenergy-1.html,6,['cache'],['cache']
Performance,"ssible Values: NONE, NEGLECT, MP2; Default: NONE. LOCAL_WEAKP (CCEOM); CCEOM —. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. LOCAL_WEAKP (CCLAMBDA); CCLAMBDA —. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE); CCRESPONSE —. Type: string; Default: NONE. LOCAL_WEAKP (CCSORT); CCSORT —. Type: string; Default: NONE. LOCAL_WEAKP (CIS); CIS —. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. LOCK_OCC (DCFT); DCFT — Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. M_FILE (TRANSQT); TRANSQT —. Type: integer; Default: 0. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS); GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_BUCKETS (TRANSQT); TRANSQT —. Type: integer; Default: 499. MAX_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. MAX_MOGRAD_C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:54971,perform,performed,54971,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"ssible Values: SCF; Default: SCF. Expert Convergence Control/Stabilization¶. FOLLOW_STEP_SCALE¶. When using STABILITY_ANALYSIS = FOLLOW, how much to scale the step along the eigenvector by. Type: double; Default: 0.5. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert SAD Guess Algorithm¶. SAD_CHOL_TOLERANCE¶. SAD Guess Cholesky Cutoff (for eliminating redundancies). Type: conv double; Default: 1e-7. SAD_F_MIX_START¶. SAD Guess F-mix Iteration Start. Type: integer; Default: 50. SAD_MAXITER¶. Maximum number of SAD guess iterations. Type: integer; Default: 50. SAD_PRINT¶. The amount of SAD information to print to the output. Type: integer; Default: 0. Expert DFT¶. DFT_BLOCK_MAX_POINTS¶. The maximum number of grid points per evaluation block. Type: integer; Default: 5000. DFT_BLOCK_MAX_RADIUS¶. The maximum radius to terminate subdivision of an octree block [au]. Type: double; Default: 3.0. DFT_BLOCK_MIN_POINTS¶. The minimum number of grid points per evaluation block. Type: integer; Default: 1000. DFT_BLOCK_SCHEME¶. The blocking scheme for DFT. Type: string; Possible Values: NAIVE, OCTREE; Default: OCTREE. DFT_GRID_NAME¶. The DFT grid specification, such as SG1. Type: string; Possible Values: SG0, SG1; Default: No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html:10552,LOAD,LOAD,10552,psi4manual/4.0b5/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html,2,['LOAD'],['LOAD']
Performance,"ssible Values: SCF; Default: SCF. Expert Convergence Control/Stabilization¶. FOLLOW_STEP_SCALE¶. When using STABILITY_ANALYSIS = FOLLOW, how much to scale the step along the eigenvector by. Type: double; Default: 0.5. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert SAD Guess Algorithm¶. SAD_CHOL_TOLERANCE¶. SAD Guess Cholesky Cutoff (for eliminating redundancies). Type: conv double; Default: 1e-7. SAD_F_MIX_START¶. SAD Guess F-mix Iteration Start. Type: integer; Default: 50. SAD_MAXITER¶. Maximum number of SAD guess iterations. Type: integer; Default: 50. SAD_PRINT¶. The amount of SAD information to print to the output. Type: integer; Default: 0. Expert DFT¶. DFT_BLOCK_MAX_POINTS¶. The maximum number of grid points per evaluation block. Type: integer; Default: 5000. DFT_BLOCK_MAX_RADIUS¶. The maximum radius to terminate subdivision of an octree block [au]. Type: double; Default: 3.0. DFT_BLOCK_MIN_POINTS¶. The minimum number of grid points per evaluation block. Type: integer; Default: 1000. DFT_BLOCK_SCHEME¶. The blocking scheme for DFT. Type: string; Possible Values: NAIVE, OCTREE; Default: OCTREE. DFT_GRID_NAME¶. The DFT grid specification, such as SG1. Type: string; Possible Values: SG1; Default: No Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html:9705,LOAD,LOAD,9705,psi4manual/4.0b3/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html,4,['LOAD'],['LOAD']
Performance,"ssume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print(info). # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequencies(name, **k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:50772,Perform,Perform,50772,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Perform'],['Perform']
Performance,"ss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16291,perform,perform,16291,psi4manual/1.8.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html,7,"['Optimiz', 'optimiz', 'perform']","['OptimizationConvergenceError', 'optimization', 'optimize', 'perform']"
Performance,"ss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.opt.html:16727,perform,perform,16727,psi4manual/1.9.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.opt.html,7,"['Optimiz', 'optimiz', 'perform']","['OptimizationConvergenceError', 'optimization', 'optimize', 'perform']"
Performance,"st Suite and Sample Inputs. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. CFOUR; CHEMPS2; COOKBOOK; DFTD3; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/testsuite-1.html:989,optimiz,optimizations,989,psi4manual/1.2.1/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/testsuite-1.html,2,['optimiz'],['optimizations']
Performance,"st be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into PSI4 format. Note; PSI4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in PSI4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:6794,optimiz,optimization,6794,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,9,['optimiz'],['optimization']
Performance,"st be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into Psi4 format. Note; Psi4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in Psi4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; Psi4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:6798,optimiz,optimization,6798,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['optimiz'],['optimization']
Performance,"st computing values of basis functions (puream and non-puream) at points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mbis-6; MBIS calculation on H2O. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc13b; Tests RHF CCSD(T)gradients. soscf-large; Second-order SCF convergnece: Benzene. mints-helper; A general test of the MintsHelper function. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. extern3; External potential calculation with one Ghost atom and one point charge at the same position. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc17; Single point energies of multiple excited states with EOM-CCSD. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. scf-occ; force occupations in scf. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:27747,optimiz,optimization,27747,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"st important keyword argument is ROOTS_PER_IRREP,; which is an array with the number of excited states desired; for each irreducible representation. Most ADC methods; are only supported at C1 symmetry at the moment, such that; this option should in most cases be set to an array with a single; element only. For example one can run an ADC(2) calculation for 10; (singlet) excited states using:; set roots_per_irrep [10]; properties('adc(2)', properties=[""oscillator_strength""]). where the molecule section was dropped for brevity.; Selecting the excitation manifold.; To select between the possible excitation manifolds,; use the KIND keyword. For restricted references; by default only singlet excited states are computed,; corresponding to the keyword value 'singlet'.; To compute triplet states, select 'triplet'.; To compute both without making a spin distinction, select 'any'.; The latter is default for unrestricted references.; The special KIND value 'spin_flip' selects; a spin-flip computation where a simultaneous flip of spin; and excitation is performed. This is only available; for unrestricted references and not for CVS-ADC(n) methods,; see table ADC capabilities of Psi4.; Using the core-valence separation.; For tackling core-valence excitations using the CVS-ADC(n); methods, the keyword argument NUM_CORE_ORBITALS; is additionally required. It is used to specify the number of; (spatial) orbitals to put into the core space and thus select; as target orbitals for a core-valence excitation process.; A value of 2 indicates, for example,; that the two lowest-energy \(\alpha\) and the two; lowest-energy \(\beta\) orbitals are placed in the core space.; Since the implemented ADC procedures tackle the; lowest-energy excitations, the value should be specified; such that the targeted core orbital is just inside the core space.; Example: Consider furane, \(C_4H_4O\). In order to tackle; the oxygen 1s edge, i.e simulate a O 1s XAS spectrum, one may; just set NUM_CORE_ORBITALS to 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/adc.html:5962,perform,performed,5962,psi4manual/master/adc.html,https://psicode.org,https://psicode.org/psi4manual/master/adc.html,9,['perform'],['performed']
Performance,"st, you can see the geometry string ne2_geometry has a two dashes to separate the monomers from each other. Also note we’ve used a Z-matrix to specify the geometry, and we’ve used a variable (R) as the interatomic distance. We have not specified the value of R in the ne2_geometry string like we normally would. That’s because we are going to vary it during the scan across the potential energy surface, by using a Python loop over the list of interatomic distances Rvals.; Before we are able to pass our molecule to Psi4, we need to do two things. First, we must set the value of the intermolecular separation in our Z-matrix (by using Python 3 string formatting) to the particular value of R. Second, we need to turn the Z-matrix string into a Psi4 molecule, by passing it to `psi4.geometry() <http://psicode.org/psi4manual/master/api/psi4.driver.geometry.html#psi4.driver.geometry>`__. The; argument bsse_type='cp' tells Psi4 to perform counterpoise (CP) correction on the dimer to compute the CCSD(T)/aug-cc-pVDZ interaction energy, which is stored in our ecp dictionary at each iteration of our Python loop. Note that we didn’t need to specify ghost atoms, and we didn’t need to call the monomer and dimer computations separately. Psi4 does it all for us, automatically.; Near the very end of the output file output.dat, the counterpoise correction Python function will print a nice summary of the results of the counterpoise computation (the energies of the dimer, of monomer 1 with the ghost functions of monomer 2, of monomer 2 with the ghost functions of monomer 1, and the overall counterpoise corrected interaction energy):; N-Body: Computing complex (1/2) with fragments (2,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (2,), basis = (1, 2): -128.70932405488924); ...; N-Body: Computing complex (2/2) with fragments (1,) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:20588,perform,perform,20588,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,11,['perform'],['perform']
Performance,"st-range point (R = 0.7 R_e). frac-sym; Fractional occupation with symmetry. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. options1; check all variety of options parsing. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. mbis-2; MBIS calculation on OH- (Expanded Arrays). scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fnocc3; Test FNO-QCISD(T) computation. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. cepa-module; routing check on lccd, lccsd, cepa(0). opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. aediis-2; EDIIS test case from 10.1063/1.1470195. cc56; EOM-CCSD/6-31g excited state transition data for water cation. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. scf-response2; Compute ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:22486,optimiz,optimizations,22486,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimizations']
Performance,"st; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'); core.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.set_global_option('DF_INTS_IO', 'LOAD'). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'); core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF (Dimer Basis)'); core.print_out('\n'); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs). if (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF (Dimer Basis)'); core.print_out('\n'); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.set_global_option('DF_INTS_IO', df_ints_io). core.IO.set_default_namespace('monomerAm'); core.print_out('\n'); p4util.banner('Monomer A HF (Monomer Basis)'); core.print_out('\n'); monomerAm_wfn = scf_helper('RHF', molecule=monomerAm, **kwargs). core.IO.set_default_namespace('monomerBm'); core.print_out('\n'); p4util.banner('Monomer B HF (Monomer Basis)'); core.print_out('\n'); monomerBm_wfn = scf_helper('RHF', molecule=monomerBm,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:107444,LOAD,LOAD,107444,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,9,['LOAD'],['LOAD']
Performance,"st[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). [docs]; def build_tasks(self, obj, **kwargs):; # permanently a dummy function; pass. [docs]; def plan(self):; # uncalled function; return [t.plan() for t in self.task_list.values()]. [docs]; def compute(self, client: Optional[""qcportal.FractalClient""] = None):; """"""Run each job in task list.""""""; instructions = ""\n"" + p4util.banner(f"" FiniteDifference Computations"", strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in self.task_list.values():; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = {k: v.get_results(client=client) for k, v in self.task_list.items()}. # load AtomicComputer results into findifrec[reference]; reference = self.findifrec[""reference""]; task = results_list[""reference""]; response = task.return_result; reference[""module""] = getattr(task.provenance, ""module"", None). if task.driver == 'energy':; reference['energy'] = response. elif task.driver == 'gradient':; reference['gradient'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; reference['hessian'] = response; reference['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; reference['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:46854,load,load,46854,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,3,['load'],['load']
Performance,"stallation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir. cd {top-level-psi4-dir} && cmake -S. -Bobjdir; cd {top-level-psi4-dir} && cmake -S. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration settings for a future compilation¶; Create a file like do-configure with the cmake command and options; on one line.; >>> cd {top-level-psi4-dir}; >>> cat do-configure; cmake -S. -B{objdir} \; -DCMAKE_INSTALL_PATH=""/Users/me/psi4"" \; -DCMAKE_PREFIX_PATH=""/Users/me/externals/install-libint"" \; -DMAX_AM_ERI=6 \; -DENABLE_gdma=ON \; -DBUILD_SHARED_LIBS=ON; >>> chmod u+x do-configure; >>> ./do-configure. What is the directory layout of the insta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:24091,optimiz,optimization,24091,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,9,['optimiz'],['optimization']
Performance,"stallation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to fix error “RuntimeError: value for ERI”¶; You will need to rebuild Libint. Reissue cmake or edit; CMakeCache.txt with larger MAX_AM_ERI and rebuild. How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir; cd {top-level-psi4-dir} && cmake -H. -Bobjdir; cd {top-level-psi4-dir} && cmake -H. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration settings for a future compilation¶; Create a file like do-configure with the cmake command and options; on one line.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10>>> cd {top-level-psi4-d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:18312,optimiz,optimization,18312,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,4,['optimiz'],['optimization']
Performance,"stalling PSI4¶; The latest version of the PSI4 program package may be obtained at; www.psicode.org. The; source code is available as a gzipped tar archive (named, for example,; psi4.X.tar.gz, and binaries may be available for certain architectures.; For detailed installation and testing instructions, please refer to the; installation instructions at the PSI4 website above or to the file; psi4/INSTALL distributed with the package. Additional compilation; hints may be found at Psi Compiling. Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/introduction-1.html:7083,perform,perform,7083,psi4manual/4.0b2/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html,2,['perform'],['perform']
Performance,"stance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDIN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:7778,optimiz,optimizations,7778,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,10,['optimiz'],['optimizations']
Performance,"start, start + v); start += v. molecule_total_atoms = sum(fragment_size_dict.values()). # Now compute the energies; energies_dict = {}; ptype_dict = {}; for n in compute_list.keys():; core.print_out(""\n ==> N-Body: Now computing %d-body complexes <==\n\n"" % n); total = len(compute_list[n]); for num, pair in enumerate(compute_list[n]):; core.print_out(""\n N-Body: Computing complex (%d/%d) with fragments %s in the basis of fragments %s.\n\n"" %; (num + 1, total, str(pair[0]), str(pair[1]))); ghost = list(set(pair[1]) - set(pair[0])). current_mol = molecule.extract_subsets(list(pair[0]), ghost); ptype_dict[pair] = func(method_string, molecule=current_mol, **kwargs); energies_dict[pair] = core.get_variable(""CURRENT ENERGY""); core.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" %; (str(pair[0]), str(pair[1]), energies_dict[pair])). # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # core.set_global_option('DF_INTS_IO', 'LOAD'). core.clean(). # Final dictionaries; cp_energy_by_level = {n: 0.0 for n in nbody_range}; nocp_energy_by_level = {n: 0.0 for n in nbody_range}. cp_energy_body_dict = {n: 0.0 for n in nbody_range}; nocp_energy_body_dict = {n: 0.0 for n in nbody_range}; vmfc_energy_body_dict = {n: 0.0 for n in nbody_range}. # Build out ptype dictionaries if needed; if ptype != 'energy':; if ptype == 'gradient':; arr_shape = (molecule_total_atoms, 3); elif ptype == 'hessian':; arr_shape = (molecule_total_atoms * 3, molecule_total_atoms * 3); else:; raise KeyError(""N-Body: ptype '%s' not recognized"" % ptype). cp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_by_level = {n: np.zeros(arr_shape) for n in nbody_range}. cp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; nocp_ptype_body_dict = {n: np.zeros(arr_shape) for n in nbody_range}; vmfc_ptype_body_dict = {n: np.zeros(arr_sh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html:10254,LOAD,LOAD,10254,psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_nbody.html,1,['LOAD'],['LOAD']
Performance,"starting with the HOMO. Type: integer; Default: 3. EP2_ORBITALS (DFEP2); DFEP2 — Explicitly pick orbitals to use in the EP2 method, overrides EP2_NUM_IP and EP2_NUM_EA options. Input array should be [[orb1, orb2], [], …] for each irrep. Type: array; Default: No Default. EP_EA_POLES (OCC); OCC — Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES (OCC); OCC — Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER (OCC); OCC — Maximum number of electron propagator iterations. Type: integer; Default: 30. EX_ALLOW (DETCI); DETCI (Expert) — An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. EX_LEVEL (DETCI); DETCI — The CI excitation level. Type: integer; Default: 2. EXCH_SCALE_ALPHA (SAPT); SAPT — Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. EXCITATION_RANGE (CCEOM); CCEOM (Expert) — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. EXPLICIT_HAMILTONIAN (CPHF); CPHF — Do explicit hamiltonian only?. Type: boolean; Default: false. EXTERN (SCF); SCF — An ExternalPotential (built by Python or nullptr/None). Type: boolean; Default: false. EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS); GLOBALS (Expert) — Assume external fields are arranged so that they h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:122299,perform,perform,122299,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['perform'],['perform']
Performance,"stein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/introduction-1.html:6774,Optimiz,Optimized,6774,psi4manual/4.0b3/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html,2,['Optimiz'],['Optimized']
Performance,"steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using finite differences of energies instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). import optking. Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:3621,Optimiz,Optimize,3621,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,8,"['Optimiz', 'optimiz']","['Optimize', 'optimize']"
Performance,"ster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.energy-1.html:21261,perform,perform,21261,psi4manual/1.3.2/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.energy-1.html,4,['perform'],['perform']
Performance,"ster. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MemDFJK; docstring. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NBOWriter; The Natural Bond Orbital Writer. NablaInt; Computes nabla integrals. NumIntHelper; Computes numerical integrals using a DFT grid. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. OneBodySOInt. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapInt; Computes overlap integrals. PMLocalizer; Performs Pipek-Mezey orbital localization. PetiteList; Handles symmetry transformations. PointFunctions; docstring. PointGroup; Contains information about the point group. PotentialInt; Computes potential integrals. PrimitiveType; May be Normalized or Unnormalized. Prop; docstring. ProtoIntVector. ProtoVector. PsiReturnType; Return status. QuadrupoleInt; Computes quadrupole integrals. RHF; docstring. RKSFunctions; docstring. ROHF; docstring. SADGuess; docstring. SOBasisSet; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis. SOMCSCF; docstring. SalcComponent; Component of a Cartesian displacement SALC in the basis of atomic displacements. SaveType; The layout of the matrix for saving. ShellInfo. Slice; Slicing for Matrix and Vector objects. SuperFunctional; docstring. SymmetryOperation; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection. TLaplaceDenominator; Computer class for a Laplace factor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:14051,Perform,Performs,14051,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['Perform'],['Performs']
Performance,"ster. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. fci-h2o; 6-31G H2O Test FCI Energy Point. opt11; Transition-state optimizations of HOOH to both torsional transition states. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. pywrap-db2; Database calculation, run in sow/reap mode. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. dft-custom; DFT custom functional test. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. adc2; ADC(2)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:42305,perform,performed,42305,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"story.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n'); molecule.print_in_input_format(). n += 1. optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]; def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:77301,Optimiz,OptimizationConvergenceError,77301,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,6,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimization']"
Performance,"story.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n'); molecule.print_in_input_format(). n += 1. optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:77276,Optimiz,OptimizationConvergenceError,77276,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimization']"
Performance,"string. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:2637,Perform,Perform,2637,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['Perform'],['Perform']
Performance,"string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. Table Of Contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. Previous topic; ZETA; Next topic; ABCD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccresponse-1.html:3591,CACHE,CACHELEVEL,3591,psi4manual/4.0b3/autodir_options_c/module__ccresponse-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccresponse-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. Table Of Contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. Previous topic; ZETA; Next topic; ABCD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccresponse-1.html:3591,CACHE,CACHELEVEL,3591,psi4manual/4.0b4/autodir_options_c/module__ccresponse-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccresponse-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"string; Default: No Default. BASIS (SCF); SCF — Primary basis set. Type: string; Possible Values: basis string; Default: No Default. BASIS_GUESS (SCF); SCF — Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. BCCD_MAXITER (CCENERGY); CCENERGY — Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. BENCH (GLOBALS); GLOBALS — Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC); FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be he",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:6476,optimiz,optimization,6476,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"string; Default: No Default. CFOUR_GEO_CONV¶. Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below Hartree/bohr, where is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC¶. Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP¶. Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD¶. Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:30417,optimiz,optimizations,30417,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,4,['optimiz'],"['optimizations', 'optimizer']"
Performance,"string; Default: No Default. DF_BASIS_MP2 (LMP2); LMP2 — Auxiliary basis set for MP2 density fitting calculations. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT (DFTSAPT); DFTSAPT — The name of the response auxiliary basis set. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT (SAPT); SAPT — Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (CPHF); CPHF — Auxiliary basis for SCF. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (SCF); SCF — Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_FITTING_CONDITION (SCF); SCF (Expert) — Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO (DFMP2); DFMP2 (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_IO (SCF); SCF (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_NUM_THREADS (DFMP2); DFMP2 — Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. DF_INTS_NUM_THREADS (SCF); SCF — Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. DF_LMP2 (LMP2); LMP2 — Do use density fitting? Turned on with specification of fitting basis. Type: boolean; Default: true. DF_SCF_GUESS (SCF); SCF — Use DF integrals tech to converge the SCF before switching to a conventional tech. Type: boolean; Default: true. DFCC (FNOCC); FNOCC — Do use density fitting in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. DFMP2_MEM_FACTOR (DFMP2); DFMP2 — % of memory for DF-MP2 three-index buffers. Type: double; Default: 0.9. DFM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:26399,LOAD,LOAD,26399,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['LOAD'],['LOAD']
Performance,"string; Default: SAD-FIT. DF_BASIS_SAPT (SAPT); SAPT — Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (CPHF); CPHF — Auxiliary basis for SCF. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (SCF); SCF — Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_BUMP_R0 (SCF); SCF — Bump function min radius. Type: double; Default: 0.0. DF_BUMP_R1 (SCF); SCF — Bump function max radius. Type: double; Default: 0.0. DF_DOMAINS (SCF); SCF — FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. DF_FITTING_CONDITION (SCF); SCF (Expert) — Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO (DFMP2); DFMP2 (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_IO (SCF); SCF (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_NUM_THREADS (DFMP2); DFMP2 — Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. DF_INTS_NUM_THREADS (SCF); SCF — Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. DF_METRIC (SCF); SCF — FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. DF_SCF_GUESS (SCF); SCF — Use DF integrals tech to converge the SCF before switching to a conventional tech in a SCF_TYPE DIRECT calculation. Type: boolean; Default: true. DF_THETA (SCF); SCF — FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. DFCC (FNOCC); FNOCC — Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:98814,LOAD,LOAD,98814,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,4,['LOAD'],['LOAD']
Performance,"string; Default: SAD-FIT. DF_BASIS_SAPT (SAPT); SAPT — Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (CPHF); CPHF — Auxiliary basis for SCF. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (SCF); SCF — Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_BUMP_R0 (SCF); SCF — Bump function min radius. Type: double; Default: 0.0. DF_BUMP_R1 (SCF); SCF — Bump function max radius. Type: double; Default: 0.0. DF_DOMAINS (SCF); SCF — FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. DF_FITTING_CONDITION (SCF); SCF (Expert) — Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO (DFMP2); DFMP2 (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_IO (SCF); SCF (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_NUM_THREADS (DFMP2); DFMP2 — Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. DF_INTS_NUM_THREADS (SCF); SCF — Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. DF_METRIC (SCF); SCF — FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. DF_SCF_GUESS (SCF); SCF — Use DF integrals tech to converge the SCF before switching to a conventional tech in a |scf__scf_type| DIRECT calculation. Type: boolean; Default: true. DF_THETA (SCF); SCF — FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. DFCC (FNOCC); FNOCC — Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:99115,LOAD,LOAD,99115,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,2,['LOAD'],['LOAD']
Performance,"string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with PSI4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user should not specify the entire; physical memory of the system, or swapping is likely. However, for especially large; calculations, it is better to set the memory keyword to a value less than 16 GB.; Set the CACHELEVEL keyword to 0.; This will turn off cacheing, which, for very large calculations, can; lead to heap fragmentation and memory faults, even when sufficient; physical memory exists.; Set the PRINT keyword to 2. This; will help narrow where memory bottlenecks or other errors exist in the; event of a crash. Excited State Coupled Cluster Calculations¶; A complete list of keywords related to; coupled cluster linear response is provided in Appendix CCEOM.; The most important keywords associated with EOM-CC calculations are:. ROOTS_PER_IRREP¶. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. SINGLES_PRINT¶. Do print information on the iterative solution to the single-excitation EOM-CC problem used as a gues",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cc-1.html:6623,cache,cacheing,6623,psi4manual/4.0b5/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cc-1.html,2,['cache'],['cacheing']
Performance,"string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with PSI4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user should not specify the entire; physical memory of the system, or swapping is likely. However, for especially large; calculations, it is better to set the memory keyword to a value less than 16 GB.; Set the CACHELEVEL keyword to 0.; This will turn off cacheing, which, for very large calculations, can; lead to heap fragmentation and memory faults, even when sufficient; physical memory exists.; Set the PRINT keyword to 2. This; will help narrow where memory bottlenecks or other errors exist in the; event of a crash. Excited State Coupled Cluster Calculations¶; A complete list of keywords related to; coupled cluster linear response is provided in Appendix CCEOM.; The most important keywords associated with EOM-CC calculations are:. ROOTS_PER_IRREP¶. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. SINGLES_PRINT¶. Do print information on the iterative solution to the single-excitation EOM-CC problem used as a gues",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cc-1.html:6636,cache,cacheing,6636,psi4manual/4.0b4/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cc-1.html,2,['cache'],['cacheing']
Performance,"string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with PSI4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user should not specify the entire; physical memory of the system, or swapping is likely. However, for especially large; calculations, it is better to set the memory keyword to a value less than 16 GB.; Set the CACHELEVEL keyword to 0.; This will turn off cacheing, which, for very large calculations, can; lead to heap fragmentation and memory faults, even when sufficient; physical memory exists.; Set the PRINT keyword to 2. This; will help narrow where memory bottlenecks or other errors exist in the; event of a crash. Excited State Coupled Cluster Calculations¶; A complete list of keywords related to; coupled cluster linear response is provided in Appendix CCEOM.; The most important keywords associated with EOM-CC calculations are:. ROOTS_PER_IRREP¶. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. SINGLES_PRINT¶. Do print information on the iterative solution to the single-excitation EOM-CC problem used as a guess to full EOM-CC?. Type: boolean; Default: false. SCHMIDT_ADD_RESIDUAL_TOLERANCE¶. Minimum absolu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cc-1.html:6588,cache,cacheing,6588,psi4manual/4.0b2/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cc-1.html,4,['cache'],['cacheing']
Performance,"string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with Psi4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user should not specify the entire; physical memory of the system, or swapping is likely. However, for especially large; calculations, it is better to set the memory keyword to a value less than 16 GB.; Set the CACHELEVEL keyword to 0.; This will turn off cacheing, which, for very large calculations, can; lead to heap fragmentation and memory faults, even when sufficient; physical memory exists.; Set the PRINT keyword to 2. This; will help narrow where memory bottlenecks or other errors exist in the; event of a crash. Excited State Coupled Cluster Calculations¶; A complete list of keywords related to; coupled cluster linear response is provided in Appendix CCEOM.; The most important keywords associated with EOM-CC calculations are:. ROOTS_PER_IRREP¶. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. SINGLES_PRINT¶. Do print information on the iterative solution to the single-excitation EOM-CC problem used as a gues",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cc-1.html:6687,cache,cacheing,6687,psi4manual/1.0.0/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cc-1.html,2,['cache'],['cacheing']
Performance,"stup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:18751,optimiz,optimization,18751,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"success() in module psi4.driver. sum() psi4.core.Dimension method, [1], [2]. sum_of_squares() psi4.core.Matrix method, [1], [2]. SuperFunctional class in psi4.core, [1]. symbol() psi4.core.Molecule method, [1], [2]. psi4.core.PointGroup method, [1], [2]. SYMM_TOL (OPTKING). SYMMETRIZE (OCC). symmetrize() psi4.core.Molecule method, [1], [2]. symmetrize_gradient() psi4.core.Matrix method, [1], [2]. symmetry. molecule. symmetry() psi4.core.Matrix method, [1], [2]. symmetry_from_input() psi4.core.Molecule method, [1], [2]. SymmetryOperation class in psi4.core, [1]. symnormalize() psi4.core.CIVector method, [1], [2]. T. T (THERMO). T2_COUPLED (CCENERGY). T3_WS_INCORE (CCENERGY). (CCEOM). T_AMPS (CCHBAR). Table class in psi4.driver. TDHF_MEM_SAFETY_FACTOR (CPHF). TDM (DETCI). TEST_B (OPTKING). TEST_DERIVATIVE_B (OPTKING). test_functional() psi4.core.SuperFunctional method, [1], [2]. TestComparisonError. theory. ; ADC. CC. CI. DCFT. DF-MP2. DFT. FISAPT. OEProp. OLCCD. OMP2. OMP3. Orbital-Optimized Methods. SAPT. SCF. cbs(), [1]. THETA_POINTS (SCF). THICKNESS (SCF). threading, [1]. THREE_PARTICLE (DCFT). ThreeCenterOverlapInt class in psi4.core, [1]. TIKHONOW_MAX (PSIMRCC). TIKHONOW_OMEGA (DCFT). (PSIMRCC). TIKHONOW_TRIPLES (PSIMRCC). TILE_SZ (SCF). to_array() psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. to_arrays() psi4.core.Molecule method, [1], [2]. to_dict() psi4.core.Molecule method, [1], [2]. to_schema() psi4.core.Molecule method, [1], [2]. to_serial() psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. to_string() psi4.core.Molecule method, [1], [2]. to_tuple() psi4.core.Dimension method, [1], [2]. tocclean() psi4.core.IO method, [1], [2]. tocentry_exists() psi4.core.IO method, [1], [2]. tocprint() psi4.core.IO method, [1], [2]. tocwrite() psi4.core.IO method, [1], [2]. TPDM (DETCI). tpdm() psi4.core.CIWavefunction method, [1], [2]. TPDM_ABCD_TYPE (OCC). trace() psi4.core.Matrix method, [1], [2]. psi4.core.SymmetryOperation m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:121815,Optimiz,Optimized,121815,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,"supplied for each basis set,; including heavy-augmented and Truhlar’s [Papajak:2011:10] calendar; truncations described in Table Months Bases. Fitting bases; in Tables JKFIT,; RI, and DUAL; are available for methods incorporating density-fitting or dual-basis; approximations. JKFIT sets are appropriate for fitting -type products,; such as encountered in SCF theory and the electrostatics/exchange terms of SAPT.; RI sets are appropriate for fitting -type products, such as encountered in; MP2 and most SAPT terms. Citations for basis sets can be found in their; definition files at psi4/share/basis in the source. For basis set availability by; element and the default value for keyword PUREAM, consult; Appendix Basis Sets by Element. Mixing Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizzare example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectivily omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from to ; Psi4 will detect this; automatically and run in the appropriate point group. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/basissets-1.html:2485,perform,performs,2485,psi4manual/1.0.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/basissets-1.html,2,['perform'],['performs']
Performance,"sym, initial_sym)); kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). core.set_legacy_gradient(G). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient=G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_glo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:65682,optimiz,optimization,65682,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['optimiz'],['optimization']
Performance,"symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:2559,Queue,Queue,2559,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Queue'],['Queue']
Performance,"symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. to_file([filename]); Converts a Wavefunction object to a base class. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; docstring. iteration_¶; docstring. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters. basis (str) – {‘SO’, AO’}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str) – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbitals should be returned?. Returns; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with respect to c1 symmetry if basis is AO. Return type; Matrix. Cb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:12268,perform,performed,12268,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,5,['perform'],['performed']
Performance,"system. Presently, by default, separate fragments are bonded by the; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a minimal set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default) or linear combinations of atomic positions; (automatic use of principal axes is under development).; These dimer coordinates can be directly specified through INTERFRAG_COORDS); See here <DimerSection_> for two examples of their use. Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, RS_I_RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:2643,optimiz,optimization,2643,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['optimiz'],['optimization']
Performance,"t MP2/qz2p on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_cfour.html:3049,optimiz,optimization,3049,psi4manual/master/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"t PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/testsuite-1.html:13674,perform,performed,13674,psi4manual/4.0b3/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/testsuite-1.html,4,['perform'],['performed']
Performance,"t a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. IGNORE_TAU (DCFT); DCFT (Expert) — Controls whether to ignore terms containing non-idempotent contribution to OPDM or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: false. INTCO_FIXED_EQ_FORCE_CONSTANT (OPTKING); OPTKING — In constrained optimizations, for internal coordinates with user-specified equilibrium values, this is the force constant (in au) used to apply an additional force to each coordinate. If the user is only concerned to satify the desired constraint, then the user need only ensure that this value is sufficiently large. Alternatively, the user may specify this value to apply a force of a particular magnitude, in which case the given equilibrium value may or may not be reached by the optimization. Type: double; Default: 2.0. INTCOS_GENERATE_EXIT (OPTKING); OPTKING — Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. INTERFRAG_DIST_INV (OPTKING); OPTKING — Do use for the stretching coordinate between fragments? Otherwise, use . Type: boolean; Default: false. INTERFRAG_HESS (OPTKING); OPTKING — Model Hessian to guess interfragment force constants. Type: string; Possible Values: DEFAULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE (OPTKING); OPTKING — When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, INTERFRAGMENT; Default: FIXED. INTERFRAG_STEP_LIMIT (OPTKING); OPTKING — Maximum step size in bohr or radian along an interfragment coordinate. Type: double; Default: 0.4. INTERFRAGMENT_CONNECT (OPTKING); OPTKING — When connecting disparate ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:58005,optimiz,optimization,58005,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"t a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. IGNORE_TAU (DCFT); DCFT (Expert) — Controls whether to ignore terms containing non-idempotent contribution to OPDM or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: false. INTCO_FIXED_EQ_FORCE_CONSTANT (OPTKING); OPTKING — In constrained optimizations, for internal coordinates with user-specified equilibrium values, this is the force constant (in au) used to apply an additional force to each coordinate. If the user is only concerned to satify the desired constraint, then the user need only ensure that this value is sufficiently large. Alternatively, the user may specify this value to apply a force of a particular magnitude, in which case the given equilibrium value may or may not be reached by the optimization. Type: double; Default: 2.0. INTCOS_GENERATE_EXIT (OPTKING); OPTKING — Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. INTERFRAG_DIST_INV (OPTKING); OPTKING — Do use for the stretching coordinate between fragments? Otherwise, use . Type: boolean; Default: false. INTERFRAG_HESS (OPTKING); OPTKING — Model Hessian to guess interfragment force constants. Type: string; Possible Values: DEFAULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE (OPTKING); OPTKING — When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, INTERFRAGMENT; Default: FIXED. INTERFRAG_STEP_LIMIT (OPTKING); OPTKING — Maximum step size in bohr or radian along an interfragment coordinate. Type: double; Default: 0.4. INTERNAL_ROTATIONS (MCSCF); MCSCF — Do consider internal rotations?. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:54397,optimiz,optimization,54397,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"t al., JCP 104, 8007 (1996). dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. numpy-array-interface; Numpy interface testing. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. pywrap-align; apply linear fragmentation algorithm to a water cluster. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. dfcasscf-sp; CASSCF/6-31G** energy point. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. cbs-xtpl-dict; Extrapolated water energies. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:20955,perform,performing,20955,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performing']
Performance,"t and dict serialization passed to; :func:`numpy.savez`, so ``.npz`` file saved and None returned.; When `filename` None, dict serialization returned. """"""; ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; # If returning arrays to user, we want to return copies (snapshot), not; # views of the core.Matrix's memory.; if filename is None and not v.flags['OWNDATA']:; v = np.copy(v); ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def _np_read(; self: Union[core.Matrix, core.Vector],; filename: str,; prefix: str = """",; ) -> Union[core.Matrix, core.Vector]:; """"""Reads the data from a NumPy compressed or uncompressed file using :func:`numpy.load`. Parameters; ----------; self; Pointer to which class to be constructed.; filename; File name to read.; prefix; Name under which array was saved for NumPy.; """""". if isinstance(filename, np.lib.npyio.NpzFile):; data = filename; elif isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:10644,load,load,10644,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,2,['load'],['load']
Performance,"t applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below Hartree/bohr, where is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR); CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Mi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:47905,optimiz,optimization,47905,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"t atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. mom-h2o-3; MOM excitation from LUMO HOMO+3. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. sapt10; usapt example with empty beta due to frozen core. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. opt1-fd; SCF STO-3G geometry optimzation, with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:12672,perform,performed,12672,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"t below). Density Cumulant Functional Theory (DCFT)¶; PSI4 features several formulations of newly-developed density cumulant; functional theory (DCFT). The theory and benchmark of this theory are; discussed in the following papers:; DC-06 (also known as DCFT-06):. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). ODC-06 and ODC-12:. “Orbital-optimized density cumulant functional theory,” A. Yu. Sokolov, and; H. F. Schaefer, J. Chem. Phys. 139, 204110 (2013).; (doi: 10.1063/1.4833138). ODC-13:. “Density cumulant functional theory from a unitary transformation:; N-representability, three-particle correlation effects, and application; to O4+,” A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,; J. Chem. Phys. 141, 074111 (2014).; (doi: 10.1063/1.4892946). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:5463,optimiz,optimized,5463,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,4,['optimiz'],['optimized']
Performance,"t below). Density Cumulant Functional Theory (DCFT)¶; Psi4 features several formulations of newly-developed density cumulant; functional theory (DCFT). The theory and benchmark of this theory are; discussed in the following papers:; DC-06 (also known as DCFT-06):. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). ODC-06 and ODC-12:. “Orbital-optimized density cumulant functional theory,” A. Yu. Sokolov, and; H. F. Schaefer, J. Chem. Phys. 139, 204110 (2013).; (doi: 10.1063/1.4833138). ODC-13:. “Density cumulant functional theory from a unitary transformation:; N-representability, three-particle correlation effects, and application; to O4+,” A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,; J. Chem. Phys. 141, 074111 (2014).; (doi: 10.1063/1.4892946). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:3673,optimiz,optimized,3673,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,2,['optimiz'],['optimized']
Performance,"t but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:24114,optimiz,optimization,24114,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['optimiz'],['optimization']
Performance,"t calculation. run_detcas(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF. run_detci(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. run_detci_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. run_dfmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. run_dfmp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. run_dfmp2_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 property calculation. run_dfocc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. run_dfocc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. run_dfocc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. run_dft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory calculation. run_dft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. run_dft_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; DFT calculations. This is a simple alias to run_scf(); since DFT properties all handled through oeprop. run_dmrgci(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an DMRG calculation. run_dmrg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:162251,optimiz,optimized,162251,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance,"t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code/objdir/stage//usr/local/psi4/lib/')); except ImportError:; pass. # This is the important part; import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4 will print any output to the screen; this can be changed by giving a file name (with path if not in the current working directory) to the function psi4.core.set_output_file() :psicode:[API] <psi4manual/master/api/psi4.core.set_output_file> , as a string:. [2]:. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psiapi.html:1424,load,loaded,1424,psi4manual/1.6.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psiapi.html,2,['load'],['loaded']
Performance,"t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code/objdir/stage//usr/local/psi4/lib/')); except ImportError:; pass. # This is the important part; import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4 will print any output to the screen; this can be changed by giving a file name (with path if not in the current working directory) to the function psi4.core.set_output_file() API, as a string:. [2]:. psi4.core.set_output_file('output.dat', False). Additionally, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psiapi-1.html:1424,load,loaded,1424,psi4manual/1.4.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psiapi-1.html,4,['load'],['loaded']
Performance,"t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/home/runner/work/psi4/psi4/code/objdir/stage//usr/local/psi4/lib/')); except ImportError:; pass. # This is the important part; import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4 will print any output to the screen; this can be changed by giving a file name (with path if not in the current working directory) to the function psi4.set_output_file() API, as a string:. [3]:. psi4.set_output_file('output.dat', False). Additionally, output may",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:1433,load,loaded,1433,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,2,['load'],['loaded']
Performance,"t have psi4. in front, then submit it to the executable psi4 which processes the Psithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top, and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Note: PsiAPI mode has been available since late 2016 and the v1.1 release. While we aim to provide deprecation warnings and upgrade helpers, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Here, we will explore the basics of using Psi4 in the interactive PsiAPI style where it is loaded directly as a Python module by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. # Ignore this block -- it's for the documentation build; try:; import os, sys; sys.path.insert(1, os.path.abspath('/psi/gits/hrw-demo/objdir_docs311cf_make/stage//usr/local/psi4/lib/')); except ImportError:; pass. # This is the important part; import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4 will print any output to the screen; this can be changed by giving a file name (with path if not in the current working directory) to the function psi4.core.set_output_file() :psicode:[API] <psi4manual/master/api/psi4.core.set_output_file> , as a string:. [2]:.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psiapi.html:1426,load,loaded,1426,psi4manual/1.8.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psiapi.html,1,['load'],['loaded']
Performance,"t in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~driver_cbs.complete_basis_set` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sherrill Group Gold Standard'; return driver_cbs.cbs(func, label, **kwargs). [docs]def allen_focal_point(func, label, **kwargs):; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; :py:func:`~driver_cbs.complet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/aliases.html:3678,optimiz,optimization,3678,psi4manual/1.0.0/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/aliases.html,8,['optimiz'],"['optimization', 'optimize']"
Performance,"t individual integral objects for correctness. mp2-1; All-electron MP2 6-31G** geometry optimization of water. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. fci-coverage; 6-31G H2O Test for coverage. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tdscf-1; td-uhf test on triplet states of methylene (rpa). sad-scf-type; Test SAD SCF guesses on noble gas atom. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. props4; Electrostatic potential and electric field evaluated on a grid around water. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. pywrap-checkrun-uhf; This checks that all energy me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:24733,perform,performed,24733,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"t is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CPHF); CPHF — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (CPHF); CPHF — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:10315,CACHE,CACHELEVEL,10315,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"t is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; Some existing examples are below. psi4.driver.aliases.sherrill_gold_standard(**kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2().; :rtype: List[Dict[str, Any]]. \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). Return type:; List[Dict[str, Any]]. psi4.driver.aliases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code.; :rtype: List[Dict[str, Any]]. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cbs.html:31138,optimiz,optimization,31138,psi4manual/master/cbs.html,https://psicode.org,https://psicode.org/psi4manual/master/cbs.html,6,['optimiz'],"['optimization', 'optimize']"
Performance,"t matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the sam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:105136,load,load,105136,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['load'],['load']
Performance,"t matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:10613,load,load,10613,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"t method. Functional class in psi4.core. functional() psi4.core.HF method. psi4.core.VBase method. functionals. functions_local_to_global() psi4.core.BlockOPoints method. fx() psi4.core.Molecule method. fy() psi4.core.Molecule method. fZ() psi4.core.Molecule method. fz() psi4.core.Molecule method. fzc() psi4.core.MOSpace static method. fzv() psi4.core.MOSpace static method. G. G_CONVERGENCE (OPTKING). gamma psi4.driver.p4util.Lineshape attribute. gamma() psi4.core.CharacterTable method. gau2grid. GAUGE (ADC). (CCDENSITY). (CCRESPONSE). Gaussian class in psi4.driver.p4util. Gaussian Formatted Checkpoint. GaussianShell class in psi4.core. GaussianType class in psi4.core. gCP. GDMA. gdma() in module psi4.driver. GDMA_LIMIT (GDMA). GDMA_MULTIPOLE_UNITS (GDMA). GDMA_ORIGIN (GDMA). GDMA_RADIUS (GDMA). GDMA_SWITCH (GDMA). gemm() psi4.core.Matrix method. genbas() psi4.core.BasisSet method. general. ; setting keywords. general_invert() psi4.core.Matrix method. GEOM_MAXITER (OPTKING). geometry optimization. ; constrained. convergence criteria. function call. IRC. minima. output. transition state. geometry optimization, optimization. geometry() in module psi4.driver. psi4.core.Molecule method. GeometryUnits class in psi4.core. get() psi4.core.IntVector method. psi4.core.Matrix method. psi4.core.Vector method. get_active_molecule() in module psi4.core. get_algorithm() psi4.core.FittingMetric method. get_amplitudes() psi4.core.CCWavefunction method. get_AO_core() psi4.core.DFHelper method. get_AO_size() psi4.core.DFHelper method. get_array() psi4.core.Wavefunction method. get_array_variable() in module psi4.core. get_array_variables() in module psi4.core. get_basisset() psi4.core.Wavefunction method. get_block() psi4.core.IntVector method. psi4.core.Matrix method. psi4.core.VBase method. psi4.core.Vector method. get_bool() psi4.core.Options method. get_current_module() psi4.core.Options method. get_datadir() in module psi4.core. get_default_namespace() psi4.core.IO static method.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:55799,optimiz,optimization,55799,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['optimiz'],['optimization']
Performance,"t of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. pywrap-align; apply linear fragmentation algorithm to a water cluster. scf-level-shift-rks; SCF level shift on an RKS computation. fci-coverage; 6-31G H2O Test for coverage. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mints-helper; A general test of the MintsHelper function. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. mints8; Patch of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:44484,optimiz,optimization,44484,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"t reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. omp2.5; Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. olccd; Orbital-Optimized Linear CCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE CONV. Density-Fitted Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE DF. Cholesky-Decomposed Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; —; CC_TYPE CD. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:9868,Optimiz,Optimized,9868,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,11,['Optimiz'],['Optimized']
Performance,"t screening!. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc54; CCSD dipole with user-specified basis set. cubeprop; RHF orbitals and density for water. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. sapt11; sapt example with orbital freezing with alkali metal and dMP2. scf-guess-read2; Test if the the guess read in the same basis converges. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. mints-benchmark; run some BLAS benchmarks. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. linK-1; RHF Linear Exchang",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:2381,optimiz,optimizations,2381,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimizations']
Performance,"t symmetry operation. d is; hardwired to 5x5 since the H irrep in Ih is 5 dimensional. E()[source]¶; Set equal to the identity. SymmetryOperation()[source]¶; Cast SymRep to SymmetryOperation. c2_x()[source]¶; Set equal to C2 about the x axis. c2_y()[source]¶; Set equal to C2 about the y axis. c2_z()[source]¶; Set equal to C2 about the z axis. constructor_order(i)[source]¶; Initialize order only. constructor_symmetryoperation(so)[source]¶; Initialize from 3x3 SymmetryOperation. i()[source]¶; Set equal to an inversion. operate(r)[source]¶; This operates on this with r (i.e. return r * this). rotation(theta)[source]¶; Set equal to a clockwise rotation by 2pi/n or theta degrees. set_dim(i)[source]¶; Set the dimension of d. sigma_h()[source]¶; Set equal to reflection in xy plane. sigma_xz()[source]¶; Set equal to reflection in xz plane. sigma_yz()[source]¶; Set equal to reflection in yz plane. trace()[source]¶; returns the trace of the transformation matrix. transform(r)[source]¶; This performs the transform r * this * r~. unit()[source]¶; Set equal to a unit matrix. zero()[source]¶; zero out the symop. class SymmetryOperation(*args)[source]¶; The SymmetryOperation class provides a 3 by 3 matrix; representation of a symmetry operation, such as a rotation or reflection. E()[source]¶; Set equal to E. analyze_d()[source]¶. bit()[source]¶; Get the bit value. c2_x()[source]¶; Set equal to C2 about the x axis. c2_y()[source]¶; Set equal to C2 about the y axis. c2_z()[source]¶; Set equal to C2 about the z axis. constructor_symmetryoperation(so)[source]¶. i()[source]¶; Set equal to an inversion. operate(r)[source]¶; This operates on this with r (i.e. return r * this). rotation(theta)[source]¶; Set equal to a clockwise rotation by 2pi/n or theta degrees. sigma_xy()[source]¶; Set equal to reflection in xy plane. sigma_xz()[source]¶; Set equal to reflection in xz plane. sigma_yz()[source]¶; Set equal to reflection in yz plane. trace()[source]¶; returns the trace of the transformati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:16469,perform,performs,16469,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performs']
Performance,"t to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic posit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:2006,optimiz,optimizations,2006,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,2,['optimiz'],['optimizations']
Performance,"t with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent.; SOSCF [Off by Default]; See Second-order Convergence. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if INTS_TOLERANCE; is set to 1.0E-8 or so.; DF [Default]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:20969,bottleneck,bottleneck,20969,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['bottleneck'],['bottleneck']
Performance,"t(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); if core.get_option('FNOCC', 'NAT_ORBS'):; mints = core.MintsHelper(ref_wfn.basisset()); mints.set_print(1); mints.integrals(). core.mrcc_generate_input(ref_wfn, level); ref_wfn.set_module(""mrcc""). # Load the fort.56 file; # and dump a copy into the outfile; core.print_out('\n===== Begin fort.56 input for MRCC ======\n'); core.print_out(open('fort.56', 'r').read()); core.print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:163989,Load,Load,163989,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,2,['Load'],['Load']
Performance,"t(round(damping_percentage))). if verbose > 3:; self.Ca().print_out(); self.Cb().print_out(); self.Da().print_out(); self.Db().print_out(). # Print out the iteration; core.print_out("" @%s%s iter %3s: %20.14f %12.5e %-11.5e %s\n"" %; (""DF-"" if is_dfjk else """", reference, ""SAD"" if ((self.iteration_ == 0) and self.sad_) else self.iteration_, SCFE, Ediff, Dnorm, '/'.join(status))). # if a an excited MOM is requested but not started, don't stop yet; if self.MOM_excited_ and not self.MOM_performed_:; continue. # if a fractional occupation is requested but not started, don't stop yet; if frac_enabled and not self.frac_performed_:; continue. # Call any postiteration callbacks; if not ((self.iteration_ == 0) and self.sad_) and _converged(Ediff, Dnorm, e_conv=e_conv, d_conv=d_conv):; break; if self.iteration_ >= core.get_option('SCF', 'MAXITER'):; raise SCFConvergenceError(""""""SCF iterations"""""", self.iteration_, self, Ediff, Dnorm). def scf_finalize_energy(self):; """"""Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. """""". # post-scf vv10 correlation; if core.get_option('SCF', ""DFT_VV10_POSTSCF"") and self.functional().vv10_b() > 0.0:; self.functional().set_lock(False); self.functional().set_do_vv10(True); self.functional().set_lock(True); core.print_out("" ==> Computing Non-Self-Consistent VV10 Energy Correction <==\n\n""); SCFE = 0.0; self.form_V(); SCFE += self.compute_E(); self.set_energies(""Total Energy"", SCFE). # Perform wavefunction stability analysis before doing; # anything on a wavefunction that may not be truly converged.; if core.get_option('SCF', 'STABILITY_ANALYSIS') != ""NONE"":. # Don't bother computing needed integrals if we can't do anything with them.; if self.functional().needs_xc():; raise ValidationError(""Stability analysis not yet supported for XC functionals.""). # We need the integral fil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:13869,Perform,Performs,13869,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['Perform'],['Performs']
Performance,"t(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vect",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:105552,Load,Load,105552,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['Load'],['Load']
Performance,"t(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None¶; Print the matrix with atom labels, assuming ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:11029,Load,Load,11029,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['Load'],['Load']
Performance,"t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; Presently (May 2016), only two of the five delta possibilities are active. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:12280,perform,performed,12280,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,4,['perform'],['performed']
Performance,"t); include/ (installed headers for psi4 + any external proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.h (primary psi4 header); include/psi4/masses.h (a project-wide psi4 header); include/psi4/libmints/ (psi4 library headers); include/psi4/libfock/ (ditto); share/ (read-only arch-indep files for psi4 + any external proj); share/cmake/psi4/ (files for detecting installed targets); share/cmake/psi4/psi4Config.cmake (psi4 build/install info); share/cmake/psi4/psi4ConfigVersion.cmake (psi4 version info); share/doc/psi4/html/ (sphinx html documentation); share/psi4/ (text files needed by psi4); share/psi4/basis (basis sets); share/psi4/plugins (plugin template files); share/psi4/fsapt (fsapt scripts); share/psi4/samples/ (sample input files); lib/ (shared libraries and py modules for psi4 + any external proj); # ordinary; lib/psi4/ (object files); lib/psi4/driver/ (py-side, uncompiled); lib/psi4/header.py (prints file header); lib/psi4/__init__.py (module marker/loader for psi4.core); lib/psi4/core.so (c-side, compiled and bound by pybind11); # conda; lib/pythonX.X/site-packages/psi4/. The following environment variables point to certain places in the above; directory structure. None to few need to be set; see for details:; running compiled executable,; running compiled Python module,; running conda binary. PATH pointing to bin; PYTHONPATH pointing to lib (ordinary) or lib/pythonX.X/site-packages (conda); PSIDATADIR pointing to share/psi4. How to run Psi4 as executable after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage/prefix for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:18190,load,loader,18190,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['load'],['loader']
Performance,"t, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.molutil import *; from psi4.driver.p4util.exceptions import *; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.energy` or :py:func:`~psi4.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:2051,optimiz,optimize,2051,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,3,['optimiz'],['optimize']
Performance,"t, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None; Loads a matrix from an ASCII file in MPQC format. name; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int; Returns the number of irreps. np; View without only one irrep. classmethod np_read(filename, prefix=''); Reads the data from a NumPy compress file. np_write(filename=None, prefix=''); Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:21597,Load,Load,21597,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,1,['Load'],['Load']
Performance,"t-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/kw-2; testing best practices options, part ii. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/mp2-1; All-electron MP2 6-31G** geometry op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_cfour.html:1167,optimiz,optimization,1167,psi4manual/master/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"t-xdist. PSI4 Documentation (available pre-built at psicode.org/psi4manual/master/index.html). Sphinx (3.5+) http://sphinx-doc.org; Perl (for some auto-documentation scripts) https://www.perl.org/; nbsphinx (for converting Jupyter notebooks) http://nbsphinx.readthedocs.io/en/jupyter-theme/; sphinx-psi-theme https://github.com/psi4/sphinx-psi-theme; See [“message” lines] for advice on obtaining docs dependencies or [conda env spec]; See psi4/.github/workflows/docs.yml for full docs building procedure to follow. Ambit — https://github.com/jturney/ambit; CheMPS2 — [what is CheMPS2?] [CheMPS2 min version]. HDF5 https://support.hdfgroup.org/HDF5/; zlib http://www.zlib.net/. ecpint — [what is ecpint?] [ecpint min version]; dkh — [what is dkh?] [dkh min version]. Fortran Compiler. gdma — [what is gdma?] [gdma min version]. Fortran Compiler. PCMSolver — [what is PCMSolver?]. Fortran Compiler; zlib http://www.zlib.net/. simint — [what is simint?] [simint min version]. Additionally, there are runtime-loaded capabilities:. PylibEFP & libefp — [what is LibEFP?] [LibEFP min version]; cfour — [what is CFOUR?]; dftd3 — [what is DFTD3?]; simple-dftd3 — [what is DFTD3?] (Nov 2022; added by v1.7) preferred alternative to dftd3 https://github.com/dftd3/simple-dftd3; gcp — [what is gCP?]; mctc-gcp — [what is gCP?] (Nov 2022; added by v1.7) preferred alternative to gcp https://github.com/grimme-lab/gcp; dftd4 — <sec:dftd3> https://github.com/dftd4/dftd4; mrcc — [what is MPCC?]; v2rdm_casscf — [what is v2rdm_casscf?]; sns-mp2 — https://github.com/DEShawResearch/sns-mp2/commits/master; resp — https://github.com/cdsgroup/resp; gpu_dfcc — https://github.com/edeprince3/gpu_dfcc/commits/master; OpenFermion-Psi4 — https://github.com/quantumlib/OpenFermion; cppe — https://github.com/maxscheurer/cppe; mp2d — https://github.com/Chandemonium/MP2D; FockCI — https://github.com/shannonhouck/psi4fockci; cct3 — https://github.com/piecuch-group/cct3; adcc — https://github.com/adc-connect/adcc; BrianQC —",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:8721,load,loaded,8721,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,3,['load'],['loaded']
Performance,"t. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: str; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: str; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: str; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: str; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: str; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates the inferior ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html:36023,perform,performed,36023,psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver_cbs.html,8,['perform'],['performed']
Performance,"t. 10, 4417 (2014).; (doi: 10.1021/ct500724p).; “Communication: Practical Intramolecular Symmetry Adapted Perturbation Theory; via Hartree-Fock Embedding,”; R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C. D. Sherrill,; J. Chem. Phys. 143, 051103 (2015).; (doi: 10.1063/1.4927575). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:13481,Optimiz,Optimized,13481,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,6,['Optimiz'],['Optimized']
Performance,"t. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); psi4.wavefunction().energy(). optstash.restore(); return psi4.get_variable('CURRENT ENERGY'). else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:36026,optimiz,optimization,36026,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['optimiz'],['optimization']
Performance,"t. LOCAL_WEAKP¶. Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. PROP_ALL¶. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes?. Type: boolean; Default: false. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. JOBTYPE¶. Type of job being performed. Type: string; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: NONE. Table Of Contents. CCLAMBDA; General; ABCD; AO_BASIS; CACHELEVEL; CAS_FILES_WRITE; DIIS; FOLLOW_ROOT; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; RESTART; ROOTS_PER_IRREP; R_CONVERGENCE; SEKINO; ZETA. Expert; JOBTYPE; WFN. Previous topic; WFN; Next topic; ABCD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__cclambda-1.html:3353,perform,performed,3353,psi4manual/4.0b5/autodir_options_c/module__cclambda-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__cclambda-1.html,4,"['CACHE', 'perform']","['CACHELEVEL', 'performed']"
Performance,"t.__setattr__(self, name, value). [docs]def new_get_attr(self, name):; """"""Function to redefine __getattr__ method of molecule class.""""""; fxn = object.__getattribute__(self, ""is_variable""); isvar = fxn(name). if isvar:; fxn = object.__getattribute__(self, ""get_variable""); return fxn(name). return object.__getattribute__(self, name). [docs]def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while White or Queue: # Iterates to the next fragment; Fragment.append([]). while Queue: # BFS within a fragment; for u in Queue: # find all white neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt(; (self.x(i) - self.x(u)) ** 2 +; (self.y(i) - self.y(u)) ** 2 +; (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + \; vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # & remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html:5780,Queue,Queue,5780,psi4manual/1.0.0/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html,1,['Queue'],['Queue']
Performance,"t.__setattr__(self, name, value). [docs]def new_get_attr(self, name):; """"""Function to redefine __getattr__ method of molecule class.""""""; fxn = object.__getattribute__(self, ""is_variable""); isvar = fxn(name). if isvar:; fxn = object.__getattribute__(self, ""get_variable""); return fxn(name). return object.__getattribute__(self, name). [docs]def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].appen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:5863,Queue,Queue,5863,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Queue'],['Queue']
Performance,"t3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. scf7; Tests SCF gradient in the presence of a dipole field. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. mints-helper; A general test of the MintsHelper function. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). scf-upcast-custom-basis; test scf castup with custom basis sets. dct10; The multiple guesses for DCT amplitudes for ODC-12. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. sapt-ecp; sapt0 of charged system in ECP basis set. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cbs-xtpl-alpha; Extrapolated water energies. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:21186,optimiz,optimizations,21186,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimizations']
Performance,"t: 1.27. CEPA_SOS_SCALE¶. CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE¶. CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER¶. Maximum number of electron propagator iterations. Type: integer; Default: 30. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__occ-1.html:2257,perform,perform,2257,psi4manual/1.0.0/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__occ-1.html,24,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"t: 150. FITTING_ALGORITHM (CPHF); CPHF — Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. FITTING_CONDITION (CPHF); CPHF — The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOCK_TOLERANCE (LMP2); LMP2 — Minimum absolute value below which parts of the Fock matrix are skipped. Type: conv double; Default: 1e-2. FOLLOW (STABILITY); STABILITY — Do follow the most negative eigenvalue of the Hessian towards a lower energy HF solution? Follow a UHF UHF instability of same symmetry?. Type: boolean; Default: false. FOLLOW_ROOT (CLAG); CLAG — Root to get OPDM. Type: integer; Default: 1. FOLLOW_ROOT (DETCI); DETCI — The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 1. FOLLOW_ROOT (MCSCF); MCSCF — Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FOLLOW_ROOT (PSIMRCC); PSIMRCC — Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FOLLOW_STEP_SCALE (SCF); SCF (Expert) — When using STABILITY_ANALYSIS = FOLLOW, how much to scale the step along the eigenvector by. Type: double; Default: 0.5. FOLLOW_VECTOR (DETCI); DETCI (Expert) — In following a particular root (see FOLLOW_ROOT), sometimes the root number changes. To follow a root of a particular character, one can specify a list of determinants and their coefficients, and the code will follow the root with the closest overlap. The user specifies arrays containing the absolute alpha string indices (A_i below), absolute beta indices (B_i below), and CI coefficients (C_i below) to form the desired vector. The format is FOLLOW_VECTOR = [ [[A_1, B_1], C_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:45455,optimiz,optimization,45455,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimization']
Performance,"t: 150. FITTING_ALGORITHM (CPHF); CPHF — Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. FITTING_CONDITION (CPHF); CPHF — The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOCK_TOLERANCE (LMP2); LMP2 — Minimum absolute value below which parts of the Fock matrix are skipped. Type: conv double; Default: 1e-2. FOLLOW (STABILITY); STABILITY — Do follow the most negative eigenvalue of the Hessian towards a lower energy HF solution? Follow a UHF UHF instability of same symmetry?. Type: boolean; Default: false. FOLLOW_ROOT (CLAG); CLAG — Root to get OPDM. Type: integer; Default: 1. FOLLOW_ROOT (DETCI); DETCI — The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 1. FOLLOW_ROOT (MCSCF); MCSCF — Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FOLLOW_ROOT (PSIMRCC); PSIMRCC — Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FOLLOW_VECTOR (DETCI); DETCI (Expert) — In following a particular root (see FOLLOW_ROOT), sometimes the root number changes. To follow a root of a particular character, one can specify a list of determinants and their coefficients, and the code will follow the root with the closest overlap. The user specifies arrays containing the absolute alpha string indices (A_i below), absolute beta indices (B_i below), and CI coefficients (C_i below) to form the desired vector. The format is FOLLOW_VECTOR = [ [[A_1, B_1], C_1], [[A_2, B_2], C_2], ...]. Type: array; Default: No Default. FORCE_RESTART (CCENERGY); CCENERGY (Expert) — Do restart the coupled-cluster iterations even if MO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:33774,optimiz,optimization,33774,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"t: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM —. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR —. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA —. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT —. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 —. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 —. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM —. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (MP2); MP2 — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:6629,CACHE,CACHELEVEL,6629,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"t: 2.5. AVG_STATES (DETCI); DETCI — Array giving the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 0. Type: array; Default: No Default. AVG_WEIGHTS (DETCI); DETCI — Array giving the weights for each state in a state-averaged procedure. Type: array; Default: No Default. B_RAS3_MAX (DETCI); DETCI — maximum number of beta electrons in RAS III. Type: integer; Default: -1. BASIS (DFMP2); DFMP2 — Primary basis set. Type: string; Possible Values: basis string; Default: NONE. BASIS (MINTS); MINTS — Primary basis set. Available basis sets. Type: string; Possible Values: basis string; Default: No Default. BASIS (SAPT); SAPT — Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. BASIS (SCF); SCF — Primary basis set. Type: string; Possible Values: basis string; Default: No Default. BASIS_GUESS (SCF); SCF — Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. BASIS_RELATIVISTIC (GLOBALS); GLOBALS — Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. BCCD_MAXITER (CCENERGY); CCENERGY — Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. BENCH (GLOBALS); GLOBALS — Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC); FNOCC — Maximum number of iterations for B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:5476,perform,performing,5476,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['perform'],['performing']
Performance,"t: 2.5. AVG_STATES (DETCI); DETCI — Array giving the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 1. Type: array; Default: No Default. AVG_WEIGHTS (DETCI); DETCI — Array giving the weights for each state in a state-averaged procedure. Type: array; Default: No Default. B_RAS3_MAX (DETCI); DETCI — maximum number of beta electrons in RAS III. Type: integer; Default: -1. BASIS (DFMP2); DFMP2 — Primary basis set. Type: string; Possible Values: basis string; Default: NONE. BASIS (MINTS); MINTS — Primary basis set. Available basis sets. Type: string; Possible Values: basis string; Default: No Default. BASIS (SAPT); SAPT — Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. BASIS (SCF); SCF — Primary basis set. Type: string; Possible Values: basis string; Default: No Default. BASIS_GUESS (SCF); SCF — Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. BCCD_MAXITER (CCENERGY); CCENERGY — Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. BENCH (GLOBALS); GLOBALS — Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC); FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined bas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:5622,perform,performing,5622,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performing']
Performance,"t: C. FISAPT_LINK_SELECTION (FISAPT); FISAPT — Specification algorithm for link bonds in ISAPT. Type: string; Possible Values: AUTOMATIC, MANUAL; Default: AUTOMATIC. FISAPT_MANUAL_LINKS (FISAPT); FISAPT — Manual link bond specification [[Atom1, Atom2], ...]. Type: array; Default: No Default. FISAPT_MEM_SAFETY_FACTOR (FISAPT); FISAPT (Expert) — Memory safety factor for heavy FISAPT operations. Type: double; Default: 0.9. FISAPT_PLOT_FILEPATH (FISAPT); FISAPT — Filepath to drop scalar data. Type: string; Default: plot/. FITTING_ALGORITHM (CPHF); CPHF — Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. FITTING_CONDITION (CPHF); CPHF — The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. FIXED_BEND (OPTKING); OPTKING — Specify angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_COORD_FORCE_CONSTANT (OPTKING); OPTKING — In constrained optimizations, for coordinates with user-specified equilibrium values, this is the initial force constant (in au) used to apply an additional force to each coordinate. Type: double; Default: 0.5. FIXED_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOLLOW_ROOT (DETCI); DETCI — The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 0. FOLLOW_ROOT (MCSCF); MCSCF — Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FOLLOW_ROOT (PSIMRCC); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:125804,optimiz,optimizations,125804,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimizations']
Performance,"t: C. FISAPT_LINK_SELECTION (FISAPT); FISAPT — Specification algorithm for link bonds in ISAPT. Type: string; Possible Values: AUTOMATIC, MANUAL; Default: AUTOMATIC. FISAPT_MANUAL_LINKS (FISAPT); FISAPT — Manual link bond specification [[Atom1, Atom2], ...]. Type: array; Default: No Default. FISAPT_MEM_SAFETY_FACTOR (FISAPT); FISAPT (Expert) — Memory safety factor for heavy FISAPT operations. Type: double; Default: 0.9. FISAPT_PLOT_FILEPATH (FISAPT); FISAPT — Filepath to drop scalar data. Type: string; Default: plot/. FITTING_ALGORITHM (CPHF); CPHF — Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. FITTING_CONDITION (CPHF); CPHF — The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. FIXED_BEND (OPTKING); OPTKING — Specify angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_COORD_FORCE_CONSTANT (OPTKING); OPTKING — In constrained optimizations, for coordinates with user-specified equilibrium values, this is the initial force constant (in au) used to apply an additional force to each coordinate. Type: double; Default: 0.5. FIXED_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOLLOW_ROOT (DETCI); DETCI — The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 1. FOLLOW_ROOT (MCSCF); MCSCF — Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FOLLOW_ROOT (PSIMRCC); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:124867,optimiz,optimizations,124867,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimizations']
Performance,"t: WERNER. LOCAL_PAIRDEF¶. Definition of local pair domains. Type: string; Default: No Default. LOCAL_WEAKP¶. Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique available option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. PROP_ALL¶. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. RESTART¶. Do restart the coupled-cluster iterations from old \(\lambda_1\) and \(\lambda_2\) amplitudes?. Type: boolean; Default: false. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. JOBTYPE¶. Type of job being performed. Type: string; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCLAMBDA; General; ABCD; AO_BASIS; CACHELEVEL; DIIS; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; RESTART; ROOTS_PER_IRREP; R_CONVERGENCE; SEKINO; ZETA. Expert; JOBTYPE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cclambda-1.html:3266,perform,performed,3266,psi4manual/1.4.0/autodir_options_c/module__cclambda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cclambda-1.html,4,"['CACHE', 'perform']","['CACHELEVEL', 'performed']"
Performance,"t: WERNER. LOCAL_PAIRDEF¶. Definition of local pair domains. Type: string; Default: No Default. LOCAL_WEAKP¶. Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique available option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. PROP_ALL¶. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. RESTART¶. Do restart the coupled-cluster iterations from old \(\lambda_1\) and \(\lambda_2\) amplitudes?. Type: boolean; Default: false. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. JOBTYPE¶. Type of job being performed. Type: string; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCLAMBDA; General; ABCD; AO_BASIS; CACHELEVEL; DIIS; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; RESTART; ROOTS_PER_IRREP; R_CONVERGENCE; SEKINO; ZETA. Expert; JOBTYPE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__cclambda-1.html:3266,perform,performed,3266,psi4manual/1.5.0/autodir_options_c/module__cclambda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__cclambda-1.html,4,"['CACHE', 'perform']","['CACHELEVEL', 'performed']"
Performance,"t: false. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:6912,CACHE,CACHELEVEL,6912,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,"['CACHE', 'Cache']","['CACHELEVEL', 'Cacheing']"
Performance,"t: false. PRINT_MOS¶. Flag to print the molecular orbitals. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, FAST_DF, CD; Default: PK. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 100.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the cc-pVDZ-RI basis set (when availab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html:2479,perform,performing,2479,psi4manual/4.0b5/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html,2,['perform'],['performing']
Performance,"t; Change in energy for last iteration; d_conv : float; RMS change in density for last iteration. """""". def __init__(self, eqn_description, iteration, wfn, e_conv, d_conv):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; what : str; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats : Dict; Dictionary of convergence statistics of last iteration.; Keys are:. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged; """""". def __init__(self, iteration, wfn, what, stats):; # prepare message, including excitation energies and residual norm; conv_info = ""==> Convergence statistics from last iteration <==\n\n""; conv_info += ""Excitation Energy"".center(21) + f"" {'D[value]':^15}"" + ""|R|"".center(11) + ""\n""; conv_info += f""{'-':->20} {'-':->15} {'-':->15}\n""; for e, diff, r_norm in zip(stats[""val""], stats[""delta_val""], stats[""res_norm""]):; conv_info += f"" {e:.6f} {diff:-11.5e} {r_norm:12.5e}\n""; ConvergenceError.__init__(self,; eqn_description=f""""""TDSCF solver ({what})"""""",; iteration=iteration,; additional_info=conv_info); self.wfn = wfn; self.what = what; self.stats = stats. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class Missi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:5175,perform,performed,5175,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,6,['perform'],['performed']
Performance,"t; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import psi4; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; psi4.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/plugins-1.html:6285,Load,Load,6285,psi4manual/4.0b5/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/plugins-1.html,2,['Load'],['Load']
Performance,"t_; single-point CCSD(T)/qz2p on water. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/kw-1; testing best practices options, part i. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html:3024,optimiz,optimization,3024,psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,2,['optimiz'],['optimization']
Performance,"t_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Find rval of the minimum of energies, check number of points left and right; min_index = np.argmin(energies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/diatomic.html:5343,optimiz,optimization,5343,psi4manual/1.6.x/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/diatomic.html,5,['optimiz'],['optimization']
Performance,"t_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Find rval of the minimum of energies, check number of points left and right; min_index = np.argmin(energies); if min_index < 3 :; core.print_out(""\nWarning: fewer than 3 points provided with a r < r(min(E))!\n""); if min_index >= len(energies) - 3:; core.print_out(""\nWarning: fewer than 3 points provided with a r > r(min(E))!\n""). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n""); re = rvals[min_index]; maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html:5344,optimiz,optimization,5344,psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/diatomic.html,2,['optimiz'],['optimization']
Performance,"t_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF' and sapt_basis == 'dimer'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerB); if (ri == 'DF' and sapt_basis == 'dimer'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_loc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:33945,LOAD,LOAD,33945,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['LOAD'],['LOAD']
Performance,"t_file (string) – ['file.1, file.32] || ./file || etc.; Binary data files to be renamed for calculation restart. name; calls method. efp; effective fragment potential (EFP) [manual]. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order Moller–Plesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. scs-omp2; spin-component scaled OMP2 [manual]. scs(n)-omp2; a special version of SCS-OMP2 for nucleobase interactions [manual]. scs-omp2-vdw; a special version of SCS-OMP2 (from ethene dimers) [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. sos-pi-omp2; A special version of SOS-OMP2 for pi systems [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. scs-omp3; spin-component scaled OMP3 [manual]. scs(n)-omp3; a special version of SCS-OMP3 for nucleobase interactions [manual]. scs-omp3-vdw; a special version of SCS-OMP3 (from ethene dimers) [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. sos-pi-omp3; A special version of SOS-OMP3 for pi systems [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/energy-1.html:2132,optimiz,optimized,2132,psi4manual/1.0.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/energy-1.html,2,['optimiz'],['optimized']
Performance,"t_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if db_mode == 'continuous':; exec(banners). molecule = core.Molecule.from_dict(GEOS[rgt].to_dict()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, core.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); if allowoptexceeded:; try:; ERGT[rgt] = func(molecule=molecule, **kwargs); except ConvergenceError:; core.print_out(""Optimization exceeded cycles for %s"" % (rgt)); ERGT[rgt] = 0.0; else:; ERGT[rgt] = func(molecule=molecule, **kwargs); core.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.get_variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""core.print_variables()\n""""""); freagent.write(""""""core.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html:21561,Optimiz,Optimization,21561,psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,1,['Optimiz'],['Optimization']
Performance,"t_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + rgt). # all modes need to step through the reagents but all for different purposes; # continuous: defines necessary commands, executes energy(method) call, and collects results into dictionary; # sow: opens individual reagent input file, writes the necessary commands, and writes energy(method) call; # reap: opens individual reagent output file, collects results into a dictionary; if db_mode == 'continuous':; exec(banners). molecule = core.Molecule.from_dict(GEOS[rgt].to_dict()); molecule.set_name(rgt); molecule.update_geometry(). exec(commands); #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, core.get_global_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); if allowoptexceeded:; try:; ERGT[rgt] = func(molecule=molecule, **kwargs); except ConvergenceError:; core.print_out(""Optimization exceeded cycles for %s"" % (rgt)); ERGT[rgt] = 0.0; else:; ERGT[rgt] = func(molecule=molecule, **kwargs); core.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = core.variable(envv); core.set_global_option(""REFERENCE"", user_reference); core.clean(); #core.opt_clean(); core.clean_variables(). elif db_mode == 'sow':; with open('%s.in' % (rgt), 'w') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt], 'dbmol')). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""core.print_variables()\n""""""); freagent.write(""""""core.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt))",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:21278,Optimiz,Optimization,21278,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['Optimiz'],['Optimization']
Performance,"t_hessian = 0; PsiMod.set_gradient(G); PsiMod.set_global_option('CART_HESS_READ', True); elif ((full_hess_every == -1) and (PsiMod.get_global_option('CART_HESS_READ')) and (n == 1)):; pass; # Do nothing; user said to read existing hessian once; else:; PsiMod.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # print 'cart_hess_read', PsiMod.get_global_option('CART_HESS_READ'); # Take step; if PsiMod.optking() == PsiMod.PsiReturnType.EndLoop:; print('Optimizer: Optimization complete!'); PsiMod.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (PsiMod.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False):; PsiMod.opt_clean(); PsiMod.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(). optstash.restore(); return thisenergy. PsiMod.print_out('\n Structure for next step:\n'); PsiMod.get_active_molecule().print_out_in_angstrom(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = get_psifile(1); kwargs['mode'] = 'sow'. n += 1. PsiMod.print_out('\tOptimizer: Did not converge!'); optstash.restore(); return 0.0. ## Aliases ##; opt = optimize. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """"""; namelower = name.lower(). # matches 'mrccsdt(q)'; if namelower.startswith('mrcc'):; # grabs 'sdt(q)'; ccfullname = namelower[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method' : 1, 'order' : 2, 'fullname' : 'CCSD' },; 'sdt' : { 'method' : 1, 'order' : 3, 'fullname' : 'CCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:41426,Optimiz,Optimization,41426,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Optimiz'],['Optimization']
Performance,"t_hrgt(sset='default', actv='default')[source]¶. get_hrxn(sset='default')[source]¶. get_missing_reactions(modelchem, sset='default')[source]¶; Returns a dictionary (keys self.dbse and all component; WrappedDatabase.dbse) of two elements, the first being the number; of reactions sset should contain and the second being a list of; the reaction names (dbrxn) not available for modelchem. Absence; of benchmark not considered. get_reactions(modelchem, sset='default', benchmark='default', failoninc=True)[source]¶; Collects the reactions present in sset from each WrappedDatabase,; checks that modelchem and benchmark ReactionDatum are present; (fails if failoninc True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; modelchem, the modelchem key needed to access benchmark, and; the Reaction object. integer_reactions()[source]¶; Returns boolean of whether reaction names need to be cast to integer. load_qcdata_byproject(project, pythonpath=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; standard location for project :module dbse_project and function; load_project. Module search path can be prepended with pythonpath. load_qcdata_hdf5_trusted(project, path=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. load_qcdata_hrxn_byproject(project, path=None)[source]¶. load_saptdata_frombfdb(sset='default', pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True)[source]¶; This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. load_subsets(modname='subsetgenerator', pythonpath=None)[source]¶; For each component database, loads subsets from all functions; in module modname. Default modname usues standard generators. mcs = None¶; assembly pattern for transspecies modelchems; >>> print asdf.mcs.keys(); X",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:32966,load,loads,32966,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['load'],['loads']
Performance,"t_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(moleculeclone); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print("""""" %d displacements needed ..."""""" % (ndisp), end=''); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if opt_mode == 'sow':; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:38035,optimiz,optimize,38035,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimize']
Performance,"t_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); psi4.wavefunction().energy(). optstash.restore(); return psi4.get_variable('CURRENT ENERGY'). else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:35580,Perform,Performing,35580,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Perform'],['Performing']
Performance,"t_molecule_for_input(moleculeclone).encode('utf-8')); fmaster.write(p4util.format_options_for_input(moleculeclone, **kwargs)); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, freq_dertype=1, **kwargs); fmaster.write((""""""retE, retwfn = %s('%s', **kwargs)\n\n"""""" % (frequency.__name__, lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')); core.print_out(instructionsM). for n, displacement in enumerate(displacements):; rfile = 'FREQ-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""core.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Hessian Computation: Gradient Displacement %d ')\n"""""" % (n + 1); banners += """"""core.print_out('\\n')\n\n"""""". if freq_mode == 'continuous':. # print progress to file and screen; core.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); moleculeclone.set_geometry(displacement). # Perform the gradient calculation; G, wfn = gradient(lowername, molecule=moleculeclone, return_wfn=True, **kwargs); gradients.append(wfn.gradient()); energies.append(core.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; core.clean(). # S/R: Write each displaced geometry to an input file; elif freq_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, kwargs, function call and energy save; # forcexyz in molecule writer S/R enforcement of !reinterpret_coordentry above; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the hessian() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(moleculeclone, forcexyz=True).encode('utf-8')); freagent.write(p4util.format_options_for_input(moleculeclone, **kwargs).encode('utf-8')); kwargs['return_wfn'] = True; p4util.forma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:71365,Load,Load,71365,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['Load'],['Load']
Performance,"t_molecule_for_input(moleculeclone).encode('utf-8')); fmaster.write(p4util.format_options_for_input(moleculeclone, **kwargs)); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, freq_dertype=1, **kwargs); fmaster.write((""""""retE, retwfn = %s('%s', **kwargs)\n\n"""""" % (frequency.__name__, lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')); psi4.print_out(instructionsM). for n, displacement in enumerate(displacements):; rfile = 'FREQ-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Hessian Computation: Gradient Displacement %d ')\n"""""" % (n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if freq_mode == 'continuous':. # print progress to file and screen; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); moleculeclone.set_geometry(displacement). # Perform the gradient calculation; G, wfn = gradient(lowername, molecule=moleculeclone, return_wfn=True, **kwargs); gradients.append(wfn.gradient()); energies.append(psi4.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; psi4.clean(). # S/R: Write each displaced geometry to an input file; elif freq_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, kwargs, function call and energy save; # forcexyz in molecule writer S/R enforcement of !reinterpret_coordentry above; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the hessian() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(moleculeclone, forcexyz=True).encode('utf-8')); freagent.write(p4util.format_options_for_input(moleculeclone, **kwargs).encode('utf-8')); kwargs['return_wfn'] = True; p4util.forma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:69385,Load,Load,69385,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Load'],['Load']
Performance,"tabase python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric we",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:5885,Optimiz,Optimize,5885,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,10,"['Optimiz', 'optimiz']","['Optimize', 'optimize']"
Performance,tails] <dd_mp4>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) :ref:`[manual] <sec:arbpt>` :ref:`[details] <dd_zapt2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp2 | spin-component scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp2 | spin-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp3 | spin-component scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp3 | spin-opposite scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:12264,optimiz,optimized,12264,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimized']
Performance,"taken from Garza and Scuseria, DOI: 10.1063/1.4740249. Type: double; Default: 1.0e-4. SCF_INITIAL_START_DIIS_TRANSITION¶. SCF error at which to start the linear interpolation between DIIS steps and steps of the initial SCF accelerator. Value taken from Garza and Scuseria, DOI: 10.1063/1.4740249. Type: double; Default: 1.0e-1. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html:8760,perform,perform,8760,psi4manual/1.6.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html,1,['perform'],['perform']
Performance,"tal energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:29944,load,load,29944,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['load'],['load']
Performance,"tal energy, the correlation energy, a delta correction to the; correlation energy, and a second delta correction. Each is activated by its; stage_wfn keyword and is only allowed if all preceding stages are active. .. include:: cbs_eqn.rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * df-scf; * mp2; * df-mp2; * cc2; * ccsd; * bccd; * cc3; * ccsd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci. :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``'mp2'`` |dr| || ``'ccsd'`` || etc. Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. :type delta2_wfn: string; :param delta2_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. :type delta2_wfn_lesser: string; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:54265,perform,performed,54265,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,1,['perform'],['performed']
Performance,"tal gradient. Type: conv double; Default: 1e-3. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MP2_AMP_TYPE¶. The algorithm that used to handle mp2 amplitudes. The DIRECT option means compute amplitudes on the fly * whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html:3575,optimiz,optimized-,3575,psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,2,['optimiz'],['optimized-']
Performance,"tal space. nirrep(self: psi4.core.OrbitalSpace) → int¶; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace) → None¶; Print information about the orbital space to the output file. class psi4.core.OverlapInt¶; Bases: psi4.core.OneBodyAOInt; Computes overlap integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.PMLocalizer¶; Bases: psi4.core.Localizer; Performs Pipek-Mezey orbital localization. L¶; Localized orbital coefficients. U¶; Orbital rotation matrix. build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix) → psi4.core.Localizer¶; Build the localization scheme. converged¶; Did the localization procedure converge?. localize(self: psi4.core.Localizer) → None¶; Perform the localization procedure. class psi4.core.PetiteList¶; Bases: pybind11_builtins.pybind11_object; Handles symmetry transformations. aotoso(self: psi4.core.PetiteList) → psi4.core.Matrix¶; Return the AO->SO coefficient matrix. print(self: psi4.core.PetiteList, arg0: str) → None¶; Print to outfile. sotoao(self: psi4.core.PetiteList) → psi4.core.Matrix¶; Return the SO->AO coefficient matrix. class psi4.core.PointFunctions¶; Bases: psi4.core.BasisFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, arg0: psi::BlockOPoints) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int¶; docstring. orbital_value",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:155526,Perform,Perform,155526,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['Perform'],['Perform']
Performance,"tal space. nirrep(self: psi4.core.OrbitalSpace) → int¶; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace) → None¶; Print information about the orbital space to the output file. class psi4.core.OverlapInt¶; Bases: psi4.core.OneBodyAOInt; Computes overlap integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.PMLocalizer¶; Bases: psi4.core.Localizer; Performs Pipek-Mezey orbital localization. L¶; Localized orbital coefficients. U¶; Orbital rotation matrix. build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix) → psi4.core.Localizer¶; Build the localization scheme. converged¶; Did the localization procedure converge?. localize(self: psi4.core.Localizer) → None¶; Perform the localization procedure. class psi4.core.PetiteList¶; Bases: pybind11_builtins.pybind11_object; Handles symmetry transformations. aotoso(self: psi4.core.PetiteList) → psi4.core.Matrix¶; Return the AO->SO coefficient matrix. print(self: psi4.core.PetiteList, arg0: str) → None¶; Print to outfile. sotoao(self: psi4.core.PetiteList) → psi4.core.Matrix¶; Return the SO->AO coefficient matrix. class psi4.core.PointFunctions¶; Bases: psi4.core.BasisFunctions; docstring. ansatz(self: psi4.core.PointFunctions) → int¶; docstring. basis_values(self: psi4.core.BasisFunctions) → Dict[str, psi4.core.Matrix]¶; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi::BlockOPoints) → None¶; docstring. compute_points(self: psi4.core.PointFunctions, block: psi::BlockOPoints, force_compute: bool=True) → None¶; docstring. deriv(self: psi4.core.BasisFunctions) → int¶; docstring. max_functions(self: psi4.core.BasisFunctions) → int¶; docstring. max_points(self: psi4.core.BasisFunctions) → int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:190227,Perform,Perform,190227,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['Perform'],['Perform']
Performance,tal-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. olccd; Orbital-Optimized Linear CCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE CONV. Density-Fitted Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE DF. Cholesky-Decomposed Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; —; CC_TYPE CD. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:11327,Optimiz,Optimized,11327,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,6,['Optimiz'],['Optimized']
Performance,"tal-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. olccd; Orbital-Optimized Linear CCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE CONV. Density-Fitted Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE DF. Cholesky-Decomposed Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; —; CC_TYPE CD. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/occ-1.html:11408,Optimiz,Optimized,11408,psi4manual/1.4.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/occ-1.html,5,['Optimiz'],['Optimized']
Performance,"tal-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:9732,optimiz,optimized,9732,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,4,['optimiz'],['optimized']
Performance,"tals from the SAD density; matrix to get proper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]. GWHA generalized Wolfsberg-Helmholtz modification of the core; Hamiltonian matrix. Usually less accurate than the core guess: the; latter is exact for one-electron systems, GWH is not; see; [Lehtola:2019:1593]). HUCKELAn extended Hückel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]. MODHUCKELLike HUCKEL, an extended Hückel guess based on; on-the-fly atomic UHF calculations alike SAD, see; [Lehtola:2019:1593]. This variant employs an updated rule for the; generalized Wolfsberg-Helmholz formula from [Ammeter:1978:3686]. READRead the previous orbitals from a wfn file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations. SAPSuperposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]; and [Lehtola:2020:012516]. The guess and its implementation have; been described in [Lehtola:2019:1593]. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]. SAPGAUSuperposition of Atomic Potentials, but using error function based; fits to the atomic radial potentials as discussed in; [Lehtola:2020:144105]. The main difference to the SAP guess; discussed above [Lehtola:2019:25945] is that the SA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:18606,optimiz,optimizations,18606,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,2,['optimiz'],['optimizations']
Performance,"tance between; atoms 1 and 3, as well as that between 2 and 4; set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDIN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:7791,optimiz,optimizations,7791,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,4,['optimiz'],['optimizations']
Performance,"tanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. nbo; Generation of NBO file. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. mbis-5; MBIS calculation on ZnO. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. fd-gradient; SCF STO-3G finite-difference tests. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. scf3; File retention, docc, socc, and bond distances specified explicitly. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. options1; check all variety of options parsing. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:37791,optimiz,optimization,37791,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"taneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OMP2_ORBS_PRINT¶. Do print OMP2 orbital energies?. Type: boolean; Default: false. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_SCALE¶. Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. Table Of Contents. OMP2; General; CACHELEVEL; CC_MAXITER; CUTOFF; DIIS_MAX_VECS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E_CONVERGENCE; HESS_TYPE; LEVEL_SHIFT; LINEQ_SOLVER; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; MO_READ; MO_STEP_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html:2936,optimiz,optimization,2936,psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,2,['optimiz'],['optimization']
Performance,"tart a CC calculation which stopped for various reasons, e.g. time limit, in the correlation part. However, note that a restart which is specified by ON (= 1) needs the following files of the previous unfinished calculation: JOBARC, JAINDX, MOINTS, and MOABCD. Type: boolean; Default: false. CFOUR_RES_RAMAN¶. This option can be used to convert an analytically calculated gradient vector to a particular normal coordinate representation. A useful application is to calculate the gradient of an electronically excited state in the normal coordinate representation of the ground electronic state, as this provides a first approximation to resonance Raman intensities (hence the name of the keyword). Calculations that use the this option require the externally supplied force constant matrix FCMFINAL, which is written to disk during the course of both analytic and finite-difference vibrational frequency calculations. No such transformation is performed if OFF (=0); while ON (=1) directs the program to evaluate the gradient and transform it to the chosen set of normal coordinates. A warning message is printed if the force constant matrix is unavailable. Type: boolean; Default: false. CFOUR_ROT_EVEC¶. Specifies which eigenvector of the orbital rotation Hessian is to be used to rotate the original SCF orbitals. By default, it will use that associated with the lowest eigenvalue of the totally symmetric part of the block-factored Hessian, as this choice often leads to the lowest energy SCF solution. For RHF stability checks, only those instabilities which correspond to RHF solutions will be considered. It is important to understand that following non-symmetric eigenvectors lowers the symmetry of the wavefunction and that following RHF –> UHF stabilities leads to a UHF solution. To converge the SCF roots associated with such instabilities, one must run the calculation in reduced symmetry and as a closed-shell UHF case, respectively. Value n directs the program to follow the vector ass",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:53519,perform,performed,53519,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,17,['perform'],['performed']
Performance,"tarting from bent structure. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. cisd-sp; 6-31G** H2O Test CISD Energy Point. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. props4; Electrostatic potential and electric field evaluated on a grid around water. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mp2-1; All-electron MP2 6-31G** geometry optimization of water. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. dft2; DFT Functional Test. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. aediis-1; ADIIS test case, from 10.1063/1.3304922. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fsapt-ext-abc; FSAPT with external charge on trimer. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. dft-reference; MP2 with a PBE0 reference computation. dft1; DFT Functional Test all values update for new BraggSlater radii. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. nbody-multi-level-2; many-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:25789,optimiz,optimization,25789,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"tates? Default true. Type: boolean; Default: true. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF)¶CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCT)¶DCT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:116188,optimiz,optimization,116188,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"tation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [E_h] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized linearized coupled cluster; doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2 level of theory. OMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2.5 level of theory. OMP2.5 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2.5 level of theory. OMP3 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:42295,optimiz,optimized,42295,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,4,['optimiz'],['optimized']
Performance,"tation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:18058,optimiz,optimized,18058,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,17,['optimiz'],['optimized']
Performance,"tations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. GAUGE¶. Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. Table Of Contents. CC: Coupled Cluster Methods; Basic Keywords; REFERENCE; R_CONVERGENCE; MAXITER; BRUECKNER_ORBS_R_CONVERGENCE; RESTART; CACHELEVEL; CACHETYPE; NUM_AMPS_PRINT; MP2_AMPS_PRINT. Larger Calculations; Excited State Coupled Cluster Calculations; ROOTS_PER_IRREP; E_CONVERGENCE; SINGLES_PRINT; SCHMIDT_ADD_RESIDUAL_TOLERANCE; EOM_GUESS. Linear Response (CCLR) Calculations; PROPERTY; OMEGA; GAUGE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Next topic; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cc-1.html:10203,CACHE,CACHELEVEL,10203,psi4manual/1.0.0/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cc-1.html,4,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"tconf _NPROCESSORS_ONLN`. 5. Test. Optionally, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. 1>>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run Psi4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that Python,; CMake, NumPy, and Libint (and even C++ compilers on Linux) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++11 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (2.7, 3.5, or 3.6) https://www.python.org/; CMake (3.3+) http://www.cmake.org/download/; NumPy (needed at runtime, not buildtime) http://www.numpy.org/; System utilities: GNU make, GNU install, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. Libint — [what is this?] [min version]; pybind11 — [what is this?] [min version]. What are the add-on capabilities for Psi4 and what are their dependencies¶; Each of the items below is an independent additional capability that can; be built with PSI4. Sub-items below are the respective additional; dependencies of the add-on. Select which, if any, you want, and examine; the links for appropriate enabling arguments to cmake. Note that many; are available pre-built from conda. PSI4 Testing; CTest http://www.cmake.org/download/; Perl (for some coupled-cluster CTest ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:3880,Optimiz,Optimized,3880,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['Optimiz'],['Optimized']
Performance,"te CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/energy.html:37644,perform,perform,37644,psi4manual/1.8.x/energy.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/energy.html,2,['perform'],['perform']
Performance,"te CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/energy.html:38974,perform,perform,38974,psi4manual/1.9.x/energy.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/energy.html,2,['perform'],['perform']
Performance,"te difference by gradient calculations'; print(info). func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print(' %d displacements needed.' % ndisp). #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # call thermo module; PsiMod.thermo(). optstash.restore(); # TODO: add return statement. else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print(info). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lower",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:64054,Perform,Perform,64054,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Perform'],['Perform']
Performance,"te difference by gradient calculations'; print(info). func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print(' %d displacements needed.' % ndisp). #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print(info). # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This ve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:49220,Perform,Perform,49220,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Perform'],['Perform']
Performance,"te that many; are available pre-built from conda. PSI4 Testing; CTest http://www.cmake.org/download/; Perl (for some coupled-cluster CTest tests) http://perl.org; pytest (for installed testing) http://doc.pytest.org/en/latest/. PSI4 Documentation (available pre-built at http://www.psicode.org/psi4manual/master/index.html); Sphinx (1.5+) http://sphinx-doc.org; Perl (for some auto-documentation scripts) http://perl.org; nbsphinx (for converting Jupyter notebooks) http://nbsphinx.readthedocs.io/en/jupyter-theme/; sphinx-psi-theme https://github.com/psi4/sphinx-psi-theme; See [“message” lines] for advice on obtaining docs dependencies. CheMPS2 — [what is this?] [min version]; HDF5 https://support.hdfgroup.org/HDF5/; zlib http://www.zlib.net/. dkh — [what is this?] [min version]; Fortran Compiler. gdma — [what is this?] [min version]; Fortran Compiler. PCMSolver — [what is this?]; Fortran Compiler; zlib http://www.zlib.net/. simint — [what is this?] [min version]. Additionally, there are runtime-loaded capabilities:. PylibEFP & libefp — [what is this?] [min version]; cfour — [what is this?]; dftd3 — [what is this?]; gcp — [what is this?]; mrcc — [what is this?]; v2rdm_casscf — [what is this?]; snsmp2 — https://github.com/DEShawResearch/sns-mp2/commits/master; resp — https://github.com/cdsgroup/resp; gpu_dfcc — https://github.com/edeprince3/gpu_dfcc/commits/master; OpenFermion-Psi4 — https://github.com/quantumlib/OpenFermion. How to configure code to use high angular momentum basis sets¶; The Libint integral code handles arbitrary order; angular momentum, but compiling that is prohibitive. The default of 5; is generally good. 7 has met all of a research group’s needs for; years. 4 is handy for quickly testing other parts of the build. Build with Higher Angular Momentum; >>> cmake -DMAX_AM_ERI=6. Relevant CMake Options:; MAX_AM_ERI=N # The maximum angular momentum level (1=p, 2=d, 3=f,; # etc.) for the libint integrals and derivative; # integrals. A value of N implies a ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:6684,load,loaded,6684,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['load'],['loaded']
Performance,"te that this algorithm is not optimized for doubles-only computations. Type: boolean; Default: false. CEPA_SCALE_OS¶. Oppposite-spin scaling factor for SCS-CEPA. Type: double; Default: 1.27. CEPA_SCALE_SS¶. Same-spin scaling factor for SCS-CEPA. Type: double; Default: 1.13. CEPA_VABCD_DIRECT¶. Use integral-direct implementation of the (ac|bd) t(ij,cd) contraction? AO integrals will be generated on the fly. The CEPA iterations will be slower, but the AO->MO integral transform will be faster, and the out-of-core sort of the (AC|BD) integrals will be avoided. Type: boolean; Default: false. DIIS_MAX_VECS¶. Number of vectors to store for DIIS extrapolation. Type: integer; Default: 8. DIPMOM¶. Compute the dipole moment? Note that quadrupole moments will also be computed if PRINT >= 2. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to converge the t1 and t2 amplitudes. Type: integer; Default: 100. MP2_SCALE_OS¶. Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. MP2_SCALE_SS¶. Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0/3.0. R_CONVERGENCE¶. Desired convergence for the t1 and t2 amplitudes, defined as the norm of the change in the amplitudes between iterations. Type: conv double; Default: 1.0e-7. SCS_CEPA¶. Perform SCS-CEPA? If true, note that the default values for the spin component scaling factors are optimized for the CCSD method. Type: boolean; Default: false. Table Of Contents. CEPA; General; CEPA_LEVEL; CEPA_NO_SINGLES; CEPA_SCALE_OS; CEPA_SCALE_SS; CEPA_VABCD_DIRECT; DIIS_MAX_VECS; DIPMOM; MAXITER; MP2_SCALE_OS; MP2_SCALE_SS; R_CONVERGENCE; SCS_CEPA. Previous topic; WFN; Next topic; CEPA_LEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__cepa-1.html:1741,Perform,Perform,1741,psi4manual/4.0b3/autodir_options_c/module__cepa-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__cepa-1.html,4,"['Perform', 'optimiz']","['Perform', 'optimized']"
Performance,"te. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print(""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/util.html:2404,Perform,Performs,2404,psi4manual/4.0b3/_modules/util.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/util.html,1,['Perform'],['Performs']
Performance,"te; that PSI4 expects the numpy file on disk to have the .npy extension, not, e.g., .npz. Convergence Stabilization¶; With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via options. MOM [Off by Default]MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations \(N,N+2,\ldots\), invoking; MOM_START N can often rescue the convergence of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:21787,optimiz,optimized,21787,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,4,['optimiz'],['optimized']
Performance,"ted by the SCF_TYPE; keyword, which may be one of the following. PK [Default]An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals. OUT_OF_COREAn out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals. DIRECTA threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if INTS_TOLERANCE; is set to 1.0E-8 or so. DF [Default]A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [\(\gtrsim\)CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved. CDA threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. COSXAn algorithm based on the semi-numerical “chain of spheres exchange” (COSX); approach described ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:25830,optimiz,optimized,25830,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,2,['optimiz'],['optimized']
Performance,"ted by the SCF_TYPE; keyword, which may be one of the following. PK [Default]An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals. OUT_OF_COREAn out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals. DIRECTA threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if INTS_TOLERANCE; is set to 1.0E-8 or so. DF [Default]A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [\(\gtrsim\)CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved. CDA threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. In some cases the above algorithms have multiple implementations that return; the same result, but a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:25354,optimiz,optimized,25354,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,4,['optimiz'],['optimized']
Performance,"ted functions like the above looked like; energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z'). energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z"", ""scheme"": corl_xtpl_helgaker_2}]). The difference is that the main function; psi4.cbs() and extrapolation schemes like; psi4.driver.driver_cbs_helper.xtpl_highest_1() and; psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2() and composite; aliases like psi4.driver.aliases.sherrill_gold_standard(); and psi4.driver.aliases.allen_focal_point() in the old way; passed the Python function directly, whereas the new way uses the; string of the function name. A CCSD(T) DT coupled-cluster correction atop a TQ MP2 extrapolation; geometry optimization can also be accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(""cbs"", corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases; complete_basis_set(). Returns; (float) – Total electronic energy in Hartrees. PSI variables. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:1799,optimiz,optimize,1799,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,3,['optimiz'],['optimize']
Performance,ted in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:6244,Optimiz,Optimized,6244,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,4,['Optimiz'],['Optimized']
Performance,"ted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_active_efp() → psi4.core.EFP¶; Returns the currently active EFP object. psi4.core.get_active_molecule() → psi::Molecule¶; Returns the curren",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:227236,Perform,Performs,227236,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['Perform'],['Performs']
Performance,"ted ref gradient due to new BraggSlater radii. fci-h2o; 6-31G H2O Test FCI Energy Point. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-level-shift-uhf; SCF level shift on a UHF computation. linK-2; RKS Linear Exchange Algorithm test for benzene. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. sapt11; sapt example with orbital freezing with alkali metal and dMP2. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cbs-delta-energy; Extrapolated energies with delta correction. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:7784,optimiz,optimization,7784,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,4,['optimiz'],"['optimization', 'optimized']"
Performance,"ted, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Grab grid points. Skip the first nine lines and the last one; evec = np.genfromtxt(expected, skip_header=9, skip_footer=1); cvec = np.genfromtxt(computed, skip_header=9, skip_footer=1); if evec.size == cvec.size:; if not np.allclose(cvec, evec, rtol=5e-05, atol=1e-10):; message = (""\t%s: computed cube file does not match expected cube file."" % label); raise TestComparisonError(message); else:; message = (""\t%s: computed cube file does not match size of expected cube file."" % label); raise TestComparisonError(message); success(label); return True. [docs]def compare_wavefunctions(expected, computed, digits=9, label='Wavefunctions equal'):; """"""Function to compare two wavefunctions. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # yapf: disable; if expected.Ca(): compare_matrices(expected.Ca(), computed.Ca(), digits, 'compare Ca'); if expected.Cb(): compare_matrices(expected.Cb(), computed.Cb(), digits, 'compare Cb'); if expected.Da(): compare_matrices(expected.Da(), computed.Da(), digits, 'compare Da'); if expected.Db(): compare_matrices(expected.Db(), computed.Db(), digits, 'compare Db'); if expected.Fa(): compare_matrices(expected.Fa(), computed.Fa(), digits, 'compare Fa'); if expected.Fb(): compare_matrices(expected.Fb(), computed.Fb(), digits, 'compare Fb'); if expected.H(): compare_matrices(expected.H(), computed.H(), digits, 'compare H'); if expected.S(): compare_matrices(expected.S(), computed.S(), digits, 'compare S'); if expected.X(): compare_matrices(expected.X(), computed.X(), digits, 'compare X'); if expected.aotoso(): compare_matrices(expected.aotoso(), computed.aotoso(), digits, 'compare aotoso'); if expected.gradient(): compare_matr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:13869,Perform,Performs,13869,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['Perform'],['Performs']
Performance,"ted.dim(irrep) != computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" % (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if(abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10 ** (-digits)):; failed = 1; break. if(failed):; core.print_out(""The computed vector\n""); computed.print_out(); core.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry), expected.get(irrep, entry))); raise TestComparisonError(message); success(label); return True. [docs]def compare_arrays(expected, computed, digits, label):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2:; TestComparisonError(""Input shapes do not match.""). tol = 10 ** (-digits); if not np.allclose(expected, computed, atol=tol):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label); return True. [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Skip the first six elemets which are just labels; evec = [float(k) for k in expected.split()[6:]]; cvec = [float(k) for k in computed.split()[6:]]; if len(evec) == len(cvec):; for n in range(len(evec)):; if (math.fab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:11559,Perform,Performs,11559,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['Perform'],['Performs']
Performance,"teger; Default: 0. CFOUR_FD_CALCTYPE (CFOUR)¶CFOUR — Specifies the algorithm used to compute the harmonic force constants in finite-difference calculations.GRADONLY (=0) evaluates the force constants and dipole moment derivatives by numerical differentiation of analytic gradients; ENERONLY (=1) evaluates the force constants by second differences of energies (dipole moment derivatives are not evaluated); while MIXED (=2) evaluates 1x1 blocks of symmetry-blocked force constants by second differences pf energies and all other elements by first differences of gradients. the GRADONLY and MIXED approaches may, of course, only be used hwen using computational methods for which analytic gradients are available. Type: string; Possible Values: GRADONLY, ENERONLY, MIXED; Default: GRADONLY. CFOUR_FD_IRREPS (CFOUR)¶CFOUR — Requests that only vibrational frequencies of certain symmetry types are evaluated in a VIBRATION=FINDIF calculation. The numbers of the irreducible representations for which vibrational analysis is to be performed are separated by slashes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT (CFOUR)¶CFOUR — ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:41447,perform,performed,41447,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['perform'],['performed']
Performance,"teger; Default: 1. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. NO_SINGLES¶. Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. OFFDIAGONAL_CCSD_T¶. Do include the off-diagonal corrections in (T) computations?. Type: boolean; Default: true. PERTURB_CBS¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: false. PERTURB_CBS_COUPLING¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Default: SECOND_ORDER. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-9. SMALL_CUTOFF¶. Type: integer; Default: 0. TIKHONOW_MAX¶. The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TRIPLES_ALGORITHM¶. The type of algorithm to use for (T) computations. Type: string; Possible Values: SPIN_ADAPTED, RESTRICTED, UNRESTRICTED; Default: RESTRICTED. TRIPLES_DIIS¶. Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?. Type: boolean; Default: false. USE_SPIN_SYM¶. Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. WFN_SYM¶. The symmetry of the target wavefunction, specified either by Sch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__psimrcc-1.html:3433,perform,perform,3433,psi4manual/1.4.0/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__psimrcc-1.html,9,['perform'],['perform']
Performance,"teger; Default: 2. CACHELEVEL (CPHF); CPHF — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (CPHF); CPHF — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:10442,CACHE,CACHETYPE,10442,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,4,"['CACHE', 'cache']","['CACHETYPE', 'cache']"
Performance,"teger; Default: 2. CACHELEVEL (OMP2); OMP2 — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (OMP3); OMP3 — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (MP2); MP2 — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the ac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:10285,cache,cache,10285,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"tegrals can be read from it.; For more information on stability analysis, see the stability; documentation. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT; truncations, using different basis sets, is reported in; [Parker:2014:094106]. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. If the open-shell SAPT0 code is used,; [Gonthier:2016:134106] should be additionally cited. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:14136,perform,perform,14136,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,20,"['perform', 'scalab']","['perform', 'scalable']"
Performance,"tegrals can be read from it.; For more information on stability analysis, see the stability; documentation. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT; truncations, using different basis sets, is reported in; [Parker:2014:094106]. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. If the open-shell SAPT0 code is used,; [Gonthier:2016:134106] should be additionally cited. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to a JKFIT basis. Previous to v1.6, defaulted to DF_BASIS_SAPT See fitting not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:18794,perform,perform,18794,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,10,"['perform', 'scalab']","['perform', 'scalable']"
Performance,"tegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:4988,load,loaded,4988,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,4,['load'],['loaded']
Performance,"tein, and C. D. Sherrill,; J. Chem. Phys. 139, 174102 (2013).; (doi: 10.1063/1.4826520).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84).; “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077). F/I-SAPT. “Chemical Assignment of Symmetry-Adapted Perturbation Theory Interaction; Energy Components: The Functional-Group SAPT Partition,”; R. M. Parrish, T. M. Parker, and C. D. Sherrill,; J. Chem. Theory Comput. 10, 4417 (2014).; (doi: 10.1021/ct500724p).; “Communication: Practical Intramolecular Symmetry Adapted Perturbation Theory; via Hartree-Fock Embedding,”; R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C. D. Sherrill,; J. Chem. Phys. 143, 051103 (2015).; (doi: 10.1063/1.4927575). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Ap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:12841,Optimiz,Optimized,12841,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,12,"['Optimiz', 'optimiz']","['Optimized', 'optimized']"
Performance,"temperatures and pressures but not for different isotopologs. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-delta-energy; Extrapolated energies with delta correction. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. scf6; Tests RHF/ROHF/UHF SCF gradients. numpy-array-interface; Numpy interface testing. gibbs; Test Gib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:13764,optimiz,optimization,13764,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"ten and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to :py:func:`numpy.load`; to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:5034,load,load,5034,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,3,['load'],['load']
Performance,"tep in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); else:; instructionsM += """"""# psi4 -a -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); instructionsM += """"""# After each optimization iteration, the OPT-master.in file is overwritten so return here\n""""""; instructionsM += """"""# for new instructions. With the use of the psi4 -a flag, OPT-master.out is not\n""""""; instructionsM += """"""# overwritten and so maintains a history of the job. To use the (binary) optimizer\n""""""; instructionsM += """"""# data file to accelerate convergence, the OPT-master jobs must run on the same computer.\n\n"""""". fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write(format_molecule_for_input(molecule)); fmaster.write(format_options_for_input()); format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Gradient %d Computation: Displacement %d')\n"""""" % (opt_iter, n + 1); banners += """"""PsiMod.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; PsiMod.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:26733,optimiz,optimize,26733,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['optimiz'],['optimize']
Performance,"tep in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); else:; instructionsM += """"""# psi4 -a -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); instructionsM += """"""# After each optimization iteration, the OPT-master.in file is overwritten so return here\n""""""; instructionsM += """"""# for new instructions. With the use of the psi4 -a flag, OPT-master.out is not\n""""""; instructionsM += """"""# overwritten and so maintains a history of the job. To use the (binary) optimizer\n""""""; instructionsM += """"""# data file to accelerate convergence, the OPT-master jobs must run on the same computer.\n\n"""""". fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write(format_molecule_for_input(molecule)); fmaster.write(format_options_for_input()); format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Gradient %d Computation: Displacement %d')\n"""""" % (opt_iter, n + 1); banners += """"""PsiMod.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""). # Load in displacement into the active molecule; PsiMod.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:29211,optimiz,optimize,29211,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['optimiz'],['optimize']
Performance,"tep_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:61051,optimiz,optimized,61051,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['optimiz'],['optimized']
Performance,"ter Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. pywrap-db2; Database calculation, run in sow/reap mode. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:11023,perform,performs,11023,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,"['optimiz', 'perform']","['optimization', 'performs']"
Performance,"ter Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. pywrap-db2; Database calculation, run in sow/reap mode. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. sapt-ecp; sapt0 of charged system in ECP basis set. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:11713,perform,performs,11713,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,8,"['optimiz', 'perform']","['optimization', 'performs']"
Performance,"ter about 4 cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; ----------------------------------------------------------------------; Step Energy Delta(E) MAX force MAX Delta(q); ----------------------------------------------------------------------; 1 -76.026653665892 -76.026653665892 1.52e-02 1.52e-02; 2 -76.026907793199 -0.000254127307 9.55e-03 9.55e-03; 3 -76.027052927171 -0.000145133972 4.47e-04 4.47e-04; 4 -76.027053472137 -0.000000544965 1.16e-04 1.16e-04; ----------------------------------------------------------------------. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at the output from running the; previous example, we see that the OH bond length is about 0.9463 Ångstroms,; and the bond angle is about 104.575 degrees. It’s good to give this many; digits (or more) to make sure there’s not significant roundoff error in the; geometry when running a frequency computation. So, our frequency; computation input (which can be found as test case; tu4-h2o-freq is:; #! Frequencies for H2O HF/cc-pVDZ at optimized geometry. memory 250 mb. molecule h2o {; O ; H 1 0.9463; H 1 0.9463 2 104.575; }. set basis cc-pVDZ; frequencies('scf'). Alternatively, it’s also possible for PSI4 to use Cartesian coordinate; input. Here, the Cartesian coordinates of the optimized geometry can be; extracted from the bottom of the optimization output. The input; would then look like this:; molecule h2o {; O 0.0000000000 -0.0000000000 -0.1224239500; H 0.0000000000 -1.4147069876 0.9714784639; H -0.0000000000 1.4147069876 0.9714784639; }. set ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:5779,optimiz,optimized,5779,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,2,['optimiz'],['optimized']
Performance,"ter about 4 cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; ----------------------------------------------------------------------; Step Energy Delta(E) MAX force MAX Delta(q); ----------------------------------------------------------------------; 1 -76.026653665892 -76.026653665892 1.52e-02 1.52e-02; 2 -76.026907793199 -0.000254127307 9.55e-03 9.55e-03; 3 -76.027052927171 -0.000145133972 4.47e-04 4.47e-04; 4 -76.027053472137 -0.000000544965 1.16e-04 1.16e-04; ----------------------------------------------------------------------. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at the output from running the; previous example, we see that the OH bond length is about 0.9463 Ångstroms,; and the bond angle is about 104.575 degrees. It’s good to give this many; digits (or more) to make sure there’s not significant roundoff error in the; geometry when running a frequency computation. So, our frequency; computation input (which can be found as test case; tu4-h2o-freq is:; #! Frequencies for H2O HF/cc-pVDZ at optimized geometry. memory 250 mb. molecule h2o {; O ; H 1 0.9463; H 1 0.9463 2 104.575; }. set basis cc-pVDZ; set scf_type pk; frequencies('scf'). Alternatively, it’s also possible for PSI4 to use Cartesian coordinate; input. Here, the Cartesian coordinates of the optimized geometry can be; extracted from the bottom of the optimization output. The input; would then look like this:; molecule h2o {; O 0.0000000000 -0.0000000000 -0.1224239500; H 0.0000000000 -1.4147069876 0.9714784639; H -0.0000000000 1.4147069876 0.97",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:5789,optimiz,optimized,5789,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,2,['optimiz'],['optimized']
Performance,"ter dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-dipole; 6-31G H2O Test FCI Energy Point. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. numpy-array-interface; Numpy interface testing. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. pywrap-align; apply linear fragmentation algorithm to a water cluster. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:19910,perform,performed,19910,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"ter method). (psi4.driver.driver_findif.FiniteDifferenceComputer method). (psi4.driver.driver_nbody.ManyBodyComputer method). C. C() (psi4.core.OrbitalSpace method). c1_deep_copy() (psi4.core.CUHF method). (psi4.core.RHF method). (psi4.core.ROHF method). (psi4.core.UHF method). (psi4.core.Wavefunction method). c2_x() (psi4.core.SymmetryOperation method). c2_y() (psi4.core.SymmetryOperation method). c2_z() (psi4.core.SymmetryOperation method). C_add() (psi4.core.JK method). c_alpha() (psi4.core.SuperFunctional method). C_clear() (psi4.core.JK method). c_functional() (psi4.core.SuperFunctional method). c_functionals() (psi4.core.SuperFunctional method). C_left_add() (psi4.core.JK method). c_omega() (psi4.core.SuperFunctional method). c_os_alpha() (psi4.core.SuperFunctional method). C_right_add() (psi4.core.JK method). c_ss_alpha() (psi4.core.SuperFunctional method). Ca() (psi4.core.SADGuess method). (psi4.core.Wavefunction method). Ca_subset() (psi4.core.Wavefunction method). CACHELEVEL (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (DCT). (OCC). CACHETYPE (CCENERGY). (CCEOM). CALC_S_SQUARED (DETCI). CANONICALIZE_ACTIVE_FAVG (MCSCF). CANONICALIZE_INACTIVE_FAVG (MCSCF). CART_HESS_READ (OPTKING). Cartesian (psi4.core.GaussianType attribute). CARTESIAN_SYM_TOLERANCE (OPTKING). Cb() (psi4.core.SADGuess method). (psi4.core.Wavefunction method). Cb_subset() (psi4.core.Wavefunction method). CBS CORRELATION ENERGY. CBS NUMBER. CBS REFERENCE ENERGY. CBS TOTAL ENERGY. cbs(). ; extrapolation schemes. output. setting keywords. theory, [1], [2]. cbs() (in module psi4.driver). cbsrec (psi4.driver.driver_cbs.CompositeComputer attribute). CC. ; theory. CC (DETCI). CC ALPHA-ALPHA PAIR ENERGIES. CC ALPHA-BETA PAIR ENERGIES. CC CORRELATION ENERGY. CC CORRELATION KINETIC ENERGY. CC CORRELATION POTENTIAL ENERGY. CC CORRELATION VIRIAL RATIO. CC D1 DIAGNOSTIC. CC D2 DIAGNOSTIC. CC DIPOLE. CC NEW D1 DIAGNOSTIC. CC SINGLET PAIR ENERGIES. CC T1 DIAGNOSTIC. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:13691,CACHE,CACHELEVEL,13691,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['CACHE'],['CACHELEVEL']
Performance,"ter method. psi4.driver.driver_nbody.ManyBodyComputer method. C. C() psi4.core.OrbitalSpace method. c1_deep_copy() psi4.core.CUHF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. c2_x() psi4.core.SymmetryOperation method. c2_y() psi4.core.SymmetryOperation method. c2_z() psi4.core.SymmetryOperation method. C_add() psi4.core.JK method. c_alpha() psi4.core.SuperFunctional method. C_clear() psi4.core.JK method. c_functional() psi4.core.SuperFunctional method. c_functionals() psi4.core.SuperFunctional method. C_left_add() psi4.core.JK method. c_omega() psi4.core.SuperFunctional method. c_os_alpha() psi4.core.SuperFunctional method. C_right_add() psi4.core.JK method. c_ss_alpha() psi4.core.SuperFunctional method. Ca() psi4.core.SADGuess method. psi4.core.Wavefunction method. Ca_subset() psi4.core.Wavefunction method. CACHELEVEL (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (DCT). (OCC). CACHETYPE (CCENERGY). (CCEOM). CALC_S_SQUARED (DETCI). CANONICALIZE_ACTIVE_FAVG (MCSCF). CANONICALIZE_INACTIVE_FAVG (MCSCF). CART_HESS_READ (OPTKING). Cartesian psi4.core.GaussianType attribute. CARTESIAN_SYM_TOLERANCE (OPTKING). Cb() psi4.core.SADGuess method. psi4.core.Wavefunction method. Cb_subset() psi4.core.Wavefunction method. CBS CORRELATION ENERGY. CBS NUMBER. CBS REFERENCE ENERGY. CBS TOTAL ENERGY. cbs(). ; extrapolation schemes. output. setting keywords. theory, [1], [2]. cbs() in module psi4.driver. cbsrec psi4.driver.driver_cbs.CompositeComputer attribute. CC. ; theory. CC (DETCI). CC ALPHA-ALPHA PAIR ENERGIES. CC ALPHA-BETA PAIR ENERGIES. CC CORRELATION ENERGY. CC CORRELATION KINETIC ENERGY. CC CORRELATION POTENTIAL ENERGY. CC CORRELATION VIRIAL RATIO. CC D1 DIAGNOSTIC. CC D2 DIAGNOSTIC. CC DIPOLE. CC NEW D1 DIAGNOSTIC. CC SINGLET PAIR ENERGIES. CC T1 DIAGNOSTIC. CC TOTAL ENERGY. CC TRIPLET PAIR ENERGIES. CC VIRIAL RATIO. CC(n-1)(n) CORRELATION ENERGY. CC(n-1)(n) TOTAL ENERGY. CC(n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:13248,CACHE,CACHETYPE,13248,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['CACHE'],['CACHETYPE']
Performance,"ter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); else:; instructionsM += """"""# psi4 -a -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); instructionsM += """"""# After each optimization iteration, the OPT-master.in file is overwritten so return here\n""""""; instructionsM += """"""# for new instructions. With the use of the psi4 -a flag, OPT-master.out is not\n""""""; instructionsM += """"""# overwritten and so maintains a history of the job. To use the (binary) optimizer\n""""""; instructionsM += """"""# data file to accelerate convergence, the OPT-master jobs must run on the same computer.\n\n"""""". fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write(format_molecule_for_input(molecule)); fmaster.write(format_options_for_input()); format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Gradient %d Computation: Displacement %d')\n"""""" % (opt_iter, n + 1); banners += """"""PsiMod.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print inf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:26279,optimiz,optimizer,26279,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,3,['optimiz'],['optimizer']
Performance,"ter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); else:; instructionsM += """"""# psi4 -a -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); instructionsM += """"""# After each optimization iteration, the OPT-master.in file is overwritten so return here\n""""""; instructionsM += """"""# for new instructions. With the use of the psi4 -a flag, OPT-master.out is not\n""""""; instructionsM += """"""# overwritten and so maintains a history of the job. To use the (binary) optimizer\n""""""; instructionsM += """"""# data file to accelerate convergence, the OPT-master jobs must run on the same computer.\n\n"""""". fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write(p4util.format_molecule_for_input(molecule)); fmaster.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:38189,optimiz,optimizer,38189,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['optimiz'],['optimizer']
Performance,"ter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); else:; instructionsM += """"""# psi4 -a -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); instructionsM += """"""# After each optimization iteration, the OPT-master.in file is overwritten so return here\n""""""; instructionsM += """"""# for new instructions. With the use of the psi4 -a flag, OPT-master.out is not\n""""""; instructionsM += """"""# overwritten and so maintains a history of the job. To use the (binary) optimizer\n""""""; instructionsM += """"""# data file to accelerate convergence, the OPT-master jobs must run on the same computer.\n\n"""""". with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); fmaster.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, dertype=dertype, **kwargs); fmaster.write((""""""retE, retwfn = optimize('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1). # Build string of title banner; banners = ''; banners += """"""core.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""core.print_out('\\n')\n\n"""""". if opt_mode == 'continuous':. # print progress to file ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:41146,optimiz,optimizer,41146,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['optimiz'],['optimizer']
Performance,"ter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); else:; instructionsM += """"""# psi4 -a -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); instructionsM += """"""# After each optimization iteration, the OPT-master.in file is overwritten so return here\n""""""; instructionsM += """"""# for new instructions. With the use of the psi4 -a flag, OPT-master.out is not\n""""""; instructionsM += """"""# overwritten and so maintains a history of the job. To use the (binary) optimizer\n""""""; instructionsM += """"""# data file to accelerate convergence, the OPT-master jobs must run on the same computer.\n\n"""""". with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); fmaster.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, dertype=dertype, **kwargs); fmaster.write((""""""retE, retwfn = optimize('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if opt_mode == 'continuous':. # print progress to file ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:39812,optimiz,optimizer,39812,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimizer']
Performance,"ter. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. fci-coverage; 6-31G H2O Test for coverage. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tdscf-1; td-uhf test on triplet states of methylene (rpa). sad-scf-type; Test SAD SCF guesses on noble gas atom. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. props4; Electrostatic potential and electric field evaluated on a grid around water. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO hand",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:25448,optimiz,optimization,25448,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"terative subspace that will; be stored before a collapse is done.; maxiter (int) – The maximum number of iterations; verbose (int) – The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns:. best_values (numpy.ndarray) – (nroots, ) The best approximation of the eigenvalues of w, computed on the last iteration of the solver; best_R (List[vector]) – (nroots) The best approximation of the right hand eigenvectors, \(X+Y\), computed on the last iteration of the solver.; best_L (List[vector]) – (nroots) The best approximation of the left hand eigenvectors, \(X-Y\), computed on the last iteration of the solver.; stats (List[Dict]) – Statistics collected on each iteration. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged. Notes; The solution vector is normalized to 1/2; The solver will return even when maxiter iterations are performed without convergence.; The caller must check stats[-1]['done'] for failure and handle each case accordingly.; References; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, “An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules.” J. Chem. Phys.,; 109, 8218 (1998). table of contents. hamiltonian_solver; hamiltonian_solver(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; hamiltonian_solver. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.p4util.hamiltonian_solver.html:2996,perform,performed,2996,psi4manual/master/api/psi4.driver.p4util.hamiltonian_solver.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.p4util.hamiltonian_solver.html,3,['perform'],['performed']
Performance,"teria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 100. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; The various non-orbital-optimized methods supported by the OCC/DFOCC; modules in PSI4 are summarized in Table OCC non-OO; Methods and detailed in Table OCC; non-OO Capabilities. Note that while two; separate libraries OCC (conventional integrals CONV) and DFOCC; (density-fitted DF and Chole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:17205,optimiz,optimization,17205,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['optimiz'],['optimization']
Performance,"terion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treatments is controlled through ‘type select’ values;; see rightmost column in Table Conventional OCC/DFOCC Methods.; Depending on efficiency considerations, the OCC & DFOCC modules may; or may not be the default in PSI4 for available methods. (See; Cross-module Redundancies for gory; details.) To call the OCC/DFOCC implementation of any method below in; preference to the default module, issue set qc_module occ. Conventional (non-OO) CC and MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. mp2; MP2; RHF/UHF/ROHF; RHF/UHF; MP2_TYPE CONV. Density-Fitted MP2; RHF/UHF/ROHF; RHF/UHF; MP2_TYPE DF. Cholesky-Decomposed MP2; RHF/UHF/ROHF; —; MP2_TYPE CD. mp3; MP3; RHF/UHF; R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/occ-1.html:15791,optimiz,optimized,15791,psi4manual/1.3.2/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/occ-1.html,2,['optimiz'],['optimized']
Performance,"terion. 7; Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:14186,optimiz,optimizer,14186,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,10,['optimiz'],"['optimize', 'optimizer']"
Performance,"terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. FORCE_RESTART¶. Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: LMP2. Table Of Contents. CCENERGY; General; ABCD; ANALYZE; BRUECKNER_ORBS_R_CONVERGENCE; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC_OS_SCALE; CC_SS_SCALE; DF_BASIS_MP2; DF_LMP2; DIAG_METHOD; DIIS; DIIS_MAX_VECS; DIIS_START_ITER; DISTANT_PAIR_CUTOFF; DOMAINS; DOMAIN_PRINT; DOMAIN_PRINT_EXIT; E_CONVERGENCE; FOCK_TOLERANCE; INTS_TOLERANCE; LOCAL; LOCAL_AMPS_PRINT_CUTOFF; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_GHOST; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; MEMORY; MP2_AMPS_PRINT; MP2_OS_SCALE; MP2_SS_SCALE; NEGLECT_DISTANT_PAIR; NEW_TRIPLES; NUM_AMPS_PRINT; PAIR_ENERGIES_PRINT; PROPERTY; REFERENCE; RESTART; ROOTS_PER_IRREP; R_CONVERGENCE; SCREEN_INTS; SCS; SCSN_MP2; SCS_CCSD; SCS_MP2; SCS_N; SEMICANONICAL; SPINADAPT_ENERGIES; T2_COUPLED; T3_WS_INCORE. Expert; AO_BASIS; FORCE_RESTART; WFN. Previous topic; ZETA; Next topic; ABCD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html:8077,CACHE,CACHELEVEL,8077,psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,4,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"tes into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_COUPLING (DCT)¶DCT — Controls whether to include the coupling terms in the DCT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS)¶GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, ADCC, CCT3; Default: No Default. QC_TYPE (DCT)¶DCT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC)¶DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF)¶SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP)¶EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. R4S (DETCI)¶DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (ADC)¶ADC — Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:195135,perform,perform,195135,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,4,['perform'],['perform']
Performance,"tes it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION¶. Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF; Default: NO. CFOUR_VTRAN¶. This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the \((ab \vert cd)\) integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD¶. Specifies the X-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword \(\times 10^{-6}\). This allows field strengths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL¶. The tolerance for storing transformed integrals. Integrals less than \(10^{-N}\) are neglected and not stored on disk. Type: integer; Default: 11. CFOUR_YFIELD¶. Specifies the Y-component of an external electric field. The value must be specified as an integer and the field used by ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html:64611,perform,performed,64611,psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,2,['perform'],['performed']
Performance,"tes it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION¶. Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF; Default: NO. CFOUR_VTRAN¶. This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD¶. Specifies the X-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword . This allows field strengths to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL¶. The tolerance for storing transformed integrals. Integrals less than are neglected and not stored on disk. Type: integer; Default: 11. CFOUR_YFIELD¶. Specifies the Y-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword . This allows field strengths t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:63935,perform,performed,63935,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['perform'],['performed']
Performance,"tes or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_MODULE¶. When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. REL_BASIS¶. Whether to uncontract the basis set in a dual basis calculation. Type: string; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. UNITS¶. Units used in geometry specification. Type: string; Possible Values: BOHR, AU, A.U., ANGSTROMS, ANG, ANGSTROM; Default: ANGSTROMS. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS¶. CubicScalarGrid maximum number of grid points per evaluation block. Type: integer; Default: 1000. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. DERTYPE¶. Derivative leve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__globals-1.html:5667,optimiz,optimized,5667,psi4manual/1.0.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__globals-1.html,2,['optimiz'],['optimized']
Performance,"tes that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:17949,optimiz,optimization,17949,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"tes which properties should be computed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); #PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory |; +-------------------------+---------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:35165,optimiz,optimize,35165,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,3,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"tes, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; 1; 2; 3; 4; 5; 6set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2; 1; 2; 3; 4freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3; 1; 2; 3; 4; 5freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4; 1; 2; 3; 4; 5; 6set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:6520,optimiz,optimize,6520,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimize']
Performance,"tesian H2O2. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. gdma1; Water RHF/cc-pVTZ distributed multipole analysis. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dcft2; DC-06 calculation for the He dimer. This performs a two-step updat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:23009,perform,performs,23009,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['perform'],['performs']
Performance,"tesian() or fail. getSDF()[source]¶; Function to return the SDF (structure-data file) of the PubChem object. getXYZFile()[source]¶; Function to obtain preferentially a molecule string; through getCartesian() or a query string otherwise. name()[source]¶; Function to return the IUPAC name of the PubChem object. getPubChemResults(name)[source]¶; Function to query the PubChem database for molecules matching the; input string. Builds a PubChem object if found. psiexceptions¶; Module with non-generic exceptions classes. exception PsiException[source]¶; Error class for Psi. exception ValidationError(msg)[source]¶; Error called for problems with the input file. Prints; error message msg to standard output stream and output file. frac¶. frac_nuke(mol, **kwargs)[source]¶. frac_traverse(mol, **kwargs)[source]¶. ip_fitting(mol, omega_l, omega_r, **kwargs)[source]¶. molutil¶; Module with utility functions that act on molecule objects. BFS(self)¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. activate(mol)[source]¶; Function to set molecule object mol as the current active molecule. dynamic_variable_bind(cls)[source]¶; Function to dynamically add extra members to; the PsiMod.Molecule class. extract_cluster_indexing(mol, cluster_size=0)[source]¶; Function to returns a LIST of all subclusters of the molecule mol of; real size cluster_size. If cluster_size = 0, returns all possible; combinations of cluster size. extract_clusters(mol, ghost=True, cluster_size=0)[source]¶; Function to return all subclusters of the molecule mol of; real size cluster_size and all other atoms ghosted if ghost; equals true, all other atoms discarded if ghost is false. If; cluster_size = 0, returns all possible combinations of cluster size. geometry(geom, name='default')[source]¶; Function to create a mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:6212,Perform,Perform,6212,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['Perform'],['Perform']
Performance,"test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that ~/.psi4rc values can be overridden by; the user).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files.; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion factor ; psi_hartree2J = 4.359744E-18 # Hartree to joule conversion factor ; psi_hartree2aJ = 4.359744 # Hartree to attojoule (10$^{-18}$J) con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:1601,load,loaded,1601,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,8,['load'],['loaded']
Performance,"test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. dft-freq-analytic2; Analytic UKS SVWN frequencies, compared to finite difference values. numpy-array-interface; Numpy interface testing. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. remp-energy1; integral conventional REMP/cc-pVDZ energies for the H2O molecule. results were independently verified against the initial wavels implementation. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc54; CCSD dipole with user-specified basis set. cubeprop; RHF orbitals and density for water. stability1; UHF->UH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/testsuite.html:1220,optimiz,optimizations,1220,psi4manual/master/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/master/testsuite.html,1,['optimiz'],['optimizations']
Performance,"text{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy MethodsThe presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:. name (str) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cbs.html:7490,perform,performed,7490,psi4manual/master/cbs.html,https://psicode.org,https://psicode.org/psi4manual/master/cbs.html,8,['perform'],['performed']
Performance,"th 6-31G basis set. opt11; Transition-state optimizations of HOOH to both torsional transition states. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. scf-occ; force occupations in scf. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. scf6; Tests RHF/ROHF/UHF SCF gradients. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. dft-reference; MP2 with a PBE0 reference computation. dft-custom; DFT custom functional test. dct10; The multiple guesses for DCT amplitudes for ODC-12. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:39966,optimiz,optimizations,39966,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimizations']
Performance,"th ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The various orbital-optimized methods supported by the OCC/DFOCC; modules in PSI4 are summarized in Table OCC OO; Methods and detailed in Table OCC; OO Capabilities. Note that while two; separate libraries OCC (conventional integrals CONV) and DFOCC; (density-fitted DF and Cholesky-decomposed CD) together provide; the methods described on this page, they are controlled through one; QC_MODULE value OCC. Without set qc_module occ,; these methods may default to implementations in other modules based on efficiency considerations. Orbital-optimized theoretical methods accessible through OCC/DFOCC¶. name; calls method; OO. omp2; orbital-optimized second-order MP perturbation theory; E/G. omp2.5; orbital-optimized average of MP2 and MP3; E/G. omp3; orbital-optimized third-order MP perturbation theory; E/G. oremp2; orbital-optimized second-order REMP hybrid PT; E/G. olccd; orbital-optimized linear coupled cluster doubles; E/G. Detailed orbital-optimized capabilities of the OCC module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[1] ↓ →; FREEZE_CORE[2]→. QC_MODULE=OCC Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. omp2[4]; MP2_TYPE; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. omp2.5[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:10486,optimiz,optimized,10486,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['optimiz'],['optimized']
Performance,"th iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC;  . 2; CC(n-1)[n];  . 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a;  . 6; CC(n)-1b;  . 7; CCn;  . 8; CC(n)-3;  . Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. Previous topic; Interface to Molden, molden(); Next topic; Psithon Functions: Invoking a Calculation. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Interfaces: Enhancing Psi4 Capabilities ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/mrcc-1.html:3630,optimiz,optimize,3630,psi4manual/1.0.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/mrcc-1.html,4,['optimiz'],['optimize']
Performance,"th one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html:2932,optimiz,optimization,2932,psi4manual/1.8.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"th up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CPHF); CPHF — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:9739,CACHE,CACHELEVEL,9739,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,4,"['CACHE', 'Cache']","['CACHELEVEL', 'Cacheing']"
Performance,"th=relpath, graphicsformat=graphicsformat); return filedict. [docs] def write_xyz_files(self, path=None):; """"""Writes xyz files for every reagent in the Database to directory; in *path* or to directory dbse_xyzfiles that it createsin cwd if; *path* is None. Additionally, writes a script to that directory; that will generate transparent-background ray-traced png files for; every reagent with PyMol. """"""; if path is None:; xyzdir = os.getcwd() + os.sep + self.dbse + '_xyzfiles' + os.sep; else:; xyzdir = os.path.abspath(path) + os.sep; if not os.path.exists(xyzdir):; os.mkdir(xyzdir). for rgt, orgt in self.hrgt.iteritems():; omol = Molecule(orgt.mol); omol.update_geometry(); omol.save_xyz(xyzdir + rgt + '.xyz'). with open(xyzdir + 'pymol_xyz2png_script.pml', 'w') as handle:; handle.write(""""""; # Launch PyMOL and run from its command line:; # PyMOL> cd {}; # PyMOL> @{}; """""".format(xyzdir, 'pymol_xyz2png_script.pml')); for rgt in self.hrgt.keys():; handle.write(""""""; load {xyzfile}; hide lines; show sticks; color grey, name c; cmd.set('''opaque_background''','''0''',quiet=0); reset; orient; cmd.zoom(buffer=0.3, complete=1); ray; png {pngfile}; reinitialize; """""".format(; xyzfile=xyzdir + rgt + '.xyz',; pngfile=xyzdir + rgt + '.png')). [docs] def plot_all_flats(self, modelchem=None, sset='default', xlimit=4.0,; failoninc=True,; saveas=None, relpath=False, graphicsformat=['pdf']):; """"""Generate pieces for inclusion into tables. Supply list of; modelchemistries to plot from *modelchem*, otherwise defaults to; all those available. Can modify subset *sset* and plotting; range *xlimit*. >>> asdf.plot_all_flats(sset='tt-5min', xlimit=4.0); """"""; mcs = self.mcs.keys() if modelchem is None else modelchem; filedict = OrderedDict(); for mc in sorted(mcs):; minifiledict = self.plot_flat(mc, sset=sset, xlimit=xlimit, view=False,; failoninc=failoninc,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); filedict[mc] = minifiledict; return filedict. [docs] def get_hrxn(self, sset=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:70715,load,load,70715,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['load']
Performance,"that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → psi::Matrix¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:147611,Perform,Performs,147611,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['Perform'],['Performs']
Performance,"that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; 1; 2; 3; 4F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  ; \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE [6];  ; \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times 10^{-3}\). TURBOMOLE [4]; \(1.0 \times 10^{-6}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\). GAU [3] [6];  ; \(4.5 \times 10^{-4}\); \(3.0 \times 10^{-4}\); \(1.8 \times 10^{-3}\); \(1.2 \times 10^{-3}\). CFOUR [4];  ;  ; \(1.0 \times 10^{-4}\);  ;  . QCHEM [1] [5]; \(1.0 \times 10^{-6}\); \(3.0 \times 10^{-4}\);  ; \(1.2 \times 10^{-3}\);  . MOLPRO [2] [5]; \(1.0 \times 10^{-6}\); \(3.0 \times 10^{-4}\);  ; \(3.0 \times 10^{-4}\);  . GAU_TIGHT [3] [6];  ; \(1.5 \times 10^{-5}\); \(1.0 \times 10^{-5}\); \(6.0 \times 10^{-5}\); \(4.0 \times 10^{-5}\). GAU_VERYTIGHT [6];  ; \(2.0 \times 10^{-6}\); \(1.0 \times 10^{-6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:11870,optimiz,optimization,11870,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,2,['optimiz'],['optimization']
Performance,"that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; 1; 2; 3; 4F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  ; \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE [6];  ; \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times 10^{-3}\). TURBOMOLE [4]; \(1.0 \times 10^{-6}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\). GAU [3] [6];  ; \(4.5 \times 10^{-4}\); \(3.0 \times 10^{-4}\); \(1.8 \times 10^{-3}\); \(1.2 \times 10^{-3}\). CFOUR [4];  ;  ; \(1.0 \times 10^{-4}\);  ;  . QCHEM [1] [5]; \(1.0 \times 10^{-6}\); \(3.0 \times 10^{-4}\);  ; \(1.2 \times 10^{-3}\);  . MOLPRO [2] [5]; \(1.0 \times 10^{-6}\); \(3.0 \times 10^{-4}\);  ; \(3.0 \times 10^{-4}\);  . INTERFRAG_TIGHT [7]; \(1.0 \times 10^{-6}\); \(1.5 \times 10^{-5}\); \(1.0 \times 10^{-5}\); \(6.0 \times 10^{-4}\); \(4.0 \times 10^{-4}\). GAU_TIGHT [3] [6];  ; \(1.5 \times 10^{-5}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/optking-1.html:11889,optimiz,optimization,11889,psi4manual/1.2.1/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/optking-1.html,4,['optimiz'],['optimization']
Performance,"the H2O molecule. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. mom-h2o-4; MOM excitation from LUMO HOMO+4. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. scf-response3; UHF Dipole Polarizability Test. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. sapt10; usapt example with empty beta due to frozen core. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cc51; EOM-CC3/cc-pVTZ on H2O. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. sapt9; usapt example with emp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:4792,perform,performs,4792,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"the H2O molecule. scf-coverage; Lithium test for coverage. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. cbs-parser; mtd/basis syntax examples. casscf-fzc-sp; CASSCF/6-31G** energy point. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. cbs-xtpl-func; optimization with method defined via cbs. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. dfccs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:5324,perform,performed,5324,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"the H2O molecule. scf3; are specified explicitly. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). omp2_5-1; OMP2 cc-pVDZ energy for the H2O molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:13017,optimiz,optimization,13017,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"the H2O molecule. scf3; are specified explicitly. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). omp2_5-1; OMP2 cc-pVDZ energy for the H2O molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:13015,optimiz,optimization,13015,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. INTEGRAL_CUTOFF¶. Cutoff value for DF integrals. Type: integer; Default: 9. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MP2_AMP_TYPE¶. The algorithm that used to handle mp2 amplitudes. The DIRECT option means compute amplitudes on the fly * whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm avail",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html:3097,optimiz,optimization,3097,psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,2,['optimiz'],['optimization']
Performance,"the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. INTEGRAL_CUTOFF¶. Cutoff value for DF integrals. Type: integer; Default: 9. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MP2_AMP_TYPE¶. The algorithm that used to handle mp2 amplitudes. The DIRECT option means compute amplitudes on the fly whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently Quasy Newton-Raphson algorithm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html:3124,optimiz,optimization,3124,psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,2,['optimiz'],['optimization']
Performance,"the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. INTEGRAL_CUTOFF¶. Cutoff value for DF integrals. Type: integer; Default: 9. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MP2_AMP_TYPE¶. The algorithm that used to handle mp2 amplitudes. The DIRECT option means compute amplitudes on the fly whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__dfocc-1.html:3095,optimiz,optimization,3095,psi4manual/1.1.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__dfocc-1.html,4,['optimiz'],['optimization']
Performance,"the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:8315,optimiz,optimization,8315,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,6,['optimiz'],"['optimization', 'optimized']"
Performance,"the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/introduction-1.html:8365,optimiz,optimization,8365,psi4manual/4.0b5/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/introduction-1.html,6,['optimiz'],"['optimization', 'optimized']"
Performance,"the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html:15151,perform,perform,15151,psi4manual/1.3.2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html,2,['perform'],['perform']
Performance,"the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import numpy as np. from psi4 import core; from psi4.driver import constants; from psi4.driver.p4util.exceptions import *. def least_squares_fit_polynomial(xvals, fvals, localization_point, no_factorials=True, weighted=True, polynomial_order=4):; """"""Performs and unweighted least squares fit of a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See http://dx.doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]def anharmonicity(rvals, energies, plot_fit='', mol = None):; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. http://dx.doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/diatomic.html:1325,Perform,Performs,1325,psi4manual/1.3.2/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/diatomic.html,1,['Perform'],['Performs']
Performance,"the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:4568,Optimiz,Optimize,4568,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,20,"['Optimiz', 'optimiz']","['Optimize', 'optimize']"
Performance,"the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy sca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:11433,optimiz,optimize,11433,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['optimiz'],['optimize']
Performance,"the density-fitted orbital optimized CC codes.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE dfocc(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; displace_atom(...); displace_atom( (Matrix)arg1, (int)arg2, (int)arg3, (int)arg4, (float)arg5) -> Matrix :; Displaces one coordinate of single atom.; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE displace_atom(N5boost10shared_ptrIN3psi6MatrixEEE,i,i,i,d); ; dmrg(...); dmrg( (Wavefunction)arg1) -> Wavefunction :; Runs the DMRG code.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE dmrg(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; efp_init(...); efp_init() -> EFP :; Initializes the EFP library and returns an EFP object.; ; C++ signature :; N5boost10shared_ptrIN3psi3efp3EFPEEE efp_init(); ; efp_set_options(...); efp_set_options() -> None :; Set EFP options from environment options object.; ; C++ signature :; void efp_set_options(); ; fd_1_0(...); fd_1_0( (Molecule)arg1, (list)arg2) -> Matrix :; Performs a finite difference gradient computation, from energy points.; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE fd_1_0(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE); ; fd_freq_0(...); fd_freq_0( (Molecule)arg1, (list)arg2, (int)arg3) -> Matrix :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE fd_freq_0(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE,i); ; fd_freq_1(...); fd_freq_1( (Molecule)arg1, (list)arg2, (int)arg3) -> Matrix :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE fd_freq_1(N5boost10shared_ptrIN3psi8MoleculeEEE,N5boost6python4listE,i); ; fd_geoms_1_0(...); fd_geoms_1_0( (Molecule)arg1) -> matrix_vector :; Gets list of displacements needed for a finite difference gradient computation, from energy points.; ; C++ signature :; St6vectorIN5boost10shared",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:679864,Perform,Performs,679864,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['Perform'],['Performs']
Performance,"the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. libint2_solid_harmonics_ordering(); The solid harmonics setting of Libint2 currently active for Psi4. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the symmetry adapted perturbation theory code. scalar_variab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:7369,Load,Load,7369,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,2,['Load'],['Load']
Performance,"the function should follow the pattern <scf|corl>_xtpl_<scientist>_<#basis>. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; Some existing examples are below. psi4.driver.aliases.sherrill_gold_standard(**kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). Return type:; List[Dict[str, Any]]. psi4.driver.aliases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:31007,optimiz,optimization,31007,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"the function should follow the pattern <scf|corl>_xtpl_<scientist>_<#basis>. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; Some existing examples are below. psi4.driver.aliases.sherrill_gold_standard(**kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). Return type; List[Dict[str, Any]]. psi4.driver.aliases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:30946,optimiz,optimization,30946,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"the geometry in string geom. get_memory(); Return the total memory allocation in bytes. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Runs IPIBroker to connect to i-PI (https://ipi-code.org/). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_method(name); Replace characters in method name so that suitable for function name or Sphinx table anchor (both as-is) or HTML table link (replace underscore in returned string by dash). sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:19117,perform,perform,19117,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"the given excitation level EX_LEVEL. Type: boolean; Default: true. MIXED4 (DETCI)¶DETCI (Expert) — Do allow “mixed” excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MO_DIIS_NUM_VECS (DFOCC)¶DFOCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER (DFOCC)¶DFOCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 100. MO_MAXITER (OCC)¶OCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF)¶MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OCC)¶OCC — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX (DFOCC)¶DFOCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_STEP_MAX (OCC)¶OCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OCC)¶OCC — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODULE (CPHF)¶CPHF — What app to test?. Type: string; Possible Values: RCPHF; Default: RCPHF. MOGRAD_DAMPING (OCC)¶OCC — Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MOLDEN_WITH_VIRTUAL (GLOBALS)¶GLOBALS — Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MOLDEN_WRITE (DFOCC)¶DFOCC — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MOLDEN_WRITE (SCF)¶SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:175963,optimiz,optimization,175963,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,4,['optimiz'],['optimization']
Performance,"the index. Note we didn’t need to specify ghost atoms, and we didn’t need; to call the monomer and dimer computations separately. The built-in; Psithon function cp() does it all for us, automatically.; And that’s it! The only remaining part of the example input is a little table; of the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol, which is; defined in Sec. Scratch Files and the ~/.psi4rc File. Notice the loop over to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. Table Of Contents. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Previous topic; Introduction; Next topic; Configuration: Preparing PSI4’s Environment; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Aug 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:19982,Optimiz,Optimization,19982,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,2,['Optimiz'],['Optimization']
Performance,"the installed or staged Psi4; How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set PSIDATADIR and why; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct“; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4. Installing from Binary; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of PSI4; Useful Commands; Troubleshooting. Scra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:2790,queue,queue,2790,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,2,['queue'],['queue']
Performance,"the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local intern",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:8029,optimiz,optimizer,8029,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['optimiz'],['optimizer']
Performance,"the number of distances""); npoints = len(rvals); if npoints < 5:; raise ValidationError(""At least 5 data points must be provided to compute anharmonicity""); core.print_out(""\n\nPerforming a fit to %d data points\n"" % npoints). # Make sure the molecule the user provided is the active one; molecule = mol if mol is not None else core.get_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n"");; re = np.mean(rvals); maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g));; if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * np.pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11 * np.sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/diatomic.html:4898,optimiz,optimization,4898,psi4manual/1.2.1/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/diatomic.html,2,['optimiz'],['optimization']
Performance,"the number of distances""); npoints = len(rvals); if npoints < 5:; raise ValidationError(""At least 5 data points must be provided to compute anharmonicity""); core.print_out(""\n\nPerforming a fit to %d data points\n"" % npoints). # Make sure the molecule the user provided is the active one; molecule = mol if mol is not None else core.get_active_molecule(); molecule.update_geometry(); natoms = molecule.natom(); if natoms != 2:; raise Exception(""The current molecule must be a diatomic for this code to work!""); m1 = molecule.mass(0); m2 = molecule.mass(1). # Optimize the geometry, refitting the surface around each new geometry; core.print_out(""\nOptimizing geometry based on current surface:\n\n"");; re = np.mean(rvals); maxit = 30; thres = 1.0e-9; for i in range(maxit):; derivs = least_squares_fit_polynomial(rvals,energies,localization_point=re); e,g,H = derivs[0:3]; core.print_out("" E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g)); if abs(g) < thres:; break; re -= g/H;; if i == maxit-1:; raise ConvergenceError(""diatomic geometry optimization"", maxit); core.print_out("" Final E = %20.14f, x = %14.7f, grad = %20.14f\n"" % (e, re, g));; if re < min(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a lower range of r values.""); if re > max(rvals):; raise Exception(""Minimum energy point is outside range of points provided. Use a higher range of r values.""). # Convert to convenient units, and compute spectroscopic constants; d0,d1,d2,d3,d4 = derivs*constants.hartree2aJ; core.print_out(""\nEquilibrium Energy %20.14f Hartrees\n"" % e); core.print_out(""Gradient %20.14f\n"" % g); core.print_out(""Quadratic Force Constant %14.7f MDYNE/A\n"" % d2); core.print_out(""Cubic Force Constant %14.7f MDYNE/A**2\n"" % d3); core.print_out(""Quartic Force Constant %14.7f MDYNE/A**3\n"" % d4). hbar = constants.h / (2.0 * pi); mu = ((m1*m2)/(m1+m2))*constants.amu2kg; we = 5.3088375e-11*sqrt(d2/mu); wexe = (1.2415491e-6)*(we/d2)**2 * ((5.0*d3*d3)/(3.0*d2)-d4). # R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/diatomic.html:4923,optimiz,optimization,4923,psi4manual/1.1.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/diatomic.html,1,['optimiz'],['optimization']
Performance,"the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" %; (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (opt_mode == 'continuous') and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.get_variable('CURRENT ENERGY'). # Compute the gradient; G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.get_variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). # S/R: Quit after getting new displacements or if forming gradient fails; if opt_mode == 'sow':; return (0.0, None); elif opt_mode == 'reap' and thisenergy == 0.0:; return (0.0, None). core.set_gradient(G). # S/R: Move opt data file from last pass into namespace for this pass; if opt_mode == 'reap' and n != 0:; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); if 'opt_datafile' in kwargs:; restartfile = kwargs.pop('opt_datafile'); shutil.copy(restartfile, p4util.get_psifile(1)). # opt_func = kwargs.get('opt_func', kwargs.get('func', energy)); # if opt_func.__name__ == 'complete_basis_set':; # core.IOManager.shared_object().set_specific_retention(1, True). if full_hess_every > -1:; core.set_global_option('HESSIAN_WRITE', True). # compute Hessian as requested; frequenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:61910,optimiz,optimization,61910,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimization']
Performance,"the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment. Also, the SAD; UHF guess is very slow in large basis sets, so you may want to cast up for; >TZ.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). Table Of Contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. Previous topic; Notes on Options; Next topic; DFT: Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:24150,optimiz,optimized,24150,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,2,['optimiz'],['optimized']
Performance,"the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment. Also, the SAD; UHF guess is very slow in large basis sets, so you may want to cast up for; >TZ.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). Table Of Contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. Previous topic; Notes on Options; Next topic; DFT: Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/scf-1.html:24565,optimiz,optimized,24565,psi4manual/4.0b5/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/scf-1.html,2,['optimiz'],['optimized']
Performance,"the program to calculate and store all elements of , while DIRECT (=1) tells the program to use alternative algorithms in which is calculated and used “on the fly”. Note that this option might be not available for all type of calculations. Type: string; Possible Values: DISK, DIRECT; Default: DISK. CFOUR_GENBAS_1 (CFOUR); CFOUR — This keyword applies only to Hydrogen and Helium atoms and specifies the number of contracted Gaussian functions per shell. There is usually no need to use this keyword, but it can be useful for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below Hartree/bohr, where is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:46819,perform,performs,46819,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performs']
Performance,"the rest of the code), it can be set by with the; psi4.set_module_options() API function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like psi4.set_options() API, psi4.set_module_options() API, psi4.energy() API, psi4.optimize(); API, psi4.frequency() API, etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT computations (i.e., SAPT0), a good error cancellation is found (Hohenstein:2012:WIREs) with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and without diffuse \(d\) functions on heavy atoms) (Papajak:2011:10). So,; we’ll use that as our standard basis set. The SAPT code is designed to use density fitting techniques, because they introduce minimal errors while providing much faster computations (Hohenstein:2010:184111,Hohenstein:2010:014101). Since we’re using density fitting for the SAPT, we might as well also use it for the Hartree-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is usually smart enough to figure out what auxiliary basis sets are needed for a given computation. In this case, jun-cc-pVDZ is a standard enough basis set (just a simple truncation of the very popular aug-cc-pVDZ basis set) that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the SAPT; procedure.; To speed up the computation a little, we also tell the SAPT procedure to freeze the core electrons by adding 'freeze_core': 'true' to the dictionary passed to psi4.set_options(). The SAPT procedure is invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here, Psi4 knows to automatically run two monomer comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:14060,perform,performed,14060,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['perform'],['performed']
Performance,"the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below Hartree/bohr, where is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR); CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:47951,optimiz,optimizations,47951,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['optimiz'],"['optimizations', 'optimizer']"
Performance,"the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. NAT_ORBS_T2¶. Do use MP2 natural orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/sapt-1.html:12611,perform,perform,12611,psi4manual/4.0b3/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/sapt-1.html,6,['perform'],['perform']
Performance,"the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. casscf-sp; CASSCF/6-31G** energy point. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-h2o; RASCI/6-31G** H2O Energy Point. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:7152,perform,performed,7152,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"the ~/.psi4rc File. Return Values and PSI Variables¶; To harness the power of Python, PSI4 makes the most pertinent results of; each computation are made available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of H2; and H atom:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol*(2*h_energy - h2_energy); print""De=%f""%D_e. The energy() function returns the final result of the computation, which we; assign to a Python variable. The two energies are then converted to a; dissociation energy and printed to the output file using standard Python; notation. Sometimes there are multiple quantities of interest; these can be; accessed through the get_variable() function. For example, after performing a; density fitted MP2 computation, both the spin component scaled energy and the; unscaled MP2 energy are made available:; e_mp2=get_variable('DF-MP2 TOTAL ENERGY'); e_scs_mp2=get_variable('SCS-DF-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of; a calculation. The values for all can be printed in the output file; with the input file command print_variables(). Note that; PSI variables accumulate over a PSI4 instance and are not cleared by; clean(). So if you run in a single input file a STO-3G FCI; followed by a aug-cc-pVQZ SCF followed by a print_variables(); command, the last will include both SCF TOTAL ENERGY and; FCI TOTAL ENERGY. Don’t get excited that you got a high-quality calculation; cheaply. Refer to Appendix PSI Variables by Module for a listing of the; variables set by each module. Loops¶; Python provides many control structures, which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets=[""cc-pVDZ"",""cc-pVTZ"",""cc-pVQZ""]; for basis_set in basis_sets:; s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:20832,perform,performing,20832,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,4,['perform'],['performing']
Performance,"the; integrals. The convergence of the two-step algorithm is accelerated using the; DIIS extrapolation technique.; 2) Simultaneous algorithm (set ALGORITHM to SIMULTANEOUS). In this algorithm; each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. The macroiterations are repeated until the simultaneous; convergence of the cumulant and the orbitals is achieved. As in the two-step algorithm, the DIIS; extrapolation is used to accelerate the convergence.; 3) Quadratically-convergent algorithm (set ALGORITHM to QC). The; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. The electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. By default the; electronic Hessian also contains the matrix elements that couple the orbitals; and the density cumulant. The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems. If the computation of the coupling elements; is not desired, it can be turned off by setting QC_COUPLING to FALSE.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below .; The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:7323,perform,performed,7323,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['perform'],['performed']
Performance,"then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MO_MAXITER (OMP2); OMP2 — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_MAXITER (OMP3); OMP3 — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF); MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OMP2); OMP2 — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_READ (OMP3); OMP3 — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_RELAX (DCFT); DCFT (Expert) — Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. MO_STEP_MAX (OMP2); OMP2 — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_STEP_MAX (OMP3); OMP3 — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OMP2); OMP2 — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MO_WRITE (OMP3); OMP3 — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODE (TRANSQT); TRANSQT — The way of transformation, from ao basis to mo basis or vice versa. Type: string; Possible Values: TO_MO, TO_AO; Default: TO_MO. MODULE (CPHF); CPHF — What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. MOLDEN_FILE (SCF); SCF — The name of a molden-style output file which is only generated if the user specifies one. Type: string; Default: No Default. MOM_OCC (SCF); SCF — The absolute indices of orbitals to excite from in MOM (+/- for alpha/bet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:74003,optimiz,optimization,74003,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"theories provided in PSI4.; To indicate MRCC as the target software, set QC_MODULE=MRCC.; This is a change as of October 2022; previously, one prefixed the method by “mr”; to indicate MRCC (e.g., energy('mrccsdt')).; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; qc_module mrcc; }; energy('ccsdt'). 'ccsdt' in the call to energy() plus qc_module=mrcc instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; Here the qc_module=mrcc is optional since PSI4 has no builtin module; that can perform CCSDT. For a method like CCSD, no specification of QC_MODULE; will default to the CCENERGY module, and specification with value mrcc is; required to route the computation to the MRCC program.; For a CCSDT(Q) energy, simply use 'ccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you can call it directly; For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC.; Perturbative methods (ccsd(t), ccsdtqp(h)_l, etc.); are available with REFERENCE ROHF in versions of MRCC published; at least after July 1, 2014.; When using ROHF-CCSDT(Q), MRCC will compute and report two variants:; CCSDT(Q)/A and CCSDT(Q)/B. [Kallay:2008:144101] PSI4 will save both energies but will use; the CCSDT(Q)/B as the CCSDT(Q) energy. CCSDT(Q)/B has been found to be; more robust by Martin. [Martin:2014:785]. QC_MODULE=MRCC. name; calls method in Kallay’s MRCC program [manual]. ccsd; CC through doubles [details]. ccsdt; CC through triples. ccsdtq; CC through quadruples. ccsdtqp; CC through quintuples. ccsdtqph; CC through sextup",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/mrcc.html:1821,perform,perform,1821,psi4manual/master/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/master/mrcc.html,8,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"theory. OMP3 CORRELATION ENERGY. OMP3 DOUBLES ENERGY. OMP3 TOTAL ENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRON ENERGY. one_electron_integrals() psi4.core.MintsHelper method. OneBodyAOInt class in psi4.core. OneBodySOInt class in psi4.core. onel_Hx() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() psi4.core.CIWavefunction method. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:101063,optimiz,optimize,101063,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['optimiz'],['optimize']
Performance,"theory. OMP3 CORRELATION ENERGY. OMP3 DOUBLES ENERGY. OMP3 TOTAL ENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRON ENERGY. one_electron_integrals() psi4.core.MintsHelper method. OneBodyAOInt class in psi4.core. OneBodySOInt class in psi4.core. onel_Hx() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() psi4.core.CIWavefunction method. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. orientation_fixed() psi4.core.Molecule method. ori",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:100028,optimiz,optimize,100028,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['optimiz'],['optimize']
Performance,"theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provide",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/testsuite-1.html:17917,perform,performed,17917,psi4manual/4.0b3/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/testsuite-1.html,4,['perform'],['performed']
Performance,"ther specify a basis known to CFOUR or via BASIS=SPECIAL (=0) requests an arbitrary basis (see non-standard basis-set input). However, the latter must be available in the supplied GENBAS file. As standard basis sets, currently the following are available. Psi4 Interface: Recommended to use instead BASIS for larger basis set selection and greater flexibility. When BASIS used, CFOUR_SPHERICAL is set appropriately. Type: string; Default: SPECIAL. CFOUR_BRUCK_CONV (CFOUR); CFOUR — experimental use. Type: integer; Default: 4. CFOUR_BRUECKNER (CFOUR); CFOUR — Specifies whether Brueckner orbitals are to be determined for the specified CC method. OFF(=0) Brueckner orbitals are not to be determined, ON (=1) they are to be determined. Type: boolean; Default: false. CFOUR_CACHE_RECS (CFOUR); CFOUR — The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL (CFOUR); CFOUR — Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Default: SCF. CFOUR_CC_CONV (CFOUR); CFOUR — Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than \(10^N\), where \(N\) is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER (CFOUR); CFOUR — Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION (CFOUR); CFOUR — Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS (=1) uses the DIIS approach by Pulay, NOJACOBI (=2) uses RLE with continuous ext",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:24530,perform,performed,24530,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"ther they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. fci-h2o; 6-31G H2O Test FCI Energy Point. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. mbis-5; MBIS calculation on ZnO. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cbs-parser; mtd/basis syntax examples. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. fci-dipole; 6-31G H2O Test FCI Energy Point. scf-response3; UHF Dipole Polarizability Test. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cc13a; UHF-CCSD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:34275,perform,performed,34275,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"ther. This; is presented in the “Orbital Check” section in these files – a value larger than; 0.1 docc is an indication that the picture of localizable functional groups may; be breaking down. We also strongly discourage the cutting of double,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Order-1 Visualization with PyMol¶; The fsapt.py script above also generates a number of order-1 .pdb files; that can be used to get a quick qualitative picture of the F-SAPT partition. The; preferred way to do this is to use PyMol to make plots of the molecular geometry; with the atoms colored according to their order-1 F-SAPT contributions. We have; a set of template .pymol scripts to help with this process. These can be; obtained by running:; 1>>> copy_pymol.py. and then in PyMol:; 1>>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; Elst.pymol), which in turn load in the molecule and order-1 analysis; (contained in the .pdb file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Difference F-SAPT Analysis¶; For those interested in taking the differences between two F-SAPT partitions; (e.g., to see how a substituent modulates a noncovalent interaction), we have; the fsapt-diff.py script to help with this. This is invoked as:; 1>>> fsapt-diff.py source-fsapt-dir1 source-fsapt-dir2 target-diff-fsapt-dir. Where the use has already performed fsapt.py analysis using the same; functional group names in source-fsapt-dir-1 and source-fsapt-dir-2. The; difference F-SAPT partition entries are computed as \(E^{\Delta} = E^{1} -; E^{2}\), and the geometries for order-1 .pdb visualization files are taken; from system 1. I-SAPT: A Representative Example¶. Caution; As of April 2018, you can’t specify molecule fragme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/fisapt-1.html:7630,load,load,7630,psi4manual/1.2.1/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/fisapt-1.html,4,['load'],['load']
Performance,"ther. This; is presented in the “Orbital Check” section in these files – a value larger than; 0.1 docc is an indication that the picture of localizable functional groups may; be breaking down. We also strongly discourage the cutting of double,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Order-1 Visualization with PyMol¶; The fsapt.py script above also generates a number of order-1 .pdb files; that can be used to get a quick qualitative picture of the F-SAPT partition. The; preferred way to do this is to use PyMol to make plots of the molecular geometry; with the atoms colored according to their order-1 F-SAPT contributions. We have; a set of template .pymol scripts to help with this process. These can be; obtained by running:; 1>>> copy_pymol.py. and then in PyMol:; 1>>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; Elst.pymol), which in turn load in the molecule and order-1 analysis; (contained in the .pdb file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Difference F-SAPT Analysis¶; For those interested in taking the differences between two F-SAPT partitions; (e.g., to see how a substituent modulates a noncovalent interaction), we have; the fsapt-diff.py script to help with this. This is invoked as:; 1>>> fsapt-diff.py source-fsapt-dir1 source-fsapt-dir2 target-diff-fsapt-dir. Where the use has already performed fsapt.py analysis using the same; functional group names in source-fsapt-dir-1 and source-fsapt-dir-2. The; difference F-SAPT partition entries are computed as \(E^{\Delta} = E^{1} -; E^{2}\), and the geometries for order-1 .pdb visualization files are taken; from system 1. I-SAPT: A Representative Example¶; Below, we show an example of using I-SAPT0/jun-cc-pVDZ to an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fisapt-1.html:7628,load,load,7628,psi4manual/1.1.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fisapt-1.html,2,['load'],['load']
Performance,"there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. INTS_TOLERANCE (SCF); SCF — Minimum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. INTS_TOLERANCE (TRANSQT2); TRANSQT2 — Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. IP_POLES (OCC); OCC — Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. IRC_DIRECTION (OPTKING); OPTKING — IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE (OPTKING); OPTKING — IRC step size in bohr(amu). Type: double; Default: 0.2. IRC_STOP (OPTKING); OPTKING — Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. ISTOP (DETCI); DETCI — Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. JOBTYPE (CCLAMBDA); CCLAMBDA (Expert) — Type of job being performed. Type: string; Default: No Default. KEEP_INTCOS (OPTKING); OPTKING — Keep internal coordinate definition file. Type: boolean; Default: false. KEEP_OEIFILE (CCSORT); CCSORT — Do retain the input one-electron integrals?. Type: boolean; Default: false. KEEP_TEIFILE (CCSORT); CCSORT — Do retain the input two-electron integrals?. Type: boolean; Default: false. LEVEL_SHIFT (DFOCC); DFOCC — Level shift to aid convergence. Type: double; Default: 0.02. LEVEL_SHIFT (MCSCF); MCSCF — Level shift to aid convergence. Type: double; Default: 0.0. LEVEL_SHIFT (OCC); OCC — Level shift to aid convergence. Type: double; Default: 0.02. LINEAR (CCRESPONSE); CCRESPONSE — Do Bartlett size-extensive linear model?. Type: boolean; Default: false. LINEQ_SOLVER (DFOCC); DFOCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINEQ_SOLVER (OCC); OCC — The solver will be used for simultaneous linear equa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:144333,perform,performed,144333,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 5; DF. optimization; 8; 6. frequency; 8; 6. SCF of post-HF; energy; 8; 6; PK [3]. optimization; 10; 7. frequency; 10; 7. CC property [2]; 10; 7. Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. [2]This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other program",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:19748,optimiz,optimization,19748,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['optimiz'],['optimization']
Performance,"this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = { 'energy' : step_energies ,; 'gradient' : step_gradients ,; 'coordinates' : step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). # S/R: Preser",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:64878,Optimiz,Optimization,64878,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Optimiz'],['Optimization']
Performance,"this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_wfn:; return (thisenergy, wfn); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if opt_mode == 'reap':; kwargs['opt_datafile'] = p4util.get_psifile(1); kwargs['mode'] = 'sow'. n += 1. if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(). optstash.restore(); raise ConvergenceError(""""""geometry ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:62495,Optimiz,Optimization,62495,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Optimiz'],['Optimization']
Performance,"this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if psi4.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); psi4.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if psi4.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if psi4.get_option('OPTKING', 'KEEP_INTCOS') == False:; psi4.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); psi4.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; psi4.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_wfn:; return (thisenergy, wfn); else:; return thisenergy. elif optking_rval == psi4.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); if (psi4.get_option('OPTKING', 'KEEP_INTCOS') == False):; psi4.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); psi4.clean(); optstash.restore(); return thisenergy. psi4.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if opt_mode == 'reap':; kwargs['opt_datafile'] = p4util.get_psifile(1); kwargs['mode'] = 'sow'. n += 1. psi4.print_out('\tOptimizer: Did not converge!'); if psi4.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if psi4.get_option('OPTKING', 'KEEP_INTCOS') == False:; psi4.opt_clean(). optst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:60653,Optimiz,Optimization,60653,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Optimiz'],['Optimization']
Performance,"this returns whether the option has been touched by the user.; ; libfock(...); libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:161018,optimiz,optimized,161018,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['optimiz'],['optimized']
Performance,"thm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. select_cisd(name, **kwargs)[source]¶; Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. select_fnoccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. select_fnoccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. select_lccd(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. select_lccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. select_mp2(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. select_mp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. select_mp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. select_mp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. select_mp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. select_mp3(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. select_mp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 gradie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:168074,perform,performance,168074,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"thm for a MP2 energy call; and directing to specified or best-performance default modules. select_mp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. select_mp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. select_mp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. select_mp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. select_mp3(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. select_mp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. select_mp4(name, **kwargs)[source]¶; Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. select_olccd(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. select_olccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. select_omp2(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. select_omp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. select_omp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:169068,perform,performance,169068,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"thm for a MP3 gradient call; and directing to specified or best-performance default modules. select_mp4(name, **kwargs)[source]¶; Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. select_olccd(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. select_olccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. select_omp2(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. select_omp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. select_omp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. select_omp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. select_omp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. select_omp3(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. select_omp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. check_iwl_file_from_scf_type(scf_type, wfn)[source]¶; Ensures that a IWL file has been written based on input SCF type. check_non_symmetric_jk_density(name)[source]¶; Ensure non-symmetric density matrices are supported for the selected JK routi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:170062,perform,performance,170062,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"thod, [1], [2]. function_to_shell() psi4.core.BasisSet method, [1], [2]. Functional class in psi4.core, [1]. functional() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.VBase method, [1], [2]. fx() psi4.core.Molecule method, [1], [2]. fy() psi4.core.Molecule method, [1], [2]. fZ() psi4.core.Molecule method, [1], [2]. fz() psi4.core.Molecule method, [1], [2]. G. G_CONVERGENCE (OPTKING). GAUGE (CCDENSITY). (CCRESPONSE). Gaussian Formatted Checkpoint. Gaussian94BasisSetParser class in psi4.core, [1]. GaussianShell class in psi4.core, [1]. GaussianType class in psi4.core, [1]. gCP. GDMA. gdma() in module psi4. in module psi4.driver. GDMA_LIMIT (GDMA). GDMA_MULTIPOLE_UNITS (GDMA). GDMA_ORIGIN (GDMA). GDMA_RADIUS (GDMA). GDMA_SWITCH (GDMA). gemm() psi4.core.Matrix method, [1], [2]. genbas() psi4.core.BasisSet method, [1], [2]. general. ; setting keywords. GEOM_MAXITER (OPTKING). geometry optimization. ; IRC. constrained. convergence criteria. function call. minima. output. transition state. geometry optimization, optimization. geometry() in module psi4.driver. psi4.core.Molecule method, [1], [2]. GeometryUnits class in psi4.core, [1]. get() psi4.core.IntVector method, [1], [2]. psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. get_active_efp() in module psi4.core, [1]. get_active_molecule() in module psi4.core, [1]. get_algorithm() psi4.core.FittingMetric method, [1], [2]. get_array() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. get_array_variable() in module psi4.core, [1]. get_array_variables() in module psi4.core, [1]. get_atomic_point_charges() in module psi4.core, [1]. get_basisset() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:48630,optimiz,optimization,48630,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['optimiz'],['optimization']
Performance,"thod. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SS_SCALE¶. A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SYMMETRIZE¶. Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5, REMP, OREMP; Default: OMP2. Expert¶. SPIN_SCALE_TYPE¶. Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. table of contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DIIS_MAX_VECS; DIIS_MIN_VECS; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; E_CONVERGENCE; IP_POLES; LEVEL_SHIFT; MAX_MOGRAD_CONVERGENCE; MOGRAD_DAMPING; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; NAT_ORBS; OCC_ORBS_PRINT; OEPROP; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; OS_SCALE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; RELAXED; REMP_A; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_TYPE; SS_SCALE; SYMMETRIZE; TPDM_ABCD_TYPE; WFN_TYPE. Expert; SPIN_SCALE_TYPE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__occ.html:8223,CACHE,CACHELEVEL,8223,psi4manual/1.8.x/autodir_options_c/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__occ.html,1,['CACHE'],['CACHELEVEL']
Performance,"thod. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SS_SCALE¶. A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SYMMETRIZE¶. Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5, REMP, OREMP; Default: OMP2. Expert¶. SPIN_SCALE_TYPE¶. Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. table of contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DIIS_MAX_VECS; DIIS_MIN_VECS; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; E_CONVERGENCE; IP_POLES; LEVEL_SHIFT; MAX_MOGRAD_CONVERGENCE; MOGRAD_DAMPING; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; NAT_ORBS; OCC_ORBS_PRINT; OEPROP; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; OS_SCALE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; RELAXED; REMP_A; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_TYPE; SS_SCALE; SYMMETRIZE; TPDM_ABCD_TYPE; WFN_TYPE. Expert; SPIN_SCALE_TYPE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__occ.html:8223,CACHE,CACHELEVEL,8223,psi4manual/1.9.x/autodir_options_c/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__occ.html,1,['CACHE'],['CACHELEVEL']
Performance,"thod. insert() psi4.core.BSVec method. installing. INTCOS_GENERATE_EXIT (OPTKING). integral() psi4.core.MintsHelper method. psi4.core.OrbitalSpace method. INTEGRAL_CUTOFF (DFOCC). INTEGRAL_PACKAGE (GLOBALS). IntegralFactory class in psi4.core. integrals, [1]. integrals() psi4.core.MintsHelper method. integrals_erf() psi4.core.MintsHelper method. integrals_erfc() psi4.core.MintsHelper method. IntegralTransform class in psi4.core. INTERFRAG_DIST_INV (OPTKING). INTERFRAG_HESS (OPTKING). INTERFRAG_MODE (OPTKING). INTERFRAG_STEP_LIMIT (OPTKING). INTERFRAGMENT_CONNECT (OPTKING). INTERNAL_ROTATIONS (MCSCF). INTRAFRAG_HESS (OPTKING). INTRAFRAG_STEP_LIMIT (OPTKING). INTRAFRAG_STEP_LIMIT_MAX (OPTKING). INTRAFRAG_STEP_LIMIT_MIN (OPTKING). INTS_TOLERANCE (CCDENSITY). (DCT). (DFMP2). (FISAPT). (MRCC). (SAPT). (SCF). IntVector class in psi4.core. invert() psi4.core.Matrix method. IO class in psi4.core. IOManager class in psi4.core. IP_POLES (OCC). ipi_broker() in module psi4.driver. IRC. ; geometry optimization. IRC_DIRECTION (OPTKING). IRC_STEP_SIZE (OPTKING). IRC_STOP (OPTKING). IrreducibleRepresentation class in psi4.core. irrep() psi4.core.CdSalc method. irrep_index() psi4.core.CdSalc method. irrep_labels() psi4.core.Molecule method. is_c_hybrid() psi4.core.SuperFunctional method. is_c_lrc() psi4.core.SuperFunctional method. is_c_scs_hybrid() psi4.core.SuperFunctional method. is_cartesian() psi4.core.GaussianShell method. is_done() psi4.core.AOShellCombinationsIterator method. is_gga() psi4.core.Functional method. psi4.core.LibXCFunctional method. psi4.core.SuperFunctional method. is_inverted() psi4.core.FittingMetric method. is_libxc_func() psi4.core.SuperFunctional method. is_lrc() psi4.core.Functional method. psi4.core.LibXCFunctional method. is_meta() psi4.core.Functional method. psi4.core.LibXCFunctional method. psi4.core.SuperFunctional method. is_poisson() psi4.core.FittingMetric method. is_pure() psi4.core.GaussianShell method. is_variable() psi4.core.Molecule method. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:78146,optimiz,optimization,78146,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,5,['optimiz'],['optimization']
Performance,"thod?; if (dertype == 2):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); optstash.restore(). # call thermo module; PsiMod.thermo(). return PsiMod.wavefunction().energy(). elif (dertype == 1):; # Ok, we're doing frequencies by gradients; info = 'Performing finite difference by gradient calculations'; print(info). func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print(' %d displacements needed.' % ndisp). #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # call thermo module; PsiMod.thermo(). optstash.restore(); # TODO: add return statement. else: # Assume energy points; # If not, perform finite diffe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:63763,Load,Loading,63763,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Load'],['Loading']
Performance,"tial energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in Psi4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OLCCD. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hami",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:3792,optimiz,optimized,3792,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,8,['optimiz'],['optimized']
Performance,"tic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc37; CC2(UHF)/cc-pV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/testsuite-1.html:18389,optimiz,optimization,18389,psi4manual/4.0b3/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"ticInt; Computes kinetic integrals. LaplaceDenominator; docstring. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MemDFJK; docstring. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NBOWriter; The Natural Bond Orbital Writer. NablaInt; Computes nabla integrals. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. OneBodySOInt. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapInt; Computes overlap integrals. PMLocalizer; Performs Pipek-Mezey orbital localization. PetiteList; Handles symmetry transformations. PointFunctions; docstring. PointGroup; Contains information about the point group. PotentialInt; Computes potential integrals. PrimitiveType; May be Normalized or Unnormalized. Prop; docstring. PseudospectralInt; Computes pseudospectral integrals. PsiReturnType; Return status. QuadrupoleInt; Computes quadrupole integrals. RHF; docstring. RKSFunctions; docstring. ROHF; docstring. SADGuess; docstring. SOBasisSet; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis. SOMCSCF; docstring. SalcComponent; Component of a Cartesian displacement SALC in the basis of atomic displacements. SaveType; The layout of the matrix for saving. ShellInfo. Slice; Slicing for Matrix and Vector objects. SuperFunctional; docstring. SymmetryOperation; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection. TaskListComputer; docstring. Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:14633,Perform,Performs,14633,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,4,['Perform'],['Performs']
Performance,"ticInt; Computes kinetic integrals. LaplaceDenominator; docstring. LibXCFunctional; docstring. Localizer; Class containing orbital localization procedures. MOSpace; Defines orbital spaces in which to transform integrals. MOWriter; Writes the MOs. Matrix; Class for creating and manipulating matrices. MatrixFactory; Creates Matrix objects. MemDFJK; docstring. MintsHelper; Computes integrals. MoldenWriter; Writes wavefunction information in molden format. MolecularGrid; docstring. Molecule; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. MultipoleInt; Computes arbitrary-order multipole integrals. MultipoleSymmetry; docstring. NBOWriter; The Natural Bond Orbital Writer. NablaInt; Computes nabla integrals. OEProp; docstring. OneBodyAOInt; Basis class for all one-electron integrals. OneBodySOInt. Options; docstring. OrbitalSpace; Contains information about the orbitals. OverlapInt; Computes overlap integrals. PMLocalizer; Performs Pipek-Mezey orbital localization. PetiteList; Handles symmetry transformations. PointFunctions; docstring. PointGroup; Contains information about the point group. PotentialInt; Computes potential integrals. PrimitiveType; May be Normalized or Unnormalized. Prop; docstring. PsiReturnType; Return status. QuadrupoleInt; Computes quadrupole integrals. RHF; docstring. RKSFunctions; docstring. ROHF; docstring. SADGuess; docstring. SOBasisSet; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis. SOMCSCF; docstring. SalcComponent; Component of a Cartesian displacement SALC in the basis of atomic displacements. SaveType; The layout of the matrix for saving. ShellInfo. Slice; Slicing for Matrix and Vector objects. SuperFunctional; docstring. SymmetryOperation; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection. ThreeCenterOverlapInt; Three center overlap integrals. TracelessQuadrupoleInt; Comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:14743,Perform,Performs,14743,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,1,['Perform'],['Performs']
Performance,"ties for Potassium nitrate (rocket fuel!). sapt10; usapt example with empty beta due to frozen core. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. fnocc2; Test G2 method for H2O. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. mints15; check SP basis Fortran exponent parsing. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. dft-dsd; DSD S22 Ammonia test. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. scf-auto-cholesky; Cholesky filter a complete basis. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dct6; DCT calcul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:35494,optimiz,optimization,35494,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"ties in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (OMP3); OMP3 — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:9078,CACHE,CACHELEVEL,9078,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"ties in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:9719,CACHE,CACHELEVEL,9719,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"ties in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Cacheing level for libdpd. Typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:8702,cache,cache,8702,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['cache'],['cache']
Performance,"ties in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CPHF); CPHF — The amount of cacheing of data to perform.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:8577,cache,cache,8577,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,4,['cache'],['cache']
Performance,"ties in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:8772,cache,cache,8772,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,8,['cache'],['cache']
Performance,"ties to compute. Type: array; Default: No Default. PROPERTIES_ORIGIN (GLOBALS); GLOBALS — Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PROPERTY (CCENERGY); CCENERGY — The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, MAGNETIZABILITY, ROA, ALL; Default: POLARIZABILITY. PROPERTY (CCRESPONSE); CCRESPONSE — The response property desired. Acceptable values are POLARIZABILITY (default) for dipole polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. PT_ENERGY (PSIMRCC); PSIMRCC — The type of perturbation theory computation to perform. Type: string; Default: SECOND_ORDER. PUREAM (GLOBALS); GLOBALS — Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_COUPLING (DCFT); DCFT — Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS); GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:188445,perform,perform,188445,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"ties to compute. Type: array; Default: No Default. PROPERTIES_ORIGIN (GLOBALS); GLOBALS — Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PROPERTY (CCENERGY); CCENERGY — The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, MAGNETIZABILITY, ROA, ALL; Default: POLARIZABILITY. PROPERTY (CCRESPONSE); CCRESPONSE — The response property desired. Acceptable values are POLARIZABILITY (default) for dipole polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. PT_ENERGY (PSIMRCC); PSIMRCC — The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. PUREAM (GLOBALS); GLOBALS — Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_COUPLING (DCFT); DCFT — Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS); GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:186441,perform,perform,186441,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,4,['perform'],['perform']
Performance,"ties(wfn); cp.compute_properties(). [docs]def set_memory(bytes):; """"""Function to reset the total memory allocation.""""""; psi4.set_memory(bytes). [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return psi4.get_memory(). [docs]def set_num_threads(nthread):; """"""Function to reset the number of threads to parallelize across.""""""; psi4.set_nthread(nthread). [docs]def get_num_threads():; """"""Function to return the number of threads to parallelize across.""""""; return psi4.nthread(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); psi4.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`uti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:3762,Perform,Performs,3762,psi4manual/1.0.0/_modules/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html,1,['Perform'],['Performs']
Performance,"timization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using finite differences of energies instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). import optking. Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:4147,Optimiz,Optimize,4147,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['Optimiz'],['Optimize']
Performance,"timization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using finite differences of energies instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). import optking. Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶; Optking currently has two transition state algorithms. The current default is the; newer RS_I_RFO algorithm [Besalu:1998:265] . The old algorithm can be used by setting; STEP_TYPE P_RFO for OPT_TYPE TS. Calculate a starting Hessian and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:4166,Optimiz,Optimize,4166,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['Optimiz'],['Optimize']
Performance,"timization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:1828,perform,performs,1828,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,2,['perform'],['performs']
Performance,"timize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond dista",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:5426,optimiz,optimization,5426,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimization']
Performance,"timize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:5712,optimiz,optimization,5712,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,4,['optimiz'],['optimization']
Performance,"timize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragmen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optking-1.html:5386,optimiz,optimization,5386,psi4manual/4.0b4/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html,4,['optimiz'],['optimization']
Performance,"timize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond dista",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:5438,optimiz,optimization,5438,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['optimiz'],['optimization']
Performance,"timized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimize",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:17296,Optimiz,Optimized,17296,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,17,['Optimiz'],['Optimized']
Performance,"timized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/introduction-1.html:9430,optimiz,optimized,9430,psi4manual/4.0b5/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/introduction-1.html,2,['optimiz'],['optimized']
Performance,"tinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are written to the; designated scratch numbered by content and labeled; with the process id, then are deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the PSI4 I/O management routines is available,; and is called psi4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to your input; file:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 12; contains information about the internal coordiantes of a geometry optimization.; The user may want to retain this in the working directory; (i.e., where PSI4 was launched from) to analyze the optimization. This is; accomplished by the commands below:; psi4_io.set_specific_path(12, './'); psi4_io.set_specific_retention(12, True). # equivalent to above; psi4_io.set_specific_path(PSIF_INTCO, './'); psi4_io.set_specific_retention(PSIF_INTCO, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously. Elementary Restart¶; The PSI4 intermediate files use the following naming scheme; psi.PID.name.filenumber. where by default, PID is the process number, name the name of the molecule,; and filenumber is listed in content.; For ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external.html:6629,optimiz,optimization,6629,psi4manual/master/external.html,https://psicode.org,https://psicode.org/psi4manual/master/external.html,9,['optimiz'],['optimization']
Performance,ting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/UHF/RKS/UKS. The orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. omp3; Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp3; A special version of SCS-OMP3 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/UHF/RKS/UKS. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. MAX_MOGRAD_CONVERGENCE¶. Convergence ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:4960,optimiz,optimized,4960,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,2,['optimiz'],['optimized']
Performance,"ting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). OPDM_AVG (DETCI). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (DFMP2). operate() SymmetryOperation method. SymRep method. opt(); . see optimize(); . OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). optimize(); . setting keywords. optimize() in module driver. OptionsState class in p4util.optproc. OptionState class in p4util.optproc. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orca_gradient_list() in module qcdb.orca. orca_list() in module qcdb.orca. order() CharacterTable method. IrreducibleRepresentation method. OrderedDict class in qcdb.oldpymodules. orientation_fixed() LibmintsMolecule method. OrientMols class in qcdb.orient. origin() PointGroup method. original_coef() ShellInfo method. original_coefs() ShellInfo method. ORTH_TYPE (DFOCC). (OCC). oss WrappedDatabase attribute. output; . SAPT. cbs(). database(). geometry optimization. vibrational analysis. OVERLAP_CHECK (CCEOM). oxcom() in module qcdb.dbwrap. P. P (THERMO). p() IrreducibleRepresentation method. p4const module. p4const.__init__ module. p4const.physconst module. p4const.psifiles module. p4util module. p4util.__init__ module. p4util.basislist module. p4util.basislistdunning module. p4util.basislistother module. p4util.exceptions module. p4util.inpsight module. p4util.numpy_helper module. p4util.optproc module. p4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:54975,Optimiz,Optimized,54975,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['Optimiz'],['Optimized']
Performance,"ting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (DETCI). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (DFMP2). opt(); . see optimize(); . OPT_METHOD (OCC). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in optproc. OptionState class in optproc. optproc module. ORB_OPT (OCC). ORB_RESP_SOLVER (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OCEPA. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OCC). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_multiline_array() in module input. PATH, [1], [2], [3], [4]. PB_LAMBDA (DFTSAPT). PCG_BETA_TYPE (OCC). PCG_CONVERGENCE (OCC). PCG_MAXITER (OCC). PEP1. perp_unit() in module qcdb.vecutil. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). PHI_POINTS (SCF). physconst module. physical constants. PITZER (TRANSQT). point_group() LibmintsMolecule method. POINTS (FINDIF). POLE_MAXITER (ADC). populateExtern() Diffuse method. QMMM method. PR (ADC). PRECONDITIONER (DETCI). prerequisites. PRESORT_FILE (TRANSQT). PRINT (CPHF). (DFTSAPT). (GLOBALS). (SAPT). PRINT_BASIS (SCF). print_basis_families() in module basislist. pri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:31659,Optimiz,Optimized,31659,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['Optimiz'],['Optimized']
Performance,"tings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:15785,optimiz,optimization,15785,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"tion Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). 1; 2; 3; 4; 5; 6; 7; 8>>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:12599,optimiz,optimization,12599,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,8,['optimiz'],"['optimization', 'optimize']"
Performance,tion Functional; Y; —; 0.110000; 0.250000; —; —; —; Y;  . LC-VV10; LC-VV10 GGA Exchange-Correlation Functional; Y; —; 0.450000; —; —; —; —; —; —. LRC-WPBE; LRC-WPBE GGA Exchange-Correlation Functional; Y; —; 0.300000; —; —; —; —; —; —. LRC-WPBEH; LRC-wPBEh Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.200000; —; —; —; —; —. M11; M11 Meta-GGA XC Functional; Y; Y; 0.250000; 0.428000; —; —; —; —; —. M11-D3BJ; M11 Meta-GGA XC Functional; Y; Y; 0.250000; 0.428000; —; —; —; Y;  . MN12-SX; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; —; —. MN12-SX-D3BJ; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; Y;  . N12-SX; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; —; —. N12-SX-D3BJ; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; Y;  . TUNED-CAM-B3LYP; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; 0.150000; 0.079900; —; —; —; —; —. WB97; wB97 GGA Exchange-Correlation Functional; Y; —; 0.400000; —; —; —; —; —; —. WB97M-D3BJ; wB97M-V with D3(BJ) instead of VV10 dispersion; Y; Y; 0.300000; 0.150000; —; —; —; Y;  . WB97M-V; wB97M-V Hyb-GGA Exchange-Correlation Functional; Y; Y; 0.300000; 0.150000; —; —; —; —; —. WB97X; wB97X Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; —; —. WB97X-D; wB97X-D Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.222036; —; —; —; Y;  . WB97X-D3BJ; wB97X-V with D3(BJ) instead of VV10 dispersion; Y; —; 0.300000; 0.167000; —; —; —; Y;  . WB97X-V; wB97X-V Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.167000; —; —; —; —; —. WPBE; PBE SR-XC Functional (HJS Model); Y; —; 0.400000; —; —; —; —; —; —. WPBE-D3BJ; PBE SR-XC Functional (HJS Model); Y; —; 0.400000; —; —; —; —; Y;  . WPBE-D3MBJ; PBE SR-XC Functional (HJS Model); Y; —; 0.400000; —; —; —; —; Y;  . WPBE0; PBE0 SR-XC,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_dft_lrc-1.html:2212,TUNE,TUNED-CAM-,2212,psi4manual/1.3.2/autodoc_dft_lrc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_dft_lrc-1.html,8,['TUNE'],['TUNED-CAM-']
Performance,"tion fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. # Quickly normalize the types for both python 2 and 3; try:; unicode = unicode; except NameError:; # 'unicode' is undefined, must be Python 3; str = str; unicode = str; bytes = bytes; basestring = (str,bytes); else:; # 'unicode' exist",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:87038,perform,performs,87038,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,3,['perform'],['performs']
Performance,"tion fills out a form NEED with the computations needed to fulfill its call; if (largs['mode'].lower() == 'requisition'):; mode = largs['mode'].lower(). if 'wfnname' in largs:; wfnname = largs['wfnname']; else:; raise ValidationError('Call to \'%s\' has keyword \'wfnname\' missing.' % (functionname)). if re.match(r'scf_.*$', functionname) and (wfnname != 'scf'):; raise ValidationError('Call to \'%s\' is intended for scf portion of calculation.' % (functionname)); if re.match(r'corl_.*$', functionname) and (wfnname == 'scf'):; raise ValidationError('Call to \'%s\' is not intended for scf portion of calculation.' % (functionname)). if 'basisname' in largs:; BSET = largs['basisname']; else:; raise ValidationError('Call to \'%s\' has keyword \'basisname\' missing.' % (functionname)). if 'basiszeta' in largs:; ZSET = largs['basiszeta']; else:; raise ValidationError('Call to \'%s\' has keyword \'basiszeta\' missing.' % (functionname)). # Mode where function reads the now-filled-in energies from that same form and performs the sp, xtpl, delta, etc.; elif (largs['mode'].lower() == 'evaluate'):; mode = largs['mode'].lower(). if 'needname' in largs:; NEED = largs['needname']; else:; raise ValidationError('Call to \'%s\' has keyword \'needname\' missing.' % (functionname)). else:; raise ValidationError('Call to \'%s\' has keyword \'mode\' missing or invalid.' % (functionname)). return [mode, NEED, wfnname, BSET, ZSET]. [docs]def split_menial(menial):; r""""""Function used by :py:func:`~wrappers.complete_basis_set` to separate; *menial* 'scftot' into [scf, tot] and 'mp2corl' into [mp2, corl]. """"""; PTYP = ['tot', 'corl']; for temp in PTYP:; if menial.endswith(temp):; temp_wfn = menial[:-len(temp)]; temp_portion = temp. return [temp_wfn, temp_portion]. ## Aliases ##; cbs = complete_basis_set. #################################; ## End of Complete Basis Set ##; #################################. Quick search. Enter search terms or a module, class or function name.; . Navigation. index",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:85797,perform,performs,85797,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['perform'],['performs']
Performance,"tion for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:1802,optimiz,optimization,1802,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"tion result as the second element (after float energy) of a tuple. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1944,optimiz,optimization,1944,psi4manual/1.1.0/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html,8,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"tion scheme used by the integral and integral derivative program. SEGMENTED (=0) uses a segmented contraction scheme; GENERAL (=1) uses a general contraction scheme, and UNCONTRACTED (=2) uses the corresponding uncontracted sets. Note that even for truly segmented basis sets, the integral programs run significantly faster in the GENERAL mode. Type: string; Possible Values: SEGMENTED, GENERAL, UNCONTRACTED; Default: GENERAL. CFOUR_CONVERGENCE (CFOUR); CFOUR — Identical to CFOUR_GEO_CONV. Type: integer; Default: 4. CFOUR_COORDINATES (CFOUR); CFOUR — Specifies the type of coordinates used in the input file ZMAT. Value INTERNAL (=0) means that the geometry is supplied in the usual Z-matrix format, while CARTESIAN (=1) means that the geometry is given in Cartesian coordinates. A third option is XYZINT (=2) for which a Z-matrix connectivity is defined, but with values of the internal coordinates defined implicitly by supplying Cartesian coordinates. Note that geometry optimizations are currently only possible for INTERNAL and XYZ2INT. Psi4 Interface: Keyword set from active molecule, always CARTESIAN. Above restrictions on geometry optimizations no longer apply. Type: string; Possible Values: INTERNAL, CARTESIAN, XYZINT; Default: INTERNAL. CFOUR_CORE_ORBITALS (CFOUR); CFOUR — Specifies the core orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_ACTIVE_ORBI. The core orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of core orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION. Type: array; Default: No Default. CFOUR_CPHF_CONVER (CFOUR); CFOUR — Specifies the convergence criterion for the iterative solution of the CPHF and Z-vector equations. The solutions are considered to be converged when the r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:29641,optimiz,optimizations,29641,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,8,['optimiz'],['optimizations']
Performance,"tion to add basis *fit* as associated fitting basis; member *jkfit* to a BasisFamily object.; """"""; self.jkfit = sanitize_basisname(fit). [docs] def add_rifit(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *rifit* to a BasisFamily object.; """"""; self.rifit = sanitize_basisname(fit). [docs] def add_dualfit(self, fit):; """"""Function to add basis *fit* as associated helper basis; member *dualfit* to a BasisFamily object.; """"""; self.dualfit = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from basislistdunning import load_basfam_dunning; from basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; return None. [do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html:3257,load,load,3257,psi4manual/4.0b5/_modules/p4util/basislist.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/basislist.html,1,['load'],['load']
Performance,"tion to add basis *fit* as associated fitting basis; member *jkfit* to a BasisFamily object.; """"""; self.jkfit = sanitize_basisname(fit). [docs] def add_rifit(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *rifit* to a BasisFamily object.; """"""; self.rifit = sanitize_basisname(fit). [docs] def add_dualfit(self, fit):; """"""Function to add basis *fit* as associated helper basis; member *dualfit* to a BasisFamily object.; """"""; self.dualfit = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``.; """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases.; """"""; from p4util.basislistdunning import load_basfam_dunning; from p4util.basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases.; """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_orbital(name):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found.; """"""; basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; return fam.ornate; re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html:3601,load,load,3601,psi4manual/1.0.0/_modules/p4util/basislist.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/basislist.html,1,['load'],['load']
Performance,"tion type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. EX_LEVEL (DETCI); DETCI — The CI excitation level. Type: integer; Default: 2. EXCITATION_RANGE (CCEOM); CCEOM (Expert) — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. EXPLICIT_HAMILTONIAN (CPHF); CPHF — Do explicit hamiltonian only?. Type: boolean; Default: false. EXTERN (SCF); SCF — An ExternalPotential (built by Python or NULL/None). Type: python; Default: No Default. FAIL_ON_MAXITER (SCF); SCF — Fail if we reach maxiter without converging?. Type: boolean; Default: true. FAVG (MCSCF); MCSCF — Do use the average Fock matrix during the SCF optimization?. Type: boolean; Default: false. FAVG_CCSD_T (PSIMRCC); PSIMRCC — Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FAVG_START (MCSCF); MCSCF — Iteration at which to begin using the averaged Fock matrix. Type: integer; Default: 5. FCI (DETCI); DETCI — Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FCI_STRINGS (DETCI); DETCI (Expert) — Do store strings specifically for FCI? (Defaults to TRUE for FCI.). Type: boolean; Default: false. FILTER_GUESS (DETCI); DETCI (Expert) — Do invoke the FILTER_GUESS options that are used to filter out some trial vectors which may not have the appropriate phase convention between two determinants? This is useful to remove, e.g., delta states when a sigma state is desired. The user inputs two determinants (by giving the absolute alpha string number and beta string number for each), and also the desired phase between th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:41755,optimiz,optimization,41755,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimization']
Performance,"tion via analytic gradients. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. cubeprop; RHF orbitals and density for water. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dfcasscf-sp; CASSCF/6-31G** energy point. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:17617,perform,performs,17617,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['perform'],['performs']
Performance,"tion(""FRAC_START"", 0); psi4.set_global_option(""REFERENCE"", ""UHF""); energy('scf', molecule=molecule, **kwargs); psi4.set_global_option(""REFERENCE"", ""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_LOAD"", False). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E, wfn = energy('scf', return_wfn=True, molecule=molecule, **kwargs); C = 1; if E == 0.0:; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if LUMO > 0:; eps = wfn.epsilon_a(); potentials.append(eps[int(HOMO) - 1]); else:; eps = wfn.epsilon_b(); potentials.append(eps[-int(HOMO) - 1]). occs.append(occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). psi4.set_global_option(""DF_INTS_IO"", old_df_ints_io). # => Print the results out <= #; E = {}; psi4.print_out(""""""\n ==> Fractional Occupation Traverse Results <==\n\n""""""); psi4.print_out(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; psi4.print_out(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (occs[k], energies[k], potentials[k], convs[k])); E[occs[k]] = energies[k]. psi4.print_out('\n\t""You trying to be a hero Watkins?""\n'); psi4.print_out('\t""Just trying to kill some bugs sir!""\n'); psi4.print_out('\t\t\t-Starship Troopers\n'). # Drop the files out; fh = open(traverse_filename, 'w'); fh.write(""""""\t%-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(occs)):; fh.write(""""""\t%11.3E %24.16E %24.16E %11d\n"""""" % (occs[k], energies[k], potentials[k], convs[k])); fh.close(). # Properly, should clone molecule but since not returned and easy to unblemish,; molecule.set_molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/frac.html:5995,LOAD,LOAD,5995,psi4manual/1.0.0/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/frac.html,1,['LOAD'],['LOAD']
Performance,"tion('SCF', 'D_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). optstash.restore(); return returnvalue. ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory :ref:`[manual] <sec:dcft>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` |; +-------------------------+---------------------------------------------------------------------------------------+; | df-mp2 | MP2 with density fitting :ref:`[manual] <sec:dfmp2>` |; +-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:45572,Optimiz,Optimizations,45572,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Optimiz'],['Optimizations']
Performance,"tion(opt); handled_locally = True; flat_options[key] = val. if ghoc and not handled_locally:; # some options are globals section (not level) so not in any module; flat_options[opt] = core.get_global_option(opt). # The normal machinery to forward plugin options to Psi goes through 'plugin_load'.; # Forte doesn't use this. Pending a larger options rewrite (move to a Python dictionary?),; # we need the following dirty hack. try:; import forte # Needed for Forte options to run.; except ImportError:; pass; else:; # Initialization tasks with Psi options; psi_options = core.get_options(); current_module = psi_options.get_current_module(); # Get the current Forte options from Forte; forte_options = forte.ForteOptions(); forte.register_forte_options(forte_options); psi_options.set_current_module(""FORTE""); try:; forte_options.get_options_from_psi4(psi_options); except RuntimeError:; # If we're in this case, Forte hasn't pushed its options to Psi.; pass; else:; # Load changed Forte options into `flat_options`; for name, metadata in forte_options.dict().items():; if metadata[""value""] != metadata[""default_value""]:; flat_options[f""forte__{name.lower()}""] = metadata[""value""]; finally:; # Restore current module; psi_options.set_current_module(current_module); return flat_options. [docs]; def state_to_atomicinput(; *,; driver: str,; method: str,; basis: Optional[str] = None,; molecule: Optional[core.Molecule] = None,; function_kwargs: Optional[Dict[str, Any]] = None) -> AtomicInput:; """"""Form a QCSchema for job input from the current state of |PSIfour| settings. Parameters; ----------; driver; {'energy', 'gradient', 'hessian'}; Target derivative level.; method; Level of theory for job.; basis; Basis set for job, if not to be extracted from :term:`BASIS <BASIS (MINTS)>`.; molecule; Molecule for job, if not the active one from; :py:func:`~psi4.core.get_active_molecule`.; function_kwargs; Additional keyword arguments to pass to the driver function. Returns; -------; ~qcelemental.models.A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html:15646,Load,Load,15646,psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/procutil.html,3,['Load'],['Load']
Performance,"tion(opt); handled_locally = True; flat_options[key] = val. if ghoc and not handled_locally:; # some options are globals section (not level) so not in any module; flat_options[opt] = core.get_global_option(opt). # The normal machinery to forward plugin options to Psi goes through 'plugin_load'.; # Forte doesn't use this. Pending a larger options rewrite (move to a Python dictionary?),; # we need the following dirty hack. try:; import forte # Needed for Forte options to run.; except ImportError:; pass; else:; # Initialization tasks with Psi options; psi_options = core.get_options(); current_module = psi_options.get_current_module(); # Get the current Forte options from Forte; forte_options = forte.ForteOptions(); forte.register_forte_options(forte_options); psi_options.set_current_module(""FORTE""); try:; forte_options.get_options_from_psi4(psi_options); except RuntimeError:; # If we're in this case, Forte hasn't pushed its options to Psi.; pass; else:; # Load changed Forte options into `flat_options`; for name, metadata in forte_options.dict().items():; if metadata[""value""] != metadata[""default_value""]:; flat_options[f""forte__{name.lower()}""] = metadata[""value""]; finally:; # Restore current module; psi_options.set_current_module(current_module); return flat_options. [docs]def state_to_atomicinput(; *,; driver: str,; method: str,; basis: Optional[str] = None,; molecule: Optional[core.Molecule] = None,; function_kwargs: Optional[Dict[str, Any]] = None) -> AtomicInput:; """"""Form a QCSchema for job input from the current state of |PSIfour| settings. Parameters; ----------; driver; {'energy', 'gradient', 'hessian'}; Target derivative level.; method; Level of theory for job.; basis; Basis set for job, if not to be extracted from :term:`BASIS <BASIS (MINTS)>`.; molecule; Molecule for job, if not the active one from; :py:func:`~psi4.core.get_active_molecule`.; function_kwargs; Additional keyword arguments to pass to the driver function. Returns; -------; ~qcelemental.models.Ato",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html:15638,Load,Load,15638,psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/procutil.html,1,['Load'],['Load']
Performance,"tion, such as a rotation or reflection.; Methods Summary. E((self: psi4.core.SymmetryOperation) -> None); Set equal to E. c2_x((self: psi4.core.SymmetryOperation) -> None); Set equal to C2 about the x axis. c2_y((self: psi4.core.SymmetryOperation) -> None); Set equal to C2 about the y axis. c2_z((self: psi4.core.SymmetryOperation) -> None); Set equal to C2 about the z axis. i((self: psi4.core.SymmetryOperation) -> None); Set equal to an inversion. operate((self: psi4.core.SymmetryOperation, ...); Performs the operation arg2 * arg1. rotate_n((self: psi4.core.SymmetryOperation, ...); Set equal to a clockwise rotation by 2pi/n. rotate_theta(...); Set equal to a clockwise rotation by theta. sigma_xy(...); Set equal to reflection in xy plane. sigma_xz(...); Set equal to reflection in xz plane. sigma_yz(...); Set equal to reflection in yz plane. trace(...); Returns trace of transformation matrix. transform(...); Performs the transform arg2 * arg1 * arg2~. transpose(...); Performs transposition of matrix operation. unit((self: psi4.core.SymmetryOperation) -> None); Set equal to a unit matrix. zero((self: psi4.core.SymmetryOperation) -> None); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOpera",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.symmetryoperation.html:1218,Perform,Performs,1218,psi4manual/1.1.0/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.symmetryoperation.html,1,['Perform'],['Performs']
Performance,"tion. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Corre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/opt-1.html:1035,optimiz,optimized,1035,psi4manual/4.0b4/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html,2,['optimiz'],['optimized']
Performance,"tion. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Psithon Functions: Invoking a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Corre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/opt-1.html:1035,optimiz,optimized,1035,psi4manual/4.0b5/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/opt-1.html,2,['optimiz'],['optimized']
Performance,"tion. Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». Source code for aliases; """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import PsiMod; import re; import os; import math; import warnings; from driver import *; from wrappers import *; from molutil import *; from text import *; from procutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrillgroup_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> energy('sherrillgroup_gold_standard'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html:1040,perform,performed,1040,psi4manual/4.0b4/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/aliases.html,1,['perform'],['performed']
Performance,"tion. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (CCDENSITY)¶CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY)¶CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM)¶CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR)¶CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cach",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:8508,CACHE,CACHELEVEL,8508,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,4,['CACHE'],['CACHELEVEL']
Performance,"tion. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. mbis-2; MBIS calculation on OH- (Expanded Arrays). dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. pywrap-cbs1; Various basis set extrapolation tests. cc52; CCSD Response for H2O2. mints-benchmark; run some BLAS benchmarks. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. freq-masses; check nonphysical masses possible. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cc17; Single point energies of multiple excited states with EOM-CCSD. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:30961,perform,performing,30961,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performing']
Performance,"tion. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:2189,perform,perform,2189,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,30,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,tion; REFERENCE — PSI4 [beta5] documentation; SCF_TYPE — PSI4 [beta5] documentation; SCHWARZ_CUTOFF — PSI4 [beta5] documentation; SCS — PSI4 [beta5] documentation; SCS_N — PSI4 [beta5] documentation; SOLVER_CONVERGENCE — PSI4 [beta5] documentation; SOLVER_EXACT_DIAGONAL — PSI4 [beta5] documentation; SOLVER_MAX_SUBSPACE — PSI4 [beta5] documentation; SOLVER_MAXITER — PSI4 [beta5] documentation; SOLVER_MIN_SUBSPACE — PSI4 [beta5] documentation; SOLVER_N_GUESS — PSI4 [beta5] documentation; SOLVER_N_ROOT — PSI4 [beta5] documentation; SOLVER_NORM — PSI4 [beta5] documentation; SOLVER_PRECONDITION — PSI4 [beta5] documentation; SOLVER_PRECONDITION_MAXITER — PSI4 [beta5] documentation; SOLVER_PRECONDITION_STEPS — PSI4 [beta5] documentation; SOLVER_QUANTITY — PSI4 [beta5] documentation; SOLVER_TYPE — PSI4 [beta5] documentation; TDHF_MEM_SAFETY_FACTOR — PSI4 [beta5] documentation; WFN — PSI4 [beta5] documentation; ALGORITHM — PSI4 [beta5] documentation; AO_BASIS — PSI4 [beta5] documentation; CACHELEVEL — PSI4 [beta5] documentation; DAMPING_PERCENTAGE — PSI4 [beta5] documentation; DCFT_FUNCTIONAL — PSI4 [beta5] documentation; DCFT_GUESS — PSI4 [beta5] documentation; DIIS_MAX_VECS — PSI4 [beta5] documentation; DIIS_MIN_VECS — PSI4 [beta5] documentation; DIIS_START_CONVERGENCE — PSI4 [beta5] documentation; IGNORE_TAU — PSI4 [beta5] documentation; INTS_TOLERANCE — PSI4 [beta5] documentation; LAMBDA_MAXITER — PSI4 [beta5] documentation; LOCK_OCC — PSI4 [beta5] documentation; MAXITER — PSI4 [beta5] documentation; MO_RELAX — PSI4 [beta5] documentation; QC_COUPLING — PSI4 [beta5] documentation; R_CONVERGENCE — PSI4 [beta5] documentation; REFERENCE — PSI4 [beta5] documentation; RELAX_GUESS_ORBITALS — PSI4 [beta5] documentation; RELAX_TAU — PSI4 [beta5] documentation; RESPONSE_ALGORITHM — PSI4 [beta5] documentation; SCF_MAXITER — PSI4 [beta5] documentation; STABILITY_ADD_VECTORS — PSI4 [beta5] documentation; STABILITY_AUGMENT_SPACE_TOL — PSI4 [beta5] documentation; STABILITY_CHECK — PSI4 ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1552211,CACHE,CACHELEVEL,1552211,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,"tion; of the grid is important. This COSX implementation uses two separate grids.; By default, the SCF algorithm is first converged on a smaller grid, followed by a; number of SCF iterations up to a maximum value (controlled by the COSX_MAXITER_FINAL keyword); on a larger grid. By default, COSX_MAXITER_FINAL is set to 1, a single; SCF iteration, which results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. Setting COSX_MAXITER_FINAL to 0 disables the; larger grid entirely. Setting COSX_MAXITER_FINAL to -1 allows; for the SCF to fully converge on the larger grid, useful for the study of wavefunction; properties such as gradients. The size of the initial grid is controlled by the keywords; COSX_RADIAL_POINTS_INITIAL and COSX_SPHERICAL_POINTS_INITIAL.; The final grid is controlled by COSX_RADIAL_POINTS_FINAL and; COSX_SPHERICAL_POINTS_FINAL. Currently, the default grids are very crude,; allowing for high performance at the cost of accuracy. If high-accuracy calculations; are desired with COSX, the grid sizes should be increased.; Screening thresholds over integrals, densities, and basis extents are set; with the COSX_INTS_TOLERANCE, COSX_DENSITY_TOLERANCE, and; COSX_BASIS_TOLERANCE keywords, respectively. COSX_INTS_TOLERANCE; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; COSX_DENSITY_TOLERANCE controls the threshold for significant; shell pairs in the density matrix. Lastly, COSX_BASIS_TOLERANCE is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to DFT_BASIS_TOLERANCE.; The INCFOCK keyword (defaults to false) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:37986,perform,performance,37986,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,2,['perform'],['performance']
Performance,"tionDatum are present; (fails if failoninc True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; modelchem, the modelchem key needed to access benchmark, and; the Reaction object. integer_reactions()[source]¶; Returns boolean of whether reaction names need to be cast to integer. load_qcdata_byproject(project, pythonpath=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; standard location for project :module dbse_project and function; load_project. Module search path can be prepended with pythonpath. load_qcdata_hdf5_trusted(project, path=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. load_qcdata_hrxn_byproject(project, path=None)[source]¶. load_saptdata_frombfdb(sset='default', pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True)[source]¶; This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. load_subsets(modname='subsetgenerator', pythonpath=None)[source]¶; For each component database, loads subsets from all functions; in module modname. Default modname usues standard generators. mcs = None¶; assembly pattern for transspecies modelchems; >>> print asdf.mcs.keys(); XXXX. plot_all_flats(modelchem=None, sset='default', xlimit=4.0, failoninc=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Generate pieces for inclusion into tables. Supply list of; modelchemistries to plot from modelchem, otherwise defaults to; all those available. Can modify subset sset and plotting; range xlimit.; >>> asdf.plot_all_flats(sset='tt-5min', xlimit=4.0). plot_axis(axis, modelchem, benchmark='default', sset='default', failoninc=True, verbose=False, color='sapt', view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶. plot_bars(modelchem, benchmark='default', sset",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:33593,load,loads,33593,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['load'],['loads']
Performance,"tional theory from a unitary transformation:; N-representability, three-particle correlation effects, and application; to O4+,” A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,; J. Chem. Phys. 141, 074111 (2014).; (doi: 10.1063/1.4892946). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) and Cholesky decomposition (CD); coupled cluster in PSI, and its performance for non-covalent interactions; and reaction energies, is discussed in. “Accuracy and Efficiency of Coupled-Cluster Theory Using; Density Fitting / Cholesky Decomposition, Frozen Natural Orbitals,; and a T1-Transformed Hamiltonian,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 2687-2696 (2013).; (doi: 10.1021/ct400250u). Implementation of the asymmetric triples correction for the density-fitted; and cholesky-decomposed coupled-cluster singles and doubles method. “A noniterative asymmetric triple excitation correction for the density-fitted; coupled-cluster singles and doubles",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:8987,perform,performance,8987,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,17,['perform'],['performance']
Performance,"tional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/opt-1.html:6691,optimiz,optimizations,6691,psi4manual/4.0b3/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html,2,['optimiz'],['optimizations']
Performance,"tional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html:12237,perform,perform,12237,psi4manual/1.3.2/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html,28,"['Optimiz', 'optimiz', 'perform']","['OptimizationConvergenceError', 'optimization', 'optimize', 'perform']"
Performance,"tioned or intramolecular SAPT. Type: conv double; Default: 1e-8. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to a JKFIT basis. Previous to v1.6, defaulted to DF_BASIS_SAPT See fitting notes . Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. MAXITER¶. Maximum number of CPHF iterations. Type: integer; Default: 50. MAX_CCD_DIISVECS¶. Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MIN_CCD_DIISVECS¶. Mini",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__sapt.html:2234,perform,perform,2234,psi4manual/master/autodir_options_c/module__sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__sapt.html,1,['perform'],['perform']
Performance,"tions known to PSI4. psi4.driver.driver_cbs_helper.register_xtpl_function(func)[source]¶; Register a user-defined extrapolation function to use like an built-in one. Parameters:; func (Callable) – A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See psi4/psi4/driver/driver_cbs_helper.py and pywrap-cbs1 for; examples. The name of the function should follow the pattern <scf|corl>_xtpl_<scientist>_<#basis>. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; Some existing examples are below. psi4.driver.aliases.sherrill_gold_standard(**kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). Return type:; List[Dict[str, Any]]. psi4.driver.aliases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:30626,perform,performed,30626,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,1,['perform'],['performed']
Performance,"tions known to PSI4. psi4.driver.driver_cbs_helper.register_xtpl_function(func)[source]¶; Register a user-defined extrapolation function to use like an built-in one. Parameters:; func (Callable) – A Python function that applies a basis set extrapolation formula to scalars and optionally to; NumPy arrays. See psi4/psi4/driver/driver_cbs_helper.py and pywrap-cbs1 for; examples. The name of the function should follow the pattern <scf|corl>_xtpl_<scientist>_<#basis>. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; Some existing examples are below. psi4.driver.aliases.sherrill_gold_standard(**kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2().; :rtype: List[Dict[str, Any]]. \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). Return type:; List[Dict[str, Any]]. psi4.driver.aliases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cbs.html:30635,perform,performed,30635,psi4manual/master/cbs.html,https://psicode.org,https://psicode.org/psi4manual/master/cbs.html,3,['perform'],['performed']
Performance,"tions on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * 1.00e-06 * 1.20e-03 * o ~; --------------------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:7632,optimiz,optimizations,7632,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['optimiz'],['optimizations']
Performance,"tions"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; As of October 2018, only two explicit `deltaN_[wfn,basis,scheme]` sets of options are active; if more delta functions are required, use the `cbs_metadata` interface. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) COR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:10846,perform,performed,10846,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,2,['perform'],['performed']
Performance,"tions"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; As of October 2018, only two explicit `deltaN_[wfn,basis,scheme]` sets of options are active; if more delta functions are required, use the `cbs_metadata` interface. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs-1.html:16858,perform,performed,16858,psi4manual/1.4.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs-1.html,4,['perform'],['performed']
Performance,"tions. Type: boolean; Default: true. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; 1; 2; 3; 4; 5; 6; 7; 8energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). For now, charge transfer computations are not available with open-shell SAPT0.; A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; 1; 2; 3; 4; 5 SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:24919,perform,perform,24919,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['perform'],['perform']
Performance,"tivate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:2988,Queue,Queue,2988,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Queue'],['Queue']
Performance,"tive spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.core.print_variables() → None¶; Prints all PSI variables that have been set internally. psi4.core.psi_top_srcdir() → str¶; Returns the location of the source code. psi4.core.psimrcc(arg0: psi::Wavefunction) → float¶; Runs the multireference coupled cluster code. psi4.core.reopen_outfile() → None¶; Reopens the output file. psi4.core.revoke_global_option_changed(arg0: str) → None¶; Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:154187,load,loaded,154187,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,6,['load'],['loaded']
Performance,"tive, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. INTS_TOLERANCE (SCF)¶SCF — Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 1e-12. IP_POLES (OCC)¶OCC — Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. IRC_DIRECTION (OPTKING)¶OPTKING — IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE (OPTKING)¶OPTKING — IRC step size in bohr(amu)\(^{1/2}\). Type: double; Default: 0.2. IRC_STOP (OPTKING)¶OPTKING — Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. ISOTROPIC_POL (PE)¶PE — Make polarizabilities isotropic. Type: boolean; Default: false. ISTOP (DETCI)¶DETCI — Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. JOBTYPE (CCLAMBDA)¶CCLAMBDA (Expert) — Type of job being performed. Type: string; Default: No Default. KEEP_INTCOS (OPTKING)¶OPTKING — Keep internal coordinate definition file. Type: boolean; Default: false. KIND (ADC)¶ADC — The kind of states to compute. Type: string; Possible Values: SINGLET, TRIPLET, SPIN_FLIP, ANY; Default: SINGLET. LEVEL_SHIFT (DFOCC)¶DFOCC — Level shift to aid convergence. Type: double; Default: 0.02. LEVEL_SHIFT (MCSCF)¶MCSCF — Level shift to aid convergence. Type: double; Default: 0.0. LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 0.02. LEVEL_SHIFT (SCF)¶SCF — Do use a level shift?. Type: double; Default: 0.0. LEVEL_SHIFT_CUTOFF (SCF)¶SCF — DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. LINEAR (CCRESPONSE)¶CCRESPONSE — Do Bartlett size-extensive linear model?. Type: boolean; Default: false. LINEQ_SOLVER (DFOCC)¶DFOCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:149510,perform,performed,149510,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"tivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None¶; Print the matrix with atom labels, assuming it is an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:135975,Load,Loads,135975,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['Load'],['Loads']
Performance,"tivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str='outfile') → None¶; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix) → None¶; Prints the matrix to the output file. pseudoi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:11188,Load,Loads,11188,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,1,['Load'],['Loads']
Performance,tlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. omp2.5; Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. olccd; Orbital-Optimized Linear CCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE CONV. Density-Fitted Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE DF. Cholesky-Decomposed Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; —; CC_TYPE CD. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:10131,Optimiz,Optimized,10131,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,11,['Optimiz'],['Optimized']
Performance,"to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbita",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:21602,perform,performed,21602,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['perform'],['performed']
Performance,"to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. omp3-grad2; OMP3 cc-pVDZ gradient for the NO rad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:21092,perform,performed,21092,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['perform'],['performed']
Performance,"to Libint by E. Valeev; Interface to Libint by E. Valeev; Interface to Libxc by M. A. L. Marques; Interface to Libxc by M. A. L. Marques; Adding Add-Ons; Adding Add-Ons; Git, Versioning; Git, Versioning; Managing: Git, Conda, CMake and all that; Managing: Git, Conda, CMake and all that; Release Procedures; Release Procedures; MCSCF: Multi-Configurational Self-Consistent-Field; MCSCF: Multi-Configurational Self-Consistent-Field; Theoretical Methods: SCF to FCI; Theoretical Methods: SCF to FCI; Interface to Molden — molden(); Interface to Molden — molden(); Interface to MRCC by M. Kállay; Interface to MRCC by M. Kállay; <no title>; <no title>; Basis Set Superposition Corrections; Basis Set Superposition Corrections; Notes on Options; Notes on Options; Notes on Options; Notes on Options; Interface to NumPy; Interface to NumPy; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Evaluation of One-Electron Properties — oeprop(); Evaluation of One-Electron Properties — oeprop(); Geometry Optimization — optimize() and gradient(); Geometry Optimization — optimize() and gradient(); LibOptions: globals, locals, has_changed and all that; LibOptions: globals, locals, has_changed and all that; Geometry Optimization; Geometry Optimization; Interface to PCMSolver by R. Di Remigio; Interface to PCMSolver by R. Di Remigio; PEP1: Proposing PsiPEP for PSI4; PEP1: Proposing PsiPEP for PSI4; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Plugin v2rdm_casscf by A. E. DePrince; Plugin v2rdm_casscf by A. E. DePrince; Creating New Plugins; Creating New Plugins; Adding Methods to Driver; Adding Methods to Driver; Linear Algebra in PSI4; Linear Algebra in PSI4; Community Code of Conduct; Community Code of Conduct; P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:594097,Optimiz,Optimized,594097,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,32,"['Optimiz', 'optimiz']","['Optimization', 'Optimized', 'optimize']"
Performance,"to SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI mode:; 1psi4.set_memory(int(5e8)). Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and Geometry Specification¶. Molecule ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:4011,perform,perform,4011,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,2,['perform'],['perform']
Performance,"to add basis *fit* as associated fitting basis; member *jdef* to a BasisFamily object. """"""; self.jdef = sanitize_basisname(fit). [docs] def add_jkfit_default(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *jkdef* to a BasisFamily object. """"""; self.jkdef = sanitize_basisname(fit). [docs] def add_rifit_default(self, fit):; """"""Function to add basis *fit* as associated fitting basis; member *ridef* to a BasisFamily object. """"""; self.ridef = sanitize_basisname(fit). [docs]def sanitize_basisname(name):; """"""Function to return *name* in coded form, stripped of; characters that confuse filenames, characters into lowercase,; ``+`` into ``p``, ``*`` into ``s``, and ``(``, ``)``, & ``,``; into ``_``. """"""; temp = name.lower(); temp = temp.replace('+', 'p'); temp = temp.replace('*', 's'); temp = temp.replace('(', '_'); temp = temp.replace(')', '_'); temp = temp.replace(',', '_'); return temp. [docs]def load_basis_families():; """"""Function to load into the array ``basisfamily_list``; BasisFamily objects for all Psi4's standard installed bases. """"""; from .basislistdunning import load_basfam_dunning; from .basislistother import load_basfam_other. if len(basisfamily_list) == 0:; load_basfam_dunning(); load_basfam_other(); return basisfamily_list. [docs]def print_basis_families():; """"""Function to print to the output file a formatted summary; of all the BasisFamily objects in ``basisfamily_list``, by; default all Psi4's standard installed bases. """"""; basisfamily_list = load_basis_families(). text = ''; for fam in basisfamily_list:; text += '%s' % (fam); return text. [docs]def corresponding_basis(name, role='BASIS'):; """"""Function to validate if the orbital basis *name* in coded or; ornate form is in Psi4's standard installed bases list. ``None``; is returned if the orbital basis is not found. """"""; role = role.upper(); basisfamily_list = load_basis_families(). for fam in basisfamily_list:; if sanitize_basisname(fam.ornate) == sanitize_basisname(name):; if ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html:4888,load,load,4888,psi4manual/1.0.0/_modules/qcdb/basislist.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/basislist.html,1,['load'],['load']
Performance,"to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; densit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:2606,perform,performs,2606,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,12,['perform'],['performs']
Performance,"to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:1689,perform,performed,1689,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,15,['perform'],['performed']
Performance,"to be treated with standard DMA. Type: double; Default: 4.0. GEOM_MAXITER (OPTKING); OPTKING — Maximum number of geometry optimization steps. Type: integer; Default: 50. GRADIENT_WRITE (FINDIF); FINDIF — Do write a gradient output file? If so, the filename will end in .grad, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. GUESS (SCF); SCF — The type of guess orbitals. Defaults to SAD for RHF, GWH for ROHF and UHF, and READ for geometry optimizations after the first step. Type: string; Possible Values: AUTO, CORE, GWH, SAD, READ; Default: AUTO. GUESS_MIX (SCF); SCF — Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST (SCF); SCF — If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. GUESS_R_CONVERGENCE (DCFT); DCFT — Convergence criterion for the density cumulant and orbital guess for the variationally orbital-optimized DCFT methods. Currently only available for ALGORITHM = SIMULTANEOUS. Type: conv double; Default: 1e-3. GUESS_VECTOR (DETCI); DETCI (Expert) — Guess vector type. Accepted values are UNIT for a unit vector guess (NUM_ROOTS and NUM_INIT_VECS must both be 1); H0_BLOCK to use eigenvectors from the H0 BLOCK submatrix (default); DFILE to use NUM_ROOTS previously converged vectors in the D file;. Type: string; Possible Values: UNIT, H0_BLOCK, DFILE; Default: H0_BLOCK. H0_BLOCK_COUPLING (DETCI); DETCI (Expert) — Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE (DETCI); DETCI (Expert) — Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:135216,optimiz,optimization,135216,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimization']
Performance,"to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indices specified above (\(0.0\ge occ \ge 1.0\)). Type: array; Default: No Default. Environmental Effects¶. EXTERN¶. An ExternalPotential (built by Python or nullptr/None). Type: boolean; Default: false. ONEPO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html:6780,perform,perform,6780,psi4manual/1.3.2/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indices specified above (\(0.0\le {\rm occ} \le 1.0\)). Type: array; Default: No Default. Environmental Effects¶. EXTERN¶. An ExternalPotential (built by Python or nullptr/None). Type: boolean; Default: false.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html:7313,perform,perform,7313,psi4manual/1.4.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html,4,['perform'],['perform']
Performance,"to linearized coupled cluster doubles; method, LCCD). CEPA0 can be considered as a particular case of the DC-06 and DC-12; methods in the limit of zero non-idempotency of \(\boldsymbol{\gamma_1}\). This option has a limited; functionality and should only be used for test purposes. For the production-level CEPA0 code, see the; OCC module. The DCFT code can also be used to; compute the \((\lambda_3)\) energy correction that perturbatively accounts; for three-particle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computation of the \((\lambda_3)\) correction can be; requested by setting the THREE_PARTICLE option to PERTURBATIVE. A; combination of the ODC-13 functional with the \((\lambda_3)\) correction; [denoted as \(\mbox{ODC-13$(\lambda_3)$}\)] has been shown to provide highly; accurate results for open-shell molecules near equilibrium geometries.; At the present moment, all of the DCFT methods support unrestricted reference; orbitals (REFERENCE UHF), which can be used to perform energy and; gradient computations for both closed- and open-shell molecules. In addition,; the ODC-06 and ODC-12 methods support restricted reference orbitals; (REFERENCE RHF) for the energy and gradient computations of; closed-shell molecules. Note that in this case restricted reference orbitals; are only available for ALGORITHM SIMULTANEOUS. Iterative Algorithms¶; As explained in the Theory section, in order to obtain the DCFT energy one; needs to solve a system of coupled equations for orbitals and density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option. SIMULTANEOUS [Default]; In the simultaneous algorithm the DCFT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dcft-1.html:7831,perform,perform,7831,psi4manual/1.1.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dcft-1.html,6,['perform'],['perform']
Performance,"to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecula",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:10719,perform,performed,10719,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['perform'],['performed']
Performance,"to obtain than the Coulomb matrix. The global hybrid ansatz has become; exceedingly popular, with functionals such as the ubiquitous B3LYP often; producing absurdly accurate results.; A more advanced GKS functional technology which has developed enormous; popularity in recent years is the Long-Range Corrected (LRC) ansatz. LRC; recognizes that the local DFA is potentially exact at short range in the; exchange hole, and that the hybrid-exchange energy of the noninteracting; quasiparticles is also exact for true electrons at long range in the exchange; hole. Therefore LRC switches from DFA at short range to hybrid exchange at long; range, typically using the function as a; partition function.; Tying all these pieces together, a full LRC-hybrid GKS functional has the; generic form,. For LRC functionals, the choice of range-separtion parameter has; been the subject of considerable activity since the inception of LRC; functionals. Some authors advocate a static range-separation parameter; determined by optimization over a test set of chemical systems. However, a more; physically-motivated and often more accurate approach is the idea of “gap; fitting” or “optimal tuning” or simply “tuning.” The most popular tuned-LRC; approach is IP-fitting, in which the is varied until the; Koopman’s IP (the opposite of the HOMO energy) matches the true IP (the; difference between -electron and -electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. Note that LRC functionals with default only capture the; dependence,. hybrid functionals only capture part of the dependence,. and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. IP-tuned LRC functionals effectively pin the chemical potential at ; electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dft-1.html:6954,optimiz,optimization,6954,psi4manual/4.0b3/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dft-1.html,10,['optimiz'],['optimization']
Performance,"to this file. # ATTN NEW ADDITIONS!; # consult http://sirius.chem.vt.edu/psi4manual/master/proc_py.html. [docs]def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """"""; optstash = OptionsState(; ['SCF', 'REFERENCE'],; ['DCFT', 'REFERENCE']). PsiMod.set_local_option('SCF', 'REFERENCE', 'UHF'); PsiMod.set_local_option('DCFT', 'REFERENCE', 'UHF'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs); PsiMod.dcft(). optstash.restore(). [docs]def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; optstash = OptionsState(; ['GLOBALS', 'DERTYPE']). PsiMod.set_global_option('DERTYPE', 'FIRST'); run_dcft(name, **kwargs); PsiMod.deriv(). optstash.restore(). [docs]def run_omp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. """"""; # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return PsiMod.occ(). [docs]def run_omp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; OMP2 gradient calculation. """"""; optstash = OptionsState(; ['REFERENCE'],; ['GLOBALS', 'DERTYPE']). PsiMod.set_global_option('DERTYPE', 'FIRST'); run_omp2(name, **kwargs); PsiMod.deriv(). optstash.restore(). [docs]def run_mp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a MP2 calculation. """"""; optstash = OptionsState(; ['OCC', 'ORB_OPT']). PsiMod.set_local_option('OCC', 'ORB_OPT', 'FALSE'); run_omp2(name, **kwargs). optstash.restore(). [docs]def run_mp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a MP2 gradient calculation. """"""; optstash = OptionsState(; ['",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:1705,optimiz,optimized,1705,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['optimiz'],['optimized']
Performance,"to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (OMP3); OMP3 — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (MP2); MP2 — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CAS_FILES_WRITE ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:10725,cache,cache,10725,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:3012,perform,perform,3012,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,24,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"tomatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. Psi4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number .; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:20054,tune,tuned,20054,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['tune'],['tuned']
Performance,"top:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:7551,optimiz,optimization,7551,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,4,['optimiz'],['optimization']
Performance,"top?. Type: boolean; Default: false. INTERFRAGMENT_CONNECT¶. When connecting disparate fragments when frag_mode = SIMPLE, a “bond” is assigned if interatomic distance is less than (this number) * sum of covalent radii. The value is then increased until all the fragments are connected (directly or indirectly). Type: double; Default: 1.8. INTERFRAG_DIST_INV¶. Do use \(\frac{1}{R_{AB}}\) for the stretching coordinate between fragments? Otherwise, use \(R_{AB}\). Type: boolean; Default: false. INTERFRAG_HESS¶. Model Hessian to guess interfragment force constants. Type: string; Possible Values: DEFAULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE¶. When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, PRINCIPAL_AXES; Default: FIXED. Misc.¶. FINAL_GEOM_WRITE¶. Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. FIXED_COORD_FORCE_CONSTANT¶. In constrained optimizations, for coordinates with user-specified equilibrium values, this is the initial force constant (in au) used to apply an additional force to each coordinate. Type: double; Default: 0.5. KEEP_INTCOS¶. Keep internal coordinate definition file. Type: boolean; Default: false. LINESEARCH_STATIC_MAX¶. If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.100. LINESEARCH_STATIC_MIN¶. If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.001. LINESEARCH_STATIC_N¶. If doing a static line search, scan this many points. Type: integer; Default: 8. TEST_B¶. Do test B matrix?. Type: b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__optking-1.html:8863,optimiz,optimization,8863,psi4manual/1.1.0/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__optking-1.html,11,['optimiz'],['optimization']
Performance,"torage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:9039,CACHE,CACHELEVEL,9039,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,"['CACHE', 'Cache']","['CACHELEVEL', 'Cacheing']"
Performance,"torage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CPHF); CPHF — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attemp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:8914,CACHE,CACHELEVEL,8914,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,4,"['CACHE', 'Cache']","['CACHELEVEL', 'Cacheing']"
Performance,"torage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attemp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:8468,CACHE,CACHELEVEL,8468,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,"['CACHE', 'Cache']","['CACHELEVEL', 'Cacheing']"
Performance,"torage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:9109,CACHE,CACHELEVEL,9109,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,"['CACHE', 'Cache']","['CACHELEVEL', 'Cacheing']"
Performance,"torted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. pywrap_alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. pywrap_all; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:11622,optimiz,optimization,11622,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"tory or zipped archive from; https://github.com/psi4/psi4. CompilersPSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. Compiler requirements are primarily; C++14 compliance (now GCC version 6.0 or above).; For some architectures, a precompiled binary is available. See Compiling and Installing for details. PythonPSI4 1.1 and 1.2 are supported on Python 2.7, 3.5,; and 3.6. After 1.2, only Python 3 will be supported; in accordance with other scientific software projects).; The future plan is to support the two or three latest Python versions.; PSI4 1.3 supports Python 3.6 and 3.7.; PSI4 1.4 supports Python 3.6, 3.7, 3.8, and 3.9. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Energy (CFOUR), Gradient,; Gradient (CFOUR), and Frequency. Summary of theoretical methods available in PSI4¶. Method; Energy; Gradient; Parallelism; Variants. Reference; Type; Reference; Type; OO 9; FNO 1. HF, HF-3c; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF/ROHF; CONV/DF; threaded. DFT, PBEh-3c; RKS/UKS; CONV/DF/CD 7; RKS/UKS; DF 4; threaded. EFP 5; RHF. —; —. DCT; RHF/UHF; CONV/DF; RHF/UHF; CONV; partially threaded. MP2 10; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G. MP3 10; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G; E. MP2.5 10; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded 3; E/G. MP4 10; RHF; CONV; —; —; threaded 3. E. MP(n); RHF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:23251,perform,perform,23251,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,2,['perform'],['perform']
Performance,"tpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). Return type:; List[Dict[str, Any]]. psi4.driver.aliases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). Return type:; List[Dict[str, Any]]. Additional composite aliases are easy to define by the; user. Follow models in psi4/psi4/driver/aliases.py; and cbs-xtpl-nbody and use the; psi4.driver.driver_cbs_helper.register_composite_function(); to make",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:31660,perform,performed,31660,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,1,['perform'],['performed']
Performance,"tpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cbs-1.html:7584,perform,performed,7584,psi4manual/4.0b4/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cbs-1.html,4,['perform'],['performed']
Performance,"tput file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:58636,Optimiz,OptimizationConvergenceError,58636,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Optimiz'],['OptimizationConvergenceError']
Performance,"trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. E(self: psi4.core.SymmetryOperation) → None; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None; Set equal to an inversion. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None; Zero out the symmet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.symmetryoperation.html:3462,Perform,Performs,3462,psi4manual/1.1.0/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.symmetryoperation.html,2,['Perform'],['Performs']
Performance,"tracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:47323,optimiz,optimization,47323,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimization']
Performance,"tral molecule to start.""""""); if molecule.schoenflies_symbol() != 'c1':; core.print_out("""""" Requested procedure `ip_fitting` does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""); molecule = molecule.clone(); molecule.reset_point_group('c1'); molecule.update_geometry(). charge0 = molecule.molecular_charge(); mult0 = molecule.multiplicity(). # How many electrons are there?; N = 0; for A in range(molecule.natom()):; N += molecule.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1) / 2); Na = int(N - Nb). # Work in the ot namespace for this procedure; core.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""SAVE""); E, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Burn-in', **kwargs); core.set_local_option(""SCF"", ""DF_INTS_IO"", ""LOAD""). if not wfn.functional().is_x_lrc():; raise ValidationError(""""""Not sensible to optimize omega for non-long-range-correction functional.""""""). # Determine HOMO, to determine mult1; eps_a = wfn.epsilon_a(); eps_b = wfn.epsilon_b(); if Na == Nb:; HOMO = -Nb; elif Nb == 0:; HOMO = Na; else:; E_a = eps_a.np[int(Na - 1)]; E_b = eps_b.np[int(Nb - 1)]; if E_a >= E_b:; HOMO = Na; else:; HOMO = -Nb. Na1 = Na; Nb1 = Nb; if HOMO > 0:; Na1 -= 1; else:; Nb1 -= 1. charge1 = charge0 + 1; mult1 = Na1 - Nb1 + 1. omegas = []; E0s = []; E1s = []; kIPs = []; IPs = []; types = []. # Right endpoint; core.set_local_option('SCF', 'DFT_OMEGA', omega_r). # Neutral; if read:; core.set_local_option(""SCF"", ""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). molecule.set_molecular_charge(charge0); molecule.set_multiplicity(mult0); E0r, wfn = driver.energy('scf', dft_functional=name, return_wfn=True, molecule=molecule,; banner='IP Fitting SCF: Neutral, Right Endpoint', **kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:17024,LOAD,LOAD,17024,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,4,['LOAD'],['LOAD']
Performance,"transforms and reorders integrals for use in the coupled cluster codes. cctriples((arg0: psi::Wavefunction) -> float); Runs the coupled cluster (T) energy code. clean(() -> None); Function to remove scratch files. clean_options(() -> None); Function to reset options to clean state. clean_variables(() -> None); Empties all PSI variables that have set internally. close_outfile(() -> None); Closes the output file. dcft(...); Runs the density cumulant functional theory code. detci(...); Runs the determinant-based configuration interaction code. dfmp2(...); Runs the DF-MP2 code. dfocc(...); Runs the density-fitted orbital optimized CC codes. displace_atom((arg0: psi::Matrix, arg1: int, ...); Displaces one coordinate of single atom. dmrg(...); Runs the DMRG code. efp_init(() -> psi4.core.EFP); Initializes the EFP library and returns an EFP object. efp_set_options(() -> None); Set EFP options from environment options object. fd_1_0((arg0: psi::Molecule, ...); Performs a finite difference gradient computation, from energy points. fd_freq_0((arg0: psi::Molecule, arg1: list, ...); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1((arg0: psi::Molecule, arg1: list, ...); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(...); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0((arg0: psi::Molecule, ...); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1((arg0: psi::Molecule, ...); Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. finalize(() -> None). fisapt((arg0: psi::Wavefunction) -> float); Runs the functional-group intramolecular symmetry adapted perturbation theory code. flush_outfile(() -> None); Flushes the output file. fnocc(...); Runs the fno-ccsd(t)/qcisd(t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:163747,Perform,Performs,163747,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['Perform'],['Performs']
Performance,"tribute). original_coef() (psi4.core.GaussianShell method). ORTH_TYPE (DFOCC). (OCC). OS_SCALE (OCC). outfile_name() (in module psi4.core). output. ; cbs(). database(). geometry optimization. SAPT. vibrational analysis. overlap() (psi4.core.FISAPT method). overlap_3c() (psi4.core.IntegralFactory method). OVERLAP_CHECK (CCEOM). overlap_grad() (psi4.core.MintsHelper method). OverlapInt (class in psi4.core). owner_group (psi4.driver.AtomicComputer attribute). P. p (psi4.core.AOShellCombinationsIterator attribute). P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parent_atom() (psi4.core.BlockOPoints method). PARENT_SYMMETRY (GLOBALS). ParsingError. partial_cholesky_factorize() (psi4.core.Matrix method). partition() (psi4.core.FISAPT method). PastureRequiredError. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32]. PBS queueing system. PCG_BETA_TYPE (DFOCC). (OCC). PCG_CONVERGENCE (DFOCC). (OCC). PCG_MAXITER (DFOCC). (OCC). PCM, [1]. Using PCM. PCM (GLOBALS). PCM POLARIZATION ENERGY. PCM_CC_TYPE (PCM). PCM_enabled() (psi4.core.Wavefunction method). pcm_helper() (in module psi4.driver). (in module psi4.driver.p4util). PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PE. Using PE. PE (GLOBALS). PE ENERGY. PE_ECP (PE). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() (psi4.core.MintsHelper method). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() (psi4.core.MintsHelper method). (psi4.core.SOBasisSet method). petite_list1() (psi4.core.MintsHelper method). PetiteList (class in psi4.core). PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_onel() (psi4.core.CIWavefunction method). pitzer_to_ci_order_twoel() (psi4.core.CIWavefunction method). PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). plan() (psi4.dri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:89916,queue,queueing,89916,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['queue'],['queueing']
Performance,"tribute. psi4.core.PseudospectralInt attribute. psi4.core.QuadrupoleInt attribute. psi4.core.TracelessQuadrupoleInt attribute. original_coef() psi4.core.GaussianShell method. ORTH_TYPE (DFOCC). (OCC). OS_SCALE (OCC). outfile_name() in module psi4.core. output. ; cbs(). database(). geometry optimization. SAPT. vibrational analysis. overlap() psi4.core.FISAPT method. overlap_3c() psi4.core.IntegralFactory method. OVERLAP_CHECK (CCEOM). overlap_grad() psi4.core.MintsHelper method. OverlapInt class in psi4.core. P. p psi4.core.AOShellCombinationsIterator attribute. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. PARENT_SYMMETRY (GLOBALS). ParsingError. partial_cholesky_factorize() psi4.core.Matrix method. partition() psi4.core.FISAPT method. PastureRequiredError. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32]. PBS queueing system. PCG_BETA_TYPE (DFOCC). (OCC). PCG_CONVERGENCE (DFOCC). (OCC). PCG_MAXITER (DFOCC). (OCC). PCM. Using PCM. PCM (GLOBALS). PCM POLARIZATION ENERGY. PCM_CC_TYPE (PCM). PCM_enabled() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. pcm_helper() in module psi4.driver. PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PE. Using PE. PE (GLOBALS). PE ENERGY. PE_ECP (PE). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() psi4.core.MintsHelper method. PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() psi4.core.MintsHelper method. psi4.core.SOBasisSet method. petite_list1() psi4.core.MintsHelper method. PetiteList class in psi4.core. PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:102366,queue,queueing,102366,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,4,['queue'],['queueing']
Performance,"tributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.dbse)); return; else:; raise ValidationError(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39254,load,loading,39254,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loading']
Performance,"tric field evaluated on a grid around water. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. phi-ao; Test computing values of basis functions (puream and non-puream) at points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mbis-6; MBIS calculation on H2O. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc13b; Te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:26272,optimiz,optimization,26272,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"tries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:2885,optimiz,optimization,2885,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,24,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"tring; Default: No Default. BCCD_MAXITER (CCENERGY); CCENERGY — Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. BENCH (GLOBALS); GLOBALS — Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC); FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:6809,CACHE,CACHELEVEL,6809,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,12,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"tring; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; 1; 2; 3; 4; 5; 6; 7molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; 1optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; 1; 2set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; 1optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; 1; 2set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; 1; 2; 3; 4; 5; 6; 7set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; 1; 2set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:4360,Optimiz,Optimize,4360,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,2,['Optimiz'],['Optimize']
Performance,"trix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter, …); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. diis(self); docstring. diis_manager(self); docstring. finalize(self); Cleans up the the Wavefunction’s temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. functional(self); Returns the internal DFT Superfunctional. get_energies(self, arg0); docstring. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. initialize(); Specialized initialization, compute integrals and does everyt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:1618,Perform,Performs,1618,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['Perform'],['Performs']
Performance,"trix)arg2, (bool)arg3, (bool)arg4) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE doublet(N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,b,b); | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | C++ signature :; | void gemm(N3psi6MatrixE {lvalue},b,b,d,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,d); | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | C++ signature :; | d get(N3psi6MatrixE {lvalue},i,i [,i]); | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | C++ signature :; | void identity(N3psi6MatrixE {lvalue}); | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | C++ signature :; | void invert(N3psi6MatrixE {lvalue}); | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void load(N3psi6MatrixE {lvalue},Ss); | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void load_mpqc(N3psi6MatrixE {lvalue},Ss); | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | C++ signature :; | Ss name(N3psi6MatrixE {lvalue}); | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | C++ signature :; | i nirrep(N3psi6MatrixE {lvalue}); | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE partial_cholesky_factorize(N3psi6MatrixE {lvalue},d,b); | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE power(N3psi6MatrixE {lvalue},d,d); | ; | print_out(...); | print_out( (Matrix)arg1) -> None :; | docstring; | ; | C++ signature :; | void print_out(N3psi6MatrixE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:517635,load,load,517635,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,4,['load'],['load']
Performance,"trix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently Quasy Newton-Raphson algorithm avaliable with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treatme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:12213,optimiz,optimization,12213,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['optimiz'],['optimization']
Performance,"trix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/occ-1.html:15065,optimiz,optimization,15065,psi4manual/1.3.2/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/occ-1.html,2,['optimiz'],['optimization']
Performance,"trix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treatme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:15070,optimiz,optimization,15070,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,4,['optimiz'],['optimization']
Performance,"trolled by the; keywords COSX_RADIAL_POINTS_INITIAL and COSX_SPHERICAL_POINTS_INITIAL.; The final grid is controlled by COSX_RADIAL_POINTS_FINAL and; COSX_SPHERICAL_POINTS_FINAL. The defaults for both grids aim to balance; cost and accuracy.; Screening thresholds over integrals, densities, and basis extents are set; with the COSX_INTS_TOLERANCE, COSX_DENSITY_TOLERANCE, and; COSX_BASIS_TOLERANCE keywords, respectively. COSX_INTS_TOLERANCE; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; COSX_DENSITY_TOLERANCE controls the threshold for significant; shell pairs in the density matrix. Lastly, COSX_BASIS_TOLERANCE is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to DFT_BASIS_TOLERANCE.; The INCFOCK keyword (defaults to false) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option is disabled by default because of; potential SCF convergence issues, particularly when using diffuse basis functions.; The COSX_OVERLAP_FITTING keyword (defaults to true) reduces numerical; integration errors using the method described in [Izsak:2011:144105] and is; always recommended. Linear Exchange¶; Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663], is available in Psi4 in conjunction with composite algorithms that build J (SCF_TYPE set to J_alg+LINK).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant elements through ref",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:37300,perform,performance,37300,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,1,['perform'],['performance']
Performance,"trolled by the; keywords COSX_RADIAL_POINTS_INITIAL and COSX_SPHERICAL_POINTS_INITIAL.; The final grid is controlled by COSX_RADIAL_POINTS_FINAL and; COSX_SPHERICAL_POINTS_FINAL. The defaults for both grids aim to balance; cost and accuracy.; Screening thresholds over integrals, densities, and basis extents are set; with the COSX_INTS_TOLERANCE, COSX_DENSITY_TOLERANCE, and; COSX_BASIS_TOLERANCE keywords, respectively. COSX_INTS_TOLERANCE; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; COSX_DENSITY_TOLERANCE controls the threshold for significant; shell pairs in the density matrix. Lastly, COSX_BASIS_TOLERANCE is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX analogue to DFT_BASIS_TOLERANCE.; The INCFOCK keyword (defaults to false) increases performance; by constructing the Fock matrix from differences in the density matrix, which; are more amenable to screening. This option is disabled by default because of; potential SCF convergence issues, particularly when using diffuse basis functions.; The COSX_OVERLAP_FITTING keyword (defaults to true) reduces numerical; integration errors using the method described in [Izsak:2011:144105] and is; always recommended. Linear Exchange¶; Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663], is available in Psi4 in conjunction with integral-direct density fitting for Coulomb construction (SCF_TYPE set to LINK).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs. Specifically, LinK exploits the fact that the Exchange term; requires only a linear-scaling number of significant ele",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:32749,perform,performance,32749,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,1,['perform'],['performance']
Performance,"tructure methods are available in the PSI4; package, from Hartree–Fock molecular orbital theory to coupled-cluster; theory to full configuration interaction. This section introduces; the methods available and some of their most common input parameters.; A complete list of standard keywords is provided in Appendix; Keywords by Module. Notes on Options; Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Recommendations. Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Recommendations. Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations. Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/methods-1.html:1715,Optimiz,Optimization,1715,psi4manual/4.0b2/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/methods-1.html,6,['Optimiz'],"['Optimization', 'Optimizations', 'Optimizing']"
Performance,"true. Alternatively, another value for \(\alpha\); can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; set exch_scale_alpha 1.0. will set \(\alpha = 1.0\) and scale exchange energies with \(p_{EX}(1.0)\).; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (9)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis aug-cc-pvdz. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:10005,perform,perform,10005,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,7,['perform'],['perform']
Performance,"trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals.; Optking does support the specification of ghost atoms. Certain internal coordinates such; as torsions become poorly defined when they contain near-linear bends.; An internal error AlgError may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; however, they may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting OPT_COORDINATES to cartesian will avoid any internal; coordinate difficulties altogether. These coordinate changes can be automatically; performed by turning DYNAMIC_LEVEL to 1. Warning; In some cases, such as the coordinate issues described above, optking will reset to maintain; a consistent history. If an error occurs in Psi4 due to GEOM_MAXITER being exceeded but; the final step report indicates that optking has not taken GEOM_MAXITER steps, such a; reset has occured. Inspection will show that the step counter was reset to 1 somewhere in the; optimization. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:18157,perform,performed,18157,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,4,['perform'],['performed']
Performance,"try and variables:\n'); psi4.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (psi4.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False):; psi4.opt_clean(); psi4.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(). optstash.restore(); return thisenergy; psi4.print_out('\n Structure for next step:\n'); psi4.get_active_molecule().print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = p4util.get_psifile(1); kwargs['mode'] = 'sow'. n += 1. psi4.print_out('\tOptimizer: Did not converge!'). optstash.restore(); return 0.0. ## Aliases ##; opt = optimize. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """"""; namelower = name.lower(). # matches 'mrccsdt(q)'; if namelower.startswith('mrcc'):; # grabs 'sdt(q)'; ccfullname = namelower[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method' : 1, 'order' : 2, 'fullname' : 'CCSD' },; 'sdt' : { 'method' : 1, 'order' : 3, 'fullname' : 'CCSDT' },; 'sdtq' : { 'method' : 1, 'order' : 4, 'fullname' : 'CCSDTQ' },; 'sdtqp' : { 'method' : 1, 'order' : 5, 'fullname' : 'CCSDTQP' },; 'sdtqph' : { 'method' : 1, 'order' : 6, 'fullname' : 'CCSDTQPH' },; 'sd(t)' : { 'method' : 3, 'order' : -3, 'fullname' : 'CCSD(T)' },; 'sdt(q)' : { 'method' : 3, 'order' : -4, 'fullname' : 'CCSDT(Q)' },; 'sdtq(p)' : { 'method' : 3, 'order' : -5, 'fullname' : 'CCSDTQ(P)' },; 'sdtqp(h)' : { 'method' : 3, 'order' : -6, 'fullname' : 'CCSDTQP(H)' },; 'sd(t)_l' : ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:54575,optimiz,optimize,54575,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['optimiz'],['optimize']
Performance,"try from a starting point with a non-linear central bond angle. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. nbo; Generation of NBO file. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. scf-guess-read3; Test if the the guess read in the same basis converges. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cubeprop; RHF orbitals and density for water. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. opt11; Transition-state optimizations of HOOH to both torsional transition states. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. cc13d; Tests analytic CC2 gradients. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. fnocc6; Test method/basis with disk_df. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cepa1; cc-pvdz H2O Test CE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:37812,optimiz,optimizations,37812,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimizations']
Performance,"try optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/opt-1.html:1260,perform,performs,1260,psi4manual/4.0b2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html,2,['perform'],['performs']
Performance,try optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj. b3lyp-d3mbj. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exchange-Correlation Functional. b3p86-d3bj. b3pw91; B3PW91 Hyb-GGA Exchange-Correlation Functional. b3pw91-d3bj. b3pw91-nl; B3PW91-nl Hyb-GGA Exchange-Correlation Functional. b5050lyp; B5050LYP Hyb-GGA Exchange-Correlation Functional. b86b95; B86B95 Hyb-GGA Exchang,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:3231,optimiz,optimized,3231,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,15,['optimiz'],['optimized']
Performance,"try optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING); OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC); DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC); OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:112897,perform,perform,112897,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,16,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"try. (Default : 0). Type: integer; Default: 0. CFOUR_FD_CALCTYPE¶. Specifies the algorithm used to compute the harmonic force constants in finite-difference calculations.GRADONLY (=0) evaluates the force constants and dipole moment derivatives by numerical differentiation of analytic gradients; ENERONLY (=1) evaluates the force constants by second differences of energies (dipole moment derivatives are not evaluated); while MIXED (=2) evaluates 1x1 blocks of symmetry-blocked force constants by second differences pf energies and all other elements by first differences of gradients. the GRADONLY and MIXED approaches may, of course, only be used hwen using computational methods for which analytic gradients are available. Type: string; Possible Values: GRADONLY, ENERONLY, MIXED; Default: GRADONLY. CFOUR_FD_IRREPS¶. Requests that only vibrational frequencies of certain symmetry types are evaluated in a VIBRATION=FINDIF calculation. The numbers of the irreducible representations for which vibrational analysis is to be performed are separated by slashes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT¶. Specifies whet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:23827,perform,performed,23827,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,17,['perform'],['performed']
Performance,"ts * Negative - Triplets *. Type: array; Default: No Default. CIS_TOPDM_STATES (CPHF); CPHF — Which states to save AO transition OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. COLLAPSE_SIZE (DETCI); DETCI — Gives the number of vectors to retain when the Davidson subspace is collapsed (see MAX_NUM_VECS). If greater than one, the collapsed subspace retains the best estimate of the CI vector for the previous n iterations. Defaults to 1. Type: integer; Default: 1. COLLAPSE_WITH_LAST (CCEOM); CCEOM — Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. COMPUTE_MP4_TRIPLES (FNOCC); FNOCC (Expert) — Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES (FNOCC); FNOCC (Expert) — Do compute triples contribution?. Type: boolean; Default: true. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC); PSIMRCC — Do include the terms that coupl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:19109,optimiz,optimization,19109,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimization']
Performance,"ts and is recommended, while OFF often results in poor convergence and thus cannot be recommended. Type: string; Possible Values: RLE, DIIS, NOJACOBI, OFF; Default: DIIS. CFOUR_CC_MAXCYC¶. Specifies the maximum number of iterations in solving the CC amplitude equations. Type: integer; Default: 50. CFOUR_CC_PROGRAM¶. Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, MRCC, EXTERNAL; Default: VCC. CFOUR_CHARGE¶. Specifies the molecular charge. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 0. CFOUR_CIS_CONV¶. Specifies the convergence threshold as \(10^{-N}\) for CIS calculations. Type: integer; Default: 5. CFOUR_CONTINUUM¶. Signifies that one or more “continuum” orbitals should be added to the calculation. VIRTUAL and DVIRTUAL specify one or two orbital which should be initially unoccupied (in the SCF calculation), while OCCUPIED and DOCCUPIED ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html:10579,optimiz,optimization,10579,psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,2,['optimiz'],['optimization']
Performance,"ts and is recommended, while OFF often results in poor convergence and thus cannot be recommended. Type: string; Possible Values: RLE, DIIS, NOJACOBI, OFF; Default: DIIS. CFOUR_CC_MAXCYC¶. Specifies the maximum number of iterations in solving the CC amplitude equations. Type: integer; Default: 50. CFOUR_CC_PROGRAM¶. Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, MRCC, EXTERNAL; Default: VCC. CFOUR_CHARGE¶. Specifies the molecular charge. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 0. CFOUR_CIS_CONV¶. Specifies the convergence threshold as for CIS calculations. Type: integer; Default: 5. CFOUR_CONTINUUM¶. Signifies that one or more “continuum” orbitals should be added to the calculation. VIRTUAL and DVIRTUAL specify one or two orbital which should be initially unoccupied (in the SCF calculation), while OCCUPIED and DOCCUPIED specify one ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:10467,optimiz,optimization,10467,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['optimiz'],['optimization']
Performance,"ts and is recommended, while OFF often results in poor convergence and thus cannot be recommended. Type: string; Possible Values: RLE, DIIS, NOJACOBI, OFF; Default: DIIS. CFOUR_CC_MAXCYC¶. Specifies the maximum number of iterations in solving the CC amplitude equations. Type: integer; Default: 50. CFOUR_CC_PROGRAM¶. Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, NCC, MRCC, EXTERNAL; Default: VCC. CFOUR_CHARGE¶. Specifies the molecular charge. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 0. CFOUR_CIS_CONV¶. Specifies the convergence threshold as \(10^{-N}\) for CIS calculations. Type: integer; Default: 5. CFOUR_CONTINUUM¶. Signifies that one or more “continuum” orbitals should be added to the calculation. VIRTUAL and DVIRTUAL specify one or two orbital which should be initially unoccupied (in the SCF calculation), while OCCUPIED and DOCCU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cfour-1.html:10581,optimiz,optimization,10581,psi4manual/1.2.1/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cfour-1.html,13,['optimiz'],['optimization']
Performance,"ts loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-1]); basis = lmc[-1]. df = handle['pdie'][mc]; for dbrxn in df.index[df.notnull()].values:; [dbse, rxn] = dbrxn.split('-'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39554,Load,Loads,39554,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Load'],['Loads']
Performance,"ts that require an array input, standard Python list syntax should; be used, viz.:; 1; 2; 3set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; 1; 2; 3; 4set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use commands set_options() and; set_module_options() like below. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session.; 1; 2; 3; 4; 5; 6; 7; 8; 9psi4.set_options({; 'scf_type': 'pk',; 'e_convergence': 1.e-5,; 'soscf': True; }). psi4.set_module_options({; 'geom_maxiter': 50; }). Basis Sets¶. Basis Sets; Built-In",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:7281,perform,performed,7281,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,12,['perform'],['performed']
Performance,"ts with LRC functionals and DF integrals technology are not; currently enabled. We hope to have a patch for this deficit soon. Please let us; know if you have a strong need for this capability, and we will move the; priority up. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:22878,perform,performs,22878,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,2,['perform'],['performs']
Performance,"ts); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set' : [{'type' : 'distance',; 'indices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in; place:; molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:23191,optimiz,optimize,23191,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,9,['optimiz'],['optimize']
Performance,"tting basis sets in a session. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cc13b; Tests RHF CCSD(T)gradients. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. frac-ip-fitting; Omega optimization for LRC functional ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:15906,optimiz,optimization,15906,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,8,['optimiz'],"['optimization', 'optimized']"
Performance,"tting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). OPDM_AVG (DETCI). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (DFMP2). operate() SymmetryOperation method. SymRep method. opt(); . see optimize(); . OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). optimize(); . setting keywords. optimize() in module driver. OptionsState class in p4util.optproc. OptionState class in p4util.optproc. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orca_gradient_list() in module qcdb.orca. orca_list() in module qcdb.orca. order() CharacterTable method. IrreducibleRepresentation method. OrderedDict class in qcdb.oldpymodules. orientation_fixed() LibmintsMolecule method. OrientMols class in qcdb.orient. origin() PointGroup method. original_coef() ShellInfo method. original_coefs() ShellInfo method. ORTH_TYPE (DFOCC). (OCC). oss WrappedDatabase attribute. output; . SAPT. cbs(). database(). geometry optimization. vibrational analysis. OVERLAP_CHECK (CCEOM). oxcom() in module qcdb.dbwrap. P. P (THERMO). p() IrreducibleRepresentation method. p4const module. p4const.__init__ module. p4const.physconst module. p4const.psifiles module. p4util module. p4util.__init__ module. p4util.basislist module. p4util.basislistdunning module. p4util.basislistother module. p4util.exceptions module. p4util.inpsight module. p4util.numpy_helper module. p4util.optproc module. p4util.p4regex module. p4util.procuti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:55010,Optimiz,Optimized,55010,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['Optimiz'],['Optimized']
Performance,"ttps://github.com/Chandemonium/MP2D; FockCI — https://github.com/shannonhouck/psi4fockci; cct3 — https://github.com/piecuch-group/cct3; adcc — https://github.com/adc-connect/adcc; BrianQC — https://www.brianqc.com/; i-PI — http://ipi-code.org/; psixas — https://github.com/Masterluke87/psixas; MDI — https://github.com/MolSSI-MDI/MDI_Library; ddx — https://github.com/ddsolvation/ddx. How to use conda to get a Psi4 development environment¶; PSI4 has a lot of dependencies, some of which are complicated; to build. Fortunately, conda can supply them all. A conda; package psi4-dev is available to gather the dependencies; and build tools needed to compiler PSI4 from source. Go to; psicode.org/installs/latest, select “source” and “nightly build” along; with Linux/Mac and a Python version. Follow its instructions to create; a conda environment that has a script psi4-path-advisor. Running; psi4-path-advisor --help shows more options. Running the script; without arguments gives a cmake command that supplies paths to dependency; conda packages to CMake’s cache. You can add further cmake options to; this command when you execute it. Once the cmake command has built your; objdir, you can build PSI4. Remember to activate this; conda environment during PSI4 running or development. There are a; few extra options to psi4-path-advisor to set up using conda’s GNU; compilers (on Linux), conda’s Clang compilers (on Mac; less reliably),; or your own Intel compilers backed by conda’s GNU compilers (on Linux).; >>> git clone https://github.com/psi4/psi4.git && cd psi4; >>> conda create -n p4dev psi4-dev python=3.8 -c psi4/label/dev; >>> conda activate p4dev; >>> `psi4-path-advisor --gcc`; >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`. How to configure code to use high angular momentum basis sets¶; The Libint integral code handles; arbitrary order angular momentum (AM), but compiling that is; prohibitive. The build process for Libint2 takes longer than; for Libint1, so it’s recommended ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:10584,cache,cache,10584,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,4,['cache'],['cache']
Performance,"ttribute, [1]. original_coef() psi4.core.GaussianShell method, [1], [2]. ORTH_TYPE (DFOCC). (OCC). outfile_name() in module psi4.core, [1]. output. ; SAPT. cbs(). database(). geometry optimization. vibrational analysis. overlap() psi4.core.FISAPT method, [1], [2]. overlap_3c() psi4.core.IntegralFactory method, [1], [2]. OVERLAP_CHECK (CCEOM). overlap_grad() psi4.core.MintsHelper method, [1], [2]. OverlapInt class in psi4.core, [1]. P. p psi4.core.AOShellCombinationsIterator attribute, [1], [2]. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. ParsingError. partial_cholesky_factorize() psi4.core.Matrix method, [1], [2]. partition() psi4.core.FISAPT method, [1], [2]. pasture_required_modules psi4.driver.PastureRequiredError attribute. PastureRequiredError. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33]. PBS queueing system. PCG_BETA_TYPE (DFOCC). (OCC). PCG_CONVERGENCE (DFOCC). (OCC). PCG_MAXITER (DFOCC). (OCC). PCM. Using PCM. PCM (GLOBALS). PCM_CC_TYPE (PCM). PCM_enabled() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. pcm_helper() in module psi4.driver. PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() psi4.core.MintsHelper method, [1], [2]. PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() psi4.core.MintsHelper method, [1], [2]. psi4.core.SOBasisSet method, [1], [2]. petite_list1() psi4.core.MintsHelper method, [1], [2]. PetiteList class in psi4.core, [1]. PHI_POINTS (SCF). physconst. physical constants. pi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:104708,queue,queueing,104708,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['queue'],['queueing']
Performance,"tty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:24886,optimiz,optimization,24886,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['optimiz'],['optimization']
Performance,"tudes. The DIRECT option means compute amplitudes on the fly whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently Quasy Newton-Raphson algorithm avaliable with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. PCG_BETA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: FLETCHER_REEVES, POLAK_RIBIERE; Default: FLETCHER_REEVES. PCG_CONVERGENCE¶. Convergence criterion for residual vector of preconditioned conjugate gradient method. Type: conv double; Default: 1e-6. PCG_MAXITER¶. Maximum number of preconditioned conjugate gradient iterations. Type: integer; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html:4225,optimiz,optimize,4225,psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,2,['optimiz'],['optimize']
Performance,"tudes. The DIRECT option means compute amplitudes on the fly whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. PCG_BETA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: FLETCHER_REEVES, POLAK_RIBIERE; Default: FLETCHER_REEVES. PCG_CONVERGENCE¶. Convergence criterion for residual vector of preconditioned conjugate gradient method. Type: conv double; Default: 1e-6. PCG_MAXITER¶. Maximum number of preconditioned conjugate gradient iterations. Type: integer; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__dfocc-1.html:4196,optimiz,optimize,4196,psi4manual/1.1.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__dfocc-1.html,4,['optimiz'],['optimize']
Performance,"tures are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3382,optimiz,optimize,3382,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,3,['optimiz'],['optimize']
Performance,"turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; CI: Configuration Interaction; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:10682,optimiz,optimizations,10682,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,10,"['Optimiz', 'optimiz']","['Optimization', 'Optimizations', 'Optimizing', 'optimizations', 'optimize']"
Performance,"turn_wfn, func, mode, dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/opt-1.html:1869,optimiz,optimization,1869,psi4manual/1.4.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/opt-1.html,5,['optimiz'],['optimization']
Performance,"turn_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:1837,perform,performs,1837,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,4,['perform'],['performs']
Performance,"turns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83081,perform,performs,83081,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['perform'],['performs']
Performance,"tval[, execute, quiet]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an input dictionary. tdscf(wfn, **kwargs). temp_circular_import_blocker(). vibanal_wfn(wfn[, hess, irrep, molecule, …]); Function to perform analysis of a hessian or hessian block, specifically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, …]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). SCFConvergenceError(eqn_description, …); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, …); Error called for problems with TDSCF iterations. Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn’t and a simple syntax transition is possible. ValidationError(msg); Error called for problems with the input file. Class Inheritance Diagram¶. table",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:21865,Optimiz,OptimizationConvergenceError,21865,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,4,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimizer']"
Performance,"tware Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re; import numpy as np. from psi4 import extras; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.p4util.exceptions import *; from psi4.driver.molutil import *. from .roa import *; from . import proc_util; from . import empirical_dispersion; from . import dft_functional; from . import mcscf. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:2029,perform,performance,2029,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['perform'],['performance']
Performance,"two states. So far only implemented for degenerate doublet-Pi states and used in conjunction with SOPERT. Type: boolean; Default: false. CFOUR_BASIS¶. Specifies the AO basis used in the calculation. One can either specify a basis known to CFOUR or via BASIS=SPECIAL (=0) requests an arbitrary basis (see non-standard basis-set input). However, the latter must be available in the supplied GENBAS file. As standard basis sets, currently the following are available. Psi4 Interface: Recommended to use instead BASIS for larger basis set selection and greater flexibility. When BASIS used, CFOUR_SPHERICAL is set appropriately. Type: string; Default: SPECIAL. CFOUR_BRUCK_CONV¶. experimental use. Type: integer; Default: 4. CFOUR_BRUECKNER¶. Specifies whether Brueckner orbitals are to be determined for the specified CC method. OFF(=0) Brueckner orbitals are not to be determined, ON (=1) they are to be determined. Type: boolean; Default: false. CFOUR_CACHE_RECS¶. The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL¶. Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Default: SCF. CFOUR_CC_CONV¶. Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than \(10^N\), where \(N\) is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER¶. Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION¶. Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Pur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:7627,cache,cache,7627,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,11,['cache'],['cache']
Performance,"ty cumulant is; converged, the second set of microiterations is performed for the; self-consistent update of the orbitals with the fixed density cumulant. Each; macroiteration is completed by performing the orbital transformation of the; integrals. As in the simultaneous algorithm, the DIIS; extrapolation is used to accelerate convergence. Two-step algorithm is; only available for the DC-06 and DC-12 methods. QCIn the quadratically-convergent algorithm, the; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the cumulant will be solved using a standard Jacobi update.; If requested by the user (set QC_COUPLING to TRUE), the electronic Hessian can include; matrix elements that couple the orbitals and the density cumulant.; The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below \(10^{-7}\). The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensive \({\cal O}(N^5)\) integral transformations, the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dct.html:9792,perform,performed,9792,psi4manual/master/dct.html,https://psicode.org,https://psicode.org/psi4manual/master/dct.html,9,['perform'],['performed']
Performance,"ty fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems. SADNONatural orbitals from Superposition of Atomic Densities. Similar; to the above, but it forms natural orbitals from the SAD density; matrix to get proper orbitals which are used to start the; calculation, see [Lehtola:2019:1593]. GWHA generalized Wolfsberg-Helmholtz modification of the core; Hamiltonian matrix. May be useful in open-shell systems, but is; often less accurate than the core guess (see; [Lehtola:2019:1593]). HUCKELAn extended Hückel guess based on on-the-fly atomic UHF; calculations alike SAD, see [Lehtola:2019:1593]. READRead the previous orbitals from a wfn file, casting from; one basis to another if needed. Useful for starting anion; computations from neutral orbitals, or after small geometry; changes. At present, casting from a different molecular point; group is not supported. This becomes the default for the second; and later iterations of geometry optimizations. SAPSuperposition of Atomic Potentials. This is essentially a; modification of the core Hamiltonian, which includes screening; effects by using a radially screened effective atomic charge. The; screening effects have been calculated at the complete basis set; limit with finite-element calculations, see [Lehtola:2019:25945]; and [Lehtola:2020:012516]. The guess and its implementation have; been described in [Lehtola:2019:1593]. The guess is evaluated on a; DFT quadrature grid, so the guess energy depends slightly on the; used DFT quadrature. The current implementation is based on; exchange-only local density calculations that are but nanohartree; away from the complete basis set limit [Lehtola:2020:012516]. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:18335,optimiz,optimizations,18335,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,4,['optimiz'],['optimizations']
Performance,"type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by fini",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:48709,perform,performed,48709,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['perform'],['performed']
Performance,"type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:51961,perform,performed,51961,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['perform'],['performed']
Performance,"type. Type: string; Default: SCF. WFN (SCF)¶SCF (Expert) — Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. WFN_SYM (MCSCF)¶MCSCF — The symmetry of the SCF wavefunction. Type: string; Default: 1. WFN_SYM (PSIMRCC)¶PSIMRCC — The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Default: 1. WFN_TYPE (DFOCC)¶DFOCC — Type of the wavefunction. Type: string; Default: DF-OMP2. WFN_TYPE (OCC)¶OCC — Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5, REMP, OREMP; Default: OMP2. WRITE_NOS (CCDENSITY)¶CCDENSITY — Do write natural orbitals (molden). Type: boolean; Default: false. WRITE_OPT_HISTORY (OPTKING)¶OPTKING — Write the full history to disk. Produces a non validated OptimizationResult. Type: boolean; Default: false. WRITE_OPT_RESULT (OPTKING)¶OPTKING — Write the optimization history / state to disc. Type: boolean; Default: false. WRITE_TRAJECTORY (OPTKING)¶OPTKING — Write Optimization Trajectory. Type: boolean; Default: false. WRITER_FILE_LABEL (GLOBALS)¶GLOBALS — Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. XI (CCDENSITY)¶CCDENSITY — Do compute Xi?. Type: boolean; Default: false. XI_CONNECT (CCDENSITY)¶CCDENSITY (Expert) — Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. ZERO_INTERNAL_AMPS (PSIMRCC)¶PSIMRCC — Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. ZETA (CCDENSITY)¶CCDENSITY — Do use zeta?. Type: boolean; Default: false. ZETA (CCLAMBDA)¶CCLAMBDA — Do use zeta?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Alpha. © Copyright 2007",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:245603,Optimiz,Optimization,245603,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['Optimiz'],['Optimization']
Performance,"type. Type: string; Default: SCF. WFN (SCF)¶SCF (Expert) — Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. WFN_SYM (MCSCF)¶MCSCF — The symmetry of the SCF wavefunction. Type: string; Default: 1. WFN_SYM (PSIMRCC)¶PSIMRCC — The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Default: 1. WFN_TYPE (DFOCC)¶DFOCC — Type of the wavefunction. Type: string; Default: DF-OMP2. WFN_TYPE (OCC)¶OCC — Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5, REMP, OREMP; Default: OMP2. WRITE_NOS (CCDENSITY)¶CCDENSITY — Do write natural orbitals (molden). Type: boolean; Default: false. WRITE_OPT_HISTORY (OPTKING)¶OPTKING — Write the full history to disk. Produces a non validated OptimizationResult. Type: boolean; Default: false. WRITE_OPT_RESULT (OPTKING)¶OPTKING — Write the optimization history / state to disc. Type: boolean; Default: false. WRITE_TRAJECTORY (OPTKING)¶OPTKING — Write Optimization Trajectory. Type: boolean; Default: false. WRITER_FILE_LABEL (GLOBALS)¶GLOBALS — Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. XI (CCDENSITY)¶CCDENSITY — Do compute Xi?. Type: boolean; Default: false. XI_CONNECT (CCDENSITY)¶CCDENSITY (Expert) — Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. ZERO_INTERNAL_AMPS (PSIMRCC)¶PSIMRCC — Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. ZETA (CCDENSITY)¶CCDENSITY — Do use zeta?. Type: boolean; Default: false. ZETA (CCLAMBDA)¶CCLAMBDA — Do use zeta?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Alpha. © Copyright 2007-2022, Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:238443,Optimiz,Optimization,238443,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,1,['Optimiz'],['Optimization']
Performance,"type. Type: string; Default: SCF. WFN (SCF)¶SCF (Expert) — Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. WFN_SYM (MCSCF)¶MCSCF — The symmetry of the SCF wavefunction. Type: string; Default: 1. WFN_SYM (PSIMRCC)¶PSIMRCC — The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Default: 1. WFN_TYPE (DFOCC)¶DFOCC — Type of the wavefunction. Type: string; Default: DF-OMP2. WFN_TYPE (OCC)¶OCC — Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5, REMP, OREMP; Default: OMP2. WRITE_NOS (CCDENSITY)¶CCDENSITY — Do write natural orbitals (molden). Type: boolean; Default: false. WRITE_OPT_HISTORY (OPTKING)¶OPTKING — Write the full history to disk. Produces a non validated OptimizationResult. Type: boolean; Default: false. WRITE_OPT_RESULT (OPTKING)¶OPTKING — Write the optimization history / state to disc. Type: boolean; Default: false. WRITE_TRAJECTORY (OPTKING)¶OPTKING — Write Optimization Trajectory. Type: boolean; Default: false. WRITER_FILE_LABEL (GLOBALS)¶GLOBALS — Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. XI (CCDENSITY)¶CCDENSITY — Do compute Xi?. Type: boolean; Default: false. XI_CONNECT (CCDENSITY)¶CCDENSITY (Expert) — Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. ZERO_INTERNAL_AMPS (PSIMRCC)¶PSIMRCC — Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. ZETA (CCDENSITY)¶CCDENSITY — Do use zeta?. Type: boolean; Default: false. ZETA (CCLAMBDA)¶CCLAMBDA — Do use zeta?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Alpha. © Copyright 2007-2023, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_glossary_options_c.html:240126,Optimiz,Optimization,240126,psi4manual/1.8.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_glossary_options_c.html,1,['Optimiz'],['Optimization']
Performance,"type. Type: string; Default: SCF. WFN (SCF)¶SCF (Expert) — Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. WFN_SYM (MCSCF)¶MCSCF — The symmetry of the SCF wavefunction. Type: string; Default: 1. WFN_SYM (PSIMRCC)¶PSIMRCC — The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Default: 1. WFN_TYPE (DFOCC)¶DFOCC — Type of the wavefunction. Type: string; Default: DF-OMP2. WFN_TYPE (OCC)¶OCC — Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5, REMP, OREMP; Default: OMP2. WRITE_NOS (CCDENSITY)¶CCDENSITY — Do write natural orbitals (molden). Type: boolean; Default: false. WRITE_OPT_HISTORY (OPTKING)¶OPTKING — Write the full history to disk. Produces a non validated OptimizationResult. Type: boolean; Default: false. WRITE_OPT_RESULT (OPTKING)¶OPTKING — Write the optimization history / state to disc. Type: boolean; Default: false. WRITE_TRAJECTORY (OPTKING)¶OPTKING — Write Optimization Trajectory. Type: boolean; Default: false. WRITER_FILE_LABEL (GLOBALS)¶GLOBALS — Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. XI (CCDENSITY)¶CCDENSITY — Do compute Xi?. Type: boolean; Default: false. XI_CONNECT (CCDENSITY)¶CCDENSITY (Expert) — Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. ZERO_INTERNAL_AMPS (PSIMRCC)¶PSIMRCC — Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. ZETA (CCDENSITY)¶CCDENSITY — Do use zeta?. Type: boolean; Default: false. ZETA (CCLAMBDA)¶CCLAMBDA — Do use zeta?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Alpha. © Copyright 2007-2024, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_glossary_options_c.html:240622,Optimiz,Optimization,240622,psi4manual/1.9.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_glossary_options_c.html,1,['Optimiz'],['Optimization']
Performance,"t{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; cbs() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). table of contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Complete Basis Set. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs-1.html:28159,optimiz,optimization,28159,psi4manual/1.4.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"t{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; cbs() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). table of contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Complete Basis Set. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/cbs-1.html:28159,optimiz,optimization,28159,psi4manual/1.5.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/cbs-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"u to scale Exch-Disp2,u . Type: string; Possible Values: NONE, FIXED, DISP; Default: DISP. Advanced Keywords for SAPT(DFT)¶. SAPT_DFT_FUNCTIONAL¶. Underlying funcitonal to use for SAPT(DFT). Type: string; Default: PBE0. SAPT_DFT_DO_HYBRID¶. Enables the hybrid xc kernel in dispersion?. Type: boolean; Default: true. SAPT_DFT_EXCH_DISP_FIXED_SCALE¶. Exch-disp scaling factor for FIXED scheme for SAPT_DFT_EXCH_DISP_SCALE_SCHEME Default value of 0.686 suggested by Hesselmann and Korona, J. Chem. Phys. 141, 094107 (2014). Type: double; Default: 0.686. SAPT_DFT_MP2_DISP_ALG¶. Which MP2 Exch-Disp module to use?. Type: string; Possible Values: FISAPT, SAPT; Default: SAPT. SAPT_QUIET¶. Interior option to clean up printing. Type: boolean; Default: false. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies for closed-shell systems; only. Publications resulting from the use of the higher-order SAPT code; should cite the following:; [Hohenstein:2010:014101].; For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]).; As shown in [Parker:2014:094106], whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102], the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:24286,perform,perform,24286,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,5,['perform'],['perform']
Performance,"uantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU select",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:9316,CACHE,CACHELEVEL,9316,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['CACHE'],['CACHELEVEL']
Performance,"uare-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into PSI4 format. Note; PSI4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in PSI4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:6881,optimiz,optimization,6881,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['optimiz'],['optimization']
Performance,"uation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_INTERFRAG (OPTKING); OPTKING — Do freeze all interfragment modes?. Type: boolean; Default: false. FREEZE_INTRAFRAG (OPTKING); OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_BEND (OPTKING); OPTKING — Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_CARTESIAN (OPTKING); OPTKING — Specify atom and X, XY, XYZ, ... to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DOCC (GLOBALS); GLOBALS — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC (GLOBALS); GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING); OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM); CCEOM — Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. G_CONVERGENCE (OPTKING); OPTKING — Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:131246,optimiz,optimized,131246,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,"uation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell SAPT0 keywords¶. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies for closed-shell systems; only. Publications resulting from the use of the higher-order SAPT code; should cite the following:; [Hohenstein:2010:014101].; For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]).; As shown in [Parker:2014:094106], whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102], the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sapt-1.html:18916,perform,perform,18916,psi4manual/1.2.1/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sapt-1.html,4,['perform'],['perform']
Performance,"uations are available. The choice of the algorithm is controlled using the; ALGORITHM option. SIMULTANEOUS [Default]In the simultaneous algorithm the DCT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. The macroiterations are repeated until the simultaneous; convergence of the cumulant and orbitals is achieved.; Convergence of the simultaneous algorithm is accelerated using the; DIIS extrapolation technique. TWOSTEPIn the two-step algorithm each macroiteration consists of two sets of; microiterations. In the first set, the density cumulant equations are solved; iteratively, while the orbitals are kept fixed. After the density cumulant is; converged, the second set of microiterations is performed for the; self-consistent update of the orbitals with the fixed density cumulant. Each; macroiteration is completed by performing the orbital transformation of the; integrals. As in the simultaneous algorithm, the DIIS; extrapolation is used to accelerate convergence. Two-step algorithm is; only available for the DC-06 and DC-12 methods. QCIn the quadratically-convergent algorithm, the; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the cum",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dct.html:8942,perform,performing,8942,psi4manual/master/dct.html,https://psicode.org,https://psicode.org/psi4manual/master/dct.html,9,['perform'],['performing']
Performance,"ubblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. IGNORE_TAU (DCFT); DCFT — Controls whether to ignore terms containing non-idempotent contribution to OPDM or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: false. INTCO_FIXED_EQ_FORCE_CONSTANT (OPTKING); OPTKING — In constrained optimizations, for internal coordinates with user-specified equilibrium values, this is the force constant (in au) used to apply an additional force to each coordinate. If the user is only concerned to satify the desired constraint, then the user need only ensure that this value is sufficiently large. Alternatively, the user may specify this value to apply a force of a particular magnitude, in which case the given equilibrium value may or may not be reached by the optimization. Type: double; Default: 2.0. INTCOS_GENERATE_EXIT (OPTKING); OPTKING — Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. INTERFRAG_DIST_INV (OPTKING); OPTKING — Do use for the stretching coordinate between fragments? Otherwise, use . Type: boolean; Default: false. INTERFRAG_HESS (OPTKING); OPTKING — Model Hessian to guess interfragment force constants. Type: string; Possible Values: DEFAULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE (OPTKING); OPTKING — When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, INTERFRAGMENT; Default: FIXED. INTERFRAG_STEP_LIMIT (OPTKING); OPTKING — Maximum step size in bohr or radian along an interfragment coordinate. Type: double; Default: 0.4. INTERNAL_ROTATIONS (MCSCF); MCSCF — Do ?. Type: boolean; Default: tru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:45202,optimiz,optimization,45202,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"uble; Default: 0.75. CPHF_TASKS (CPHF); CPHF — Which tasks to run CPHF For * Valid choices: * -Polarizability *. Type: array; Default: No Default. CUTOFF (OMP2); OMP2 — Cutoff value for numerical procedures. Type: integer; Default: 14. CUTOFF (OMP3); OMP3 — Cutoff value for numerical procedures. Type: integer; Default: 14. D_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for density. Type: conv double; Default: 1e-6. D_CONVERGENCE (SAPT); SAPT — Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. D_CONVERGENCE (SCF); SCF — Convergence criterion for SCF density. In practice, the SCF energy will be good to 1-4 more than this number of digits. (This means that D_CONVERGENCE = 11 is overkill and will approach machine precision.) See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. DAMPING_CONVERGENCE (SCF); SCF — The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE (DCFT); DCFT — The amount (percentage) of damping to apply to the orbital update procedure: 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DAMPING_PERCENTAGE (PSIMRCC); PSIMRCC — The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DAMPING_PERCENTAGE (SCF); SCF ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:20498,perform,performed,20498,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,ublications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the MP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the CEPA0 code should cite the following publication(s):; [Bozkaya:2011:omp2]. Methods¶; The conventional and orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/U,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:5474,Optimiz,Optimized,5474,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,2,['Optimiz'],['Optimized']
Performance,"ubsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION (CFOUR); CFOUR — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF; Default: NO. CFOUR_VTRAN (CFOUR); CFOUR — This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the \((ab \vert cd)\) integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD (CFOUR); CFOUR — Specifies the X-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword \(\times 10^{-6}\). This allows field strengths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL (CFOUR); CFOUR — The tolerance for storing transformed integrals. Integrals less than \(10^{-N}\) are neglected and not stored on disk. Type: integer; Default: 11. CFOUR_YFIELD (CFOUR); CFOUR — Specifies the Y-component of an external electric field. The v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:83606,perform,performed,83606,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"ubsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION (CFOUR); CFOUR — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF; Default: NO. CFOUR_VTRAN (CFOUR); CFOUR — This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD (CFOUR); CFOUR — Specifies the X-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword . This allows field strengths to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL (CFOUR); CFOUR — The tolerance for storing transformed integrals. Integrals less than are neglected and not stored on disk. Type: integer; Default: 11. CFOUR_YFIELD (CFOUR); CFOUR — Specifies the Y-component of an external electric field. The value must be specified as an integer and the field used by the program will ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:83280,perform,performed,83280,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"uclear coordinates. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. soscf1; Second-order SCF convergnece: Benzene. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. cubeprop; RHF orbitals and density for water. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfomp2p5-2;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:17081,perform,performed,17081,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['perform'],['performed']
Performance,"ude:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support cu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:54681,optimiz,optimize,54681,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"ue *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label); return True. [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label); return True. [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(),; computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(),; computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if (expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" %; (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if (expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" %; (expected.n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:8559,Perform,Performs,8559,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['Perform'],['Performs']
Performance,"ue *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label); return True. [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label); return True. [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; message = (""\t%s has %d irreps, but %s has %d\n."" %; (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); raise TestComparisonError(message); if (expected.symmetry() != computed.symmetry()):; message = (""\t%s has %d symmetry, but %s has %d\n."" %; (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); raise TestComparisonError(message); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if (expected.rows(irrep) != computed.rows(irrep)):; message = (""\t%s has %d rows in irrep %d, but %s has %d\n."" %; (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep))); raise TestComparisonError(message); if (expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; message = (""\t%s has %d columns in irrep, but %s has %d\n."" %; (expected.n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html:8460,Perform,Performs,8460,psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,1,['Perform'],['Performs']
Performance,"uencies by finite differences of energies for planar C4NH4 TS. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). cc37; CC2(UHF)/cc-pVDZ energy of H2O+. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc3; Test FNO-QCISD(T) computation. scf3; File retention, docc, socc, and bond distances specified explicitly. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. dfcasscf-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. pubchem2; Superficial test of PubChem interface. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. ao-dfcasscf-sp; CASSCF/6-31G** energy point. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc43; RHF-CC2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:20456,optimiz,optimized,20456,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimized']
Performance,"uencies. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequencies.html:1053,perform,performed,1053,psi4manual/1.7.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequencies.html,1,['perform'],['performed']
Performance,"uencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequencies-1.html:1143,perform,performs,1143,psi4manual/1.4.0/api/psi4.driver.frequencies-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequencies-1.html,5,['perform'],['performs']
Performance,"uency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). psi4.hessian(name[, molecule, return_wfn, func, dertype, irrep])[source]; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. Returns:; Matrix – Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. Returns:; (Matrix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). It’s handy to collect the wavefunction after a frequency; calculation through e, wfn = psi4.frequency(...,; return_wfn=True) as the frequencies can be accessed through; psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:3550,optimiz,optimize,3550,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,4,['optimiz'],['optimize']
Performance,"uency. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequency.html:1053,perform,performed,1053,psi4manual/1.7.x/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequency.html,1,['perform'],['performed']
Performance,"ues()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results = self.prepare_results(client=client); ret_energy = results.pop(""ret_energy""); ret_ptype = results.pop(""ret_ptype""); ret_gradient = results.pop(""ret_gradient"", None). # load QCVariables; qcvars = {; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; 'NBODY NUMBER': len(self.task_list),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": ret_energy,; }. for k, val in results.items():; qcvars[k] = val. qcvars['CURRENT ENERGY'] = ret_energy; if self.driver == 'gradient':; qcvars['CURRENT GRADIENT'] = ret_ptype; properties[""return_gradient""] = ret_ptype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties':",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html:89889,load,load,89889,psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_nbody.html,3,['load'],['load']
Performance,"uess iterations. Type: integer; Default: 50. SAD_PRINT (SCF); SCF (Expert) — The amount of SAD information to print to the output. Type: integer; Default: 0. SAPT (SCF); SCF (Expert) — Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. SAPT_LEVEL (SAPT); SAPT — The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK (SAPT); SAPT — Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_FACTOR (DFTSAPT); DFTSAPT — % of memory for DF-MP2 three-index buffers. Type: double; Default: 0.9. SAPT_MEM_SAFETY (SAPT); SAPT — Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE (SAPT); SAPT — The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE (SAPT); SAPT — The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. SAVE_JK (SCF); SCF — Keep JK object for later use?. Type: boolean; Default: false. SCALE (STABILITY); STABILITY — Scale factor (between 0 and 1) for orbital rotation step. Type: double; Default: 0.5. SCF_MAXITER (DCFT); DCFT — Maximum number of the orbital update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same keyword controls the maximum number of orbital response micro-iterations per macro-iteration for the solution of the response equations (for RESPONSE_ALOGRITHM = TWOSTEP). Type: integer; Default: 50. SCF_MEM_SAFETY_FACTOR (SCF); SCF — Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE (CPHF); CPHF — SCF Type. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: DIRECT. SCF_TYPE (SCF); SCF — Wh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:116703,perform,performed,116703,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"ug-cc-pVDZ-RI df_basis_mp2; }. When most popular basis sets are being used, including Dunning and; Pople-style, the SCF, DF-MP2, and SAPT codes will chose the appropriate; auxiliary basis set automatically according to Auxiliary Basis Sets,; unless instructed otherwise by setting the auxiliary basis set in the; input. Finally, we note that the basis {...} block may also be used; for defining basis sets, as detailed in User-Defined Basis Sets. Decontracted Basis Sets¶; Decontraction of the basis set can be useful in certain situations. In order to; decontract a given basis set, simply add “-decontract” to the name of the primary basis set.; set basis cc-pvdz-decontract. Obviously this will add significantly to the computational cost of any given calculation, however it can; be useful when checking the basis set dependence of a particular calculated property or in certain situations; where a large basis set is critical. Currently it is recommended that a decontracted basis is always used when performing realtivistic calculations using the X2C Hamiltonian. User-Defined Basis Sets¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. There are three routes by which a basis set in G94 format can be introduced to Psi4‘s notice.; (1) Install new basis set file into Psi4 basis library.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Name the file with the name of the basis set and a .gbs extension,; after app",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/basissets-1.html:4870,perform,performing,4870,psi4manual/1.0.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/basissets-1.html,2,['perform'],['performing']
Performance,"ug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; Presently (May 2016), only two of the five delta possibilities are active. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cbs-1.html:11813,perform,performed,11813,psi4manual/1.0.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cbs-1.html,2,['perform'],['performed']
Performance,"ugh it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ -------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:7305,optimiz,optimize,7305,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['optimiz'],['optimize']
Performance,"ugh it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step; (in principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; -----------------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:7186,optimiz,optimize,7186,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,2,['optimiz'],['optimize']
Performance,"ugh triples with iterative quadruples (cheapest terms). ccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). ccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). ccsdt-1b; CC through doubles with iterative triples (cheaper terms). ccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). ccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). ccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). cc2; approximate CC through doubles [details]. cc3; approximate CC through triples [details]. cc4; approximate CC through quadruples. cc5; approximate CC through quintuples. cc6; approximate CC through sextuples. ccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). ccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). ccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). ccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('ccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/mrcc.html:4653,optimiz,optimize,4653,psi4manual/1.8.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/mrcc.html,2,['optimiz'],['optimize']
Performance,"ugh triples with iterative quadruples (cheapest terms). ccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). ccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). ccsdt-1b; CC through doubles with iterative triples (cheaper terms). ccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). ccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). ccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). cc2; approximate CC through doubles [details]. cc3; approximate CC through triples [details]. cc4; approximate CC through quadruples. cc5; approximate CC through quintuples. cc6; approximate CC through sextuples. ccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). ccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). ccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). ccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('ccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/mrcc.html:4653,optimiz,optimize,4653,psi4manual/1.9.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/mrcc.html,2,['optimiz'],['optimize']
Performance,"ugh triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/mrcc.html:3920,optimiz,optimize,3920,psi4manual/1.6.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/mrcc.html,2,['optimiz'],['optimize']
Performance,"uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; 1@UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; 1; 2; 3; 4; 5; 6; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:5621,perform,perform,5621,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,12,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"uired; precision. In particular, BrianQC will respect all of PSI4’s usual precision; parameters, like INTS_TOLERANCE and E_CONVERGENCE.; BrianQC can speed up a number of internal computations, including Fock and; gradient computation. Thus, BrianQC will speed up any calculation involving; those terms, such as. HF and DFT single point energies; HF and DFT geometry optimizations; HF and DFT frequency analysis. Note that not every term of every calculation can be handled by BrianQC, thus,; the actual speedup depends on the specifics of the calculation. Necessary and recommended option values¶; To ensure that a calculation works with BrianQC, the following options need to; be set when enabling BrianQC:. BrianQC currently only handles the C1 molecular symmetry point group. Thus, if; the molecule has any symmetries (which PSI4 would detect by default), the; input geometry must contain the line symmetry c1 to force PSI4 to; disregard the symmetry. To achieve peak performance, the following settings are recommended when enabling; BrianQC:. By default, PSI4 uses density-fitted preiterations for SCF, which BrianQC; doesn’t handle yet. To ensure that no non-BrianQC-accelerated iterations are; performed, disable the preiterations by setting DF_SCF_GUESS to False.; By default, PSI4 uses a disk-based Fock building, but BrianQC currently only; accelerates direct Fock builds. To ensure that Fock building is accelerated by; BrianQC, set SCF_TYPE to direct. Keywords¶. BRIANQC_ENABLE¶. Whether to enable using the BrianQC GPU module. Type: boolean; Default: false. Environment Variables¶. BRIANQC_SDK_INSTALL¶; Toggle for type of BrianQC installation.; See https://s3.amazonaws.com/streamnovation-brianqc-manual/BrianQC_Manual_v1_1_0.pdf for details. BRIANQC_INSTALL_PATH¶; Location of BrianQC installation.; See https://s3.amazonaws.com/streamnovation-brianqc-manual/BrianQC_Manual_v1_1_0.pdf for details. BRIANQC_ENABLE¶; Runtime toggle of whether to use BrianQC. table of contents. Interface ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/brianqc.html:3733,perform,performance,3733,psi4manual/master/brianqc.html,https://psicode.org,https://psicode.org/psi4manual/master/brianqc.html,9,['perform'],['performance']
Performance,"uite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/psi4/include/psi4/physconst.h; h = 6.62606896E-34 # The Planck constant (Js) ; c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; au2amu = 5.485799097E-4 # Atomic units (m$@@e$) to atomic mass units conversion fa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:1558,load,loaded,1558,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,4,['load'],['loaded']
Performance,"uite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level Psi4 source directory, and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all Psi4 input files.; For convenience, the physical constants used within the Psi4 code (which; are obtained from the 3rd edition of the IUPAC Green; book [Cohen:GreenBook:2008]) are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within Psi4, which are automatically; made available within all Psi4 input files.; # @END LICENSE; #. # Do not modify this file! It is auto-generated by the document_options_and_tests; # script, from psi4topdir/include/physconst.h; psi_h = 6.62606896E-34 # The Planck constant (Js) ; psi_c = 2.99792458E8 # Speed of light (ms$^{-1}$) ; psi_kb = 1.3806504E-23 # The Boltzmann constant (JK$^{-1}$) ; psi_R = 8.314472 # Universal gas constant (JK$^{-1}$mol$^{-1}$) ; psi_bohr2angstroms = 0.52917720859 # Bohr to Angstroms conversion factor ; psi_bohr2m = 0.52917720859E-10 # Bohr to meters conversion factor ; psi_bohr2cm = 0.52917720859E-8 # Bohr to centimeters conversion factor ; psi_amu2g = 1.660538782E-24 # Atomic mass units to grams conversion factor ; psi_amu2kg = 1.660538782E-27 # Atomic mass units to kg conversion factor ; psi_au2amu = 5.485799097E-4 # Atomic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:1608,load,loaded,1608,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['load'],['loaded']
Performance,"uivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Note; Presently (May 2016), only two of the five delta possibilities are active. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:12055,optimiz,optimize,12055,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,8,['optimiz'],['optimize']
Performance,"ul for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR)¶CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR)¶CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR)¶CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR)¶CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR)¶CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR)¶CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:47488,optimiz,optimization,47488,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['optimiz'],['optimization']
Performance,"ulate and store all elements of \(\Gamma(abcd)\), while DIRECT (=1) tells the program to use alternative algorithms in which \(\Gamma(abcd)\) is calculated and used “on the fly”. Note that this option might be not available for all type of calculations. Type: string; Possible Values: DISK, DIRECT; Default: DISK. CFOUR_GENBAS_1¶. This keyword applies only to Hydrogen and Helium atoms and specifies the number of contracted Gaussian functions per shell. There is usually no need to use this keyword, but it can be useful for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2¶. This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3¶. This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4¶. This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV¶. Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC¶. Specifies the maximum allowed number of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html:29281,perform,performs,29281,psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,15,['perform'],['performs']
Performance,"ulate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC); FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retain",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:7216,cache,cache,7216,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,12,['cache'],['cache']
Performance,"uld also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:5313,Optimiz,Optimize,5313,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,6,['Optimiz'],['Optimize']
Performance,"uld also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.0266327348",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:5966,Optimiz,Optimize,5966,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,9,['Optimiz'],['Optimize']
Performance,"uld be considered expert-only.; Once the molecular quadrature grid is built, the points are partitioned into; blocks of points which are spatially close to each other. We use an octree; algorithm for this procedure, which produces a good balance between spatial; compactness of each block (which helps achieve linear scaling due to the; exponential decay of the basis functions), and retaining a large number of; points in each block (which helps keep the FLOP rate up by allowing for a; reasonably large amount of BLAS3/BLAS2 work to form the densities and potentials; in each block). For each block, a united set of significant basis functions is; determined by the cutoff radius of each shell of basis functions. The size of; this cutoff radius (and thereby the accuracy of the density/potential; evaluation) can be varied by setting the DFT_BASIS_TOLERANCE, which; defaults to 1E-12. We are still exploring optimizations of the octree algorithm; and the basis cutoffs, but it is likely that significant speed gains may be; realized by relaxing the basis cutoff tolerance, with negligible decrease in; accuracy.; Small density values can introduce numerical instabilities with some functionals that; can result in trailing SCF convergence issues or even numerical failures (NaNs).; If the default settings of the LibXC library are insufficient, a custom value can be; request by setting DFT_DENSITY_TOLERANCE. For notorious cases a value of 1E-10; is sensible.; An example of a fully specified grid is as follows:; molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; dft_spherical_points 590 # Often needed; dft_radial_points 99 # Often needed; dft_radial_scheme treutler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_density_tolerance 1.0E-10 # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; dft_pruning_scheme robust # Generally safe and will speed things up; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dft.html:22738,optimiz,optimizations,22738,psi4manual/master/dft.html,https://psicode.org,https://psicode.org/psi4manual/master/dft.html,9,['optimiz'],['optimizations']
Performance,"uld be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. CFOUR_ESTATE_TRANS (CFOUR)¶CFOUR — Specifies whether just the excitation energies (OFF, =0) or in addition transition moments (EXPECTATION, =1) are calculated. Note that this keyword should not be used in excited-state calculations involving analytic gradients and that transition moments are essentially only available for EOM-CCSD/CCSD-LR. Type: string; Possible Values: OFF, EXPECTATION; Default: OFF. CFOUR_EVAL_HESS (CFOUR)¶CFOUR — Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. CFOUR_EXCITATION (CFOUR)¶CFOUR — Specifies in CC calculations using mrcc the excitation level if the calculation level has been chosen as CC(n), CI(n), or CCn(n). Type: integer; Default: 0. CFOUR_EXCITE (CFOUR)¶CFOUR — Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. CFOUR_FC_FIELD (CFOUR)¶CFOUR — Specifies the strength of a Fermi-Contact perturbation as required for finite-field calculations of spin densities and the FC contributions to indirect spin-spin coupling constants. The value",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:38850,optimiz,optimizations,38850,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,18,['optimiz'],"['optimizations', 'optimizer']"
Performance,"ule in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if func is None:; raise ManagedMethodError(['select_mp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:3771,perform,performance,3771,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"ule in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:7771,perform,performance,7771,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"ule in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp3_property', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_olccd_property', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; el",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:10382,perform,performance,10382,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"ule input strings identically. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fnocc2; Test G2 method for H2O. mints2-bse; Similar to mints2, but using the BSE to specify the basis sets. isapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). fcidump; test FCIDUMP functionality for rhf/uhf. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:19005,optimiz,optimization,19005,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"ule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); core.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and reopen with filehandle; print('output in', current_directory + '/' + core.outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS') == True:; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen([cfour_executable], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:7316,load,loaded,7316,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,2,['load'],['loaded']
Performance,"ule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); core.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and reopen with filehandle; print('output in', current_directory + '/' + core.outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen([cfour_executable], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html:7312,load,loaded,7312,psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,1,['load'],['loaded']
Performance,"ule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); core.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and reopen with filehandle; print('output in', current_directory + '/' + core.outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen(cfour_executable.split(), bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:7342,load,loaded,7342,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,4,['load'],['loaded']
Performance,"ule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info). # var_dict = core.variables(); packet = {; ""molecule"": self.molecule,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']; passalong = {k: v for k, v in data.items() if k not in packet}; passalong.pop('ptype', None). self.task_list[""reference""] = self.computer(**packet, **passalong). parent_group = self.molecule.point_group(); for label, displacement in self.findifrec[""displacements""].items():; clone = self.molecule.clone(); clone.reinterpret_coordentry(False); #clone.fix_orientation(True). # Load in displacement into the active molecule; clone.set_geometry(core.Matrix.from_array(displacement[""geometry""])). # If the user insists on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). packet = {; ""molecule"": clone,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; # Displacements can run in lower symmetry. Don't overwrite orbitals from reference geom; packet['keywords']['function_kwargs'].update({""write_orbitals"": False}); if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']. self.task_list[label] = self.computer(**packet, **passalong). # for n, displacement ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:44935,Load,Load,44935,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,3,['Load'],['Load']
Performance,"ule,; freq_irrep_only=self.metameta['irrep'],; stencil_size=findif_stencil_size,; step_size=findif_step_size,; t_project=translations_projection_sound,; r_project=r_project_hess). ndisp = len(self.findifrec[""displacements""]) + 1; info = f"""""" {ndisp} displacements needed ...\n""""""; core.print_out(info); logger.debug(info). # var_dict = core.variables(); packet = {; ""molecule"": self.molecule,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']; passalong = {k: v for k, v in data.items() if k not in packet}; passalong.pop('ptype', None). self.task_list[""reference""] = self.computer(**packet, **passalong). parent_group = self.molecule.point_group(); for label, displacement in self.findifrec[""displacements""].items():; clone = self.molecule.clone(); clone.reinterpret_coordentry(False); #clone.fix_orientation(True). # Load in displacement into the active molecule; clone.set_geometry(core.Matrix.from_array(displacement[""geometry""])). # If the user insists on symmetry, weaken it if some is lost when displacing.; # or 'fix_symmetry' in self.findifrec.molecule; logger.debug(f'SYMM {clone.schoenflies_symbol()}'); if self.molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). packet = {; ""molecule"": clone,; ""driver"": self.metameta['proxy_driver'],; ""method"": self.method,; ""basis"": data[""basis""],; ""keywords"": data[""keywords""] or {},; }; if 'cbs_metadata' in data:; packet['cbs_metadata'] = data['cbs_metadata']. self.task_list[label] = self.computer(**packet, **passalong). # for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; # _process_displacement(energy, lowername, molecule, displacement, n, ndisp, write_orbitals=Fa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:44860,Load,Load,44860,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,1,['Load'],['Load']
Performance,"ule_for_input(molecule)); fmaster.write(format_options_for_input()); format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Gradient %d Computation: Displacement %d')\n"""""" % (opt_iter, n + 1); banners += """"""PsiMod.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; PsiMod.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from eac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:27522,Perform,Perform,27522,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Perform'],['Perform']
Performance,"uleclone, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:59616,optimiz,optimization,59616,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,2,['optimiz'],['optimization']
Performance,"ules    .    .    .    .  · ; 1.3.2;  · . PSI4. Installation and Runtime Configuration. Obtaining PSI4¶. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid.; Take a quiz to find the best version of the codebase for; your needs, be it binary, tarball, or version-controlled repository. Or,; select outright among:. Binary Installer; Conda Binary Package; Clone from GitHub Repository; Fork from GitHub Repository (only path to develop PSI4); Tarball from GitHub Repository; Psi3 from SourceForge. Find-the-code Quiz¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base.; Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,; and optimization for a variety of processor architectures (except; Mac, which is least common denominator), I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself.; I’m on Linux or Mac or Windows with Ubuntu Bash Shell.; I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility; I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4.; In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_obtaining-1.html:987,optimiz,optimization,987,psi4manual/1.3.2/build_obtaining-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_obtaining-1.html,2,['optimiz'],['optimization']
Performance,"ules    .    .  · ; 1.1;  · . PSI4. psi4.driver.opt¶. psi4.driver.opt(name, **kwargs)¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:1088,perform,performed,1088,psi4manual/1.1.0/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html,1,['perform'],['performed']
Performance,"ules. TRIPLES (not trip), TRIPLETS (not trip), SINGLES (not sing),; SINGLETS (not sing); CONVERGENCE (not conv, not converge) and TOLERANCE (not tol); Convergence of a method should be governed by an E_CONVERGENCE for; energy and either a D_CONVERGENCE for density or a R_CONVERGENCE; for residual/amplitudes. All of these should be doubles- let the input; parser handle the flexible input format.; Diis should have a boolean DIIS (not do_diis, not use_diis) to turn; on/off diis extrapolation, a DIIS_MIN_VECS and DIIS_MAX_VECS for; minimum and maximum number of diis vectors to use, and a DIIS_START; which is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude, not amp) for amplitudes; NUM_ (not n) for number (e.g., NUM_AMPS_PRINT, MAX_NUM_VECS,; NUM_THREADS); Some names that could be split into multiple words are staying as one.; Use MAXITER, CACHELEVEL, PUREAM, DERTYPE.; INTS (not integrals), also OEI (not oe_integrals) for; one-electron integrals and TEI (not te_integrals) for two-electron; integrals; PERTURB (not pert) for perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_addon.html:7255,CACHE,CACHELEVEL,7255,psi4manual/master/manage_addon.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_addon.html,13,['CACHE'],['CACHELEVEL']
Performance,"ult. CHOLESKY_TOLERANCE¶. Tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1e-4. DF_BASIS_SCF¶. Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_SCF_GUESS¶. Do a density fitting SCF calculation to converge the orbitals before switching to the use of exact integrals in a SCF_TYPE DIRECT calculation. Type: boolean; Default: true. GUESS¶. The type of guess orbitals. See Initial Guess for what the options mean and what the defaults are. Type: string; Possible Values: AUTO, CORE, GWH, SAD, SADNO, SAP, SAPGAU, HUCKEL, READ; Default: AUTO. GUESS_MIX¶. Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. INTS_TOLERANCE¶. Screening threshold for the chosen screening method (SCHWARZ, CSAM, DENSITY) Absolute value below which TEI are neglected. Type: conv double; Default: 1e-12. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ORBITALS_WRITE¶. File name (case sensitive) to which to serialize Wavefunction orbital data. Type: string; Default: No Default. PRINT_BASIS¶. Do print the basis set?. Type: boolean; Default: false. PRINT_MOS¶. Do print the molecular orbitals?. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__scf.html:1464,optimiz,optimization,1464,psi4manual/1.8.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__scf.html,1,['optimiz'],['optimization']
Performance,"ult. DF_BASIS_SCF (CPHF); CPHF — Auxiliary basis for SCF. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SCF (SCF); SCF — Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_BUMP_R0 (SCF); SCF — Bump function min radius. Type: double; Default: 0.0. DF_BUMP_R1 (SCF); SCF — Bump function max radius. Type: double; Default: 0.0. DF_DOMAINS (SCF); SCF — FastDF geometric fitting domain selection algorithm. Type: string; Possible Values: DIATOMIC, SPHERES; Default: DIATOMIC. DF_FITTING_CONDITION (SCF); SCF (Expert) — Fitting Condition, i.e. eigenvalue threshold for RI basis. Analogous to S_TOLERANCE. Type: double; Default: 1.0e-10. DF_INTS_IO (DFMP2); DFMP2 (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_IO (SCF); SCF (Expert) — IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. DF_INTS_NUM_THREADS (DFMP2); DFMP2 — Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. DF_INTS_NUM_THREADS (SCF); SCF — Number of threads for integrals (may be turned down if memory is an issue). 0 is blank. Type: integer; Default: 0. DF_METRIC (SCF); SCF — FastDF Fitting Metric. Type: string; Possible Values: COULOMB, EWALD, OVERLAP; Default: COULOMB. DF_SCF_GUESS (SCF); SCF — Do a density fitting SCF calculation to converge the orbitals before switching to the use of exact integrals in a |scf__scf_type| DIRECT calculation. Type: boolean; Default: true. DF_THETA (SCF); SCF — FastDF SR Ewald metric range separation parameter. Type: double; Default: 1.0. DFCC (FNOCC); FNOCC — Do use density fitting or cholesky decomposition in CC? This keyword is used internally by the driver. Changing its value will have no effect on the computation. Type: boolean; Default: false. DFMP2_MEM_FACTOR (DFMP2); DFMP2 — % of memory for DF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:98050,LOAD,LOAD,98050,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['LOAD'],['LOAD']
Performance,"ult: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Secord order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_R_START¶. When to start second-order SCF iterations based on gradient RMS. Type: double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indices specified above (). Type: array; Default: No Default. Environmental Effects¶. EXTERN¶. An ExternalPotential (built by Python or NULL/None). Type: python; Default: No Default. ONEPOT_GRID_READ¶. Read an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html:6713,perform,perform,6713,psi4manual/1.0.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"ult: C. FISAPT_LINK_SELECTION (FISAPT); FISAPT — Specification algorithm for link bonds in ISAPT. Type: string; Possible Values: AUTOMATIC, MANUAL; Default: AUTOMATIC. FISAPT_MANUAL_LINKS (FISAPT); FISAPT — Manual link bond specification [[Atom1, Atom2], …]. Type: array; Default: No Default. FISAPT_MEM_SAFETY_FACTOR (FISAPT); FISAPT (Expert) — Memory safety factor for heavy FISAPT operations. Type: double; Default: 0.9. FISAPT_PLOT_FILEPATH (FISAPT); FISAPT — Filepath to drop scalar data. Type: string; Default: plot/. FITTING_ALGORITHM (CPHF); CPHF — Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. FITTING_CONDITION (CPHF); CPHF — The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. FIXED_BEND (OPTKING); OPTKING — Specify angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_COORD_FORCE_CONSTANT (OPTKING); OPTKING — In constrained optimizations, for coordinates with user-specified equilibrium values, this is the initial force constant (in au) used to apply an additional force to each coordinate. Type: double; Default: 0.5. FIXED_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOLLOW_ROOT (DETCI); DETCI — The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 0. FOLLOW_ROOT (MCSCF); MCSCF — Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FOLLOW_ROOT (PSIMRCC); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:128487,optimiz,optimizations,128487,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimizations']
Performance,"ult: QCHEM. MAX_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. RMS_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. RMS_FORCE_G_CONVERGENCE¶. Convergence criterion for geometry optmization: rms force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. Hessian Update¶. CART_HESS_READ¶. Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. HESS_UPDATE¶. Hessian update scheme. Type: string; Possible Values: NONE, BFGS, MS, POWELL, BOFILL; Default: BFGS. HESS_UPDATE_LIMIT¶. Do limit the magnitude of changes caused by the Hessian update?. Type: boolean; Default: true. HESS_UPDATE_LIMIT_MAX¶. If HESS_UPDATE_LIMIT is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 1.00. HESS_UPDATE_LIMIT_SCALE¶. If HESS_UPDATE_LIMIT is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 0.50. HESS_UPDATE_USE_LAST¶. Number of previous steps to use in Hessian u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html:5306,optimiz,optimization,5306,psi4manual/1.0.0/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html,25,['optimiz'],['optimization']
Performance,"ult: RHF. EOM_REFERENCE (CCSORT); CCSORT — Reference wavefunction type for EOM computations. Type: string; Default: RHF. EP_EA_POLES (OCC); OCC — Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES (OCC); OCC — Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER (OCC); OCC — Maximum number of electron propagator iterations. Type: integer; Default: 30. EX_ALLOW (DETCI); DETCI (Expert) — An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. EX_LEVEL (DETCI); DETCI — The CI excitation level. Type: integer; Default: 2. EXCH_SCALE_ALPHA (SAPT); SAPT — Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with . If set to a value , performs scaling with . Type: string; Default: FALSE. EXCITATION_RANGE (CCEOM); CCEOM (Expert) — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. EXPLICIT_HAMILTONIAN (CPHF); CPHF — Do explicit hamiltonian only?. Type: boolean; Default: false. EXTERN (SCF); SCF — An ExternalPotential (built by Python or NULL/None). Type: python; Default: No Default. EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS); GLOBALS (Expert) — Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code does NOT help you out in any way!. Type: boolean; Default: false. FAIL_ON_MAXITER (SCF); SCF — Fail if we reach maxiter without converging?. Type: b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:119130,perform,performs,119130,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performs']
Performance,"ult: false. OPDM_AVG (DETCI); DETCI — Do average the OPDM over several roots in order to obtain a state-average one-particle density matrix? This density matrix can be diagonalized to obtain the CI natural orbitals. Type: boolean; Default: false. OPDM_IN_FILE (TRANSQT); TRANSQT — MO-basis one-particle density matrix file. Type: integer; Default: PSIF_MO_OPDM. OPDM_KE (DETCI); DETCI (Expert) — Do compute the kinetic energy contribution from the correlated part of the one-particle density matrix?. Type: boolean; Default: false. OPDM_OUT_FILE (TRANSQT); TRANSQT — AO-basis one-particle density matrix file. Type: integer; Default: PSIF_AO_OPDM. OPDM_PRINT (DETCI); DETCI — Do print the one-particle density matrix for each root?. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY); CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (DFMP2); DFMP2 — Do relax the one-particle density matrix?. Type: boolean; Default: true. OPT_METHOD (OCC); OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. OPT_TYPE (OPTKING); OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (OCC); OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (OCC); OCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the si",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:92900,optimiz,optimization,92900,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"ult: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, FAST_DF, CD, INDEPENDENT, GTFOCK; Default: PK. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 0.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html:3239,perform,performing,3239,psi4manual/1.1.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html,2,['perform'],['performing']
Performance,"ult: true. RESTART (DETCI); DETCI — Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk; the number of vectors specified by RESTART_VECS (obsolete) is collapsed down to one vector per root. Type: boolean; Default: false. RESTART_EOM_CC3 (CCEOM); CCEOM — Do ?. Type: boolean; Default: false. RESTRICTED_DOCC (DETCI); DETCI — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_DOCC (PSIMRCC); PSIMRCC — The number of doubly occupied orbitals per irrep. Type: array; Default: No Default. RESTRICTED_DOCC (TRANSQT); TRANSQT — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (DETCI); DETCI — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (TRANSQT); TRANSQT — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RFO_FOLLOW_ROOT (OPTKING); OPTKING — Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_ROOT (OPTKING); OPTKING — Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RHF_TRIPLETS (CCEOM); CCEOM — Do ?. Type: boolean; Default: false. RMS_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. RMS_FORCE_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: rms force (internal coordinates, atomic units). Type: conv double; Default: 3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:84206,optimiz,optimized,84206,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,"ultistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequencies.html:2805,optimiz,optimize,2805,psi4manual/1.6.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequencies.html,1,['optimiz'],['optimize']
Performance,"umber):; """""" Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to :py:func:`numpy.load`; to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:4911,load,load,4911,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,3,['load'],['load']
Performance,"ument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for sa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:105091,load,load,105091,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['load'],['load']
Performance,"ument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:10568,load,load,10568,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"umentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module ». MP2¶; Performs second order Moller-Plesset perturbation theory (MP2) computations. This code can compute RHF/ROHF/UHF energies, and RHF gradient/property computations. However, given the small errors introduced, we recommend using the new density fitted MP2 codes instead, which are much more efficient. General¶. CACHELEVEL¶. The amount of cacheing of data to perform. Type: integer; Default: 2. CACHETYPE¶. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. MP2_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. Type: double; Default: 1.0/3.0. OPDM¶. Do compute the one particle density matrix, for properties?. Type: boolean; Default: false. OPDM_RELAX¶. Do add relaxation terms to the one particle density matrix, for properties?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF, ROHF; Default: RHF. SCS¶. Do perform a spin component scaled MP2 computation?. Type: boolean; Default: false. SCS_N¶. Do perform a spin component scaled (N) MP2 computation?. Type: boolean; Default: false. Expert¶. JOBTYPE¶. Type of job being performed. Type: string; Default: SP. WFN¶. Wavefunction type. Type: string; Possible Values: MP2; Default: MP2. Table Of Contents. MP2; General; CACHELEVEL; CACHETYPE; MP2_OS_SCALE; MP2_SS_SCALE; OPDM; OPDM_RELAX; REFERENCE; SCS; SCS_N. Expert; JOBTYPE; WFN. Previous topic; BASIS; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__mp2-1.html:1209,perform,perform,1209,psi4manual/4.0b2/autodir_options_c/module__mp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__mp2-1.html,12,"['CACHE', 'perform']","['CACHELEVEL', 'CACHETYPE', 'perform', 'performed']"
Performance,umentation; SAPT — PSI4 [beta2] documentation; SCF — PSI4 [beta2] documentation; STABILITY — PSI4 [beta2] documentation; TRANSQT — PSI4 [beta2] documentation; TRANSQT2 — PSI4 [beta2] documentation; CACHELEVEL — PSI4 [beta2] documentation; CACHETYPE — PSI4 [beta2] documentation; JOBTYPE — PSI4 [beta2] documentation; MP2_OS_SCALE — PSI4 [beta2] documentation; MP2_SS_SCALE — PSI4 [beta2] documentation; OPDM — PSI4 [beta2] documentation; OPDM_RELAX — PSI4 [beta2] documentation; REFERENCE — PSI4 [beta2] documentation; SCS — PSI4 [beta2] documentation; SCS_N — PSI4 [beta2] documentation; WFN — PSI4 [beta2] documentation; E_CONVERGENCE — PSI4 [beta2] documentation; INTS_TOLERANCE — PSI4 [beta2] documentation; MRCC_LEVEL — PSI4 [beta2] documentation; MRCC_METHOD — PSI4 [beta2] documentation; MRCC_NUM_SINGLET_ROOTS — PSI4 [beta2] documentation; MRCC_NUM_TRIPLET_ROOTS — PSI4 [beta2] documentation; MRCC_OMP_NUM_THREADS — PSI4 [beta2] documentation; MRCC_RESTART — PSI4 [beta2] documentation; CACHELEVEL — PSI4 [beta2] documentation; CC_MAXITER — PSI4 [beta2] documentation; CUTOFF — PSI4 [beta2] documentation; DIIS_MAX_VECS — PSI4 [beta2] documentation; DO_SCS — PSI4 [beta2] documentation; DO_SOS — PSI4 [beta2] documentation; E_CONVERGENCE — PSI4 [beta2] documentation; HESS_TYPE — PSI4 [beta2] documentation; LEVEL_SHIFT — PSI4 [beta2] documentation; MAX_MOGRAD_CONVERGENCE — PSI4 [beta2] documentation; MO_MAXITER — PSI4 [beta2] documentation; MO_READ — PSI4 [beta2] documentation; MO_STEP_MAX — PSI4 [beta2] documentation; MO_WRITE — PSI4 [beta2] documentation; MP2_OS_SCALE — PSI4 [beta2] documentation; MP2_SS_SCALE — PSI4 [beta2] documentation; NAT_ORBS — PSI4 [beta2] documentation; OMP2_ORBS_PRINT — PSI4 [beta2] documentation; OPT_METHOD — PSI4 [beta2] documentation; ORTH_TYPE — PSI4 [beta2] documentation; R_CONVERGENCE — PSI4 [beta2] documentation; RMS_MOGRAD_CONVERGENCE — PSI4 [beta2] documentation; SOS_SCALE — PSI4 [beta2] documentation; SOS_SCALE2 — PSI4 [beta2] documentation; ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:923173,CACHE,CACHELEVEL,923173,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,"umerical procedures. Type: integer; Default: 8. CUTOFF (OCC); OCC — Cutoff value for numerical procedures. Type: integer; Default: 14. D_CONVERGENCE (FISAPT); FISAPT — Convergence criterion for residual of the CPHF coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. Type: conv double; Default: 1e-8. D_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for density, as measured by the orbital gradient. Type: conv double; Default: 1e-6. D_CONVERGENCE (SAPT); SAPT — Convergence criterion for residual of the CPHF coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. Type: conv double; Default: 1e-8. D_CONVERGENCE (SCF); SCF — Convergence criterion for SCF density, defined as the RMS or maximum absolute value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. DAMPING_CONVERGENCE (SCF); SCF — The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE (DCFT); DCFT (Expert) — The amount (percentage) of damping to apply to the orbital update procedure: 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DAMPING_PERCENTAGE (PSIMRCC); PSIMRCC — The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:92008,perform,performed,92008,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"unc = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:8595,perform,performance,8595,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"unc is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD through CCENERGY for (RHF|ROHF) not enabled here since not advertised. It does run, though, see #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:22177,perform,performance,22177,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"unchanged). Type: string; Default: No Default. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. H_UPDATE_DEN_TOL¶. Denominator check for hessian update. Type: conv double; Default: 1e-7. INTERFRAG_STEP_LIMIT¶. Maximum step size in bohr or radian along an interfragment coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT¶. Initial maximum step size in bohr or radian along an internal coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT_MAX¶. Upper bound for dynamic trust radius [au]. Type: double; Default: 1.0. INTRAFRAG_STEP_LIMIT_MIN¶. Lower bound for dynamic trust radius [au]. Type: double; Default: 0.001. IRC_DIRECTION¶. IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE¶. IRC step size in bohr(amu). Type: double; Default: 0.2. IRC_STOP¶. Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. OPT_COORDINATES¶. Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. PRINT_OPT_PARAMS¶. Print all optking parameters. Type: boolean; Default: false. PRINT_TRAJECTORY_XYZ_FILE¶. Should an xyz trajectory file be kept (useful for visualization)?. Type: boolean; Default: false. RFO_FOLLOW_ROOT¶. Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX¶. Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT¶. Root for RFO to follow, 0 being lowest (for a m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html:2424,optimiz,optimization,2424,psi4manual/1.0.0/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html,2,['optimiz'],['optimization']
Performance,"uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. dft-smoke; DFT Functional Smoke Test. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. scf-guess-read2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:32922,perform,performed,32922,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. scf-guess-read2; Test if the the guess read in the sa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:29364,perform,performed,29364,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"unction to return the total memory allocation. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct (R/U/RO/CU HF/KS) wavefuncti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:19741,optimiz,optimize,19741,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,6,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"unction<sec:psimod_Wavefunction>`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~driver_cbs.complete_basis_set` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/aliases.html:3179,perform,performed,3179,psi4manual/1.0.0/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/aliases.html,1,['perform'],['performed']
Performance,"unctional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft1-alt; DFT Functional Test. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mints3; Test individual integral objects for correctness. options1; check all variety of opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:4813,perform,performs,4813,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['perform'],['performs']
Performance,"unctional available in PSI4. Methods¶; The various orbital-optimized methods supported by the OCC/DFOCC; modules in PSI4 are summarized in Table OCC OO; Methods and detailed in Table OCC; OO Capabilities. Note that while two; separate libraries OCC (conventional integrals CONV) and DFOCC; (density-fitted DF and Cholesky-decomposed CD) together provide; the methods described on this page, they are controlled through one; QC_MODULE value OCC. Without set qc_module occ,; these methods may default to implementations in other modules based on efficiency considerations. Orbital-optimized theoretical methods accessible through OCC/DFOCC¶. name; calls method; OO. omp2; orbital-optimized second-order MP perturbation theory; E/G. omp2.5; orbital-optimized average of MP2 and MP3; E/G. omp3; orbital-optimized third-order MP perturbation theory; E/G. oremp2; orbital-optimized second-order REMP hybrid PT; E/G. olccd; orbital-optimized linear coupled cluster doubles; E/G. Detailed orbital-optimized capabilities of the OCC module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[1] ↓ →; FREEZE_CORE[2]→. QC_MODULE=OCC Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. omp2[4]; MP2_TYPE; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. omp2.5[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. omp3[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. oremp2[4]; CC_TYPE; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:10676,optimiz,optimized,10676,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['optimiz'],['optimized']
Performance,"unctional labeled if canonical. ADC ROOT n TOTAL ENERGY - h TRANSITION¶; The total ADC energy of root n within irrep h. This variable is only defined for Psi’s; built-in ADC and will be removed for 1.7. ADC ROOT 0 -> ROOT n CORRELATION ENERGY - h TRANSITION¶; The correlation energy contribution to the excitation energy from the ground state to; root n within irrep h. This variable is only defined for Psi’s built-in ADC and will be removed for 1.7. AQCC DIPOLE¶; Dipole array [e a0] for the averaged quadratic coupled-cluster level of theory, (3,). AQCC QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the averaged quadratic coupled-cluster level of theory, (3, 3). AQCC TOTAL ENERGY¶. AQCC CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the averaged quadratic coupled-cluster level of theory. BRUECKNER CONVERGED¶; Value 1 (0) when the Brueckner orbitals have (have not) converged. CBS NUMBER¶. NBODY NUMBER¶. FINDIF NUMBER¶; Number of tasks [] the named procedure performs. These are immediate; tasks, so if procedures are nested, the total number of tasks is; the product. CBS TOTAL ENERGY¶. CBS CORRELATION ENERGY¶. CBS REFERENCE ENERGY¶; The total electronic energy [Eh] and its breakdown into reference total; energy [Eh] and correlation correction components [Eh] for the compound; method requested through cbs(). CCname ROOT n TOTAL ENERGY¶. TD-fctl ROOT n TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (IN h) TOTAL ENERGY¶. TD-fctl ROOT n (IN h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n within irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n (h) TOTAL ENERGY¶. TD-fctl ROOT n (h) TOTAL ENERGY¶; The total electronic energy [Eh] for the requested theory and root n, which is of irrep h (n starts at 0).; DFT functional labeled if canonical. CCname ROOT n T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:8144,perform,performs,8144,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['perform'],['performs']
Performance,unctional; Y; —; —; —; —; —; —; —; —. TH-FL; TH-FL GGA Exchange-Correlation Functional; Y; —; —; —; —; —; —; —; —. TH1; TH1 GGA Exchange-Correlation Functional; Y; —; —; —; —; —; —; —; —. TH2; TH2 GGA Exchange-Correlation Functional; Y; —; —; —; —; —; —; —; —. TH3; TH3 GGA Exchange-Correlation Functional; Y; —; —; —; —; —; —; —; —. TH4; TH4 GGA Exchange-Correlation Functional; Y; —; —; —; —; —; —; —; —. TPSS; TPSS Meta-GGA XC Functional; Y; Y; —; —; —; —; —; —; —. TPSS-D3BJ; TPSS Meta-GGA XC Functional; Y; Y; —; —; —; —; —; Y. TPSS-NL; TPSS Meta-GGA XC Functional; Y; Y; —; —; —; —; —; —; —. TPSSH; TPSSh Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TPSSH-D3BJ; TPSSh-d3bj Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y. TPSSH-NL; TPSSh-nl Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TPSSLYP1W; TPSSLYP1W GGA Exchange-Correlation Functional; Y; Y; —; —; —; —; —; —; —. TUNED-CAM-B3LYP; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; 0.150000; 0.079900; —; —; —; —; —. VSXC; VSXC Meta-GGA XC Functional; Y; Y; —; —; —; —; —; —; —. VV10; VV10 GGA Exchange-Correlation Functional; Y; —; —; —; —; —; —; —; —. WB97; wB97 GGA Exchange-Correlation Functional; Y; —; 0.400000; —; —; —; —; —; —. WB97M-D3BJ; wB97M-V with D3(BJ) instead of VV10 dispersion; Y; Y; 0.300000; 0.150000; —; —; —; Y. WB97M-V; wB97M-V Hyb-GGA Exchange-Correlation Functional; Y; Y; 0.300000; 0.150000; —; —; —; —; —. WB97X; wB97X Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; —; —. WB97X-D; wB97X-D Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.222036; —; —; —; Y. WB97X-D3; wB97X-D3 Hyb-GGA Exchange-Correlation Functional; Y; —; 0.250000; 0.195728; —; —; —; Y. WB97X-D3BJ; wB97X-V with D3(BJ) instead of VV10 dispersion; Y; —; 0.300000; 0.167000; —; —; —; Y. WB97X-V; wB97X-V Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.167000; —; —; —; —; —. WPBE; PBE SR-XC Function,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_dft_all-1.html:22510,TUNE,TUNED-CAM-,22510,psi4manual/1.4.0/autodoc_dft_all-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_dft_all-1.html,20,['TUNE'],['TUNED-CAM-']
Performance,"undant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_METHOD (DFOCC); DFOCC — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC); OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. OPT_TYPE (OPTKING); OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC); DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC); OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (DFOCC); DFOCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORB_RESP_SOLVER (OCC); OCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: stri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:178656,optimiz,optimize,178656,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimize']
Performance,"union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(ssmod, func)):; self.add_Subset(getattr(ssmod, func).__doc__, getattr(ssmod, func)). print(""""""WrappedDatabase %s: Defined subsets loaded"""""" % (self.dbse)). [docs] def get_pec_weightinfo(self):; """""". """"""; def closest(u, options):; return max(options, key=lambda v: len(os.path.commonprefix([u, v]))). dbdat = {}; oss = self.oss['default']; eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; for rxnix, rxn in enumerate(oss.hrxn):; dbdat[rxn] = {'eq': closest(rxn, eqrxns),; 'Rrat': oss.axis['Rrat'][rxnix]}; return dbdat. # def table_simple1(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['bas', ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:42746,load,load,42746,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['load']
Performance,"unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:48815,perform,performs,48815,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['perform'],['performs']
Performance,"unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:52067,perform,performs,52067,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['perform'],['performs']
Performance,"unless *exitonfail* False, in which case; returns error message. Used in input files in the test suite. """"""; if digits > 1:; thresh = 10**-digits; message = """"""\t{}: computed value ({:.{digits1}f}) does not match ({:.{digits1}f}) to {digits} digits."""""".format(; label, computed, expected, digits1=int(digits) + 1, digits=digits); else:; thresh = digits; message = (""\t%s: computed value (%f) does not match (%f) to %f digits."" % (label, computed, expected, digits)); if abs(float(expected) - float(computed)) > thresh:; # float cast handles decimal.Decimal vars; print(message); if exitonfail:; raise TestComparisonError(message); if math.isnan(computed):; print(message); print(""\tprobably because the computed value is nan.""); if exitonfail:; raise TestComparisonError(message); success(label); return True. [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label); return True. [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label); return True. [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:7621,Perform,Performs,7621,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['Perform'],['Performs']
Performance,"unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; 1; 2; 3; 4; 5; 6; 7molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; 1optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; 1; 2set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; 1optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; 1; 2set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; 1; 2; 3; 4; 5; 6; 7set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; 1; 2set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:4262,Optimiz,Optimize,4262,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,4,"['Optimiz', 'optimiz']","['Optimize', 'optimize']"
Performance,"unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_cfour-1.html:4357,optimiz,optimization,4357,psi4manual/1.1.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_cfour-1.html,4,['optimiz'],['optimization']
Performance,"unt < min_mem_allowed:; raise ValidationError(""""""set_memory(): Requested {:.3} MiB ({:.3} MB); minimum 250 MiB (263 MB). Please, sir, I want some more."""""".format(; memory_amount / 1024 ** 2, memory_amount / 1000 ** 2)). if execute:; core.set_memory_bytes(memory_amount); return memory_amount. [docs]def get_memory():; """"""Function to return the total memory allocation.""""""; return core.get_memory(). [docs]def success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); core.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label, exitonfail=True):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*; (or to *digits* itself when *digits* < 1 e.g. digits=0.04). Performs; a system exit on failure unless *exitonfail* False, in which case; returns error message. Used in input files in the test suite. """"""; if digits > 1:; thresh = 10 ** -digits; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d digits."" % (label, digits+1, computed, digits+1, expected, digits)); else:; thresh = digits; message = (""\t%s: computed value (%f) does not match (%f) to %f digits."" % (label, computed, expected, digits)); if abs(expected - computed) > thresh:; print(message); if exitonfail:; raise TestComparisonError(message); if math.isnan(computed):; print(message); print(""\tprobably because the computed value is nan.""); if exitonfail:; raise TestComparisonError(message); success(label); return True. [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html:6237,Perform,Performs,6237,psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/util.html,1,['Perform'],['Performs']
Performance,"unts of debugging information. Type: integer; Default: 1. PRINT_NOONS¶. How many NOONS to print – used in libscf_solver/uhf.cc and libmints/oeprop.cc. Type: string; Default: 3. PROPERTIES¶. List of properties to compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_MODULE¶. When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, ADCC, CCT3; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK; Default: PK. SCREENING¶. The type of screening used when computing two-electron integrals. Type: string; Possible Values: SCHWARZ, CSAM, DENSITY; Default: CSAM. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__globals-1.html:7100,optimiz,optimized,7100,psi4manual/1.5.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__globals-1.html,2,['optimiz'],['optimized']
Performance,"unts of debugging information. Type: integer; Default: 1. PRINT_NOONS¶. How many NOONS to print – used in libscf_solver/uhf.cc and libmints/oeprop.cc. Type: string; Default: 3. PROPERTIES¶. List of properties to compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_MODULE¶. When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, ADCC, CCT3; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK; Default: PK. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html:7100,optimiz,optimized,7100,psi4manual/1.4.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html,2,['optimiz'],['optimized']
Performance,"up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True, dertype=1). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; 1; 2; 3; 4; 5; 6; 7 Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; 1; 2; 3; 4; 5; 6 Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.417 0.538 1.007825; H 0.000 -0.417 0.538 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for; each atom along the normal mode coordinate. (This information could be used; to animate the vibratio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:8475,optimiz,optimization,8475,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['optimiz'],['optimization']
Performance,"up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True, dertype=1). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.417 0.538 1.007825; H 0.000 -0.417 0.538 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for; each atom along the normal mode coordinate. (This information could be used; to animate the vibrational frequency using visualization sof",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:8502,optimiz,optimization,8502,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,9,['optimiz'],['optimization']
Performance,"uples with iterative quintuples (all but the most expensive terms) |; +-------------------------+---------------------------------------------------------------------------------------+; | mrccsdtqph-3 | CC through quintuples with iterative sextuples (all but the most expensive terms) |; +-------------------------+---------------------------------------------------------------------------------------+. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type cast_up: :ref:`boolean <op_py_boolean>` or string; :param cast_up: ``'on'`` || |dl| ``'off'`` |dr| || ``'3-21g'`` || ``'cc-pVDZ'`` || etc. Indicates whether, to accelerate convergence for the scf portion of; the *name* calculation, a preliminary scf should be performed with a; small basis set (3-21G if a basis name is not supplied as keyword; value) followed by projection into the full target basis. .. deprecated:: Sept-2012; Use option |scf__basis_guess| instead. :type cast_up_df: :ref:`boolean <op_py_boolean>` or string; :param cast_up_df: ``'on'`` || |dl| ``'off'`` |dr| || ``'cc-pVDZ-RI'`` || ``'aug-cc-pVDZ-JKFIT'`` || etc. Indicates whether, when *cast_up* is active, to run the preliminary; scf in density-fitted mode or what fitting basis to employ (when; available for all elements, cc-pVDZ-RI is the default). .. deprecated:: Sept-2012; Use option |scf__df_basis_guess| instead. :type bypass_scf: :ref:`boolean <op_py_boolean>`; :param bypass_scf: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether, for *name* values built atop of scf calculations,; the scf step is skipped. Suitable when special steps are taken to get; the scf to converge in an explicit preceeding scf step. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:20859,perform,performed,20859,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['perform'],['performed']
Performance,"ur domain-specific; language (not quite Python) where commands don’t have psi4. in; front, then submit it to the executable psi4 which processes the; Psithon into pure Python and runs it internally. In PsiAPI mode, you; write a pure Python script with import psi4 at the top and commands; are behind the psi4. namespace, then submit it to the python; interpreter. Both modes are equally powerful. This tutorial covers the; PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably; for months before the 1.1 release and while we believe we’ve gotten; everything nicely arranged within the psi4. namespace, the API; should not be considered completely stable. Most importantly, as we; someday deprecate the last of the global variables, options will be; added to the method calls (e.g.,; energy('scf', molecule=mol, options=opt)); Unlike in the past, where Psi4 was executable software which could only; be called via input files like input.dat, it is now interactive,; able to be loaded directly as a Python module. Here, we will explore the; basics of using Psi4 in this new style by reproducing the section A; Psi4 Tutorial; from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your; path, feel free to execute each cell as you read along by pressing; Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python; environment:. In [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4_1495011512596/work/build/stage//scratch/psilocaluser/conda-builds/psi4_1495011512596/_b_env_placehold_placehold/lib/python3.5/site-packages')); except ImportError:; pass. import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4; will print any output to the screen; this can be changed by giving a; file name (with path if not in the current working directory) to th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:1335,load,loaded,1335,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,2,['load'],['loaded']
Performance,"ur optimizer.); Below is an example of a geometry optimization:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * 1.00e-06 * 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -76.33224285 -7.63e+01 2.41e-03 1.60e-03 1.51e-02 8.82e-03 o ~; 2 -76.33226097 -1.81e-05 4.84e-04 4.03e-04 7.71e-04 * 7.04e-04 o ~; 3 -76.33226140 -4.39e-07 * 4.31e-05 * 3.58e-05 9.89e-05 * 8.93e-05 o ~; 4 -76.332261",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:7830,optimiz,optimization,7830,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['optimiz'],['optimization']
Performance,"urce]; Function to compute various properties. Aliases:; prop(). Returns:; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (Li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prop.html:1160,optimiz,optimized,1160,psi4manual/master/prop.html,https://psicode.org,https://psicode.org/psi4manual/master/prop.html,4,['optimiz'],['optimized']
Performance,"urce]¶; Set equal to a unit matrix. zero()[source]¶; zero out the symop. class SymmetryOperation(*args)[source]¶; The SymmetryOperation class provides a 3 by 3 matrix; representation of a symmetry operation, such as a rotation or reflection. E()[source]¶; Set equal to E. analyze_d()[source]¶. bit()[source]¶; Get the bit value. c2_x()[source]¶; Set equal to C2 about the x axis. c2_y()[source]¶; Set equal to C2 about the y axis. c2_z()[source]¶; Set equal to C2 about the z axis. constructor_symmetryoperation(so)[source]¶. i()[source]¶; Set equal to an inversion. operate(r)[source]¶; This operates on this with r (i.e. return r * this). rotation(theta)[source]¶; Set equal to a clockwise rotation by 2pi/n or theta degrees. sigma_xy()[source]¶; Set equal to reflection in xy plane. sigma_xz()[source]¶; Set equal to reflection in xz plane. sigma_yz()[source]¶; Set equal to reflection in yz plane. trace()[source]¶; returns the trace of the transformation matrix. transform(r)[source]¶; This performs the transform r * this * r~. transpose()[source]¶; Transpose matrix operation. unit()[source]¶; Set equal to a unit matrix. zero()[source]¶; zero out the symop. similar(bits)[source]¶; From bits of a directionalized point group, returns array of; bits of all directions. class Molecule(psi4molstr=None)[source]¶; Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. BFS()[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. auto_fragments()[source]¶; Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. bond_profile()¶; Obtain",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:17512,perform,performs,17512,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performs']
Performance,"ure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); kwargs['molecule'] = molecule. # Allow specification of methods to arbitrary order; lowername = args[0].lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. if ""/"" in lowername:; return driver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:50451,optimiz,optimize,50451,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,3,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"ures:. Method; Available algorithms; Energy; Gradient; Reference. ODC-06; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-12; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-13; SIMULTANEOUS, QC; Y; Y; UHF. \(\mbox{ODC-12$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. \(\mbox{ODC-13$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE RHF is only available for; ALGORITHM SIMULTANEOUS. To compute \((\lambda_3)\) correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dcft-1.html:13977,perform,perform,13977,psi4manual/1.1.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dcft-1.html,6,['perform'],['perform']
Performance,"urn on this option if the induction energy is not going to be used. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. Expert¶. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. Table Of Contents. SAPT; General; AIO_CPHF; AIO_DF_INTS; BASIS; CCD_E_CONVERGENCE; CCD_MAXITER; CCD_T_CONVERGENCE; DENOMINATOR_ALGORITHM; DENOMINATOR_DELTA; DF_BASIS_ELST; DF_BASIS_SAPT; D_CONVERGENCE; E_CONVERGENCE; FREEZE_CORE; INTS_TOLERANCE; MAXITER; MAX_CCD_DIISVECS; MIN_CCD_DIISVECS; NAT_ORBS; NAT_ORBS_T2; NO_RESPONSE; OCC_TOLERANCE; PRINT; SAPT_LEVEL; SAPT_MEM_CHECK; SAPT_MEM_SAFETY; SAPT_OS_SCALE; SAPT_SS_SCALE. Expert; DO_CCD_DISP; DO_THIRD_ORDER. Previous topic; REFERENCE; Next topic; AIO_CPHF; This Page. Show Source. Quick search. Enter search terms or a module, class o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__sapt-1.html:4455,perform,performed,4455,psi4manual/4.0b4/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__sapt-1.html,2,['perform'],['performed']
Performance,"urn on this option if the induction energy is not going to be used. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. Expert¶. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. Table Of Contents. SAPT; General; AIO_CPHF; AIO_DF_INTS; BASIS; DENOMINATOR_ALGORITHM; DENOMINATOR_DELTA; DF_BASIS_ELST; DF_BASIS_SAPT; D_CONVERGENCE; E_CONVERGENCE; FREEZE_CORE; INTS_TOLERANCE; MAXITER; NAT_ORBS; NAT_ORBS_T2; NO_RESPONSE; OCC_TOLERANCE; PRINT; SAPT_LEVEL; SAPT_MEM_CHECK; SAPT_MEM_SAFETY; SAPT_OS_SCALE; SAPT_SS_SCALE. Expert; DO_THIRD_ORDER. Previous topic; REFERENCE; Next topic; AIO_CPHF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__sapt-1.html:4029,perform,performed,4029,psi4manual/4.0b2/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__sapt-1.html,2,['perform'],['performed']
Performance,"urn on this option if the induction energy is not going to be used. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. Expert¶. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. Table Of Contents. SAPT; General; AIO_CPHF; AIO_DF_INTS; BASIS; DENOMINATOR_ALGORITHM; DENOMINATOR_DELTA; DF_BASIS_ELST; DF_BASIS_SAPT; D_CONVERGENCE; E_CONVERGENCE; FREEZE_CORE; INTS_TOLERANCE; MAXITER; NAT_ORBS; NAT_ORBS_T2; NO_RESPONSE; OCC_TOLERANCE; PRINT; SAPT_LEVEL; SAPT_MEM_CHECK; SAPT_MEM_SAFETY; SAPT_OS_SCALE; SAPT_SS_SCALE. Expert; DO_THIRD_ORDER. Previous topic; REFERENCE; Next topic; AIO_CPHF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Cr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__sapt-1.html:4051,perform,performed,4051,psi4manual/4.0b3/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__sapt-1.html,2,['perform'],['performed']
Performance,"urns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:1287,optimiz,optimization,1287,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,30,['optimiz'],"['optimization', 'optimizer']"
Performance,"us = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:76334,Optimiz,OptimizationResult,76334,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Optimiz'],['OptimizationResult']
Performance,"us combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. sapt-ecp; sapt0 of charged system in ECP basis set. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). sapt10; usapt example with empty beta due to frozen core. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. fnocc2; Test G2 method for H2O. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. mints15; check SP basis Fortran exponent parsing. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. dft-dsd; DSD S22 Ammonia test. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:35036,optimiz,optimized,35036,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimized']
Performance,"us properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an input dictionary. tdscf(wfn, **kwargs). temp_circular_import_blocker(). vibanal_wfn(wfn[, hess, irrep, molecule, …]); Function to perform analysis of a hessian or hessian block, specifically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, …]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). SCFConverg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:21289,perform,perform,21289,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['perform'],['perform']
Performance,"us to the old FIXED_<COORD> keyword. Type: string; Default: No Default. RFO_FOLLOW_ROOT¶. Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX¶. Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT¶. Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RSRFO_ALPHA_MAX¶. Absolute maximum value of RS-RFO. Type: double; Default: 1e8. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, RS_I_RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. UNFREEZE_DIHEDRALS¶. Unfreeze a subset of dihedrals - meant for use with freeze_all_dihedrals. Type: string; Default: No Default. Convergence Control¶. FLEXIBLE_G_CONVERGENCE¶. Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. MAX_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. RMS_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html:5403,optimiz,optimization,5403,psi4manual/master/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html,1,['optimiz'],['optimization']
Performance,"us you may; want to have more control over the SCF procedure. You have the option of; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }. dimer = psi4.get_active_molecule(). set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }. dimer = psi4.get_active_molecule(). set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load. monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True). monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True). psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'). aux_basis = psi4.core.BasisSet.build(wfn_dimer.molecule(), ""DF_BASIS_SAPT"",; psi4.core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", psi4.core.get_global_option(""BASIS"")); wfn_dimer.set_basisset(""DF_BASIS_SAPT"", aux_basis); wfn_dimer.set_basisset(""DF_BASIS_ELST"", aux_basis). psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sapt-1.html:12078,load,load,12078,psi4manual/1.2.1/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sapt-1.html,4,['load'],['load']
Performance,"use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. NO_SINGLES¶. Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. OFFDIAGONAL_CCSD_T¶. Do include the off-diagonal corrections in (T) computations?. Type: boolean; Default: true. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Default: SECOND_ORDER. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-9. SMALL_CUTOFF¶. Type: integer; Default: 0. TIKHONOW_MAX¶. The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TRIPLES_ALGORITHM¶. The type of algorithm to use for (T) computations. Type: string; Possible Values: SPIN_ADAPTED, RESTRICTED, UNRESTRICTED; Default: RESTRICTED. TRIPLES_DIIS¶. Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?. Type: boolean; Default: false. USE_SPIN_SYM¶. Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boolean; Default: true. WFN_SYM¶. The symmetry of the target wavefunction, specified either by Sch",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__psimrcc-1.html:3240,perform,perform,3240,psi4manual/1.3.2/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__psimrcc-1.html,2,['perform'],['perform']
Performance,"use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. NO_SINGLES¶. Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. OFFDIAGONAL_CCSD_T¶. Do include the off-diagonal corrections in (T) computations?. Type: boolean; Default: true. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-9. SMALL_CUTOFF¶. Type: integer; Default: 0. TIKHONOW_MAX¶. The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TRIPLES_ALGORITHM¶. The type of algorithm to use for (T) computations. Type: string; Possible Values: SPIN_ADAPTED, RESTRICTED, UNRESTRICTED; Default: RESTRICTED. TRIPLES_DIIS¶. Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?. Type: boolean; Default: false. USE_SPIN_SYM¶. Do use symmetry to map equivalent determinants onto each other, for efficiency?. Type: boo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__psimrcc-1.html:3271,perform,perform,3271,psi4manual/1.0.0/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__psimrcc-1.html,6,['perform'],['perform']
Performance,"use they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; 1; 2set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:9504,optimiz,optimize,9504,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimize']
Performance,"uses second-order perturbation theory to correct the local-CCSD energy computed with weak pairs ignored. Type: string; Possible Values: NONE, MP2, NEGLECT; Default: NONE. LOCAL_WEAKP (CCLAMBDA)¶CCLAMBDA — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique available option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE)¶CCRESPONSE — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique available option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCK_SINGLET (PSIMRCC)¶PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI)¶DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI)¶DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI)¶DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. MADMP2_SLEEP (DFMP2)¶DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS)¶GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_ATTEMPTS (SCF)¶SCF (Expert) — When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. MAX_CCD_DIISVECS (SAPT)¶SAPT — Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MAX_DISP_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:158515,perform,performed,158515,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,8,['perform'],['performed']
Performance,"uster codes.; ; cctriples(...); cctriples() -> float :; Runs the coupled cluster (T) energy code.; ; cepa(...); cepa() -> float :; Runs the coupled electron pair approximation code; ; clean(...); clean() -> None :; Function to remove scratch files. Call between independent jobs.; ; close_outfile(...); close_outfile() -> None :; Closes the output file.; ; dcft(...); dcft() -> float :; Runs the density cumulant functional theory code.; ; deriv(...); deriv() -> int :; Runs deriv, which contracts density matrices with derivative integrals, to compute gradients.; ; detci(...); detci() -> float :; Runs the determinant-based configuration interaction code.; ; dfmp2(...); dfmp2() -> float :; Runs the DF-MP2 code.; ; dfmp2grad(...); dfmp2grad() -> float :; Runs the DF-MP2 gradient.; ; fd_1_0(...); fd_1_0( (list)arg1) -> PsiReturnType :; Performs a finite difference gradient computation, from energy points.; ; fd_freq_0(...); fd_freq_0( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from energy points, for a given irrep.; ; fd_freq_1(...); fd_freq_1( (list)arg1, (int)arg2) -> PsiReturnType :; Performs a finite difference frequency computation, from gradients, for a given irrep.; ; fd_geoms_1_0(...); fd_geoms_1_0() -> matrix_vector :; Gets the list of displacements needed for a finite difference gradient computation, from energy points.; ; fd_geoms_freq_0(...); fd_geoms_freq_0( (int)arg1) -> matrix_vector :; Gets the list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep.; ; fd_geoms_freq_1(...); fd_geoms_freq_1( (int)arg1) -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep; ; fd_geoms_hessian_0(...); fd_geoms_hessian_0() -> matrix_vector :; Gets the list of displacements needed fof a finite difference frequency computation, from energy points.; ; fd_hessian_0(...); fd_hessian_0( (list)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:105859,Perform,Performs,105859,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['Perform'],['Performs']
Performance,"uster computation. General¶. ABCD¶. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BCCD_MAXITER¶. Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__ccenergy-1.html:1240,CACHE,CACHETYPE,1240,psi4manual/1.0.0/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__ccenergy-1.html,2,['CACHE'],['CACHETYPE']
Performance,"uster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. RESTART (CCLAMBDA); CCLAMBDA — Do ?. Type: boolean; Default: false. RESTART (CCRESPONSE); CCRESPONSE — Do restart from on-disk amplitudes?. Type: boolean; Default: true. RESTART (DETCI); DETCI — Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk; the number of vectors specified by RESTART_VECS (obsolete) is collapsed down to one vector per root. Type: boolean; Default: false. RESTART_EOM_CC3 (CCEOM); CCEOM — Do ?. Type: boolean; Default: false. RESTRICTED_DOCC (DETCI); DETCI — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_DOCC (PSIMRCC); PSIMRCC — The number of doubly occupied orbitals per irrep. Type: array; Default: No Default. RESTRICTED_DOCC (TRANSQT); TRANSQT — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (DETCI); DETCI — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (TRANSQT); TRANSQT — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RFO_FOLLOW_ROOT (OPTKING); OPTKING — Do follow the initial RFO vector after the first step?. Type:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:83649,optimiz,optimized,83649,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,"ut any duplicate entries. There is no guarantee of which; duplicate entry is dropped. useful()[source]¶. Module with non-generic exceptions classes. exception FeatureNotImplemented(msg)[source]¶; Error called for functions defined but not yet implemented.; Also for functions defined that will never be implemented. exception IncompleteAtomError(msg)[source]¶; Error raised when not all variables in an atom specification; have been defined at compute time. May be a temporary situation; so message not printed but appears as traceback when error persists. exception QcdbException[source]¶; Error class for QCDB. exception ValidationError(msg)[source]¶; Error called for problems with syntax input file. Prints; error message msg to standard output stream. class Molecule(psi4molstr=None)[source]¶; Class to store python extensions to the MoleculeLibmints class.; Multiple classes allows separation of libmints and extension methods. BFS()[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. auto_fragments()[source]¶; Detects fragments in an unfragmented molecule using BFS; algorithm. Returns a new Molecule in Cartesian, fixed-geom; (no variable values), no dummy-atom format. Any non-default; charge and multiplicity assigned to first fragment. format_molecule_for_molpro()[source]¶. format_molecule_for_nwchem()[source]¶. format_molecule_for_psi4()[source]¶; Returns string of molecule definition block. format_molecule_for_qchem()[source]¶. grimme_dftd3(func=None, dashlvl=None, dashparam=None, verbosity=1)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispersion parameters in the absense of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:64082,Perform,Perform,64082,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['Perform'],['Perform']
Performance,"ut file auto-generated from the gradient() wrapper.\n\n'); fmaster.write(p4util.format_molecule_for_input(molecule)); fmaster.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""). # Load in displacement into the active molecule; psi4.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = psi4.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; psi4.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(molecule)); freagent.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:39372,Load,Load,39372,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Load'],['Load']
Performance,"ut("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:70030,optimiz,optimized,70030,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['optimiz'],['optimized']
Performance,"ut(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:67389,Optimiz,Optimizer,67389,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Optimiz'],['Optimizer']
Performance,"ut(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_act",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:69963,Optimiz,Optimizer,69963,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Optimiz'],['Optimizer']
Performance,"ut(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:62598,Optimiz,Optimizer,62598,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['Optimiz'],['Optimizer']
Performance,"utable after compilation; How to solve ModuleNotFoundError: No module named 'psi4'; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to get a Psi4 logo file; How to use a local Add-On repository in the Psi4 build; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:64365,queue,queue,64365,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,1,['queue'],['queue']
Performance,"utable after compilation; How to solve ModuleNotFoundError: No module named 'psi4'; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to get a Psi4 logo file; How to use a local Add-On repository in the Psi4 build; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_planning.html:64630,queue,queue,64630,psi4manual/1.9.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_planning.html,1,['queue'],['queue']
Performance,"ute, [1]. psi4.core.HF attribute, [1], [2]. psi4.core.RHF attribute, [1]. psi4.core.ROHF attribute, [1]. psi4.core.UHF attribute, [1]. iterations() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. IWLAndDPD psi4.core.IntegralTransform.OutputType attribute, [1]. IWLOnly psi4.core.IntegralTransform.OutputType attribute, [1]. J. J() psi4.core.JK method, [1], [2]. psi4.core.MemDFJK method, [1]. JK class in psi4.core, [1]. jk() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. JOBTYPE (CCLAMBDA). join_path() in module psi4.driver. JSCH module, [1]. K. K() psi4.core.JK method, [1], [2]. psi4.core.MemDFJK method, [1]. KEEP_INTCOS (OPTKING). keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. kinetic() psi4.core.FISAPT method, [1], [2]. kinetic_grad() psi4.core.MintsHelper method, [1], [2]. KineticInt class in psi4.core, [1]. L. L psi4.core.BoysLocalizer attribute, [1]. psi4.core.Localizer attribute, [1], [2]. psi4.core.PMLocalizer attribute, [1]. label() psi4.core.Molecule method, [1], [2]. psi4.core.MOSpace method, [1], [2]. LaplaceDenominator class in psi4.core, [1]. LCC2(+LMP2)TOTALENERGY. LCCSD. LCCSD(+LMP2)TOTALENERGY. legacy_frequencies() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. legacy_wavefunction() in module psi4.core, [1]. LEVEL_SHIFT (DFOCC). (MCSCF). (OCC). levenshtein() in module psi4.driver. LIBEFP. Libint. Libxc. LibXCFunctional class in psi4.core, [1]. license. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:83258,optimiz,optimize,83258,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['optimiz'],['optimize']
Performance,"uted are below. Input File; Description. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/testsuite-1.html:1800,optimiz,optimization,1800,psi4manual/1.3.2/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/testsuite-1.html,2,['optimiz'],['optimization']
Performance,"uthor: Lori A. Burns, Daniel G. A. Smith and Peter Kraus; Section author: Lori A. Burns and Peter Kraus; The psi4.cbs() function described below is; powerful but complicated, requiring many options. For most common; calculations, a shorthand can be accessed directly though; psi4.energy(), psi4.gradient(), etc. For example,; a MP2 single-point DT extrapolation can be accessed through the first item; below more conveniently than the equivalent second or third items. energy('mp2/cc-pv[dt]z'); energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z'); energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z""}]). A CCSD(T) DT coupled-cluster correction atop a TQ MP2 extrapolation; geometry optimization can also be accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(cbs, corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases; complete_basis_set(). Returns; (float) – Total electronic energy in Hartrees. PSI variables. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs-1.html:1036,optimiz,optimize,1036,psi4manual/1.4.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs-1.html,12,['optimiz'],['optimize']
Performance,"uthor: Lori A. Burns, Daniel G. A. Smith and Peter Kraus; Section author: Lori A. Burns and Peter Kraus; The psi4.cbs() function described below is; powerful but complicated, requiring many options. For most common; calculations, a shorthand can be accessed directly though; psi4.energy(), psi4.gradient(), etc. For example,; a MP2 single-point DT extrapolation can be accessed through the first item; below more conveniently than the equivalent second or third items. energy('mp2/cc-pv[dt]z'); energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z'); energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z""}]). A CCSD(T) DT coupled-cluster correction atop a TQ MP2 extrapolation; geometry optimization can also be accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(cbs, corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]¶; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:complete_basis_set(). Returns:(float) – Total electronic energy in Hartrees. PSI variables:. CBS TOTAL ENERGY; CBS REFERENCE ENERGY; CBS CORRELATION ENERGY; CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:1018,optimiz,optimize,1018,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,6,['optimiz'],['optimize']
Performance,"util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:68212,Optimiz,Optimize,68212,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Optimiz'],['Optimize']
Performance,"ution [E_h] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized linearized coupled cluster; doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2 level of theory. OMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2.5 level of theory. OMP2.5 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP3 level of theory. OMP3 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP3 level of theory. OREMP2 TOTAL ENERGY¶. OREMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized retaining-the-excitation-degree Møller–Plesset; hybrid perturbati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:42878,optimiz,optimized,42878,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,4,['optimiz'],['optimized']
Performance,"uto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:2619,Queue,Queue,2619,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['Queue'],['Queue']
Performance,"utput file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree-Fock (CUHF); A variant of ROHF that starts from a UHF ansatz, and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in PSI4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the set_point_group Python molecule attribute:; h.set_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3,0,1,1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Broken Symmetry¶; For certain problems, such diradicals, allowing the spin-up and spin-down orbitals to dif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:7542,perform,performance,7542,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,6,['perform'],['performance']
Performance,"utput file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree-Fock (CUHF); A variant of ROHF that starts from a UHF ansatz, and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in PSI4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the set_point_group Python molecule attribute:; h.set_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3,0,1,1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:7472,perform,performance,7472,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['perform'],['performance']
Performance,"utput file. If the; deviation is greater than a few hundredths, it is advisable to switch to an; ROHF to avoid this “spin-contamination” problem.; Restricted Open-Shell Hartree-Fock (ROHF); Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical).; Constrained Unrestricted Hartree-Fock (CUHF); A variant of ROHF that starts from a UHF ansatz, and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in Psi4, and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the set_point_group Python molecule attribute:; h.set_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3,0,1,1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Broken Symmetry¶; For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf.html:8154,perform,performance,8154,psi4manual/1.0.0/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf.html,2,['perform'],['performance']
Performance,"ux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dcft_wfn = core.dcft(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCFT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dcft_wfn = core.dcft(ref_wfn). return dcft_wfn. def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). core.set_global_option('DERTYPE', 'FIRST'); dcft_wfn = run_dcft(name, **kwargs). derivobj = core.Deriv(dcft_wfn); derivobj.set_tpdm_presorted(True); grad = derivobj.compute(). dcft_wfn.set_gradient(grad). optstash.restore(); return dcft_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val in ['DISK_DF', 'DF']:; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif type_val == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(""""""Invalid type '%s' for DFOCC"""""" ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:43835,optimiz,optimized,43835,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['optimiz'],['optimized']
Performance,"v double; Default: 1e-14. ONEPDM¶. Do compute one-particle density matrix?. Type: boolean; Default: false. ONEPDM_GRID_CUTOFF¶. Cutoff (e/A^3) for printing one-particle density matrix values on a grid. Type: double; Default: 1.0e-30. ONEPDM_GRID_DUMP¶. Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. ONEPDM_GRID_STEPSIZE¶. Stepsize (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: false. PROP_ALL¶. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. XI¶. Do compute Xi?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. AEL¶. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: SCF. XI_CONNECT¶. Do require and to be connected?. Type: boolean; Default: false. Table Of Contents. CCDENSITY; General; AO_BASIS; CACHELEVEL; GAUGE; INTS_TOLERANCE; ONEPDM; ONEPDM_GRID_CUTOFF; ONEPDM_GRID_DUMP; ONEPDM_GRID_STEPSIZE; OPDM_RELAX; PROP_ALL; PROP_ROOT; PROP_SYM; REFERENCE; ROOTS_PER_IRREP; XI; ZETA. Expert; AEL; WFN; XI_CONNECT. Previous topic; SEM_MAXITER; Next topic; AEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccdensity-1.html:2079,CACHE,CACHELEVEL,2079,psi4manual/4.0b3/autodir_options_c/module__ccdensity-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccdensity-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"v double; Default: 1e-14. ONEPDM¶. Do compute one-particle density matrix?. Type: boolean; Default: false. ONEPDM_GRID_CUTOFF¶. Cutoff (e/A^3) for printing one-particle density matrix values on a grid. Type: double; Default: 1.0e-30. ONEPDM_GRID_DUMP¶. Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. ONEPDM_GRID_STEPSIZE¶. Stepsize (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: false. PROP_ALL¶. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. XI¶. Do compute Xi?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. AEL¶. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: SCF. XI_CONNECT¶. Do require and to be connected?. Type: boolean; Default: false. Table Of Contents. CCDENSITY; General; AO_BASIS; CACHELEVEL; GAUGE; INTS_TOLERANCE; ONEPDM; ONEPDM_GRID_CUTOFF; ONEPDM_GRID_DUMP; ONEPDM_GRID_STEPSIZE; OPDM_RELAX; PROP_ALL; PROP_ROOT; PROP_SYM; REFERENCE; ROOTS_PER_IRREP; XI; ZETA. Expert; AEL; WFN; XI_CONNECT. Previous topic; SEM_MAXITER; Next topic; AEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccdensity-1.html:2079,CACHE,CACHELEVEL,2079,psi4manual/4.0b4/autodir_options_c/module__ccdensity-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccdensity-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"v double; Default: 1e-14. ONEPDM¶. Do compute one-particle density matrix?. Type: boolean; Default: false. ONEPDM_GRID_CUTOFF¶. Cutoff (e/A^3) for printing one-particle density matrix values on a grid. Type: double; Default: 1.0e-30. ONEPDM_GRID_DUMP¶. Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. ONEPDM_GRID_STEPSIZE¶. Stepsize (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: false. PROP_ALL¶. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. XI¶. Do compute Xi?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. AEL¶. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: SCF. XI_CONNECT¶. Do require and to be connected?. Type: boolean; Default: false. Table Of Contents. CCDENSITY; General; AO_BASIS; CACHELEVEL; GAUGE; INTS_TOLERANCE; ONEPDM; ONEPDM_GRID_CUTOFF; ONEPDM_GRID_DUMP; ONEPDM_GRID_STEPSIZE; OPDM_RELAX; PROP_ALL; PROP_ROOT; PROP_SYM; REFERENCE; ROOTS_PER_IRREP; XI; ZETA. Expert; AEL; WFN; XI_CONNECT. Previous topic; SEM_MAXITER; Next topic; AEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccdensity-1.html:2079,CACHE,CACHELEVEL,2079,psi4manual/4.0b5/autodir_options_c/module__ccdensity-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccdensity-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"vailable memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; \(10^{-3}\) by one or two orders of magnitude (e.g. \(10^{-2}\) or; \(10^{-1}\)). This can be particularly useful for computations using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a choice of performing the computation of the guess orbitals and cumulants; using the corresponding DC method (set ODC_GUESS to TRUE). This can often lead to; significant computational savings, since the orbital update step in the DC methods is cheap.; Convergence of the guess orbitals and cumulants can be controlled using the; GUESS_R_CONVERGENCE option. table of contents. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; DCT: Density Cumulant Theory. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/dct.html:15375,perform,performing,15375,psi4manual/1.6.x/dct.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/dct.html,1,['perform'],['performing']
Performance,"val = PsiMod.get_global_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""PsiMod.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""PsiMod.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed.' % (chgdopt)); return commands. [docs]def format_kwargs_for_input(filename, lmode=1, **kwargs):; """"""Function to pickle to file *filename* the options dictionary; *kwargs*. Mode *lmode* =2 pickles appropriate settings for; reap mode. Used to capture Python options information for; distributed (sow/reap) input files. """"""; if lmode == 2:; kwargs['mode'] = 'reap'; kwargs['linkage'] = os.getpid(); filename.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, filename); filename.write('''"""""")\n'''); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*.; ; """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not.; ; """"""; array = None; for per in list(all",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/procutil.html:3925,load,loads,3925,psi4manual/4.0b3/_modules/procutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/procutil.html,2,['load'],['loads']
Performance,"value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (OMP3); OMP3 — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (MP2); MP2 — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the ina",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:10383,CACHE,CACHELEVEL,10383,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water. PSIthonPsiAPImolecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). h2o = psi4.geometry(""""""; O; H 1 R; H 1 R 2 A; """"""). Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). psi4.set_options({""basis"": ""cc-pvdz"",; ""e_convergence"": 11}); for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; psi4.energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The Psithon function psi4.driver.p4util.Table has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below. PSIthonPsiAPImolecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(100, 103, 2). rows = []; table = []. set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:13945,perform,performed,13945,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['perform'],['performed']
Performance,"variable. del_scalar_variable(self, arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from cls if present. density_fitted(self); Returns whether this wavefunction was obtained using density fitting or not. diis(self, arg0); docstring. doccpi(self); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self, basis, subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self, basis, subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. force_doccpi(self, arg0); Specialized expert use only. force_soccpi(self, arg0); Specialized expert use only. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self, arg0, arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. frequencies(). from_file(wfn_data); Build Wavefunction from data. frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:4760,Perform,Performs,4760,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,5,['Perform'],['Performs']
Performance,variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; AtomicComputer; banner; basis_helper; cbs; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; libint2_configuration; libint2_print_out; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energies_from_fcidump; expand_psivars; fcidump; fcidump_from_file; find_approximate_string_matches; format_molecule_for_input; format_options_for_input; free_atom_volumes; Gaussian; get_memory; get_psifile; getattr_ignorecase; hamiltonian_solver; hold_options_state; import_ignorecase; InPsight; kwargs_lower; levenshtein; libint2_configuration; libint2_print_out; Lineshape; Lorentzian; mat2arr; message_box; oeprop; OptionsState; OptionsStateCM; OptionState; pcm_helper; plump_qcvar; prefactor_ecd; prefactor_opa; prepare_options_for_modules; prepare_options_for_set_options; provenance_stamp; sanitize_method; set_memory; set_module_options; set_options; SolverEngine; spectrum; state_to_atomicinput; ParsingError; P,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1738015,optimiz,optimize,1738015,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,3,['optimiz'],['optimize']
Performance,variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; test_matrix_dpd_interface; ThreeCenterOverlapInt; timer_off; timer_on; TLaplaceDenominator; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; AtomicComputer; banner; basis_helper; cbs; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; cubeprop; docs_table_link; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fcidump; fcidump_from_file; find_approximate_string_matches; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; levenshtein; libint2_configuration; libint2_print_out; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; all_casings; array_to_matrix; banner; basis_helper; block_diagonal_array; cg_solver; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; copy_file_from_scratch; copy_file_to_scratch; cubeprop; davidson_solver; DIIS; docs_table_link; drop_duplicates; energies_from_fcidump; expand_psivars; fcidump; fcidump_from_file; find_approximate_string_matches; format_molecule_for_input; format_options_for_input; free_atom_volumes; Gaussian; get_memory; get_psifile; getattr_ignorecase; hamiltonian_solver; hold_options_state; import_ignorecase; InPsight; kwargs_lower; levenshtein; libint2_configuration; libint2_print_out; Lineshape; Lorentzian; mat2arr; message_box; oeprop; OptionsState; OptionsStateCM; OptionState; pcm_helper; plump_qcvar; prefactor_ecd; prefactor_opa; prepare_options_for_modules; prepare_options_for_set_options; provenance_stamp; sanitize_method; set_memory; set_module_options; set_options; SolverEngine; spectrum; state_to_atomicinput; temp_circular_i,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:823494,optimiz,optimize,823494,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['optimiz'],['optimize']
Performance,"vdz Energy. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dcft1; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. Previous topic; Test Suite and Sample Inputs; Next topic; Basis Sets by Element; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Test Suite and Sample Inputs ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 07, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:23208,perform,performs,23208,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,2,['perform'],['performs']
Performance,"ve quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Important User Changes from cpp-optking¶. FIXED_COORD keywords have been generalized to RANGED_COORD e.g. RANGED_DISTANCE; Detailed optimization is now printed through the python logging system. If more information about; the optimization is needed. Please see <output_name>.log. table of contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY. Optimizing Minima; Hessian; Transition States and Reaction Paths; Constrained Optimizations; Multi-Fragment Optimizations; Dealing with problematic optimizations; Convergence Criteria; Interface to GeomeTRIC; Output; Important User Changes from cpp-optking. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:24864,optimiz,optimizations,24864,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,10,"['Optimiz', 'optimiz']","['Optimization', 'Optimizations', 'Optimizing', 'optimization', 'optimizations', 'optimize']"
Performance,"ve_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2356,perform,performed,2356,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,1,['perform'],['performed']
Performance,"ve_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to the driver code; self.comm = MDI_Accept_Communicator(). # Ensure that the molecule is usi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html:2354,perform,performed,2354,psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,1,['perform'],['performed']
Performance,"vel for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:9191,cache,cache,9191,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['cache'],['cache']
Performance,"vel for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE)¶CCRESPONSE — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT)¶CCTRANSORT — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCT)¶DCT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC)¶OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY)¶CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM)¶CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CALC_S_SQUARED (DETCI)¶DETCI — Do calculate the value of \(\langle S^2\rangle\) f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:10636,cache,cache,10636,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,18,['cache'],['cache']
Performance,"vel of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CPHF); CPHF — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (CPHF); CPHF — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:10217,cache,cache,10217,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"vel of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (OMP3); OMP3 — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:9771,cache,cache,9771,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"vel of theory. MP4(SDQ) TOTAL ENERGY¶. MP4(SDQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the MP4 singles, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2). MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EX",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html:13200,optimiz,optimized,13200,psi4manual/4.0b4/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html,6,['optimiz'],['optimized']
Performance,"ventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285],; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside; Psi4’s separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction; algorithm when specifying SCF_TYPE to use a composite algorithm combination (DFDIRJ+K_alg).; DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI; screening (set SCREENING to DENSITY) and incremental Fock matrix construction (set INCFOCK to TRUE). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. COSX Exchange¶; The semi-numerical COSX algorithm described in [Neese:2009:98] evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in DFT: Density Functional Theory.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; The SCF algorithm is first converged on a smaller grid, followed by a final SCF; iteration on a larger grid. This results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. The size ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:35367,perform,performance,35367,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,1,['perform'],['performance']
Performance,"ver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Adding New Code to PSI4. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/plugins-1.html:8163,load,loaded,8163,psi4manual/1.3.2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/plugins-1.html,6,['load'],"['loaded', 'loading']"
Performance,"veral fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:8186,perform,perform,8186,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['perform'],['perform']
Performance,"vered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while White or Queue: # Iterates to the next fragment; Fragment.append([]). while Queue: # BFS within a fragment; for u in Queue: # find all white neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt(; (self.x(i) - self.x(u)) ** 2 +; (self.y(i) - self.y(u)) ** 2 +; (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + \; vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # & remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if White: # can't move White -> Queue if empty; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the psi4.Molecule class. """"""; cls.__setattr__ = new_set_attr; cls.__getattr__ = new_get_attr; cls.BFS = BFS. dynamic_variable_bind(psi4.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name*; from the geometry in string *geom*. Permitted for user use but deprecated in; driver in favor of explicit molecule-passing. """"""; molecule = psi4.Molecule.create_molecule_from_string(geom); molecule.set_name(name). activate(molecule). return molecule. [docs]def activate(mol):; """"""Function to set molecule object *mol* as the current active molecule.; Permitted for user use",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html:6879,Queue,Queue,6879,psi4manual/1.0.0/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html,2,['Queue'],['Queue']
Performance,"vergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10--------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). table of contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Output. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/optking-1.html:15561,optimiz,optimizations,15561,psi4manual/1.3.2/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/optking-1.html,12,"['Optimiz', 'optimiz']","['Optimization', 'Optimizations', 'Optimizing', 'optimizations', 'optimize']"
Performance,"very 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:6797,optimiz,optimize,6797,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimize']
Performance,"very 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2; freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3; freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4; set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optkin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:6809,optimiz,optimize,6809,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['optimiz'],['optimize']
Performance,"vided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmetrize cannot be called while cartesian constraints are active ""; ""symmetrize was about to be called. Please check symmetry dependent input ""; "", such as DOCC, is correct or turn off symmetry""). # Try to resymmetrize molecule if slightly broken.; molecule.symmetrize(core.get_option(""OPTKING"", ""CARTESIAN_SYM_TOLERAN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:71830,optimiz,optimization,71830,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimization']
Performance,"vidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 12. NUM_ROOTS¶. number of CI roots to find. Type: integer; Default: 1. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. DIAG_METHOD¶. This specifies which method is to be used in diagonalizing the Hamiltonian. The valid options are: RSP, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); OLSEN, to use Olsen’s preconditioned inverse subspace method (1990); MITRUSHENKOV, to use a 2x2 Olsen/Davidson method; and DAVIDSON (or SEM) to use Liu’s Simultaneous Expansion Method, which is identical to the Davidson method if only one root is to be found. There also exists a SEM debugging mode, SEMTEST. The SEM method is the most robust, but it also requires CI vectors on disk, where is the maximum number of iterations and is the number of roots. Type: string; Possib",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/detci-1.html:6289,perform,perform,6289,psi4manual/4.0b3/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/detci-1.html,4,['perform'],['perform']
Performance,"vigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.frequency.html:1062,perform,performed,1062,psi4manual/master/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.frequency.html,1,['perform'],['performed']
Performance,"viron.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets above in the input file itself. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed. Executing PSI4 with the psi4 -m (for; messy) flag will prevent files being deleted at the end of the run:; psi4 -m. Alternately, the scratch directory can be set through the environment; variable PSI_SCRATCH (overrides ~/.psi4rc settings). (First line; for C shell; second line for bash.); setenv PSI_SCRATCH /scratch/user; export PSI_SCRATCH=/scratch/user. The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using OpenMP alone is a really; bad idea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:4316,load,loaded,4316,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['load'],['loaded']
Performance,"virtual integrals are handled in the AO Basis, using integrals stored on disk. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. fnocc2; Test G2 method for H2O. dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. scf-cholesky-basis; incremental Cholesky filtered SCF. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. cc51; EOM-CC3/cc-pVTZ on H2O. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. opt11; Transition-state optimizations of HOOH to both torsional transition states. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. scf-occ; force occupations in scf. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. scf6; Tests RHF/ROHF/UHF SCF gradients. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. linK-3; UHF and ROHF Linear Exchange Algorithm t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:38514,perform,performed,38514,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"vity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file named “intco.dat”. See the Optimizing Minima; section for more detail. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:2192,Optimiz,Optimizations,2192,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,2,['Optimiz'],['Optimizations']
Performance,"volved. CDA threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. PSI4 also features the capability to use “composite” Fock matrix build; algorithms - arbitrary combinations of specialized algorithms that construct; either the Coulomb or the Exchange matrix separately. In general, since; separate Coulomb and Exchange matrix build algorithms exploit properties specific to; their respective matrix, composite algorithms display lower; scaling factors than their combined Fock build counterparts. However, composite algorithms also; introduce redundant ERI computations into the calculation. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting SCF_TYPE to J_alg+K_alg,; where J_alg and K_alg are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively. Alternatively, if one is using; DFT with non-hybrid functionals, a composite Coulomb construction algorithm can be; specified solo by setting SCF_TYPE to J_alg, without the need to set; an associated K_alg.; Specialized algorithms available to construct the Coulomb term within a composite framework; are as follows:. DFDIRJAn integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays; strong performance with large system size through a combination of; effective parallelization and utilization of density-fitting to minimize; ERI computational cost. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:28351,perform,perform,28351,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,2,['perform'],['perform']
Performance,"volved. CDA threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. PSI4 also features the capability to use “composite” Fock matrix build; algorithms - arbitrary combinations of specialized algorithms that construct; either the Coulomb or the Exchange matrix separately. In general, since; separate Coulomb and Exchange matrix build algorithms exploit properties specific to; their respective matrix, composite algorithms display lower; scaling factors than their combined Fock build counterparts. However, composite algorithms also; introduce redundant ERI computations into the calculation. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting SCF_TYPE to J_alg+K_alg,; where J_alg and K_alg are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively.; Specialized algorithms available to construct the Coulomb term within a composite framework; are as follows:. DFDIRJAn integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays; strong performance with large system size through a combination of; effective parallelization and utilization of density-fitting to minimize; ERI computational cost. See the Integral-Direct Density-Fitted Coulomb Construction section for more information. Specialized algorithms available to construct the Exchange term within a composite framework; are as follows:. COSXAn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:28104,perform,perform,28104,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,1,['perform'],['perform']
Performance,"vorite linear acene dimers.; Geometries from nowhere special, and reference energies undefined. cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'FIRST3' benzene, napthalene, and anthracene dimers; 'FIRST5' benzene - pentacene dimers; 'FIRST10' benzene - decacene dimers. NCB31¶. Database (Truhlar) of several classes of noncovalent interactions.; Geometries from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; Reference energies from Truhlar and coworkers at site http://comp.chem.umn.edu/database_noncov/noncovalent.htm; First comprehensive citation JPCA 109 5656 (2005). cp 'off' || 'on'; rlxd 'off' || 'on'; benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' 3: HF-HF, He-Ne, HCCH-HCCH; 'large' 1: BzBz_PD; 'HB6' hydrogen-bonded; 'CT7' charge-transfer; 'DI6' dipole-interacting; 'WI7' weakly interacting; 'PPS5' pi-pi stacking. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. S22by5¶. Database (Hobza) of interaction energies for dissociation curves of bimolecular complexes.; Geometries and reference interaction energies from Grafova et al. JCTC 6 2365 (2010).; Note that the S22by5-N-1.0 members are essentially the same geometries as S22-N (there’s trivial round-off error) but the reference interaction energies for S22by5 are of lower quality than those of S22. cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'equilibrium'; 'mol1' five-point (0.9, 1.0, 1.2, 1.5, 2.0) \(\times R_{eq}\) dissociation curve for molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_available_databases.html:8189,optimiz,optimize,8189,psi4manual/master/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_available_databases.html,2,['optimiz'],['optimize']
Performance,"w “mixed” excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MO_DIIS_NUM_VECS (DFOCC)¶DFOCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER (DFOCC)¶DFOCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_MAXITER (OCC)¶OCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF)¶MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OCC)¶OCC — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX (DFOCC)¶DFOCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_STEP_MAX (OCC)¶OCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OCC)¶OCC — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODULE (CPHF)¶CPHF — What app to test?. Type: string; Possible Values: RCPHF; Default: RCPHF. MOGRAD_DAMPING (OCC)¶OCC — Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MOLDEN_WITH_VIRTUAL (GLOBALS)¶GLOBALS — Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MOLDEN_WRITE (DFOCC)¶DFOCC — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MOLDEN_WRITE (SCF)¶SCF — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:169902,optimiz,optimization,169902,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['optimiz'],['optimization']
Performance,"w; examples that work on the PSI4 developers’ systems:. Linux with ATLAS:; --with-blas='-lf77blas -latlas' --with-lapack='-llapack -lcblas'. Mac OS X with vecLib:; --with-blas='-altivec -framework vecLib' --with-lapack=' '. Linux with MKL 8.1 and icc/icpc/ifort 9.1:; --with-libdirs=-L/usr/local/opt/intel/mkl/8.0.2/lib/32 --with-blas=-lmkl --with-lapack=-lmkl_lapack32. Linux on ia32 with MKL 10.1 and icc/icpc 11.0:; --with-blas='-Wl,--start-group -L/usr/local/opt/intel/mkl/10.1.0.015/lib/32 -l mkl -Wl,--end-group -lguide -lpthread'. Compilation notes for ATLAS; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full ATLAS installation notes.; You’ll need a Fortran compiler installed.; Unpack the source code, then make a compilation directory (could; be an obj subdirectory in the source directory, or elsewhere).; Turn off CPU throttling so the auto-tuning capabilities have a chance; to work. On Linux, this can be tune using; /usr/bin/cpufreq-selector -g performance. cd into the compilation directory and run the source; directory configure script there, with any necessary flags, e.g.,; /usr/local/src/atlas/configure --prefix=/usr/local/atlas. where prefix gives the installation directory.; It should automatically detect if you’re on an x86_64; Then make and check using; make; make check; make ptcheck. And install; make install. Compilation notes for netlib’s LAPACK; These shortcut notes might be helpful if you are using Linux. However,; we recommend reading and following the full LAPACK installation notes.; You’ll need a Fortran compiler installed.; If you decide to compile LAPACK from source, it may be obtained from; http://www.netlib.org/lapack/. Unpack the source code, and in the; top-level source directory, you need to create a make.inc file with; the appropriate options for your machine. For Linux/gfortran,; simply; cp make.inc.example make.inc. Next, edit BLASLIB in make.inc to point to your BLAS library",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:24401,tune,tune,24401,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,6,"['perform', 'tune']","['performance', 'tune']"
Performance,"w_wavefunction(N5boost10shared_ptrIN3psi8MoleculeEEE,Ss). psi4.nthread()¶; Python Library Documentation: built-in function nthread in module psi4; nthread(...). nthread() -> int :. Returns the number of threads to use in SMP parallel computations.; C++ signature :. i nthread(). psi4.nuclear_dipole()¶; Python Library Documentation: built-in function nuclear_dipole in module psi4; nuclear_dipole(...). nuclear_dipole( (Molecule)arg1) -> Vector :. docstring; C++ signature :. N5boost10shared_ptrIN3psi6VectorEEE nuclear_dipole(N5boost10shared_ptrIN3psi8MoleculeEEE). psi4.occ()¶; Python Library Documentation: built-in function occ in module psi4; occ(...). occ( (Wavefunction)arg1) -> Wavefunction :. Runs the orbital optimized CC codes.; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE occ(N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.opt_clean()¶; Python Library Documentation: built-in function opt_clean in module psi4; opt_clean(...). opt_clean() -> None :. Cleans up the optimizer’s scratch files.; C++ signature :. void opt_clean(). psi4.optking()¶; Python Library Documentation: built-in function optking in module psi4; optking(...). optking() -> int :. Runs the geometry optimization / frequency analysis code.; C++ signature :. i optking(). psi4.outfile_name()¶; Python Library Documentation: built-in function outfile_name in module psi4; outfile_name(...). outfile_name() -> str :. Returns the name of the output file.; C++ signature :. Ss outfile_name(). psi4.plugin()¶; Python Library Documentation: built-in function plugin in module psi4; plugin(...). plugin( (str)arg1, (Wavefunction)arg2) -> Wavefunction :. docstring; C++ signature :. N5boost10shared_ptrIN3psi12WavefunctionEEE plugin(Ss,N5boost10shared_ptrIN3psi12WavefunctionEEE). psi4.plugin_close()¶; Python Library Documentation: built-in function plugin_close in module psi4; plugin_close(...). plugin_close( (str)arg1) -> None :. docstring; C++ signature :. void plugin_close(Ss). psi4.plugin_close_all()¶;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:35029,optimiz,optimizer,35029,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['optimiz'],['optimizer']
Performance,"ware Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import re; import os; import math; import warnings; import psi4; import p4util; from driver import *; from wrappers import *; #from extend_Molecule import *; from molutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrill_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; name = 'mp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html:1856,perform,performed,1856,psi4manual/4.0b5/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/aliases.html,1,['perform'],['performed']
Performance,"wargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn: core.Wavefunction, hess: np.ndarray = None, irrep: Union[int, str] = None, molecule=None, project_trans: bool = True, project_rot: bool = True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:80028,perform,perform,80028,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,"wargs)¶; Function to compute various properties. Aliases; prop(). Returns; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (Lis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.prop-1.html:1109,optimiz,optimized,1109,psi4manual/1.4.0/api/psi4.driver.prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.prop-1.html,5,['optimiz'],['optimized']
Performance,"wargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc. func = None; if reference == 'R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:13944,perform,performance,13944,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,6,['perform'],['performance']
Performance,"wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:50222,optimiz,optimized,50222,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimized']
Performance,"wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = { 'energy' : step_energies ,; 'gradient' : step_gradients ,; 'coordinates' : step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if opt_mode == 'reap':; kwargs['opt_datafile'] = p4util.get_psifile(1); kwargs['mode'] = 'sow'. n += 1. if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(). optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:65697,Optimiz,OptimizationConvergenceError,65697,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,2,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimization']"
Performance,"wb88_x_functional() (in module functional). build_wb88_x_superfunctional() (in module functional). build_wb97_superfunctional() (in module functional). build_wb97x_superfunctional() (in module functional). build_wb97xd_superfunctional() (in module functional). build_wblyp_superfunctional() (in module functional). build_wpbe0_superfunctional() (in module functional). build_wpbe_superfunctional() (in module functional). build_wpbe_x_functional() (in module functional). build_wpbe_x_superfunctional() (in module functional). build_wpbesol0_superfunctional() (in module functional). build_wpbesol_superfunctional() (in module functional). build_wpbesol_x_functional() (in module functional). build_wpbesol_x_superfunctional() (in module functional). build_ws_x_functional() (in module functional). build_ws_x_superfunctional() (in module functional). build_wsvwn_superfunctional() (in module functional). C. C-side; . setting keywords. CACHELEV (PLUGIN_MP2), [1]. (PLUGIN_TEST_MATRIX), [1]. CACHELEVEL (ADC). (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCSORT). (DCFT). (MP2). (OMP2). (STABILITY). (TRANSQT2). CACHETYPE (CCENERGY). (CCEOM). (MP2). call_function_in_1st_argument() (in module wrappers). CANONICALIZE_ACTIVE_FAVG (MCSCF). CANONICALIZE_INACTIVE_FAVG (MCSCF). CART_HESS_READ (OPTKING). CAS_FILES_WRITE (CLAG). cbs(); . extrapolation schemes. output. setting keywords. theory, [1]. CBSCORRELATIONENERGY. CBSREFERENCEENERGY. CBSTOTALENERGY. CC; . theory. CC (DETCI). CC, coupled cluster. CC2CORRELATIONENERGY. CC2TOTALENERGY. CC3_FOLLOW_ROOT (CCEOM). CC3CORRELATIONENERGY. CC3TOTALENERGY. CC_A_RAS3_MAX (DETCI). CC_B_RAS3_MAX (DETCI). CC_EX_LEVEL (DETCI). CC_FIX_EXTERNAL (DETCI). CC_FIX_EXTERNAL_MIN (DETCI). CC_MACRO (DETCI). CC_MAXITER (OMP2). CC_MIXED (DETCI). CC_NUM_THREADS (CCENERGY). (CCEOM). (CCTRIPLES). (PSIMRCC). CC_OS_SCALE (CCENERGY). CC_RAS34_MAX (DETCI). CC_RAS3_MAX (DETCI). CC_RAS4_MAX (DETCI). CC_SS_SCALE (CCENERGY). CC_UPDATE_EPS (DETCI). CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/genindex.html:5291,CACHE,CACHELEVEL,5291,psi4manual/4.0b2/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/genindex.html,1,['CACHE'],['CACHELEVEL']
Performance,"weak pairs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__ccresponse-1.html:3771,CACHE,CACHELEVEL,3771,psi4manual/1.2.1/autodir_options_c/module__ccresponse-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__ccresponse-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"wed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD¶. Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. CFOUR_GIAO¶. Specifies whether gauge-including atomic orbitals are used (ON) or not (OFF). Default: ON for CFOUR_PROPS =NMR and =MAGNETIC, otherwise OFF. Type: string; Possible Values: ON, OFF; Default: No Default. CFOUR_GRID¶. Keyword used to control type of grid calculation (see later section in this manual). Options are OFF (=0), no grid calculation; CARTESIAN (=1), steps are in Cartesian coordinates (which must be run with CFOUR_COORDINATES =CARTESIAN); INTERNAL (=2), steps are in Z-matrix internal coordinates; QUADRATURE (=3) steps are chosen for an integration based on Gauss-Hermite quadrature. (Default: OFF). Type: string; Possible Values: OFF, CARTESIAN, INTERNAL, QUADRATURE; Default: OFF. CFOUR_GUESS¶. Where the initial SCF eigenvectors are read from. MOREAD mea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:31351,optimiz,optimization,31351,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,17,['optimiz'],['optimization']
Performance,"wer(). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'). ri = core.get_option('SCF', 'SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.get_variable('MP2 CORRELATION ENERGY'). if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.get_variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs). # Delta MP2; if do_delta_mp2:; select_mp2(name, ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.get_variable('MP2 CORRELATION ENERGY'); core.set_variable('SAPT MP2 CORRELATION ENERGY', mp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:95658,LOAD,LOAD,95658,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['LOAD'],['LOAD']
Performance,"wfn = procedures['energy'][lowername](lowername, molecule=molecule, **kwargs). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). optstash.restore(); if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg', 'psimrcc']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; kwargs = p4util.kwargs_lower(kwargs). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']:; gradient_type = 'cbs_wrapper'; else:; # Bounce to name if name is non-CBS function; gradient_type = 'custom_function'; elif kwargs.get('bsse_type', None) is not None:; gradient_type = 'nbody_gufunc'; elif '/' in name:; gradient_type = 'cbs_gufunc'; else:; gradient_type = '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:36333,optimiz,optimize,36333,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in core.OEProp.valid_methods or ""MULTIPOLE("" in prop:; oe.add(prop); oe.compute(); dct_wfn.oeprop = oe. for k, v in dct_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC. Se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:62111,optimiz,optimized,62111,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['optimiz'],['optimized']
Performance,"wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in core.OEProp.valid_methods or ""MULTIPOLE("" in prop:; oe.add(prop); oe.compute(); dct_wfn.oeprop = oe. for k, v in dct_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC""""""). if name in ['mp2', 'omp2']:; core.set_local",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:56020,optimiz,optimized,56020,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimized']
Performance,"wfn specified. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:1973,optimiz,optimization,1973,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,4,['optimiz'],['optimization']
Performance,"wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:49155,optimiz,optimization,49155,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,2,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: false. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. HESS_TYPE¶. Type Hessian matrix will be used in orbital optimization procedure. Type: string; Possible Values: NONE; Default: NONE. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html:1337,perform,perform,1337,psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,2,['perform'],['perform']
Performance,"width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'),; textables.graphics, {}],; ['d', 'NBC10', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'NBC1'}],; ['d', 'HBC6', r""""""TT\footnotemark[2] """""", textables.val, {'sset': 'tt-5min', 'dbse': 'HBC1'}],; ['d', 'Avg', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'DB4'}]]. footnotes = [fnreservoir['blankslat'], fnreservoir['5min']]; landscape = True; theme = 'lgmerge'; title = r""""""Interaction energy [kcal/mol] {{err}} subset statistics with computed with {{opt}}{0}."""""".format(; '' if subjoin else r"""""" and {bas}""""""); return rowplan, columnplan, landscape, footnotes, title, theme. [docs]class DB4(Database):; def __init__(self, pythonpath=None, loadfrompickle=False, path=None):; """"""Initialize FourDatabases object from SuperDatabase""""""; Database.__init__(self, ['s22', 'nbc10', 'hbc6', 'hsg'], dbse='DB4',; pythonpath=pythonpath, loadfrompickle=loadfrompickle, path=path). # # load up data and definitions; # self.load_qcdata_byproject('dft'); # self.load_qcdata_byproject('pt2'); # #self.load_qcdata_byproject('dhdft'); # self.load_subsets(); self.define_supersubsets(); self.define_supermodelchems(). [docs] def define_supersubsets(self):; """""". """"""; self.sset['tt'] = ['default', 'default', 'default', 'default']; self.sset['hb'] = ['hb', None, 'default', 'hb']; self.sset['mx'] = ['mx', 'mx', None, 'mx']; self.sset['dd'] = ['dd', 'dd', None, 'dd']; self.sset['mxdd'] = ['mxdd', 'default', None, 'mxdd']; self.sset['pp'] = ['mxddpp', 'mxddpp', None, None]; self.sset['np'] = ['mxddnp', 'mxddnp', None, 'mxdd']; self.sset['tt-5min'] = ['default', '5min', '5min', 'default']; self.sset['hb-5min'] = ['hb', None, '5min', 'hb']; self.sset['mx-5min'] = ['mx', 'mx-5min', None, 'mx']; self.sset['dd-5min'] = ['dd', 'dd-5min', None, 'dd']; self.sset['mxdd-5min'] = ['mxdd', '5min', None, 'mxdd']; self.sset['pp-5min'] = ['mxddpp', 'mxddpp-5min', None, None]; self.sset['np-5min'] = ['mxddnp', 'mxd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:106323,load,load,106323,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['load']
Performance,"will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psimrcc.html:4029,perform,performing,4029,psi4manual/master/psimrcc.html,https://psicode.org,https://psicode.org/psi4manual/master/psimrcc.html,4,['perform'],['performing']
Performance,with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA) w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA) w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA) w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA) w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Fu,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:3470,optimiz,optimized,3470,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['optimiz'],['optimized']
Performance,"with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:3612,optimiz,optimized,3612,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,4,['optimiz'],['optimized']
Performance,"with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:3342,optimiz,optimized,3342,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,2,['optimiz'],['optimized']
Performance,with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj;  . b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj;  . b3lyp-d3mbj;  . b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exchange-Correlation Functional. b3p86-d3bj;  . b3pw91; B3PW91 Hyb-GGA Exchange-Correlation Functional. b3pw91-d3bj;  . b3pw,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:3199,optimiz,optimized,3199,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,8,['optimiz'],['optimized']
Performance,with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d;  . b3lyp-d3;  . b3lyp-d3bj;  . b3lyp-d3m;  . b3lyp-d3mbj;  . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d;  . b97-d3;  . b97-d3bj;  . b97-d3m;  . b97-d3mbj;  . blyp; BLYP GGA ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:2966,optimiz,optimized,2966,psi4manual/1.1.0/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html,2,['optimiz'],['optimized']
Performance,"with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. docs_dft; This test is used to construct the documentation; it is not suitable for emulation by users. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf3; are specified explicitly. cc52; CCSD Response for H2O2. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. docs_psimod; This test is used to construct the documentation; it is not suitable for emulation by users. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dfmp2_1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. cc8b; ROHF-CCSD cc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:9063,perform,performed,9063,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['perform'],['performed']
Performance,"with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. sapt-ecp; sapt0 of charged system in ECP basis set. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dft1; DFT Functional Test. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-cbs1; Various basis set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:12107,perform,performs,12107,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(ssmod, func)):; self.add_Subset(getattr(ssmod, func).__doc__, getattr(ssmod, func)). print(""""""WrappedDatabase %s: Defined subsets loaded"""""" % (self.dbse)). [docs] def get_pec_weightinfo(self):; """""". """"""; def closest(u, options):; return max(options, key=lambda v: len(os.path.commonprefix([u, v]))). dbdat = {}; oss = self.oss['default']; eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; for rxnix, rxn in enumerate(oss.h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:42464,Load,Loads,42464,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['Load'],['Loads']
Performance,"with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. isapt-charged; This test case shows an example of running the I-SAPT0/aug-cc-pVDZ computation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algorithm is used. The system is taken from http://dx.doi.org/10.1016/j.comptc.2014.02.008. fnocc7; Test fnocc with linear dependencies. fnocc6; Test method/basis with disk_df. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. sapt-ecp; sapt0 of charged system in ECP basis set. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. oremp-grad2; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. single point energies were independently checked using the original wavels code. oremp-grad1; integral conventional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). phi-ao; Test computing values of basis functions (puream and non-puream) at points. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. tu4-h2o-freq; Optimization followed by frequen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:39757,perform,performs,39757,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). # power user returns; E, wfn = psi4.energy(..., return_wfn=True); E, wfn = psi4.optimize(..., return_wfn=True); E, wfn = psi4.frequency(..., return_wfn=True); G, wfn = psi4.gradient(..., return_wfn=True) # used by optimize(); H, wfn = psi4.hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print(wfn.gradient().rms()). # format output for other programs; psi4.molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:. PSIthonPsiAPIbasis_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:11255,optimiz,optimize,11255,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['optimiz'],['optimize']
Performance,"without screening!. casscf-fzc-sp; CASSCF/6-31G** energy point. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. fci-h2o-2; 6-31G H2O Test FCI Energy Point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fnocc7; Test fnocc with linear dependencies. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:10005,optimiz,optimization,10005,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"wly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds¶; SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49 SAPT Results; --------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sapt-1.html:27608,perform,performed,27608,psi4manual/1.2.1/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sapt-1.html,4,['perform'],['performed']
Performance,"wn above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; SAPT Results; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:19509,perform,performed,19509,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['performed']
Performance,"wn above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as; energy('sapt2',sapt_basis='monomer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; SAPT Results; --------------------------------------------------------------------------; Electrostatics -13.06429805 mH -8.19797114 kcal mol^-1; Elst10,r -13.37543274 mH -8.39321111 kcal mol^-1; Elst12,r 0.04490253 mH 0.02817676 kcal mol^-1; Elst13,r 0.26623216 mH 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:14100,perform,performed,14100,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['perform'],['performed']
Performance,"wo; dashes between nonbonded fragments. For example, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions (that have been exp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:15305,perform,perform,15305,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,6,['perform'],['perform']
Performance,"word CFOUR_MEM_UNIT. Default: 100 000 000 (approximately 381 or 762 MB for 32 or 64 bit machines, respectively). Psi4 Interface: Keyword set in MB from memory input command when given. Type: integer; Default: 100000000. CFOUR_METHOD (CFOUR); CFOUR — Specifies the geometry optimization strategy. Four values are permitted: NR (=0) – Straightforward Newton-Raphson search for minimum; RFA (=1) – Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. CFOUR_MRCC (CFOUR); CFOUR — Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY (CFOUR); CFOUR — Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING (CFOUR); CFOUR — Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested vi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:56191,optimiz,optimizations,56191,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,16,['optimiz'],"['optimizations', 'optimizer']"
Performance,"word must match the database python file. Examples :. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/db-1.html:6073,perform,performed,6073,psi4manual/4.0b3/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/db-1.html,2,['perform'],['performed']
Performance,"words. theory. OMP2 CORRELATION ENERGY. OMP2 DOUBLES ENERGY. OMP2 TOTAL ENERGY. OMP2.5. ; setting keywords. OMP2.5 CORRELATION ENERGY. OMP2.5 DOUBLES ENERGY. OMP2.5 TOTAL ENERGY. OMP3. ; setting keywords. theory. OMP3 CORRELATION ENERGY. OMP3 DOUBLES ENERGY. OMP3 TOTAL ENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRON ENERGY. one_electron_integrals() psi4.core.MintsHelper method. OneBodyAOInt class in psi4.core. OneBodySOInt class in psi4.core. onel_Hx() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() psi4.core.CIWavefunction method. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:100860,optimiz,optimize,100860,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['optimiz'],['optimize']
Performance,"words. theory. OMP2 CORRELATION ENERGY. OMP2 DOUBLES ENERGY. OMP2 TOTAL ENERGY. OMP2.5. ; setting keywords. OMP2.5 CORRELATION ENERGY. OMP2.5 DOUBLES ENERGY. OMP2.5 TOTAL ENERGY. OMP3. ; setting keywords. theory. OMP3 CORRELATION ENERGY. OMP3 DOUBLES ENERGY. OMP3 TOTAL ENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRON ENERGY. one_electron_integrals() psi4.core.MintsHelper method. OneBodyAOInt class in psi4.core. OneBodySOInt class in psi4.core. onel_Hx() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() psi4.core.CIWavefunction method. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:99825,optimiz,optimize,99825,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['optimiz'],['optimize']
Performance,"write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OMP2_ORBS_PRINT¶. Do print OMP2 orbital energies?. Type: boolean; Default: false. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_SCALE¶. Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. Table Of Contents. OMP2; General; CACHELEVEL; CC_MAXITER; CUTOFF; DIIS_MAX_VECS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E_CONVERGENCE; HESS_TYPE; LEVEL_SHIFT; LINEQ_SOLVER; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SS_SCALE; NAT_ORBS; OMP2_ORBS_PRINT; OPT_METHOD; ORTH_TYPE; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_SCALE; SOS_SCALE2; SOS_TYPE. Previous topic; MRCC_RESTART; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html:3582,optimiz,optimized-,3582,psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,6,"['CACHE', 'optimiz']","['CACHELEVEL', 'optimized-']"
Performance,"write_csx flag on. compare_cubes(expected, computed, label)[source]¶; Function to compare two cube files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_integers(expected, computed, label)[source]¶; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_strings(expected, computed, label)[source]¶; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. compare_values(expected, computed, digits, label)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits.; Performs a system exit on failure. Used in input files in the test suite. compare_vectors(expected, computed, digits, label)[source]¶; Function to compare two vectors. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. copy_file_from_scratch(filename, prefix, namespace, unit, move=False)[source]¶; Function to move file out of scratch with correct naming; convention.; Arguments:; @arg filename full path to target file; @arg prefix computation prefix, usually ‘psi’; @arg namespace context namespace, usually molecule name; @arg unit unit number, e.g. 32; @arg move ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:133053,Perform,Performs,133053,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Perform'],['Performs']
Performance,"wton-Raphson step. OREMP. The REMP hybrid perturbation theory is a constrained mixture of the Møller–Plesset perturbation theory and the; Retaining the Excitation degree perturbation theory([Fink:2006:RE], [Behnle:2019:REMP]).; The mixing ratio is determined by the parameter :math’:A:. \[\widehat{H}^{(0)}_\text{REMP} = (1-A)\widehat{H}^{(0)}_\text{RE} + A\widehat{H}^{(0)}_\text{MP}\]; Technically, the second order of RE corresponds to LCCD for RHF and UHF references. REMP2 and its orbital-optimized variant OREMP2; are thus straightforward to implement in a (O)LCCD program by appropriate scaling of residual vector contributions and density matrices. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]; OREMP2 [Behnle:2021:OREMP], and [Behnle:2022:OREMP]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The various orbital-optimized methods supported by the OCC/DFOCC; modules in PSI4 are summarized in Table OCC OO; Methods and detailed in Table OCC; OO Capabilities. Note that while two; separate libraries OCC (conventional integrals CONV) and DFOCC; (density-fitted DF and Cholesky-decomposed CD) together provide; the methods described on this page, they are controlled through one; QC_MODULE value OCC. Without set qc_module occ,; these methods may default to implementations in other modules based on efficiency considerations. Orbital-optimized theoretical met",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:9350,optimiz,optimized,9350,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['optimiz'],['optimized']
Performance,"x 2-norm) for numerical solvers (instability analysis and CPHF/CPKS). Type: conv double; Default: 1.0e-6. SOLVER_MAXITER¶. Maximum iterations for numerical solvers (instability analysis and CPHF/CPKS). Type: integer; Default: 100. SOLVER_N_GUESS¶. Number of guess vectors per root for instability analysis. Type: integer; Default: 1. SOLVER_N_ROOT¶. Number of roots to converge for all irreps during instability analysis. (Overridden by SOLVER_ROOTS_PER_IRREP.). Type: integer; Default: 1. SOLVER_ROOTS_PER_IRREP¶. Number of roots to converge, per irrep, during instability analysis. (Overrides SOLVER_N_ROOT.). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html:9009,perform,perform,9009,psi4manual/1.7.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html,4,['perform'],['perform']
Performance,"x and thus greatly improve performance. COSX Exchange¶; The semi-numerical COSX algorithm described in [Neese:2009:98] evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in DFT: Density Functional Theory.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; By default, the SCF algorithm is first converged on a smaller grid, followed by a; number of SCF iterations up to a maximum value (controlled by the COSX_MAXITER_FINAL keyword); on a larger grid. By default, COSX_MAXITER_FINAL is set to 1, a single; SCF iteration, which results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. Setting COSX_MAXITER_FINAL to 0 disables the; larger grid entirely. Setting COSX_MAXITER_FINAL to -1 allows; for the SCF to fully converge on the larger grid, useful for the study of wavefunction; properties such as gradients. The size of the initial grid is controlled by the keywords; COSX_RADIAL_POINTS_INITIAL and COSX_SPHERICAL_POINTS_INITIAL.; The final grid is controlled by COSX_RADIAL_POINTS_FINAL and; COSX_SPHERICAL_POINTS_FINAL. Currently, the default grids are very crude,; allowing for high performance at the cost of accuracy. If high-accuracy calculations; are desired with COSX, the grid sizes should be increased.; Screening thresholds over integrals, densities, and basis extents are set; with the COSX_INTS_TOLERANCE, COSX_DENSITY_TOLERANCE, and; COSX_BASIS_TOLERANCE keywords, respectively. COSX_INTS_TOLERANCE; is the most consequential of the three thresholds i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:37368,perform,performing,37368,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,2,['perform'],['performing']
Performance,"x in nbody_range}; for n in nbody_range:; compute_list[n] |= cp_compute_list[n]; compute_list[n] |= nocp_compute_list[n]; compute_list[n] |= vmfc_compute_list[n]; core.print_out("" Number of %d-body computations: %d\n"" % (n, len(compute_list[n]))). metadata['compute_dict'] = {'all': compute_list, 'cp': cp_compute_list, 'nocp': nocp_compute_list, ; 'vmfc_compute': vmfc_compute_list, 'vmfc_levels': vmfc_level_list}; return metadata. def compute_nbody_components(func, method_string, metadata):; """"""Computes requested N-body components. Performs requested computations for psi4::Molecule object `molecule` according to; `compute_list` with function `func` at `method_string` level of theory. Parameters; ----------; func : {'energy', 'gradient', 'hessian'}; Function object to be called within N-Body procedure.; method_string : str; Indicates level of theory to be passed to function `func`.; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'compute_list'``: dict of int: set; List of computations to perform. Keys indicate body-levels, e.g,. `compute_list[2]` is the; list of all 2-body computations required.; ``'kwargs'``: dict; Arbitrary keyword arguments to be passed to function `func`. Returns; -------; dict of str: dict; Dictionary containing computed N-body components. Contents:; ``'energies'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations; ``'intermediates'``: dict of str: float64; Dictionary of psivars for intermediate N-body computations to be set at the end of the; N-body procedure.; """"""; # Get required metadata; kwargs = metadata['kwargs']; molecule = metadata['molecule']; #molecule = core.get_active_molecule(); compute_list = metadata['compute_dict']['all']. # Now compute the energies; energies_dict = {}; ptype_dict = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:13228,perform,perform,13228,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['perform'],['perform']
Performance,"x() (psi4.core.CdSalc method). irrep_labels() (psi4.core.Molecule method). is_c_hybrid() (psi4.core.SuperFunctional method). is_c_lrc() (psi4.core.SuperFunctional method). is_c_scs_hybrid() (psi4.core.SuperFunctional method). is_cartesian() (psi4.core.GaussianShell method). is_done() (psi4.core.AOShellCombinationsIterator method). is_gga() (psi4.core.Functional method). (psi4.core.SuperFunctional method). is_inverted() (psi4.core.FittingMetric method). is_libxc_func() (psi4.core.SuperFunctional method). is_lrc() (psi4.core.Functional method). is_meta() (psi4.core.Functional method). (psi4.core.SuperFunctional method). is_poisson() (psi4.core.FittingMetric method). is_pure() (psi4.core.GaussianShell method). is_variable() (psi4.core.Molecule method). is_x_hybrid() (psi4.core.SuperFunctional method). is_x_lrc() (psi4.core.SuperFunctional method). ISA. ; MBIS. Isotopes. ISOTROPIC_POL (PE). ISTOP (DETCI). iteration (psi4.driver.ConvergenceError attribute). (psi4.driver.OptimizationConvergenceError attribute). (psi4.driver.SCFConvergenceError attribute). (psi4.driver.TDSCFConvergenceError attribute). iteration_ (psi4.core.HF attribute). iteration_energies (psi4.core.HF attribute). iterations() (psi4.core.HF method). J. J() (psi4.core.JK method). JK (class in psi4.core). jk() (psi4.core.HF method). JOBTYPE (CCLAMBDA). K. K() (psi4.core.JK method). keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. keywords (psi4.driver.AtomicComputer attribute). (psi4.driver.driver_cbs.CompositeComputer attribute). (psi4.driver.driver_nbody.ManyBodyComputer attribute). KIND (ADC). kinetic() (psi4.core.FISAPT method). kinetic_grad() (psi4.core.MintsHelper method). KineticInt (class in psi4.core). kwargs_lower() (in module psi4.driver.p4util). L. L (psi4.core.Localizer attribute). label() (psi4.core.Molecule method). (p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:68985,Optimiz,OptimizationConvergenceError,68985,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['Optimiz'],['OptimizationConvergenceError']
Performance,"x) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector]) – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11974,load,load,11974,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,1,['load'],['load']
Performance,"x) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11954,load,load,11954,psi4manual/1.8.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html,1,['load'],['load']
Performance,"x. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. mints3; Test individual integral objects for correctness. dft-custom; DFT custom functional test. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. soscf-large; Second-order SCF convergnece: Benzene. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). casscf-fzc-sp; CASSCF/6-31G** energy point. scf-coverage; Lithium test for coverage. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. dfm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:23776,optimiz,optimizes,23776,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimizes']
Performance,"x? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None; Loads a matrix from an ASCII file in MPQC format. name; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int; Returns the number of irreps. np; View without only one irrep. classmethod np_read(filename, prefix=''); Reads the data from a NumPy compress file. np_write(filename=None, prefix=''); Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:21426,load,load,21426,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"x?. Type: boolean; Default: false. OPDM_RELAX (DFMP2)¶DFMP2 — Do relax the one-particle density matrix?. Type: boolean; Default: true. OPT_COORDINATES (OPTKING)¶OPTKING — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_METHOD (DFOCC)¶DFOCC — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC)¶OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. OPT_RESTART (OPTKING)¶OPTKING — Restart the optimization from optking’s written history. Type: double; Default: 0. OPT_TYPE (OPTKING)¶OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC)¶DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC)¶OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (DFOCC)¶DFOCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:187079,perform,performed,187079,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,3,['perform'],['performed']
Performance,"xEEE {lvalue},N5boost10shared_ptrIN3psi6VectorEEE {lvalue},N3psi17diagonalize_orderE); | ; | doublet(...); | doublet( (Matrix)arg1, (Matrix)arg2, (bool)arg3, (bool)arg4) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE doublet(N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,b,b); | ; | gemm(...); | gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :; | docstring; | ; | C++ signature :; | void gemm(N3psi6MatrixE {lvalue},b,b,d,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,d); | ; | get(...); | get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :; | docstring; | ; | C++ signature :; | d get(N3psi6MatrixE {lvalue},i,i [,i]); | ; | identity(...); | identity( (Matrix)arg1) -> None :; | docstring; | ; | C++ signature :; | void identity(N3psi6MatrixE {lvalue}); | ; | invert(...); | invert( (Matrix)arg1) -> None :; | docstring; | ; | C++ signature :; | void invert(N3psi6MatrixE {lvalue}); | ; | load(...); | load( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void load(N3psi6MatrixE {lvalue},Ss); | ; | load_mpqc(...); | load_mpqc( (Matrix)arg1, (str)arg2) -> None :; | docstring; | ; | C++ signature :; | void load_mpqc(N3psi6MatrixE {lvalue},Ss); | ; | name(...); | name( (Matrix)arg1) -> str :; | docstring; | ; | C++ signature :; | Ss name(N3psi6MatrixE {lvalue}); | ; | nirrep(...); | nirrep( (Matrix)arg1) -> int :; | docstring; | ; | C++ signature :; | i nirrep(N3psi6MatrixE {lvalue}); | ; | partial_cholesky_factorize(...); | partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi6MatrixEEE partial_cholesky_factorize(N3psi6MatrixE {lvalue},d,b); | ; | power(...); | power( (Matrix)arg1, (float)arg2, (float)arg3) -> Dimension :; | docstring; | ; | C++ signature :; | N3psi9DimensionE power(N3psi6MatrixE {lvalue",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:517622,load,load,517622,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['load'],['load']
Performance,"x_distance) matches to string seq1 among options. format_molecule_for_input(mol[, name, forcexyz]); Old function for input string from molecule. format_options_for_input([molecule]); Function to return a string of commands to replicate the current state of user-modified options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. get_memory(); Return the total memory allocation in bytes. get_psifile(fileno[, pidspace]); Form full path and filename for psi scratch file. getattr_ignorecase(module, attr); Extract attribute attr from module if attr is available in any possible lettercase permutation. hamiltonian_solver(engine, guess, *, nroot); Finds the smallest eigenvalues and associated right and left hand eigenvectors of a large real Hamiltonian eigenvalue problem emulated through an engine. hold_options_state(); Return a context manager that will collect the current state of :rtype: Iterator[None]. import_ignorecase(module); Import loader for module in any possible lettercase permutation. kwargs_lower(kwargs); Function to rebuild and return kwargs dictionary sanitized. levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. libint2_configuration(); Returns information on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). rtype:; None. mat2arr(mat); Convert Matrix to List. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. plump_qcvar(key, val); Prepare serialized QCVariables for QCSchema AtomicResult.extras[""qcvars""] by converting flat arrays into numpy, shaped ones and floating strings. prefactor_ecd(); Prefactor for converting microscopic observable to decadic molar extinction coefficient in electronic circular dichroism. prefactor_opa(); Prefactor for converting microscopic ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:25652,load,loader,25652,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,1,['load'],['loader']
Performance,"xample psi4/samples/example_psi4rc_file).; All the commands mentioned in section Scratch Files can be used in this file.; To set up the scratch path:; psi4_io.set_default_path('/scratch/user'). To set up the scratch path from a variable $MYSCRATCH:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). To set up a specific path for the internal coordinate file and instruct PSI4 not to delete it:; psi4_io.set_specific_path(12, './'); psi4_io.set_specific_retention(12, True). # equivalent to above; psi4_io.set_specific_path(PSIF_INTCO, './'); psi4_io.set_specific_retention(PSIF_INTCO, True). The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instructions in the ~/.psi4rc file. During; execution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed.; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and C++; std::thread for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MK",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external.html:11169,load,loaded,11169,psi4manual/master/external.html,https://psicode.org,https://psicode.org/psi4manual/master/external.html,9,['load'],['loaded']
Performance,"xamples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908  ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:7403,Optimiz,Optimizer,7403,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,8,['Optimiz'],"['Optimization', 'Optimizer']"
Performance,"xecutable after compilation; How to solve ModuleNotFoundError: No module named 'psi4'; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to get a Psi4 logo file; How to use a local Add-On repository in the Psi4 build; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_planning.html:63981,queue,queue,63981,psi4manual/1.7.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_planning.html,1,['queue'],['queue']
Performance,"xed” excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MO_DIIS_NUM_VECS (OCC); OCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER (OCC); OCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF); MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OCC); OCC — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_RELAX (DCFT); DCFT (Expert) — Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. MO_STEP_MAX (OCC); OCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OCC); OCC — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODE (TRANSQT); TRANSQT — The way of transformation, from ao basis to mo basis or vice versa. Type: string; Possible Values: TO_MO, TO_AO; Default: TO_MO. MODULE (CPHF); CPHF — What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. MOGRAD_DAMPING (OCC); OCC — Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MOLDEN_WRITE (SCF); SCF — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MOM_OCC (SCF); SCF — The absolute indices of orbitals to excite from in MOM (+/- for alpha/b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:78261,optimiz,optimization,78261,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimization']
Performance,"xible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess; Convergence Stabilization; ERI Algorithms; Second-order Convergence; Stability Analysis; External potentials and QM/MM; Convergence and Algorithm Defaults; Recommendations. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:36044,optimiz,optimized,36044,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,2,['optimiz'],['optimized']
Performance,"ximation¶; Recently, the SAPT second-order exchange terms have been derived without; the \(S^{2}\) approximation in the works [Schaffer:2012:1235] and; [Schaffer:2013:2570]. These new terms can be computed with the following; settings:; set SAPT_DFT_FUNCTIONAL HF; set DO_IND_EXCH_SINF true # calculate Exch-Ind20 (S^inf); set SAPT_DFT_MP2_DISP_ALG fisapt; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'). These calculations are performed with the atomic orbital and; density-fitting scheme of [J. M. Waldrop et al., to be published]. S^inf Keywords¶. DO_IND_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Induction terms. Type: boolean; Default: false. DO_DISP_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Dispersion terms. Type: boolean; Default: false. SAPT0-D¶; In SAPT0, the computation of \(E_{disp}^{(20)} + E_{exch-disp}^{(20)}\) represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; Grimme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:45207,bottleneck,bottleneck,45207,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,4,['bottleneck'],['bottleneck']
Performance,"ximum number of iterations for Brueckner CCD. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CPHF_CUTOFF¶. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_CUTOFF¶. Value (always between one and ze",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__ccenergy-1.html:1435,cache,cache,1435,psi4manual/1.4.0/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__ccenergy-1.html,9,['cache'],['cache']
Performance,"xpansion are available in the SAPT; module of PSI4. The simplest truncation of SAPT is denoted SAPT0; and defined in Eq. (1). (1); In this notation, defines the order in and in ; the; subscript, , indicates that orbital relaxation effects are included. (2). (3). (4). (5); A thorough analysis of the performance of these truncations of SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs].; The SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency. A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:2765,perform,perform,2765,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['perform'],['perform']
Performance,"xpected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. compare_csx()[source]¶; Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. compare_cubes(expected, computed, label)[source]¶; Function to compare two cube files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_integers(expected, computed, label)[source]¶; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_strings(expected, computed, label)[source]¶; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. compare_values(expected, computed, digits, label)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits.; Performs a system exit on failure. Used in input files in the test suite. compare_vectors(expected, computed, digits, label)[source]¶; Function to compare two vectors. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. copy_file_from_scratch(filename, prefix, namespace, unit, move=False)[source]¶; Fu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:132755,Perform,Performs,132755,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Perform'],['Performs']
Performance,"xternal proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.h (primary psi4 header); include/psi4/masses.h (a project-wide psi4 header); include/psi4/libmints/ (psi4 library headers); include/psi4/libfock/ (ditto); share/ (read-only arch-indep files for psi4 + any external proj); share/cmake/psi4/ (files for detecting installed targets); share/cmake/psi4/psi4Config.cmake (psi4 build/install info); share/cmake/psi4/psi4ConfigVersion.cmake (psi4 cmake version info); share/doc/psi4/html/ (sphinx html documentation); share/psi4/ (text files needed by psi4); share/psi4/basis (basis sets); share/psi4/plugins (plugin template files); share/psi4/fsapt (fsapt scripts); share/psi4/samples/ (sample input files); lib/ (shared libraries and py modules for psi4 + any external proj); # ordinary; lib/psi4/ (object files); lib/psi4/driver/ (py-side, uncompiled); lib/psi4/header.py (prints file header); lib/psi4/metadata.py (psi4 version info); lib/psi4/__init__.py (module marker/loader for psi4.core); lib/psi4/core.cpython-*.so (c-side, compiled and bound by pybind11); # conda; lib/pythonX.X/site-packages/psi4/. The following environment variables point to certain places in the above; directory structure. None to few need to be set; see for details:; running compiled executable,; running compiled Python module,; running conda binary. PATH pointing to bin; PYTHONPATH pointing to lib (ordinary) or lib/pythonX.X/site-packages (conda); PSIDATADIR pointing to share/psi4. How to run Psi4 as executable after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:26594,load,loader,26594,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,11,['load'],['loader']
Performance,"xternal proj); include/psi4/ (header files for #include-ing); include/psi4/psi4-dec.h (primary psi4 header); include/psi4/masses.h (a project-wide psi4 header); include/psi4/libmints/ (psi4 library headers); include/psi4/libfock/ (ditto); share/ (read-only arch-indep files for psi4 + any external proj); share/cmake/psi4/ (files for detecting installed targets); share/cmake/psi4/psi4Config.cmake (psi4 build/install info); share/cmake/psi4/psi4ConfigVersion.cmake (psi4 cmake version info); share/doc/psi4/html/ (sphinx html documentation); share/psi4/ (text files needed by psi4); share/psi4/basis (basis sets); share/psi4/plugins (plugin template files); share/psi4/fsapt (fsapt scripts); share/psi4/samples/ (sample input files); lib/ (shared libraries and py modules for psi4 + any external proj); # ordinary; lib/psi4/ (object files); lib/psi4/driver/ (py-side, uncompiled); lib/psi4/header.py (prints file header); lib/psi4/metadata.py (psi4 version info); lib/psi4/__init__.py (module marker/loader for psi4.core); lib/psi4/core.so (c-side, compiled and bound by pybind11); # conda; lib/pythonX.X/site-packages/psi4/. The following environment variables point to certain places in the above; directory structure. None to few need to be set; see for details:; running compiled executable,; running compiled Python module,; running conda binary. PATH pointing to bin; PYTHONPATH pointing to lib (ordinary) or lib/pythonX.X/site-packages (conda); PSIDATADIR pointing to share/psi4. How to run Psi4 as executable after compilation¶; Substituting the full installation directory prefix and a; suitable scratch directory, issue the following commands directly in your; terminal or place them into your “rc” file and open a new terminal. (To; use a staged installation directory, substitute; objdir/stage/prefix for prefix.); # csh, tcsh: add to shell or ~/.tcshrc file; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:21125,load,loader,21125,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['load'],['loader']
Performance,"xt{aug-cc-pV[DT]Z}}\right) - \mathcal{F}_{\text{corl_xtpl_helgaker_2}} \left(E_{\text{corl},\; \text{MP2}}^{\text{aug-cc-pV[DT]Z}}\right)\]. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (str) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html:5163,perform,performed,5163,psi4manual/1.3.2/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.cbs-1.html,2,['perform'],['performed']
Performance,"y (DCT)¶; PSI4 features several formulations of newly-developed density cumulant; theory (DCT), also known as density cumulant functional theory (DCFT).; The theory and benchmark of this theory are discussed in the following papers:; DC-06 (also known as DCT-06):. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). ODC-06 and ODC-12:. “Orbital-optimized density cumulant functional theory,” A. Yu. Sokolov, and; H. F. Schaefer, J. Chem. Phys. 139, 204110 (2013).; (doi: 10.1063/1.4833138). ODC-13:. “Density cumulant functional theory from a unitary transformation:; N-representability, three-particle correlation effects, and application; to O4+,” A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,; J. Chem. Phys. 141, 074111 (2014).; (doi: 10.1063/1.4892946). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:7796,optimiz,optimized,7796,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,9,['optimiz'],['optimized']
Performance,"y (HF & DFT) calculation. run_scf_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SCF gradient calculation. run_scf_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to run_scf(); since SCF properties all handled through oeprop. scf_helper(name, **kwargs)[source]¶; Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). select_ccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. select_ccsd_at_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. select_ccsd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. select_ccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. select_ccsd_t__gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. select_cisd(name, **kwargs)[source]¶; Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. select_fnoccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. select_fnoccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. select_lccd(name, **kwargs)[source]¶; Function selecting the algorithm for a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:166750,perform,performance,166750,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"y 2000 Mb. memory 2000000 Kb. One convenient way to override the Psi4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and Geometry Specification¶. Molecule and Geometry Specification; Coordinates; Molecule Keywords; Multiple Molecules; Ghost Atoms; Isotopic Substitution; PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Advanced Python. To add EFP fragments to a molecule, see Molecule Specification. Job Control Keywords¶; Psi4 comprises a number of modules, written in C++, that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file which control its function.; These keywords are detailed in Appendix Keywords by Module.; The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:5324,perform,perform,5324,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['perform'],['perform']
Performance,"y Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. docs_dft; This test is used to construct the documentation; it is not suitable for emulation by users. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf3; are specified explicitly. cc52; CCSD Response for H2O2. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. docs_psimod; This test is used to construct the documentation; it is not suitable for emulation by users. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dfmp2_1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:8955,optimiz,optimization,8955,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"y Testing the in line -decontract option for basis sets. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. fci-h2o; 6-31G H2O Test FCI Energy Point. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. fnocc4; Test FNO-DF-CCSD(T) energy. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. opt10; 6-31G MP2 transition-state optimi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:2696,optimiz,optimized,2696,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['optimiz'],['optimized']
Performance,"y allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. temp_circular_import_blocker(). vibanal_wfn(wfn[, hess, irrep, molecule, …]); Function to perform analysis of a hessian or hessian block, specifically…. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpiricalDispersion([name_hint, level_hint, …]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). SCFConvergenceError(eqn_description, …); Error called for problems with SCF iterations. Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Cl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:314653,Optimiz,OptimizationConvergenceError,314653,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,4,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimizer']"
Performance,"y available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods. Type: boolean; Default: false. DISP_SIZE (FINDIF); FINDIF — Displacement size in au for finite-differences. Type: double; Default: 0.005. DISTANT_PAIR_CUTOFF (LMP2); LMP2 — Distant pair cutoff. Type: double; Default: 8.0. DISTRIBUTED_MATRIX (SCF); SCF (Expert) — The dimension sizes of the distributed matrix. Type: array; Default: No Default. DO_ALL_TEI (TRANSQT); TRANSQT — Do transform all TEIs. Type: boolean; Default: false. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CIS); CIS — Do print the domains?. Type: boolean; Defaul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:35452,perform,perform,35452,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"y call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:19153,perform,performance,19153,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"y default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat' . # => Traverse <= #; PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""); PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico! ; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = PsiMod.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = PsiMod.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge) ; mol.set_multiplicity(mult). # Determine HOMO; ref = PsiMod.wavefunction(); eps_a = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:8321,LOAD,LOAD,8321,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,1,['LOAD'],['LOAD']
Performance,"y dependent on the reference geometry being last (as it is now); print("""""" %d displacements needed ..."""""" % (ndisp), end=''); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if opt_mode == 'sow':; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; core.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:39755,optimiz,optimization,39755,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['optimiz'],['optimization']
Performance,"y dependent on the reference geometry being last (as it is now); print("""""" %d displacements needed ..."""""" % (ndisp), end=''); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if opt_mode == 'sow':; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:38421,optimiz,optimization,38421,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimization']
Performance,"y either user or code. has_local_option_changed((arg0: str, ...); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed((arg0: str, ...); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable((arg0: str) -> bool); Returns true if the PSI variable exists/is set. initialize(() -> bool). legacy_wavefunction(() -> psi::Wavefunction); Returns the current legacy_wavefunction object from the most recent computation. libfock(...); Runs a CPHF calculation, using libfock. mcscf(...); Runs the MCSCF code, (N.B. mrcc_generate_input(...); Generates an input for Kallay’s MRCC code. mrcc_load_densities(...); Reads in the density matrices from Kallay’s MRCC code. occ(...); Runs the orbital optimized CC codes. opt_clean(() -> None); Cleans up the optimizer’s scratch files. optking(() -> int); Runs the geometry optimization / frequency analysis code. outfile_name(() -> str); Returns the name of the output file. plugin((arg0: str, ...); Call the plugin of name arg0. plugin_close((arg0: str) -> None); Close the plugin of name arg0. plugin_close_all(() -> None); Close all open plugins. plugin_load((arg0: str) -> int); Load the plugin of name arg0. prepare_options_for_module((arg0: str) -> None); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(() -> None); Prints the currently set global (all modules) options to the output file. print_options(() -> None); Prints the currently set options (to the output file) for the current module. print_out((arg0: str) -> None); Prints a string (using sprintf-like notation) to the output file. print_variables(() -> None); Prints all PSI variables that have been set internally. psi_top_srcdir(() -> str); Returns the location of the source code. psimrcc((arg0: psi::Wavefunction) -> float); Runs the multirefe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:168393,optimiz,optimization,168393,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['optimiz'],['optimization']
Performance,"y float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). # power user returns; E, wfn = psi4.energy(..., return_wfn=True); E, wfn = psi4.optimize(..., return_wfn=True); E, wfn = psi4.frequency(..., return_wfn=True); G, wfn = psi4.gradient(..., return_wfn=True) # used by optimize(); H, wfn = psi4.hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print(wfn.gradient().rms()). # format output for other programs; psi4.molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:. PSIthonPsiAPIbasis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; psi4.set_options({""basis"": basis_set}); psi4.energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, bec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:11624,optimiz,optimize,11624,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['optimiz'],['optimize']
Performance,"y for the H2O molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. fcidump; test FCIDUMP functionality for rhf/uhf. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/testsuite.html:47474,optimiz,optimized,47474,psi4manual/1.7.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/testsuite.html,3,"['optimiz', 'perform']","['optimization', 'optimized', 'performed']"
Performance,"y help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory proble",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:8848,cache,cache,8848,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,12,['cache'],['cache']
Performance,"y large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:9741,CACHE,CACHELEVEL,9741,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"y methods can run with a minimal input and set symmetry. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. sad-scf-type; Test SAD SCF guesses on noble gas atom. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. extern3; External potential calculation with one Ghost atom and one point charge at the same position. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). dct12; Spin-restricted DC-06 counterpart of dct1. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual sp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:46301,Optimiz,Optimize,46301,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['Optimiz'],['Optimize']
Performance,"y must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:5900,Load,Load,5900,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,2,['Load'],['Load']
Performance,"y must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import psi4; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; psi4.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/plugins-1.html:5900,Load,Load,5900,psi4manual/4.0b5/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/plugins-1.html,2,['Load'],['Load']
Performance,"y number in thermodynamic computations. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. dft-smoke; DFT Functional Smoke Test. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. scf-guess-read2; Test if the the guess read in the same basis converges. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed param",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:33313,perform,performs,33313,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"y optimization for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cbs-parser; mtd/basis syntax examples. scf-occ; force occupations in scf. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:29357,Optimiz,Optimize,29357,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['Optimiz'],['Optimize']
Performance,"y optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OMP3); OMP3 — Do perform spin-component-scaled OMP3 (SCS-OMP3)? In all computation, SCS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP3, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (OMP2); OMP2 — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OMP3); OMP3 — Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SOS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CIS); CIS — Do print the domains?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT (LMP2); LMP2 — Do exit after printing the domains?. Type: boolean; Default: false. DOMAINS (CIS); CIS —. Type: array; Default: No Default. E3_SCALE (OMP3); OMP3 — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:34584,perform,perform,34584,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"y optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR)¶CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. CFOUR_GIAO (CFOUR)¶CFOUR — Specifies whether gauge-including atomic orbitals are used (ON) or not (OFF). Default: ON for CFOUR_PROPS =NMR and =MAGNETIC, otherwise OFF. Type: string; Possible Values: ON, OFF; Default: No Default. CFOUR_GRID (CFOUR)¶CFOUR — Keyword used to control type of grid calculation (see later section in this manual). Options are OFF (=0), no grid calculation; CARTESIAN (=1), steps are in Cartesian coordinates (which must be run with CFOUR_COORDINATES =CARTESIAN); INTERNAL (=2), steps are in Z-matrix internal coordinates; QUADRATURE (=3) steps are chosen for an integration based on Gauss-Hermite quadrature. (Default: OFF). Type: string; Possible Values: OFF, CARTESIAN, INTERNAL, QUADRATURE; Default: OFF. CFOUR_GUESS (CFOUR)¶CFOUR — Where the initial ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:49345,optimiz,optimization,49345,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['optimiz'],['optimization']
Performance,"y the name of the output file plus the name of the current molecule. Type: boolean; Default: false. GUESS (SCF)¶SCF — The type of guess orbitals. Defaults to READ for geometry optimizations after the first step, to CORE for single atoms, and to SAD otherwise. The HUCKEL guess employs on-the-fly calculations like SAD, as described in doi:10.1021/acs.jctc.8b01089 which also describes the SAP guess. Type: string; Possible Values: AUTO, CORE, GWH, SAD, SADNO, SAP, HUCKEL, READ; Default: AUTO. GUESS_MIX (SCF)¶SCF — Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST (SCF)¶SCF — If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. GUESS_R_CONVERGENCE (DCT)¶DCT — Convergence criterion for the density cumulant and orbital guess for the variationally orbital-optimized DFT methods. Currently only available for ALGORITHM = SIMULTANEOUS. Type: conv double; Default: 1e-3. GUESS_VECTOR (DETCI)¶DETCI (Expert) — Guess vector type. Accepted values are UNIT for a unit vector guess (NUM_ROOTS and NUM_INIT_VECS must both be 1); H0_BLOCK to use eigenvectors from the H0 BLOCK submatrix (default); DFILE to use NUM_ROOTS previously converged vectors in the D file;. Type: string; Possible Values: UNIT, H0_BLOCK, DFILE; Default: H0_BLOCK. H0_BLOCK_COUPLING (DETCI)¶DETCI (Expert) — Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE (DETCI)¶DETCI (Expert) — Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0. H0_BLOCKSIZE (DETCI)¶DETCI (Expert) — This parameter specifies the size of the H0 block of the Hamiltonian which is solved exactly. The n determinants with the lowest SCF energy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:140003,optimiz,optimized,140003,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimized']
Performance,"y with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. cc13c; Tests RHF CCSD(T)gradients. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. fci-dipole; 6-31G H2O Test FCI Energy Point. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. dft-grac; Gradient regularized asymptotic correction (GRAC) test. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. scf7; Tests SCF gradient in the presence of a dipole field. pywrap-molecule; Check that C++ M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:16937,perform,performed,16937,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"y() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/plugins.html:7965,load,loaded,7965,psi4manual/1.6.x/plugins.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/plugins.html,3,['load'],"['loaded', 'loading']"
Performance,"y(arg0); Runs the code to compute coupled cluster density matrices. ccenergy(arg0); Runs the coupled cluster energy code. cceom(arg0); Runs the equation of motion coupled cluster code, for excited states. cchbar(arg0); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI variables that have set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. displace_atom(arg0, arg1, arg2, arg3, arg4); Displaces one coordinate of single atom. dmrg(arg0); Runs the DMRG code. efp_init(); Initializes the EFP library and returns an EFP object. efp_set_options(); Set EFP options from environment options object. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. fd_1_0(arg0, arg1); Performs a finite difference gradient computation, from energy points. fd_freq_0(arg0, arg1, arg2); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1(arg0, arg1, arg2); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(arg0); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0(arg0, arg1); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1(arg0, arg1); Get",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:242400,optimiz,optimized,242400,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['optimiz'],['optimized']
Performance,"y(name[, bypass_scf, molecule])[source]¶; Function to compute the single-point electronic energy. Returns:(float) Total electronic energy in Hartrees. SAPT returns interaction energy. Psi variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mcscf; multiconfigurational self consistent field (SCF). mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual]. mp2.5; average of MP2 and MP3 [manual]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. mp4; full MP4 [manual]. mpn; nth-order Moller–Plesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation, equiv. linear. CCD [manual]. cepa(0); coupled electron pair approximation variant 0 [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. cepa(3); coupled electron pair approximation variant 3 [manual]. acpf; averaged coupled-pair functional [manual]. aqcc; averaged quadratic coupled cluster [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. qcisd(t); QCISD with perturbative triples [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. fno-df-ccsd(t); CCSD(T) with density fitting and frozen natural",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/energy-1.html:1161,optimiz,optimized,1161,psi4manual/4.0b4/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/energy-1.html,4,['optimiz'],['optimized']
Performance,"y); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:9599,load,load,9599,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,8,['load'],['load']
Performance,"y, use CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. 1>>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++11 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (2.7, 3.5, or 3.6) https://www.python.org/; CMake (3.3+) http://www.cmake.org/download/; NumPy (needed at runtime and buildtime) http://www.numpy.org/; mpmath (only needed if you build gau2grid to angular momentum >16) http://mpmath.org/; System utilities: GNU make, GNU install, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. gau2grid <cmake:gau2grid — [what is this?] [min version]; Libint — [what is this?] [min version]; Libxc — [what is this?] [min version]; pybind11 — [what is this?] [min version]. Additionally, there are runtime-only dependencies:. NumPy http://www.numpy.org/; networkx https://github.com/networkx/networkx; deepdiff https://github.com/seperman/deepdiff. What are the add-on capabilities for Psi4 and what are their dependencies¶; Each of the items below is an independent additional",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:3926,Optimiz,Optimized,3926,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['Optimiz'],['Optimized']
Performance,"y,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:11404,optimiz,optimized,11404,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,2,['optimiz'],['optimized']
Performance,"y-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:2321,optimiz,optimized,2321,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,8,['optimiz'],['optimized']
Performance,y. OLCCD REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized linearized coupled cluster; doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2 level of theory. OMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2.5 level of theory. OMP2.5 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP3 level of theory. OMP3 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP3 level of theory. OREMP2 TOTAL ENERGY¶. OREMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized retaining-the-excitation-degree Møller–Plesset; hybrid perturbation theory level. OREMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized retaining-the-excitation-degree; Møller–Plesset hybrid perturbation theory level. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [E_h] from the polarizable continuum model for solvation. DD SOLVATION ENERGY¶; The energy contribution ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:43398,optimiz,optimized,43398,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,4,['optimiz'],['optimized']
Performance,"y. Psi variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mcscf; multiconfigurational self consistent field (SCF). mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual]. mp2.5; average of MP2 and MP3 [manual]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. mp4; full MP4 [manual]. mpn; nth-order Moller–Plesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation, equiv. linear. CCD [manual]. cepa(0); coupled electron pair approximation variant 0 [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. cepa(3); coupled electron pair approximation variant 3 [manual]. acpf; averaged coupled-pair functional [manual]. aqcc; averaged quadratic coupled cluster [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. qcisd(t); QCISD with perturbative triples [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. fno-df-ccsd(t); CCSD(T) with density fitting and frozen natural orbitals [manual]. bccd(t); BCCD with perturbative triples [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual]. ccenergy; expert full control over ccenergy mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/energy-1.html:1343,optimiz,optimized,1343,psi4manual/4.0b4/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/energy-1.html,4,['optimiz'],['optimized']
Performance,"y. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. options1; check all variety of options parsing. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. mbis-2; MBIS calculation on OH- (Expanded Arrays). scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fnocc3; Test FNO-QCISD(T) computation. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. cepa-module; routing check on lccd, lccsd, cepa(0). opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. aediis-2; EDIIS test case from 10.1063/1.1470195. cc56; EOM-CCSD/6-31g excited state transition data for water cation. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. scf-response2; Compute the dipole polarizability for water with custom basis set. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. scf5; Test of all different algorithms ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:22764,Optimiz,Optimize,22764,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['Optimiz'],['Optimize']
Performance,"y.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:3400,perform,performance,3400,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"y:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(ssmod, func)):; self.add_Subset(getattr(ssmod, func).__doc__, getattr(ssmod, func)). print(""""""WrappedDatabase %s: Defined subsets loaded"""""" % (self.dbse)). [docs] def get_pec_weightinfo(self):; """""". """"""; def closest(u, options):; return max(options, key=lambda v: len(os.path.commonprefix([u, v]))). dbdat = {}; oss = self.oss['default']; eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; for rxnix, rxn in enumerate(oss.hrxn):; dbdat[rxn] = {'eq': closest(rxn, eqrxns),; 'Rrat': oss.axis['Rrat'][rxnix]}; return dbdat. # def table_simple1(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'S22', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'S22', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'S22', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'S22', 'TT', textables.val, {'sset': 'default'}],; # ]; #; # def table_simple2(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:43133,load,loaded,43133,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loaded']
Performance,"y:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~driver_cbs.complete_basis_set` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/aliases.html:3133,perform,performed,3133,psi4manual/1.1.0/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/aliases.html,3,['perform'],['performed']
Performance,"y; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:7600,Optimiz,Optimized,7600,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['Optimiz'],['Optimized']
Performance,"y; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:7003,Optimiz,Optimized,7003,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,2,['Optimiz'],['Optimized']
Performance,"yOperation. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_builtins.pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.symmetryoperation.html:1119,Perform,Performs,1119,psi4manual/1.4.0/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.symmetryoperation.html,3,['Perform'],['Performs']
Performance,"y`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:49900,optimiz,optimization,49900,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,6,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"ydroxyl and phenyl moieties of the phenol dimer.; F-SAPT#2.; Discusses how to plot the order-1 F-SAPT analysis with PyMol and perform a; “difference F-SAPT” analysis; I-SAPT#1.; Describes the use of I-SAPT to analyze the interaction between the two phenol; groups in a 2,4-pentanediol molecule.; I-SAPT#2.; Discusses how to plot the density fields and ESPs of the various moieties of; the I-SAPT embedding scheme with PyMol; F/I-SAPT Options.; Details all of the more-advanced options in the F/I-SAPT code (rarely needed). The scripts discussed below are located in psi4/psi4/share/psi4/fsapt. F-SAPT: A Representative Example¶; Below, we show an example of using F-SAPT0/jun-cc-pVDZ to analyze the; distribution of the intermolecular interaction energy components between the; various hydroxyl and phenyl moieties of the phenol dimer. This example is; explicitly included in fsapt1. A video; lecture explaining this example is available F-SAPT#1,; while an additional video describing how to plot the order-1 F-SAPT analysis; with PyMol and perform a “difference F-SAPT”; analysis is available F-SAPT#2:; memory 1 GB. molecule mol {; 0 1; O -1.3885044 1.9298523 -0.4431206; H -0.5238121 1.9646519 -0.0064609; C -2.0071056 0.7638459 -0.1083509; C -1.4630807 -0.1519120 0.7949930; C -2.1475789 -1.3295094 1.0883677; C -3.3743208 -1.6031427 0.4895864; C -3.9143727 -0.6838545 -0.4091028; C -3.2370496 0.4929609 -0.7096126; H -0.5106510 0.0566569 1.2642563; H -1.7151135 -2.0321452 1.7878417; H -3.9024664 -2.5173865 0.7197947; H -4.8670730 -0.8822939 -0.8811319; H -3.6431662 1.2134345 -1.4057590; --; 0 1; O 1.3531168 1.9382724 0.4723133; H 1.7842846 2.3487495 1.2297110; C 2.0369747 0.7865043 0.1495491; C 1.5904026 0.0696860 -0.9574153; C 2.2417367 -1.1069765 -1.3128110; C 3.3315674 -1.5665603 -0.5748636; C 3.7696838 -0.8396901 0.5286439; C 3.1224836 0.3383498 0.8960491; H 0.7445512 0.4367983 -1.5218583; H 1.8921463 -1.6649726 -2.1701843; H 3.8330227 -2.4811537 -0.8566666; H 4.6137632 -1.1850101",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:3095,perform,perform,3095,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,6,['perform'],['perform']
Performance,"ymmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. PRINT_BASIS¶. Do print the basis set?. Type: boolean; Default: false. PRINT_MOS¶. Do print the molecular orbitals?. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html:2281,perform,perform,2281,psi4manual/1.3.2/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"ymmetryOperation) → None¶; Set equal to an inversion. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. E(self: psi4.core.SymmetryOperation) → None; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None; Set equal to an inversion. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None; Set equal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.symmetryoperation.html:2771,Perform,Performs,2771,psi4manual/1.1.0/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.symmetryoperation.html,2,['Perform'],['Performs']
Performance,"ymmetryOperation) → None¶; Set equal to an inversion. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. class psi4.core.ThreeCenterOverlapInt¶; Bases: object; docstring. compute_shell(self: psi4.core.ThreeCenterOverlapInt, arg0: int, arg1: int, arg2: int) → None¶; docstring. class psi4.core.TracelessQuadrupoleInt¶; Bases: psi4.core.OneBodyAOInt; docstring. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; docstring. origin¶; The origin about which the one body ints are being computed. class psi4.core.TwoBodyAOInt¶; Bases: object; docstring. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int) → int¶; docstring. class psi4.core.TwoElectronInt¶; Bases: psi4.core.TwoBodyAOInt; docstring. compute_shell(self: psi4.core.TwoBodyAOInt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:121478,Perform,Performs,121478,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['Perform'],['Performs']
Performance,"ymmetryOperation) → None¶; Set equal to an inversion. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. class psi4.core.ThreeCenterOverlapInt¶; Bases: pybind11_builtins.pybind11_object; Three center overlap integrals. compute_shell(self: psi4.core.ThreeCenterOverlapInt, arg0: int, arg1: int, arg2: int) → None¶; Compute the integrals of the form (a|b|c). class psi4.core.TracelessQuadrupoleInt¶; Bases: psi4.core.OneBodyAOInt; Computes traceless quadrupole integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin about which the one body ints are being computed. class psi4.core.TwoBodyAOInt¶; Bases: pybind11_builtins.pybind11_object; Two body integral base class. compute_shel",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:193930,Perform,Performs,193930,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['Perform'],['Performs']
Performance,"yne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. fci-dipole; 6-31G H2O Test FCI Energy Point. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. remp-energy1; integral conventional REMP/cc-pVDZ energies for the H2O molecule. results were independently verified against the initial wavels implementation. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. scf-auto-cholesky; Cholesky filter a complete basis. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fnocc7; Test fnocc with linear dependencies. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. linK-1; RHF Linear Exchange Algorithm test for water. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. mbis-5; MBIS calculation on ZnO. c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:44832,optimiz,optimization,44832,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"yntax just has to jump, this can be used to trap; the old syntax at first error and suggest the new. """""". def __init__(self, old, new, version, elaboration):; msg = ""Using `{}` instead of `{}` is obsolete as of {}.{}"".format(old, new, version, elaboration); PsiException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration, additional_info=None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer."""""". def __init__(self, eqn_description, iteration, wfn):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; e_conv : float; Change in energy for last iteration; d_conv : float; RMS change in density for last iteration. """""". def __init__(self, eqn_description, iteration, wfn, e_conv, d_conv):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]class TDSCFConvergenceError(ConvergenceError):; """"""Error called for problems with TDSCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; what : str; What we were trying to solve for (singlets/triplets, irrep) when we failed to converge; stats : Dict; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html:3739,Optimiz,OptimizationConvergenceError,3739,psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/exceptions.html,6,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimizer']"
Performance,"yp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/opt-1.html:13684,perform,perform,13684,psi4manual/1.4.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/opt-1.html,10,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"yp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 Au",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:13002,perform,perform,13002,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"yp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.optimize-1.html:13030,perform,perform,13030,psi4manual/1.4.0/api/psi4.driver.optimize-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.optimize-1.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"yp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 Nove",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.opt-1.html:13002,perform,perform,13002,psi4manual/1.5.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.opt-1.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"yp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.optimize-1.html:13030,perform,perform,13030,psi4manual/1.5.0/api/psi4.driver.optimize-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.optimize-1.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"yp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 Ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.opt.html:13002,perform,perform,13002,psi4manual/1.6.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.opt.html,2,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"yp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.optimize.html:13030,perform,perform,13030,psi4manual/1.6.x/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.optimize.html,2,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"ype: boolean; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_IND_EXCH_SINF (SAPT); SAPT (Expert) — For SAPT(DFT) computes the S^inf Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_QQR_SIEVE (CPHF); CPHF — Do we do the QQR integral sieve of Maurer et al. When false, just uses * the Schwarz sieve. Type: boolean; Default: false. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:113385,perform,perform,113385,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"ype: boolean; Default: false. T3_WS_INCORE¶. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Expert¶. AO_BASIS¶. The algorithm to use for the terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. FORCE_RESTART¶. Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Possible Values: CCSD, CCSD_T, EOM_CCSD, LEOM_CCSD, BCCD, BCCD_T, CC2, CC3, EOM_CC2, EOM_CC3, CCSD_MVD; Default: NONE. Table Of Contents. CCENERGY; General; ABCD; ANALYZE; BRUECKNER_ORBS_R_CONVERGENCE; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC_OS_SCALE; CC_SS_SCALE; DIIS; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; MP2_AMPS_PRINT; MP2_OS_SCALE; MP2_SS_SCALE; NEW_TRIPLES; NUM_AMPS_PRINT; PAIR_ENERGIES_PRINT; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SCSN_MP2; SCS_CCSD; SCS_MP2; SEMICANONICAL; SPINADAPT_ENERGIES; T2_COUPLED; T3_WS_INCORE. Expert; AO_BASIS; FORCE_RESTART; WFN. Previous topic; ZETA; Next topic; ABCD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html:6476,CACHE,CACHELEVEL,6476,psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html,4,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"ype: boolean; Default: true. DO_CCD_DISP (SAPT)¶SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC)¶DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC)¶OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DISP_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT(DFT) computes the \(S^{inf}\) Exchange-Dispersion terms. Type: boolean; Default: false. DO_IND_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT(DFT) computes the \(S^{inf}\) Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC)¶DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SINGLETS (CPHF)¶CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:114727,perform,perform,114727,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"ype: boolean; Default: true. DO_CCD_DISP (SAPT)¶SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC)¶DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC)¶OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DISP_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT(DFT) computes the \(S^{inf}\) Exchange-Dispersion terms. Type: boolean; Default: false. DO_IND_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT(DFT) computes the \(S^{inf}\) Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC)¶DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:115042,perform,perform,115042,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"ype: boolean; Default: true. OPT_COORDINATES (OPTKING); OPTKING — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_METHOD (DFOCC); DFOCC — The orbital optimization algorithm. Presently Quasy Newton-Raphson algorithm avaliable with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC); OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. OPT_TYPE (OPTKING); OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC); DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC); OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (DFOCC); DFOCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORB_RESP_SOLVER (OCC); OCC — The algorithm will be used for solving the orbital-response equations. The LIN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:177073,perform,performed,177073,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"ype: boolean; Default: true. OPT_COORDINATES (OPTKING); OPTKING — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_METHOD (DFOCC); DFOCC — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC); OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. OPT_TYPE (OPTKING); OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC); DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC); OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (DFOCC); DFOCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORB_RESP_SOLVER (OCC); OCC — The algorithm will be used for solving the orbital-response equations. The LIN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:176580,perform,performed,176580,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,4,['perform'],['performed']
Performance,"ype: double; Default: 0.1. ONEPOT_GRID_READ (SCF); SCF — Read an external potential from the .dx file?. Type: boolean; Default: false. OO_SCALE (DFOCC); DFOCC — OO scaling factor used in MSD. Type: double; Default: 0.01. OPDM (DETCI); DETCI — Do compute one-particle density matrix if not otherwise required?. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY); CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (DFMP2); DFMP2 — Do relax the one-particle density matrix?. Type: boolean; Default: true. OPT_COORDINATES (OPTKING); OPTKING — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_METHOD (DFOCC); DFOCC — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC); OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. OPT_TYPE (OPTKING); OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC); DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC); OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (DFOCC); DFOCC — The alg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:177837,optimiz,optimization,177837,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"ype: double; Default: 0.1. ONEPOT_GRID_READ (SCF); SCF — Read an external potential from the .dx file?. Type: boolean; Default: false. OO_SCALE (DFOCC); DFOCC — OO scaling factor used in MSD. Type: double; Default: 0.01. OPDM (DETCI); DETCI — Do compute one-particle density matrix if not otherwise required?. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY); CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (DFMP2); DFMP2 — Do relax the one-particle density matrix?. Type: boolean; Default: true. OPT_COORDINATES (OPTKING); OPTKING — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_METHOD (DFOCC); DFOCC — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC); OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. OPT_TYPE (OPTKING); OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC); DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC); OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (DFOCC); DFOCC — The algor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:176056,optimiz,optimization,176056,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimization']
Performance,"ype: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR —. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA —. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT —. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 —. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 —. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM —. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (MP2); MP2 — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CAS_FILES_WRITE (CLAG); CLAG — Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. CC (DETCI); DETCI — Do coupled-cluster co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:7359,cache,cache,7359,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"ype: integer; Default: 2. CACHELEVEL (DCT)¶DCT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC)¶OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY)¶CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM)¶CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CALC_S_SQUARED (DETCI)¶DETCI — Do calculate the value of \(\langle S^2\rangle\) for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CANONICALIZE_ACTIVE_FAVG (MCSCF)¶MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF)¶MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING)¶OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CARTESIAN_SYM_TOLERANCE (OPTKING)¶OPTKING — Tolerance for symmetrizing cartesian geometry between steps. Type: conv doub",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:11347,cache,cache,11347,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,4,['cache'],['cache']
Performance,"ype: integer; Default: 2. CACHELEVEL (DCT)¶DCT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC)¶OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY)¶CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM)¶CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CALC_S_SQUARED (DETCI)¶DETCI — Do calculate the value of \(\langle S^2\rangle\) for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CANONICALIZE_ACTIVE_FAVG (MCSCF)¶MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF)¶MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING)¶OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CC (DETCI)¶DETCI — Do coupled-cluster computation?. Type: boolean; Default: false. CC3_FOLLOW_ROOT (CCEOM)¶CCEOM — Do tu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:11656,cache,cache,11656,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['cache'],['cache']
Performance,"ype: string; Default: No Default. LOCAL_WEAKP¶. Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. PROP_ALL¶. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes?. Type: boolean; Default: false. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. JOBTYPE¶. Type of job being performed. Type: string; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: SCF. Table Of Contents. CCLAMBDA; General; ABCD; AO_BASIS; CACHELEVEL; DIIS; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; RESTART; ROOTS_PER_IRREP; R_CONVERGENCE; SEKINO; ZETA. Expert; JOBTYPE; WFN. Previous topic; WFN; Next topic; ABCD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__cclambda-1.html:3185,perform,performed,3185,psi4manual/4.0b3/autodir_options_c/module__cclambda-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__cclambda-1.html,4,"['CACHE', 'perform']","['CACHELEVEL', 'performed']"
Performance,"ype: string; Default: No Default. LOCAL_WEAKP¶. Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. PROP_ALL¶. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes?. Type: boolean; Default: false. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. JOBTYPE¶. Type of job being performed. Type: string; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: SCF. Table Of Contents. CCLAMBDA; General; ABCD; AO_BASIS; CACHELEVEL; DIIS; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; RESTART; ROOTS_PER_IRREP; R_CONVERGENCE; SEKINO; ZETA. Expert; JOBTYPE; WFN. Previous topic; WFN; Next topic; ABCD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__cclambda-1.html:3185,perform,performed,3185,psi4manual/4.0b4/autodir_options_c/module__cclambda-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__cclambda-1.html,4,"['CACHE', 'perform']","['CACHELEVEL', 'performed']"
Performance,"ype: string; Possible Values: SOS, SOSPI; Default: SOS. SS_SCALE¶. A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SYMMETRIZE¶. Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5, REMP, OREMP; Default: OMP2. Expert¶. SPIN_SCALE_TYPE¶. Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. table of contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DIIS_MAX_VECS; DIIS_MIN_VECS; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; E_CONVERGENCE; IP_POLES; LEVEL_SHIFT; MAX_MOGRAD_CONVERGENCE; MOGRAD_DAMPING; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; NAT_ORBS; OCC_ORBS_PRINT; OEPROP; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; OS_SCALE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; RELAXED; REMP_A; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_TYPE; SS_SCALE; SYMMETRIZE; TPDM_ABCD_TYPE; WFN_TYPE. Expert; SPIN_SCALE_TYPE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__occ.html:8230,CACHE,CACHELEVEL,8230,psi4manual/master/autodir_options_c/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__occ.html,1,['CACHE'],['CACHELEVEL']
Performance,yp” options. Of; course users can use any DFT functional available in Psi4. Methods¶; The conventional and orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optim,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:6676,Optimiz,Optimized,6676,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['Optimiz'],['Optimized']
Performance,"ys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital q",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/introduction-1.html:6505,optimiz,optimization,6505,psi4manual/4.0b3/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html,6,['optimiz'],"['optimization', 'optimized']"
Performance,"ytest (for installed testing) http://doc.pytest.org/en/latest/; pytest-xdist (for installed testing in parallel) https://docs.pytest.org/en/2.1.0/xdist.html. PSI4 Documentation (available pre-built at psicode.org/psi4manual/master/index.html). Sphinx (3.5+) http://sphinx-doc.org; Perl (for some auto-documentation scripts) https://www.perl.org/; nbsphinx (for converting Jupyter notebooks) http://nbsphinx.readthedocs.io/en/jupyter-theme/; sphinx-psi-theme https://github.com/psi4/sphinx-psi-theme; See [“message” lines] for advice on obtaining docs dependencies. Ambit — https://github.com/jturney/ambit; CheMPS2 — [what is CheMPS2?] [CheMPS2 min version]. HDF5 https://support.hdfgroup.org/HDF5/; zlib http://www.zlib.net/. dkh — [what is dkh?] [dkh min version]. Fortran Compiler. gdma — [what is gdma?] [gdma min version]. Fortran Compiler. PCMSolver — [what is PCMSolver?]. Fortran Compiler; zlib http://www.zlib.net/. simint — [what is simint?] [simint min version]. Additionally, there are runtime-loaded capabilities:. PylibEFP & libefp — [what is LibEFP?] [LibEFP min version]; cfour — [what is CFOUR?]; dftd3 — [what is DFTD3?]; gcp — [what is gCP?]; mrcc — [what is MPCC?]; v2rdm_casscf — [what is v2rdm_casscf?]; sns-mp2 — https://github.com/DEShawResearch/sns-mp2/commits/master; resp — https://github.com/cdsgroup/resp; gpu_dfcc — https://github.com/edeprince3/gpu_dfcc/commits/master; OpenFermion-Psi4 — https://github.com/quantumlib/OpenFermion; cppe — https://github.com/maxscheurer/cppe; mp2d — https://github.com/Chandemonium/MP2D; FockCI — https://github.com/shannonhouck/psi4fockci; cct3 — https://github.com/piecuch-group/cct3; adcc — https://github.com/adc-connect/adcc; BrianQC — https://www.brianqc.com/; i-PI — http://ipi-code.org/; psixas — https://github.com/Masterluke87/psixas; MDI — https://github.com/MolSSI-MDI/MDI_Library. How to use conda to get a Psi4 development environment¶; PSI4 has a lot of dependencies, some of which are complicated; to build. Fortunately,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_planning-1.html:7431,load,loaded,7431,psi4manual/1.4.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_planning-1.html,4,['load'],['loaded']
Performance,"ython/driver.py. For a behind-the-scenes function or if you don’t want the bother of dealing with reStructuredText, just write an ordinary docstring. It will get slurped into the documentation in plain text. Your python function should follow PEP8 conventions (without the line-length restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap_ is suggested. Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the ‘current energy’ variable. This last is needed to communicate with the optimizer.; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25). Once your python function is fairly stable on its own, it’s potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Estab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html:4255,optimiz,optimizer,4255,psi4manual/1.0.0/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html,2,['optimiz'],['optimizer']
Performance,"yword CFOUR_MEM_UNIT. Default: 100 000 000 (approximately 381 or 762 MB for 32 or 64 bit machines, respectively). Psi4 Interface: Keyword set in MB from memory input command when given. Type: integer; Default: 100000000. CFOUR_METHOD (CFOUR)¶CFOUR — Specifies the geometry optimization strategy. Four values are permitted: NR (=0) – Straightforward Newton-Raphson search for minimum; RFA (=1) – Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. CFOUR_MRCC (CFOUR)¶CFOUR — Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY (CFOUR)¶CFOUR — Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING (CFOUR)¶CFOUR — Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:56354,optimiz,optimizations,56354,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,18,['optimiz'],"['optimizations', 'optimizer']"
Performance,"yword is identical to that used in CFOUR_OCCUPATION. For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. CFOUR_ESTATE_TRANS (CFOUR); CFOUR — Specifies whether just the excitation energies (OFF, =0) or in addition transition moments (EXPECTATION, =1) are calculated. Note that this keyword should not be used in excited-state calculations involving analytic gradients and that transition moments are essentially only available for EOM-CCSD/CCSD-LR. Type: string; Possible Values: OFF, EXPECTATION; Default: OFF. CFOUR_EVAL_HESS (CFOUR); CFOUR — Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. CFOUR_EXCITATION (CFOUR); CFOUR — Specifies in CC calculations using mrcc the excitation level if the calculation level has been chosen as CC(n), CI(n), or CCn(n). Type: integer; Default: 0. CFOUR_EXCITE (CFOUR); CFOUR — Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. CFOUR_FC_FIELD (CFOUR); CFOUR — Specifies ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:38737,optimiz,optimization,38737,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimization']
Performance,"ywords is generally independent of; how the geometry of the molecule was input (whether Z-matrix or Cartesian, etc.)..; At this time; however, enforcing Cartesian constraints when using a zmatrix for; molecular input is not supported. Freezing or constraining Cartesian coordinates; requires Cartesian molecule input. If numerical errors results in symmetry; breaking, while Cartesian constraints are active, symmetrization cannot occur and; an error will be raised, prompting you to restart the job. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. lower_bound = [99.99, 109.99, 119.99, 129.99, 149.99]; upper_bound = [100, 110, 120, 130, 140, 150]; PES = []. for lower, upper in zip(lower_bound, upper_bound):; my_string = f""1 2 3 4 {lower} {upper}""; set optking ranged_dihedral = $my_string; E = optimize('scf'); PES.append((upper, E)). print(""\n\tcc-pVDZ SCF energy as a function of phi\n""); for point in PES:; print(""\t%5.1f%20.10f"" % (point[0], point[1])). To scan the potential energy surface without the RANGED_DIHEDRAL keyword, a zmatrix; can be used. Warning; Rotating dihedrals in large increments without allowing the molecule to relax; in between increments can lead to unphysical geometries with overlapping functional groups in larger molecules,; which may prevent successful constrained optimzations. Furthermore, such a relaxed scan of the PES does; not always procude a result close to an IRC, or even a reaction path along which the energy changes in a; continuous way. molecule hooh {; 0 1; H; O 1 0.95; O 2 1.39 1 103; H 3 0.95 2 103 1 D. D = 99. units ang; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; frozen_dihedral ("" 1 2 3 4 ""); }. dihedrals = [100, 110, 120, 130, 140, 150]; PES = []. for phi in dihedrals:;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:7517,optimiz,optimize,7517,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['optimiz'],['optimize']
Performance,"yz files; using the script :source:`lib/scripts/ixyz2database.pl`.; See :ref:`sec:createDatabase` for details. .. caution:: Some features are not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching the name of a python file in ``psi4/lib/databases``.; Consult that directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:24117,perform,performed,24117,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['perform'],['performed']
Performance,"yz2database.py.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – \(\Rightarrow\) energy \(\Leftarrow\) || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/db-1.html:1827,optimiz,optimize,1827,psi4manual/1.1.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/db-1.html,12,"['optimiz', 'perform']","['optimize', 'performed']"
Performance,"y¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequency-1.html:1143,perform,performs,1143,psi4manual/1.4.0/api/psi4.driver.frequency-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequency-1.html,5,['perform'],['performs']
Performance,"z Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/opt-1.html:7065,optimiz,optimization,7065,psi4manual/4.0b4/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html,4,['optimiz'],['optimization']
Performance,"zabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. GAUGE¶. Specifies the choice of representation of the electric dipole operator. For polarizability, this keyword is ignored and LENGTH gauge is computed. For optical rotation and raman optical activity, this keyword is active, and acceptable values are LENGTH for the usual length-gauge representation, VELOCITY``(default) for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or ``BOTH. Note that, for optical rotation and raman optical activity calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: VELOCITY. table of contents. CC: Coupled Cluster Theory; Basic Keywords; REFERENCE; R_CONVERGENCE; MAXITER; BRUECKNER_ORBS_R_CONVERGENCE; RESTART; CACHELEVEL; CACHETYPE; NUM_AMPS_PRINT; MP2_AMPS_PRINT. Larger Calculations; Excited State Coupled Cluster Calculations; ROOTS_PER_IRREP; E_CONVERGENCE; SINGLES_PRINT; SCHMIDT_ADD_RESIDUAL_TOLERANCE; EOM_GUESS. Linear Response (CCLR) Calculations; PROPERTY; OMEGA; GAUGE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; CC: Coupled Cluster Theory. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cc.html:11245,CACHE,CACHELEVEL,11245,psi4manual/1.6.x/cc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cc.html,2,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"zation engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:63384,optimiz,optimization,63384,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"zation fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:59396,Optimiz,Optimize,59396,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Optimiz'],['Optimize']
Performance,"zation in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES¶. The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS¶. The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. TIKHONOW_OMEGA¶. The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. table of contents. DCT; General; ALGORITHM; AO_BASIS; DCT_FUNCTIONAL; DCT_TYPE; DF_BASIS_DCT; DIIS_START_CONVERGENCE; E_CONVERGENCE; GUESS_R_CONVERGENCE; MAXITER; ODC_GUESS; OPDM; QC_COUPLING; QC_TYPE; REFERENCE; RESPONSE_ALGORITHM; R_CONVERGENCE; THREE_PARTICLE. Expert; CACHELEVEL; DAMPING_PERCENTAGE; DCT_GUESS; DIIS_MAX_VECS; DIIS_MIN_VECS; ENERGY_LEVEL_SHIFT; INTS_TOLERANCE; ORBITAL_LEVEL_SHIFT; RELAX_GUESS_ORBITALS; STABILITY_ADD_VECTORS; STABILITY_AUGMENT_SPACE_TOL; STABILITY_CHECK; STABILITY_CONVERGENCE; STABILITY_MAX_SPACE_SIZE; STABILITY_N_EIGENVALUES; STABILITY_N_GUESS_VECTORS; TIKHONOW_OMEGA. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; DCT. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__dct.html:7089,CACHE,CACHELEVEL,7089,psi4manual/1.8.x/autodir_options_c/module__dct.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__dct.html,1,['CACHE'],['CACHELEVEL']
Performance,"zation in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES¶. The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS¶. The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. TIKHONOW_OMEGA¶. The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. table of contents. DCT; General; ALGORITHM; AO_BASIS; DCT_FUNCTIONAL; DCT_TYPE; DF_BASIS_DCT; DIIS_START_CONVERGENCE; E_CONVERGENCE; GUESS_R_CONVERGENCE; MAXITER; ODC_GUESS; OPDM; QC_COUPLING; QC_TYPE; REFERENCE; RESPONSE_ALGORITHM; R_CONVERGENCE; THREE_PARTICLE. Expert; CACHELEVEL; DAMPING_PERCENTAGE; DCT_GUESS; DIIS_MAX_VECS; DIIS_MIN_VECS; ENERGY_LEVEL_SHIFT; INTS_TOLERANCE; ORBITAL_LEVEL_SHIFT; RELAX_GUESS_ORBITALS; STABILITY_ADD_VECTORS; STABILITY_AUGMENT_SPACE_TOL; STABILITY_CHECK; STABILITY_CONVERGENCE; STABILITY_MAX_SPACE_SIZE; STABILITY_N_EIGENVALUES; STABILITY_N_GUESS_VECTORS; TIKHONOW_OMEGA. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; DCT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__dct.html:7089,CACHE,CACHELEVEL,7089,psi4manual/1.9.x/autodir_options_c/module__dct.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__dct.html,1,['CACHE'],['CACHELEVEL']
Performance,"zation potentials? Only valid OMP2. Type: boolean; Default: false. LEVEL_SHIFT¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MOGRAD_DAMPING¶. Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation paramete",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__occ.html:4146,optimiz,optimization,4146,psi4manual/1.6.x/autodir_options_c/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__occ.html,1,['optimiz'],['optimization']
Performance,"ze the cartesian coordinates of atom 2; freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3; freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4; set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:7606,optimiz,optimize,7606,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['optimiz'],['optimize']
Performance,"zed for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; # all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC bi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:1496,load,loaded,1496,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,8,['load'],['loaded']
Performance,"zed second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Algebraic-Diagrammatic Construction methods (ADC)¶; General ADC theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid development of; algebraic-diagrammatic construction methods,”; M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.; WIREs Comput. Mol. Sci., (2020).; (DOI: 10.1002/wcms.1462, Preprint https://adc-connect.org/q/publications. Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-source spin-adapted implementation of the density; matrix renormalization group for ab initio quantum chemistry,”; S. Wouters, W. P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:19950,optimiz,optimized,19950,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,4,['optimiz'],['optimized']
Performance,"zed second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Algebraic-Diagrammatic Construction methods (ADC)¶; General ADC theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid development of; algebraic-diagrammatic construction methods,”; M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.; WIREs Comput. Mol. Sci., (2020).; (DOI: 10.1002/wcms.1462, Preprint https://adc-connect.org/q/publications. “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and the implementation for ADC(2) excitation energies within PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:19501,optimiz,optimized,19501,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,5,['optimiz'],['optimized']
Performance,"zed second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-source spin-adapted implementation of the density; matrix renormalization group for ab initio quantum chemistry,”; S. Wouters, W. Poe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:16421,optimiz,optimized,16421,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,6,['optimiz'],['optimized']
Performance,"zed second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in Psi4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-source spin-adapted implementation of the density; matrix renormalization group for ab initio quantum chemistry,”; S. Wouters, W. Poe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:14117,optimiz,optimized,14117,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,2,['optimiz'],['optimized']
Performance,"zen-Core Operator'; moH = core.Matrix(PSIF_MO_FZC, wfn.nmopi(), wfn.nmopi()); moH.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, frzcpi+active_mopi); MO_FZC = moH.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = mo_idx(il[0][index] + offset); col = mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_A = moH_A.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_A.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = alpha_mo_idx(il[0][index] + offset); col = alpha_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; PSIF_MO_B_FZC = 'MO-basis Beta Frozen-Core Oper'; moH_B = core.Matrix(PSIF_MO_B_FZC, wfn.nmopi(), wfn.nmopi()); moH_B.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_B = moH_B.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html:6241,load,load,6241,psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,5,['load'],['load']
Performance,"{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). table of contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:22250,optimiz,optimization,22250,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; 1; 2>>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). 1; 2>>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). 1; 2>>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; 1; 2>>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). 1; 2>>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). table of contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:20483,optimiz,optimization,20483,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"| 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:2886,Optimiz,Optimizations,2886,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['Optimiz'],['Optimizations']
Performance,"| 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. 1; 2>>> # [1] Analytic hf optimization;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:3028,Optimiz,Optimizations,3028,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,4,['Optimiz'],['Optimizations']
Performance,"| 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:2615,Optimiz,Optimizations,2615,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,4,['Optimiz'],['Optimizations']
Performance,"| 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:2382,Optimiz,Optimizations,2382,psi4manual/1.1.0/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html,2,['Optimiz'],['Optimizations']
Performance,"| basis1; | The basis set on center one; | ; | basis2; | The basis set on center two; | ; | origin; | The origin about which the one body ints are being computed.; | ; | py_buffer; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Localizer(Boost.Python.instance); | docstring; | ; | Method resolution order:; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | ----------------------------------------------------------------------; | Static methods defined here:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | ----------------------------------------------------------------------; | Data descriptors defined here:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/psimod-1.html:68913,Perform,Perform,68913,psi4manual/4.0b5/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/psimod-1.html,2,['Perform'],['Perform']
Performance,"} \rangle + \cdots\]; The simplest standard CI method that improves upon Hartree–Fock is a CI; that adds all singly \(| \Phi_i^a \rangle\) and doubly; \(| \Phi_{ij}^{ab} \rangle\); substituted determinants (CISD) to the reference determinant; \(| \Phi_0 \rangle\). The CISD wavefunction has fallen out of favor; because truncated CI wavefunctions are not size-extensive, meaning; that their quality degrades for larger molecules. MP2 is a less; expensive alternative giving results similar to those of CISD for small; molecules, but the quality of MP2 does not degrade for larger molecules.; Coupled-cluster singles and doubles (CCSD) is another size-extensive; alternative; it is only slightly more costly computationally than CISD,; but it typically provides significantly more accurate results.; The CI code in PSI4 is described in detail in; [Sherrill:1999:CI]. For the reasons stated above, the CI code in; PSI4 is not optimized for CISD computations, and it uses data structures; that are particularly inefficient for CISD and may result in the program; running out of memory and crashing for CISD except on very small molecules.; Instead, DETCI was designed to be efficient; in handling more highly correlated CI wavefunctions that can be helpful in more; challenging cases such as highly strained molecules or bond breaking reactions. The CI; code is based on the fast, determinant-based string formalism; of Handy [Handy:1980]. It can solve for restricted active space; configuration interaction (RAS CI) wavefunctions as described by Olsen,; Roos, Jorgensen, and Aa. Jensen [Olsen:1988]. Excitation-class; selected multi-reference CI wavefunctions, such as second-order CI,; can be formulated as RAS CI’s. A RAS CI selects determinants for the; model space as those which have no more than \(n\) holes in the lowest set; of orbitals (called RAS I) and no more than \(m\) electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/detci.html:2133,optimiz,optimized,2133,psi4manual/master/detci.html,https://psicode.org,https://psicode.org/psi4manual/master/detci.html,9,['optimiz'],['optimized']
Performance,"}\]. \[A_{pq,rs} = \frac{\partial^2 \widetilde{E}}{\partial \kappa_{pq} \partial \kappa_{rs}}\]; Then the energy can be expanded up to second-order as follows. \[\widetilde{E}^{(2)}({\bf \kappa}) = \widetilde{E}^{(0)} + {\bf \kappa^{\dagger} w} + \frac{1}{2}~{\bf \kappa^{\dagger} A \kappa}\]; where \({\bf w}\) is the MO gradient vector, \({\bf \kappa}\) is the MO rotation vector,; and \({\bf A}\) is the MO Hessian matrix. Therefore, minimizing the energy with respect to \({\bf \kappa}\); yields. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:8677,optimiz,optimized,8677,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,11,['optimiz'],['optimized']
Performance,"}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The additional correction to the SCF reference energy [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [Eh] from the polarizable continuum model for solvation. PE ENERGY¶; The energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:34069,optimiz,optimized,34069,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['optimiz'],['optimized']
Performance,"~/.psi4rc File¶; If using the environment variable PSI_SCRATCH is inconvenient,; or if some psi4_io commands must be present in all input files,; the ~/.psi4rc resource file can be used (example psi4/samples/example_psi4rc_file).; All the commands mentioned in section Scratch Files and Elementary Restart can be used in this file.; To set up the scratch path:; 1psi4_io.set_default_path('/scratch/user'). To set up the scratch path from a variable $MYSCRATCH:; 1; 2; 3; 4import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). To set up a specific path for the checkpoint file and instruct PSI4 not to delete it:; 1; 2; 3; 4; 5; 6psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). # equivalent to above; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instructions in the ~/.psi4rc file. During; execution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed.; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and C++; std::thread for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:8957,perform,performing,8957,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,4,['perform'],['performing']
Performance,"   .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_builtins.pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.symmetryoperation.html:1037,Perform,Performs,1037,psi4manual/1.2.1/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.symmetryoperation.html,1,['Perform'],['Performs']
Performance,"   .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; prop. prop¶. psi4.driver.prop(*args, **kwargs)¶; Function to compute various properties. Aliases; prop(). Returns; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.prop-1.html:994,optimiz,optimized,994,psi4manual/1.4.0/api/psi4.driver.prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.prop-1.html,2,['optimiz'],['optimized']
Performance,"   .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; prop. prop¶. psi4.driver.prop(*args, **kwargs)¶; Function to compute various properties. Aliases; prop(). Returns; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.prop-1.html:994,optimiz,optimized,994,psi4manual/1.5.0/api/psi4.driver.prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.prop-1.html,2,['optimiz'],['optimized']
Performance,"   .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; prop. prop¶. psi4.driver.prop(*args, **kwargs)¶; Function to compute various properties. Aliases; prop(). Returns; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.prop.html:994,optimiz,optimized,994,psi4manual/1.6.x/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.prop.html,1,['optimiz'],['optimized']
Performance,"   .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.SymmetryOperation.html:1040,Perform,Performs,1040,psi4manual/1.7.x/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,"   .    .  · ; 1.6;  · . PSI4. Appendices; Test Suite and Sample Inputs. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. tdscf-7; TD-HF test variable access. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). tdscf-4; td-wb97x singlet excitation energies of methylene (tda). fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. tdscf-1; td-uhf test on triplet states of methylene (rpa). zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cubeprop; RHF orbitals and density for water. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure compu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/testsuite.html:1011,perform,performs,1011,psi4manual/1.6.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/testsuite.html,2,"['optimiz', 'perform']","['optimization', 'performs']"
Performance,"   .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module. DFMP2¶; Performs density-fitted MP2 computations for RHF/UHF/ROHF reference wavefunctions. General¶. BASIS¶. Primary basis set. Type: string; Possible Values: basis string; Default: NONE. DFMP2_MEM_FACTOR¶. % of memory for DF-MP2 three-index buffers. Type: double; Default: 0.9. DFMP2_P2_TOLERANCE¶. Minimum error in the 2-norm of the P(2) matrix for corrections to Lia and P. Type: conv double; Default: 0.0. DFMP2_P_TOLERANCE¶. Minimum error in the 2-norm of the P matrix for skeleton-core Fock matrix derivatives. Type: conv double; Default: 0.0. DF_BASIS_MP2¶. Auxiliary basis set for MP2 density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_INTS_NUM_THREADS¶. Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. MP2_OS_SCALE¶. OS Scale. Type: double; Default: 6.0. MP2_SS_SCALE¶. SS Scale. Type: double; Default: 1.0. ONEPDM¶. Do compute one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: true. Expert¶. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. MADMP2_SLEEP¶. A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. table of contents. DFMP2; General; BASIS; DFMP2_MEM_FACTOR; DFMP2_P2_TOLERANCE; DFMP2_P_TOLERANCE; DF_BASIS_MP2; DF_INTS_NUM_THREADS; INTS_TOLERANCE; MP2_OS_SCALE; MP2_SS_SCALE; ONEPDM; OPDM_RELAX. Expert; DF_INTS_IO; MADMP2_SLEEP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfmp2-1.html:1442,LOAD,LOAD,1442,psi4manual/1.3.2/autodir_options_c/module__dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfmp2-1.html,2,['LOAD'],['LOAD']
Performance," .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; prop. prop¶. psi4.driver.prop(*args, **kwargs)¶; Function to compute various properties. Aliases:; prop(). Returns:; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.prop.html:996,optimiz,optimized,996,psi4manual/1.7.x/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.prop.html,1,['optimiz'],['optimized']
Performance," .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SymmetryOperation.html:1042,Perform,Performs,1042,psi4manual/1.8.x/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance," .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → Annotated[List[Annotated[List[float], FixedSize(3)]], FixedSize(3)]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html:1042,Perform,Performs,1042,psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance," .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; CFOUR. CFOUR¶. Input File; Description. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/sp-rohf-scf; single-point HF/qz2p o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html:1037,optimiz,optimization,1037,psi4manual/1.9.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance," ; PSI4 [beta4] » ; Appendices »; Keywords by Module ». CCENERGY¶; Computes coupled cluster energies. Called as part of any coupled cluster computation. General¶. ABCD¶. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. LOCAL¶. Do simulate the effec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html:1117,cache,cache,1117,psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html,2,['cache'],['cache']
Performance," arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:2896,Perform,Perform,2896,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['Perform'],['Perform']
Performance," dim1, dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_list(x). from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm(self, transa, transb, alpha, a, b, beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. partial_cholesky_factorize(self, delta, …); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha, cutoff); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self, RMRoutfile); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:2723,load,load,2723,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,2,['load'],['load']
Performance," dim1, dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_list(x). from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm(self, transa, transb, alpha, a, b, beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.matrix.html:2753,load,load,2753,psi4manual/1.5.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.matrix.html,2,['load'],['load']
Performance," oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. filter_comments(string); Remove from string any Python-style comments (‘#’ to end of line). find_approximate_string_matches(seq1, …); Function to compute approximate string matches from a list of options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:260537,optimiz,optimize,260537,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['optimiz'],['optimize']
Performance,"¶. Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_SCF_GUESS¶. Do a density fitting SCF calculation to converge the orbitals before switching to the use of exact integrals in a SCF_TYPE DIRECT calculation. Type: boolean; Default: true. GUESS¶. The type of guess orbitals. Defaults to READ for geometry optimizations after the first step, to CORE for single atoms, and to SAD otherwise. The HUCKEL guess employs on-the-fly calculations like SAD, as described in doi:10.1021/acs.jctc.8b01089. Type: string; Possible Values: AUTO, CORE, GWH, SAD, HUCKEL, READ; Default: AUTO. GUESS_MIX¶. Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. PRINT_BASIS¶. Do print the basis set?. Type: boolean; Default: false. PRINT_MOS¶. Do print the molecular orbitals?. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html:1587,optimiz,optimization,1587,psi4manual/1.3.2/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html,2,['optimiz'],['optimization']
Performance,"¶. CANONICALIZE_ACTIVE_FAVG¶. Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG¶. Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CI_DIIS¶. Do use DIIS extrapolation to accelerate convergence of the CI coefficients?. Type: boolean; Default: false. DIIS¶. Do use DIIS extrapolation to accelerate convergence of the SCF energy (MO coefficients only)?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DOCC¶. The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. D_CONVERGENCE¶. Convergence criterion for density, as measured by the orbital gradient. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-6. FAVG¶. Do use the average Fock matrix during the SCF optimization?. Type: boolean; Default: false. FAVG_START¶. Iteration at which to begin using the averaged Fock matrix. Type: integer; Default: 5. FOLLOW_ROOT¶. Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FORCE_TWOCON¶. Do attempt to force a two configuration solution by starting with CI coefficents of \(\pm \sqrt{\frac{1}{2}}\) ?. Type: boolean; Default: false. INTERNAL_ROTATIONS¶. Do consider internal rotations?. Type: boolean; Default: true. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.0. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MO_READ¶. Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF, TWOCON, MCSCF, GENERAL; Default: RHF. SOCC¶. The number of singly occupied orbitals, per irrep. Type: array; Default: No Default. TURN_ON_ACTV¶. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__mcscf-1.html:1287,optimiz,optimization,1287,psi4manual/1.3.2/autodir_options_c/module__mcscf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__mcscf-1.html,11,['optimiz'],['optimization']
Performance,"¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: false. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. HESS_TYPE¶. Type Hessian matrix will be used in orbital optimization procedure. Type: string; Possible Values: NONE; Default: NONE. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html:1186,perform,perform,1186,psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"¶. Debye-Hückel parameter of the solvent to use. Ignored if DDX_MODEL is not LPB; mandatory for LPB. Uses the unit of the molecule (i.e. either ang^{-1} or bohr^{-1}). Type: double; Default: 0. Numerical integration and discretisation parameters¶; These parameters can be altered to balance the cost and accuracy; of the implict description of the solvation.; DDX_SOLUTE_RADIAL_POINTS and DDX_SOLUTE_SPHERICAL_POINTS influence; the accuracy of the numerical grid used to obtain the representation; of the electric potential / field of the solute density,; since a standard DFT integration grid is used to obtain these quantities.; In contrast to the integration of DFT quantities much lower accuracy; is required, such that for this step considerably smaller grids are employed.; If extremely high accuracy reference solutions are required, the DDX; DFT integration parameters might need to be increased, but this is rarely needed.; DDX_LMAX and DDX_N_LEBEDEV determine the accuracy of the computations; on the boundary of the spheres around each atom performed by DDX. DDX_LMAX; determines the largest angular momentum of the spherical harmonics basis used; to discretise quantities on the atomic spheres and DDX_N_LEBEDEV determines the; number of points of the Lebedev angular grid used for integration on the spheres.; DDX_N_LEBEDEV should be chosen higher than DDX_SOLUTE_SPHERICAL_POINTS; and the defaults are usually good. DDX_SOLUTE_RADIAL_POINTS¶. Number of radial points used to compute the integrals for DDX calculations. Type: integer; Default: 35. DDX_SOLUTE_SPHERICAL_POINTS¶. Number of spherical points used to compute the solute electric potential/field integrals for DDX calculations (A Lebedev Points number). Type: integer; Default: 110. DDX_LMAX¶. Maximal degree of modelling spherical harmonics. Type: integer; Default: 9. DDX_N_LEBEDEV¶. Number of Lebedev grid points to use. (A Lebedev Points number). Type: integer; Default: 302. Iterative solver parameters¶; These parameters",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/ddx.html:7656,perform,performed,7656,psi4manual/master/ddx.html,https://psicode.org,https://psicode.org/psi4manual/master/ddx.html,3,['perform'],['performed']
Performance,¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized linearized coupled cluster; doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2 level of theory. OMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2.5 level of theory. OMP2.5 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP3 level of theory. OMP3 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP3 level of theory. OREMP2 TOTAL ENERGY¶. OREMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized retaining-the-excitation-degree Møller–Plesset; hybrid perturbation theory level. OREMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized retain,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:43049,optimiz,optimized,43049,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,4,['optimiz'],['optimized']
Performance,"¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indices specified above (\(0.0\ge occ \ge 1.0\)). Type: array; Default: No Default. Environmental Effects¶. EXTERN¶. An ExternalPotential (built by Python or NULL/None). Type: python; Default: No Default. ONEP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html:6678,perform,perform,6678,psi4manual/1.1.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indices specified above (\(0.0\ge occ \ge 1.0\)). Type: array; Default: No Default. Environmental Effects¶. EXTERN¶. An ExternalPotential (built by Python or nullptr/None). Type: boolean; Default: false. ONEPO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__scf-1.html:6301,perform,perform,6301,psi4manual/1.2.1/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"¶. The type of guess orbitals. Type: string; Possible Values: CORE, GWH, SAD, READ; Default: CORE. INTS_TOLERANCE¶. Minimum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE¶. What algorithm to use for the SCF computation. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: PK. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 100.0. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_START¶. The minimum iteration to start storing DIIS vectors. Type: integer; Default: 1. D_CONVERGENCE¶. Convergence criterion for SCF density. Type: conv ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__scf-1.html:1637,perform,performed,1637,psi4manual/4.0b2/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__scf-1.html,2,['perform'],['performed']
Performance,"¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples:. >>> # [1] Frequency cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.frequency-1.html:1135,perform,performs,1135,psi4manual/1.3.2/api/psi4.driver.frequency-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.frequency-1.html,2,['perform'],['performs']
Performance,"¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html:1113,perform,performs,1113,psi4manual/1.1.0/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequency.html,3,['perform'],['performs']
Performance,"¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:6119,optimiz,optimize,6119,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,4,['optimiz'],['optimize']
Performance,"¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optking-1.html:5793,optimiz,optimize,5793,psi4manual/4.0b4/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html,4,['optimiz'],['optimize']
Performance,"¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:5833,optimiz,optimize,5833,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimize']
Performance,"¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2; freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3; freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:5845,optimiz,optimize,5845,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['optimiz'],['optimize']
Performance,"¶; Overloaded function. shell(self: psi4.core.BasisSet, arg0: int) -> psi4.core.GaussianShell. docstring. shell(self: psi4.core.BasisSet, arg0: int, arg1: int) -> psi4.core.GaussianShell. docstring. shell_to_ao_function(self: psi4.core.BasisSet, arg0: int) → int¶; docstring. shell_to_basis_function(self: psi4.core.BasisSet, arg0: int) → int¶; docstring. shell_to_center(self: psi4.core.BasisSet, arg0: int) → int¶; docstring. zero_ao_basis_set() → psi4.core.BasisSet¶; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. class psi4.core.BasisSetParser¶; Bases: object; docstring. class psi4.core.BoysLocalizer¶; Bases: psi4.core.Localizer; docstring. L¶; Localized orbital coefficients. U¶; Orbital rotation matrix. build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix) → psi4.core.Localizer¶; docstring. converged¶; Did the localization procedure converge?. localize(self: psi4.core.Localizer) → None¶; Perform the localization procedure. class psi4.core.CIVector¶; Bases: object; docstring. axpy(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int, arg3: int) → None¶; docstring. close_io_files(self: psi4.core.CIVector, arg0: int) → None¶; docstring. copy(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int) → None¶; docstring. dcalc(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int) → float¶; docstring. divide(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: float, arg2: int, arg3: int) → None¶; docstring. init_io_files(self: psi4.core.CIVector, arg0: bool) → None¶; docstring. norm(self: psi4.core.CIVector, arg0: int) → float¶; docstring. np¶; Returns a view of the CIVector’s buffer. read(self: psi4.core.CIVector, arg0: int, arg1: int) → int¶; docstring. scale(self: psi4.core.CIVector, arg0: float, arg1: int) → None¶; docstring. set_nvec(self: psi4.core.CIVector, arg0: int) → None¶; docstring. shift(self: psi4.core.CI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:4696,Perform,Perform,4696,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['Perform'],['Perform']
Performance,"¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. E(self: psi4.core.SymmetryOperation) → None; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.symmetryoperation.html:2698,Perform,Performs,2698,psi4manual/1.3.2/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.symmetryoperation.html,1,['Perform'],['Performs']
Performance,"¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. class psi4.core.TaskListComputer¶; Bases: pybind11_builtins.pybind11_object; docstring. set_title(self: psi4.core.TaskListComputer, arg0: str) → None¶; docstring. class psi4.core.ThreeCenterOverlapInt¶; Bases: pybind11_builtins.pybind11_object; Three center overlap integrals. compute_shell(self: psi4.core.ThreeCenterOverlapInt, arg0: int, arg1: int, arg2: int) → None¶; Compute the integrals of the form (a|b|c). class psi4.core.TracelessQuadrupoleInt¶; Bases: psi4.core.OneBodyAOInt; Computes traceless quadrupole integrals. basis¶; The basis set on center one. basis1¶; The basis set on center one. basis2¶; The basis set on center two. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int) → None¶; Compute integrals between basis functions in the given shell pair. origin¶; The origin ab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:239394,Perform,Performs,239394,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['Perform'],['Performs']
Performance,"¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. table of contents. SymmetryOperation; SymmetryOperation; SymmetryOperation.E(); SymmetryOperation.c2_x(); SymmetryOperation.c2_y(); SymmetryOperation.c2_z(); SymmetryOperation.i(); SymmetryOperation.matrix(); SymmetryOperation.operate(); SymmetryOperation.rotate_n(); SymmetryOperation.rotate_theta(); SymmetryOperation.sigma_xy(); SymmetryOperation.sigma_xz(); SymmetryOperation.sigma_yz(); SymmetryOperation.trace(); SymmetryOperation.transform(); SymmetryOperation.transpose(); SymmetryOperation.unit(); SymmetryOperation.zero(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.SymmetryOperation.html:2750,Perform,Performs,2750,psi4manual/master/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,"¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. table of contents. SymmetryOperation; SymmetryOperation; SymmetryOperation.E(); SymmetryOperation.c2_x(); SymmetryOperation.c2_y(); SymmetryOperation.c2_z(); SymmetryOperation.i(); SymmetryOperation.matrix(); SymmetryOperation.operate(); SymmetryOperation.rotate_n(); SymmetryOperation.rotate_theta(); SymmetryOperation.sigma_xy(); SymmetryOperation.sigma_xz(); SymmetryOperation.sigma_yz(); SymmetryOperation.trace(); SymmetryOperation.transform(); SymmetryOperation.transpose(); SymmetryOperation.unit(); SymmetryOperation.zero(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SymmetryOperation.html:2699,Perform,Performs,2699,psi4manual/1.8.x/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,"¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. table of contents. SymmetryOperation; SymmetryOperation; SymmetryOperation.E(); SymmetryOperation.c2_x(); SymmetryOperation.c2_y(); SymmetryOperation.c2_z(); SymmetryOperation.i(); SymmetryOperation.matrix(); SymmetryOperation.operate(); SymmetryOperation.rotate_n(); SymmetryOperation.rotate_theta(); SymmetryOperation.sigma_xy(); SymmetryOperation.sigma_xz(); SymmetryOperation.sigma_yz(); SymmetryOperation.trace(); SymmetryOperation.transform(); SymmetryOperation.transpose(); SymmetryOperation.unit(); SymmetryOperation.zero(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html:2743,Perform,Performs,2743,psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,"¶; Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. psi4.core.has_scalar_variable(arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:284034,optimiz,optimized,284034,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['optimiz'],['optimized']
Performance,"øller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). 1; 2; 3; 4; 5; 6; 7; 8>>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:4524,optimiz,optimization,4524,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"øller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix – Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. 1; 2; 3; 4; 5; 6>>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:4311,optimiz,optimization,4311,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. omp2.5[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. omp3[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. oremp2[4]; CC_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. olccd[4]; CC_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-core F. [3]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [4]; (1,2,3,4,5); Also available for DFT references RKS/UKS. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:12335,Optimiz,Optimized,12335,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['Optimiz'],['Optimized']
Performance,"̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. mp3; MP_TYPE; ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. remp2; CC_TYPE; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. lccd; CC_TYPE; ✓; ✓; ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ccd; CC_TYPE. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ccsd; CC_TYPE. ✓; ✓; ✓; ✓. ✓̲; ✓̲. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ccsd(t); CC_TYPE. ✓; ✓; ✓; ✓. ✓̲; ✓̲. a-ccsd(t)[8]; CC_TYPE. ✓̲; ✓̲; ✓̲; ✓̲. [5]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [6]; Active orbital values to the right: all-electron A and frozen-core F. [7]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [8]; a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L. table of contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced OCC Keywords; OPT_METHOD; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Basic DFOCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ORB_OPT. Advanced DFOCC Keywords; OPT_METHOD; HESS_TYPE; MO_DIIS_NUM_VECS; ORTH_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Theoretical Methods: SCF to FCI; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/occ.html:21483,Optimiz,Optimized,21483,psi4manual/1.8.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/occ.html,2,['Optimiz'],['Optimized']
Performance,"̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. mp3; MP_TYPE; ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. remp2; CC_TYPE; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. lccd; CC_TYPE; ✓; ✓; ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ccd; CC_TYPE. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ccsd; CC_TYPE. ✓; ✓; ✓; ✓. ✓̲; ✓̲. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ccsd(t); CC_TYPE. ✓; ✓; ✓; ✓. ✓̲; ✓̲. a-ccsd(t)[8]; CC_TYPE. ✓̲; ✓̲; ✓̲; ✓̲. [5]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [6]; Active orbital values to the right: all-electron A and frozen-core F. [7]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [8]; a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L. table of contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced OCC Keywords; OPT_METHOD; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Basic DFOCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ORB_OPT. Advanced DFOCC Keywords; OPT_METHOD; HESS_TYPE; MO_DIIS_NUM_VECS; ORTH_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Theoretical Methods: SCF to FCI; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/occ.html:21483,Optimiz,Optimized,21483,psi4manual/1.9.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/occ.html,2,['Optimiz'],['Optimized']
Performance,"–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). 1; 2; 3; 4; 5; 6; 7; 8>>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:12741,perform,perform,12741,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,8,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"— Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique available option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS); GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_ATTEMPTS (SCF); SCF (Expert) — When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. MAX_CCD_DIISVECS (SAPT); SAPT — Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MAX_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. MAX_MEM_BUF (SCF); SCF — Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MAX_MOGRAD_CONVERGENCE (DFOCC); DFOCC — Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MAX_MOGRAD_CONVERGENCE (OCC); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:154201,optimiz,optimization,154201,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimization']
Performance,"— Memory safety factor for allocating JK. Type: double; Default: 0.75. CPHF_TASKS (CPHF); CPHF — Which tasks to run CPHF For * Valid choices: * -Polarizability *. Type: array; Default: No Default. CUTOFF (OCC); OCC — Cutoff value for numerical procedures. Type: integer; Default: 14. D_CONVERGENCE (DFTSAPT); DFTSAPT — Convergence criterion for residual of the CPKS coefficients in the SAPT * term. Type: conv double; Default: 1e-8. D_CONVERGENCE (MCSCF); MCSCF — Convergence criterion for density. Type: conv double; Default: 1e-6. D_CONVERGENCE (SAPT); SAPT — Convergence criterion for residual of the CPHF coefficients in the SAPT term. Type: conv double; Default: 1e-8. D_CONVERGENCE (SCF); SCF — Convergence criterion for SCF density, which is defined as the RMS value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. DAMPING_CONVERGENCE (SCF); SCF — The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE (DCFT); DCFT (Expert) — The amount (percentage) of damping to apply to the orbital update procedure: 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DAMPING_PERCENTAGE (PSIMRCC); PSIMRCC — The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DAMPING_PERCENTAGE (S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:21394,perform,performed,21394,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"— SS vectors stored per root. Type: integer; Default: 5. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. STABILITY_AUGMENT_SPACE_TOL (DCFT); DCFT (Expert) — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCFT); DCFT (Expert) — Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCFT); DCFT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCFT); DCFT (Expert) — The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES (DCFT); DCFT (Expert) — The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS (DCFT); DCFT (Expert) — The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STEP_TYPE (OPTKING); OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. T (T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:124625,Perform,Performs,124625,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['Perform'],['Performs']
Performance,"— SS vectors stored per root. Type: integer; Default: 5. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. STABILITY_AUGMENT_SPACE_TOL (DCFT); DCFT (Expert) — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCFT); DCFT (Expert) — Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCFT); DCFT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCFT); DCFT (Expert) — The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES (DCFT); DCFT (Expert) — The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS (DCFT); DCFT (Expert) — The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STEP_TYPE (OPTKING); OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. T (THERMO); THERMO — Te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:119271,Perform,Performs,119271,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['Perform'],['Performs']
Performance,"’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES¶. The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS¶. The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. TIKHONOW_OMEGA¶. The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. table of contents. DCT; General; ALGORITHM; AO_BASIS; DCT_FUNCTIONAL; DCT_TYPE; DF_BASIS_DCT; DIIS_START_CONVERGENCE; E_CONVERGENCE; GUESS_R_CONVERGENCE; MAXITER; ODC_GUESS; OPDM; QC_COUPLING; QC_TYPE; REFERENCE; RESPONSE_ALGORITHM; R_CONVERGENCE; THREE_PARTICLE. Expert; CACHELEVEL; DAMPING_PERCENTAGE; DCT_GUESS; DIIS_MAX_VECS; DIIS_MIN_VECS; ENERGY_LEVEL_SHIFT; INTS_TOLERANCE; ORBITAL_LEVEL_SHIFT; RELAX_GUESS_ORBITALS; STABILITY_ADD_VECTORS; STABILITY_AUGMENT_SPACE_TOL; STABILITY_CHECK; STABILITY_CONVERGENCE; STABILITY_MAX_SPACE_SIZE; STABILITY_N_EIGENVALUES; STABILITY_N_GUESS_VECTORS; TIKHONOW_OMEGA. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; DCT. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__dct.html:7087,CACHE,CACHELEVEL,7087,psi4manual/1.6.x/autodir_options_c/module__dct.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__dct.html,1,['CACHE'],['CACHELEVEL']
Performance,"’t depend on options (scf_type) being set global or local. This input uses global. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dcft1; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. Previous topic; Test Suite and Sample Inputs; Next topic; Basis Sets by Element; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Test Suite and Sample Inputs ». © Copyright 2012, The Psi4 Project.; Last updated on Nov 02, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:20364,perform,performs,20364,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,2,['perform'],['performs']
Performance,"“SF-SAPT”) and; publications resulting from the use of the SF-SAPT code should cite the; following publications: [Patkowski:2018:164110]. Higher-Order Exchange Terms without Single-Exchange Approximation¶; Recently, several SAPT higher-order exchange terms have been derived without; the \(S^{2}\) approximation: \(E_{exch-ind}^{(20)}\) [Schaffer:2012:1235],; \(E_{exch-disp}^{(20)}\) [Schaffer:2013:2570], and \(E_{exch-ind}^{(30)}\); [Waldrop:2021:024103]. The second-order terms can be computed with the following; settings:; set SAPT_DFT_FUNCTIONAL HF; set DO_IND_EXCH_SINF true # calculate Exch-Ind20 (S^inf); set SAPT_DFT_MP2_DISP_ALG fisapt; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'). and the third-order exchange-induction term is computed as follows:; set DO_IND30_EXCH_SINF true # calculate Exch-Ind30 (S^inf); energy('sapt2+3'). These calculations are performed with the atomic orbital and; density-fitting scheme described in the Supplementary Material to; [Smith:2020:184108] for the second-order terms and in [Waldrop:2021:024103]; for the third-order exchange induction. The coupled (response) version of the; exchange-induction corrections are also calculated, exactly for; \(E_{exch-ind,resp}^{(20)}\) and by scaling the uncoupled term for; \(E_{exch-ind,resp}^{(30)}\). S^inf Keywords¶. DO_IND_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-induction term. Type: boolean; Default: false. DO_DISP_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-dispersion term. Type: boolean; Default: false. DO_IND30_EXCH_SINF¶. For SAPT2+3, compute the non-approximated third-order exchange-induction term. Type: boolean; Default: false. SAPT0-D¶; In SAPT0, the computation of \(E_{disp}^{(20)} + E_{exch-disp}^{(20)}\) represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:47997,perform,performed,47997,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,5,['perform'],['performed']
Performance,"“tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. mbis-1; MBIS calculation on H2O. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dft-grac; Gradient regularized asymptotic correction (GRAC) test. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. scf-auto-cholesky; Cholesky filter a complete basis. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). omp2p5-gra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:3977,perform,performs,3977,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"→ None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶; Forms the residual of SCF theory. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_H(self: psi4.core.HF) → None¶; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF) → None¶; Forms the S^1/2 matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF) → None¶; Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self: psi4.core.HF) → None¶; Forms the initial F matrix. frac_renormalize(self: psi4.core.HF) → None¶; docstring. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self: psi4.core.HF, arg0: str) → float¶; docstring. get_print(self: psi4.core.Wavefunction) → int¶; Get the pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html:24068,load,load,24068,psi4manual/1.6.x/api/psi4.core.CUHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.CUHF.html,5,['load'],['load']
Performance,"→ None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) → psi4.core.Matrix¶; Forms the residual of SCF theory. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_H(self: psi4.core.HF) → None¶; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF) → None¶; Forms the S^1/2 matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF) → None¶; Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self: psi4.core.HF) → None¶; Forms the initial F matrix. frac_renormalize(self: psi4.core.HF) → None¶; docstring. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self: psi4.core.HF, arg0: str) → float¶; docstring. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:23904,load,load,23904,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,5,['load'],['load']
Performance,"✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. mp3; MP_TYPE; ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. remp2; CC_TYPE; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. lccd; CC_TYPE; ✓; ✓; ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ccd; CC_TYPE. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ccsd; CC_TYPE. ✓; ✓; ✓; ✓. ✓̲; ✓̲. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ccsd(t); CC_TYPE. ✓; ✓; ✓; ✓. ✓̲; ✓̲. a-ccsd(t)[8]; CC_TYPE. ✓̲; ✓̲; ✓̲; ✓̲. [5]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [6]; Active orbital values to the right: all-electron A and frozen-core F. [7]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [8]; a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L. table of contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced OCC Keywords; OPT_METHOD; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Basic DFOCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ORB_OPT. Advanced DFOCC Keywords; OPT_METHOD; HESS_TYPE; MO_DIIS_NUM_VECS; ORTH_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Theoretical Methods: SCF to FCI; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:21490,Optimiz,Optimized,21490,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,2,['Optimiz'],['Optimized']
Performance,"﻿. <no title> — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Emerging Theoretical Methods: Plugins DFADC to RQCHF »; plugin_mp2 ». CACHELEV (PLUGIN_MP2); How to cache quantities within the DPD library. Type: integer; Default: 2. MEMORY (PLUGIN_MP2); The amount of memory available (in Mb). Type: integer; Default: 2000. PRINT (PLUGIN_MP2); The amount of information printed to the output file. Type: integer; Default: 1. REFERENCE (PLUGIN_MP2); The Reference. Type: string; Default: No Default. Previous topic; plugin_mp2; Next topic; CACHELEV; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Emerging Theoretical Methods: Plugins DFADC to RQCHF »; plugin_mp2 ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_plugins/glossary__plugin_mp2-1.html:181,CACHE,CACHELEV,181,psi4manual/4.0b2/autodir_plugins/glossary__plugin_mp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_plugins/glossary__plugin_mp2-1.html,6,"['CACHE', 'cache']","['CACHELEV', 'cache']"
Performance,"﻿. <no title> — PSI4 [beta2] documentation. Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Emerging Theoretical Methods: Plugins DFADC to RQCHF »; plugin_test_matrix ». CACHELEV (PLUGIN_TEST_MATRIX); How to cache quantities within the DPD library. Type: integer; Default: 2. MATRIX_SIZE (PLUGIN_TEST_MATRIX); The size of the matrices. Type: integer; Default: 1000. MEMORY (PLUGIN_TEST_MATRIX); The amount of memory available (in Mb). Type: integer; Default: 2000. PRINT (PLUGIN_TEST_MATRIX); The amount of information printed to the output file. Type: integer; Default: 1. TILE_SIZE (PLUGIN_TEST_MATRIX); The size of the tiles. Type: integer; Default: 10. Previous topic; plugin_test_matrix; Next topic; CACHELEV; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Emerging Theoretical Methods: Plugins DFADC to RQCHF »; plugin_test_matrix ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_plugins/glossary__plugin_test_matrix-1.html:189,CACHE,CACHELEV,189,psi4manual/4.0b2/autodir_plugins/glossary__plugin_test_matrix-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_plugins/glossary__plugin_test_matrix-1.html,6,"['CACHE', 'cache']","['CACHELEV', 'cache']"
Performance,﻿. <no title> — PSI4 [beta2] documentation. Navigation. index. modules |. next |; PSI4 [beta2] » . Introduction; Overview; Citing PSI4; Obtaining and Installing PSI4; Supported Architectures; Capabilities; Technical Support. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Configuration: Preparing PSI4’s Environment; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Basis Sets; Theoretical Methods: SCF to FCI; Notes on Options; Hartree–Fock Theory; Density Functional Theory; Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Ab Initio Polarization Propagator; Symmetry-Adapted Perturbation Theory; Coupled Cluster Methods; PSIMRCC Implementation of Mk-MRCC Theory; Interface to MRCC by M. Kállay; Configuration Interaction; Geometry Optimization. Psithon Functions: Invoking a Calculation; Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Complete Basis Set; Function Intercalls; Embarrassing Parallelism. Interfaces: Enhancing PSI4 Capabilities. Customization: Adding Simple Extensions; User-Defined Basis Sets; Defining a Method Alias; Creating a Database. Contributions: Intro to Programming in PSI4; Plugins: Adding New Functionality to PSI4; Best Practices for Python Functions; Documentation. Programming: Using the Core Libraries. Emerging Theoretical Methods: Plugins DFADC to RQCHF; plugin_cepa; plugin_ccsort; plugin_dfadc; plugin_test_matrix; plugin_ccsd_serial; plugin_l,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/index.html:321,Optimiz,Optimization,321,psi4manual/4.0b2/index.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/index.html,1,['Optimiz'],['Optimization']
Performance,"﻿. <no title> — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Test Suite and Sample Inputs ». Input File; Description. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. min_input; This checks that all energy methods can run with a minimal input and set symmetry. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. scf6; Tests RHF/ROHF/UHF SCF gradients. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DCFT-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DCFT-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:578,optimiz,optimization,578,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,2,['optimiz'],['optimization']
Performance,﻿. <no title> — PSI4 [beta3] documentation. Navigation. index. modules    . toc    . next    ; PSI4 [beta3] » . Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Installation and Runtime Configuration; Obtaining PSI4; Compiling and Installing; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Basis Sets; Theoretical Methods: SCF to FCI; Notes on Options; HF: Hartree–Fock Theory; DFT: Density Functional Theory; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; ADC: Ab Initio Polarization Propagator; SAPT: Symmetry-Adapted Perturbation Theory; CEPA: Coupled-Pair Methods; CC: Coupled Cluster Methods; PSIMRCC Implementation of Mk-MRCC Theory; Interface to MRCC by M. Kállay; CI: Configuration Interaction; Geometry Optimization; Evaluation of One-Electron Properties. Psithon Functions: Invoking a Calculation; Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls. Interfaces: Enhancing PSI4 Capabilities. Customization: Adding Simple Extensions; User-Defined Basis Sets; Defining a Method Alias; Creating a Database. Contributions: Intro to Programming in PSI4; Plugins: Adding New Functionality to PSI4; Best Practices for Python Functions; Doc,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/index.html:479,Optimiz,Optimization,479,psi4manual/4.0b3/index.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/index.html,1,['Optimiz'],['Optimization']
Performance,﻿. <no title> — PSI4 [beta3] documentation. Navigation. index. modules    . toc    ; PSI4 [beta3] » . Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Installation and Runtime Configuration; Obtaining PSI4; Compiling and Installing; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Basis Sets; Theoretical Methods: SCF to FCI; Notes on Options; HF: Hartree–Fock Theory; DFT: Density Functional Theory; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; ADC: Ab Initio Polarization Propagator; SAPT: Symmetry-Adapted Perturbation Theory; CEPA: Coupled-Pair Methods; CC: Coupled Cluster Methods; PSIMRCC Implementation of Mk-MRCC Theory; Interface to MRCC by M. Kállay; CI: Configuration Interaction; Geometry Optimization; Evaluation of One-Electron Properties. Psithon Functions: Invoking a Calculation; Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls. Interfaces: Enhancing PSI4 Capabilities. Customization: Adding Simple Extensions; User-Defined Basis Sets; Defining a Method Alias; Creating a Database. Contributions: Intro to Programming in PSI4; Plugins: Adding New Functionality to PSI4; Best Practices for Python Functions; Documentation,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/contents.html:469,Optimiz,Optimization,469,psi4manual/4.0b3/contents.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/contents.html,1,['Optimiz'],['Optimization']
Performance,"﻿. <no title> — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Test Suite and Sample Inputs ». Input File; Description. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. fnocc2; Test G2 method for H2O. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. fnocc4; Test FNO-DF-CCSD(T) energy. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. min_input; This checks that all energy methods can run with a minimal input and set symmetry. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF. omp2_5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. scf6; Tests RHF/ROHF/UHF SCF gradients. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:631,optimiz,optimization,631,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"﻿. <no title> — PSI4 [beta4] documentation. Navigation. index. modules    . toc    . next    ; PSI4 [beta4] » . Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Installation and Runtime Configuration; Obtaining PSI4; Compiling and Installing; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Basis Sets; Theoretical Methods: SCF to FCI; Notes on Options; HF: Hartree–Fock Theory; DFT: Density Functional Theory; DCFT: Density Cumulant Functional Theory; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; OCC: Conventional Møller–Plesset Perturbation Theories; CC: Coupled Cluster Methods; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; PSIMRCC Implementation of Mk-MRCC Theory; CI: Configuration Interaction; SAPT: Symmetry-Adapted Perturbation Theory; ADC: Ab Initio Polarization Propagator; Geometry Optimization; Evaluation of One-Electron Properties. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay; Interface to DFTD3 by S. Grimme; Interface to Molden. Psithon Functions: Invoking a Calculation; Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls. Customization",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/index.html:479,Optimiz,Optimization,479,psi4manual/4.0b4/index.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/index.html,1,['Optimiz'],['Optimization']
Performance,"﻿. <no title> — PSI4 [beta4] documentation. Navigation. index. modules    . toc    ; PSI4 [beta4] » . Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Installation and Runtime Configuration; Obtaining PSI4; Compiling and Installing; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Basis Sets; Theoretical Methods: SCF to FCI; Notes on Options; HF: Hartree–Fock Theory; DFT: Density Functional Theory; DCFT: Density Cumulant Functional Theory; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; OCC: Conventional Møller–Plesset Perturbation Theories; CC: Coupled Cluster Methods; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; PSIMRCC Implementation of Mk-MRCC Theory; CI: Configuration Interaction; SAPT: Symmetry-Adapted Perturbation Theory; ADC: Ab Initio Polarization Propagator; Geometry Optimization; Evaluation of One-Electron Properties. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay; Interface to DFTD3 by S. Grimme; Interface to Molden. Psithon Functions: Invoking a Calculation; Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls. Customization: Adding S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/contents.html:469,Optimiz,Optimization,469,psi4manual/4.0b4/contents.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/contents.html,1,['Optimiz'],['Optimization']
Performance,"﻿. <no title> — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Test Suite and Sample Inputs ». Input File; Description. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. fnocc2; Test G2 method for H2O. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. fnocc4; Test FNO-DF-CCSD(T) energy. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. min_input; This checks that all energy methods can run with a minimal input and set symmetry. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF. omp2_5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. scf6; Tests RHF/ROHF/UHF SCF gradients. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:631,optimiz,optimization,631,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"﻿. <no title> — PSI4 [beta5] documentation. Navigation. index. modules    . toc    . next    ; PSI4 [beta5] » . Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Installation and Runtime Configuration; Obtaining PSI4; Compiling and Installing; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Basis Sets; Theoretical Methods: SCF to FCI; Notes on Options; HF: Hartree–Fock Theory; DFT: Density Functional Theory; DCFT: Density Cumulant Functional Theory; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; OCC: Conventional Møller–Plesset Perturbation Theories; CC: Coupled Cluster Methods; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; PSIMRCC Implementation of Mk-MRCC Theory; CI: Configuration Interaction; SAPT: Symmetry-Adapted Perturbation Theory; ADC: Ab Initio Polarization Propagator; Geometry Optimization; Evaluation of One-Electron Properties. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay; Interface to DFTD3 by S. Grimme; Interface to Molden. Psithon Functions: Invoking a Calculation; Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls. Customization",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/index.html:479,Optimiz,Optimization,479,psi4manual/4.0b5/index.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/index.html,1,['Optimiz'],['Optimization']
Performance,"﻿. <no title> — PSI4 [beta5] documentation. Navigation. index. modules    . toc    ; PSI4 [beta5] » . Introduction; Overview; Citing PSI4; Supported Architectures; Capabilities; Technical Support. Installation and Runtime Configuration; Obtaining PSI4; Compiling and Installing; Scratch Files and the ~/.psi4rc File; Threading; Command Line Options; Environment Variables. A PSI4 Tutorial; Basic Input File Structure; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Basis Sets; Theoretical Methods: SCF to FCI; Notes on Options; HF: Hartree–Fock Theory; DFT: Density Functional Theory; DCFT: Density Cumulant Functional Theory; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; OCC: Conventional Møller–Plesset Perturbation Theories; CC: Coupled Cluster Methods; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; PSIMRCC Implementation of Mk-MRCC Theory; CI: Configuration Interaction; SAPT: Symmetry-Adapted Perturbation Theory; ADC: Ab Initio Polarization Propagator; Geometry Optimization; Evaluation of One-Electron Properties. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay; Interface to DFTD3 by S. Grimme; Interface to Molden. Psithon Functions: Invoking a Calculation; Notes on Options; Energy; Property; Counterpoise Correct; Optimize; Frequency; Database; Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls. Customization: Adding S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/contents.html:469,Optimiz,Optimization,469,psi4manual/4.0b5/contents.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/contents.html,1,['Optimiz'],['Optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Test Suite and Sample Inputs; <no title>. Input File; Description. dft-freq-analytic2; Analytic UKS SVWN frequencies, compared to finite difference values. numpy-array-interface; Numpy interface testing. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. remp-energy1; integral conventional REMP/cc-pVDZ energies for the H2O molecule. results were independently verified against the initial wavels implementation. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. dft-dens-cut; LibXC density screening test. Tests empty, C-only, X-only and XC superfunctionals. ‘super_mix’ showcases how to use different screening values for X and C parts. SCF will fail or crash (nans) without screening!. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc54; CCSD dipole with user-specified basis set. cubeprop; RHF orbitals and density for water. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. dft-custom-gga; DFT (LDA/GGA) test of cus",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:503,optimiz,optimizations,503,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,1,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; ADC. CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; ADC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__cachelevel-1.html:120,CACHE,CACHELEVEL,120,psi4manual/1.1.0/autodir_options_c/adc__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/adc__cachelevel-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCDENSITY. CACHELEVEL. The amount of caching of data to perform. Type: integer; Default: 2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCDENSITY. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel-1.html:126,CACHE,CACHELEVEL,126,psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccdensity__cachelevel-1.html,4,"['CACHE', 'perform']","['CACHELEVEL', 'perform']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html:125,CACHE,CACHELEVEL,125,psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachetype-1.html:125,CACHE,CACHETYPE,125,psi4manual/1.1.0/autodir_options_c/ccenergy__cachetype-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__cachetype-1.html,8,"['CACHE', 'cache']","['CACHETYPE', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. RESTART. Do restart the coupled-cluster iterations from old \(t_1\) and \(t_2\) amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__restart-1.html:230,optimiz,optimizations,230,psi4manual/1.1.0/autodir_options_c/ccenergy__restart-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__restart-1.html,2,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. SCSN_MP2. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__scsn_mp2-1.html:162,optimiz,optimized,162,psi4manual/1.1.0/autodir_options_c/ccenergy__scsn_mp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccenergy__scsn_mp2-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCEOM. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCEOM. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cceom__cachelevel-1.html:122,CACHE,CACHELEVEL,122,psi4manual/1.1.0/autodir_options_c/cceom__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cceom__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCEOM. CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCEOM. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cceom__cachetype-1.html:122,CACHE,CACHETYPE,122,psi4manual/1.1.0/autodir_options_c/cceom__cachetype-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cceom__cachetype-1.html,4,"['CACHE', 'cache']","['CACHETYPE', 'cached']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCHBAR. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCHBAR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cchbar__cachelevel-1.html:123,CACHE,CACHELEVEL,123,psi4manual/1.1.0/autodir_options_c/cchbar__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cchbar__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cclambda__cachelevel-1.html:125,CACHE,CACHELEVEL,125,psi4manual/1.1.0/autodir_options_c/cclambda__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cclambda__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. JOBTYPE. Type of job being performed. Type: string; Default: No Default. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cclambda__jobtype-1.html:152,perform,performed,152,psi4manual/1.1.0/autodir_options_c/cclambda__jobtype-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cclambda__jobtype-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. CACHELEVEL. Caching level for libdpd. Type: integer; Default: 2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccresponse__cachelevel-1.html:127,CACHE,CACHELEVEL,127,psi4manual/1.1.0/autodir_options_c/ccresponse__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/ccresponse__cachelevel-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCTRANSORT. CACHELEVEL. Caching level for libdpd. Type: integer; Default: 2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CCTRANSORT. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cctransort__cachelevel-1.html:127,CACHE,CACHELEVEL,127,psi4manual/1.1.0/autodir_options_c/cctransort__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cctransort__cachelevel-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CACHE_RECS. The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_cache_recs-1.html:178,cache,cache,178,psi4manual/1.1.0/autodir_options_c/cfour__cfour_cache_recs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_cache_recs-1.html,2,['cache'],['cache']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CALC_LEVEL. Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Possible Values: SCF, HF, MBPT(2), MP2, MBPT(3), MP3, SDQ-MBPT(4), SDQ-MP4, MBPT(4), MP4, CCD, CCSD, CCSD(T), CCSDT-1, CCSDT-1b, CCSDT-2, CCSDT-3, CCSDT-4, CCSDT, CC2, CC3, QCISD, QCISD(T), CID, CISD, UCC(4), B-CCD; Default: SCF. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_calc_level-1.html:179,perform,performed,179,psi4manual/1.1.0/autodir_options_c/cfour__cfour_calc_level-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_calc_level-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CC_PROGRAM. Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, MRCC, EXTERNAL; Default: VCC. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_cc_program-1.html:421,perform,performance,421,psi4manual/1.1.0/autodir_options_c/cfour__cfour_cc_program-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_cc_program-1.html,4,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_COORDINATES. Specifies the type of coordinates used in the input file ZMAT. Value INTERNAL (=0) means that the geometry is supplied in the usual Z-matrix format, while CARTESIAN (=1) means that the geometry is given in Cartesian coordinates. A third option is XYZINT (=2) for which a Z-matrix connectivity is defined, but with values of the internal coordinates defined implicitly by supplying Cartesian coordinates. Note that geometry optimizations are currently only possible for INTERNAL and XYZ2INT. Psi4 Interface: Keyword set from active molecule, always CARTESIAN. Above restrictions on geometry optimizations no longer apply. Type: string; Possible Values: INTERNAL, CARTESIAN, XYZINT; Default: INTERNAL. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_coordinates-1.html:564,optimiz,optimizations,564,psi4manual/1.1.0/autodir_options_c/cfour__cfour_coordinates-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_coordinates-1.html,4,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CURVILINEAR. Specifies whether or not Hessian matrix is transformed (nonlinearly) to curvilinear internal coordinates. A value of 0 (or OFF) turns the transformation off if the analytic force constants are not available, while it is always performed if CURVILINEAR=1 (or ON). Values higher than 1 (or NO) unconditionally turn the transformation off.(Default: ON if analytic Hessian is available, OFF otherwise). Type: boolean; Default: true. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_curvilinear-1.html:368,perform,performed,368,psi4manual/1.1.0/autodir_options_c/cfour__cfour_curvilinear-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_curvilinear-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_DERIV_LEVEL. Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimization(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_deriv_level-1.html:671,optimiz,optimization,671,psi4manual/1.1.0/autodir_options_c/cfour__cfour_deriv_level-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_deriv_level-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_EVAL_HESS. Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_eval_hess-1.html:186,optimiz,optimization,186,psi4manual/1.1.0/autodir_options_c/cfour__cfour_eval_hess-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_eval_hess-1.html,6,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_EXCITE. Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_excite-1.html:187,perform,performed,187,psi4manual/1.1.0/autodir_options_c/cfour__cfour_excite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_excite-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_FD_IRREPS. Requests that only vibrational frequencies of certain symmetry types are evaluated in a VIBRATION=FINDIF calculation. The numbers of the irreducible representations for which vibrational analysis is to be performed are separated by slashes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_fd_irreps-1.html:344,perform,performed,344,psi4manual/1.1.0/autodir_options_c/cfour__cfour_fd_irreps-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_fd_irreps-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GENBAS_2. This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_genbas_2-1.html:151,perform,performs,151,psi4manual/1.1.0/autodir_options_c/cfour__cfour_genbas_2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_genbas_2-1.html,2,['perform'],['performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GENBAS_3. This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_genbas_3-1.html:151,perform,performs,151,psi4manual/1.1.0/autodir_options_c/cfour__cfour_genbas_3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_genbas_3-1.html,2,['perform'],['performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GENBAS_4. This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_genbas_4-1.html:151,perform,performs,151,psi4manual/1.1.0/autodir_options_c/cfour__cfour_genbas_4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_genbas_4-1.html,2,['perform'],['performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GEO_CONV. Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_conv-1.html:187,optimiz,optimization,187,psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_conv-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_conv-1.html,8,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GEO_MAXCYC. Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_maxcyc-1.html:189,optimiz,optimization,189,psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_maxcyc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_maxcyc-1.html,6,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GEO_MAXSTEP. Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_maxstep-1.html:208,optimiz,optimizations,208,psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_maxstep-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_maxstep-1.html,6,['optimiz'],"['optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GEO_METHOD. Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_method-1.html:168,optimiz,optimization,168,psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_geo_method-1.html,6,['optimiz'],"['optimization', 'optimized']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_HFSTABILITY. Control analysis of the stability of RHF, ROHF and UHF wavefunctions, as well as a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC , after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_hfstability-1.html:354,perform,performs,354,psi4manual/1.1.0/autodir_options_c/cfour__cfour_hfstability-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_hfstability-1.html,4,['perform'],['performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_JODA_PRINT. Controls amount of debug printing performed by xjoda. The higher the number, the more information is printed. Values of 25 or higher generally do not produce anything of interest to the general user. Do not set JODA_PRINT to 999 as this will cause the core vector to be dumped to disk. Type: integer; Default: 0. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_joda_print-1.html:174,perform,performed,174,psi4manual/1.1.0/autodir_options_c/cfour__cfour_joda_print-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_joda_print-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_LOCK_ORBOCC. This keyword is used by the SCF program to determine if the orbital occupancy (by symmetry block) is allowed to change in the course of the calculation. ON (=1) locks the occupation to that set by the keyword CFOUR_OCCUPATION (or the initial guess if omitted); OFF (= 0) permits the occupation to change. (Default : 1 if the occupation is specified with CFOUR_OCCUPATION and for second and later steps of optimizations; 0 if CFOUR_OCCUPATION omitted.). Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_lock_orbocc-1.html:546,optimiz,optimizations,546,psi4manual/1.1.0/autodir_options_c/cfour__cfour_lock_orbocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_lock_orbocc-1.html,2,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_METHOD. Specifies the geometry optimization strategy. Four values are permitted: NR (=0) – Straightforward Newton-Raphson search for minimum; RFA (=1) – Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_method-1.html:159,optimiz,optimization,159,psi4manual/1.1.0/autodir_options_c/cfour__cfour_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_method-1.html,6,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_MRCC. Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_mrcc-1.html:177,perform,performs,177,psi4manual/1.1.0/autodir_options_c/cfour__cfour_mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_mrcc-1.html,2,['perform'],['performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_NEGEVAL. Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead. Type: string; Possible Values: ABORT, SWITCH, RFA; Default: ABORT. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_negeval-1.html:261,optimiz,optimization,261,psi4manual/1.1.0/autodir_options_c/cfour__cfour_negeval-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_negeval-1.html,8,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_QRHFGUES. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_qrhfgues-1.html:574,perform,performed,574,psi4manual/1.1.0/autodir_options_c/cfour__cfour_qrhfgues-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_qrhfgues-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_QRHF_GENERAL. The presence of this keyword specifies that a QRHF based CC calculation, or alternatively, an SCF calculation that uses the CFOUR_QRHFGUES option, is to be performed. Type: array; Default: No Default. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_qrhf_general-1.html:298,perform,performed,298,psi4manual/1.1.0/autodir_options_c/cfour__cfour_qrhf_general-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_qrhf_general-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_REFERENCE. Specifies the type of SCF calculation to be performed. RHF (= 0) requests a restricted Hartree-Fock reference; UHF (= 1) an unrestricted Hartree-Fock reference; ROHF (= 2) a restricted open-shell Hartree-Fock calculation; TCSCF (=3) a two-configurational SCF calculation, and CASSCF (=4) a complete-active space SCF calculations (currently not implemented). Psi4 Interface: Keyword subject to translation from value of REFERENCE unless set explicitly. Type: string; Possible Values: RHF, UHF, ROHF, TCSCF, CASSCF; Default: RHF. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_reference-1.html:183,perform,performed,183,psi4manual/1.1.0/autodir_options_c/cfour__cfour_reference-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_reference-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_RES_RAMAN. This option can be used to convert an analytically calculated gradient vector to a particular normal coordinate representation. A useful application is to calculate the gradient of an electronically excited state in the normal coordinate representation of the ground electronic state, as this provides a first approximation to resonance Raman intensities (hence the name of the keyword). Calculations that use the this option require the externally supplied force constant matrix FCMFINAL, which is written to disk during the course of both analytic and finite-difference vibrational frequency calculations. No such transformation is performed if OFF (=0); while ON (=1) directs the program to evaluate the gradient and transform it to the chosen set of normal coordinates. A warning message is printed if the force constant matrix is unavailable. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_res_raman-1.html:773,perform,performed,773,psi4manual/1.1.0/autodir_options_c/cfour__cfour_res_raman-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_res_raman-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_UPDATE_HESSIAN. Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_update_hessian-1.html:340,optimiz,optimization,340,psi4manual/1.1.0/autodir_options_c/cfour__cfour_update_hessian-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_update_hessian-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_VIBRATION. Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF; Default: NO. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_vibration-1.html:741,perform,performed,741,psi4manual/1.1.0/autodir_options_c/cfour__cfour_vibration-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_vibration-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_VTRAN. This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the \((ab \vert cd)\) integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_vtran-1.html:202,perform,performed,202,psi4manual/1.1.0/autodir_options_c/cfour__cfour_vtran-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/cfour__cfour_vtran-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DCFT. CACHELEVEL. Controls how to cache quantities within the DPD library. Type: integer; Default: 2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DCFT. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dcft__cachelevel-1.html:121,CACHE,CACHELEVEL,121,psi4manual/1.1.0/autodir_options_c/dcft__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dcft__cachelevel-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DCFT. GUESS_R_CONVERGENCE. Convergence criterion for the density cumulant and orbital guess for the variationally orbital-optimized DCFT methods. Currently only available for ALGORITHM = SIMULTANEOUS. Type: conv double; Default: 1e-3. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DCFT. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dcft__guess_r_convergence-1.html:237,optimiz,optimized,237,psi4manual/1.1.0/autodir_options_c/dcft__guess_r_convergence-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dcft__guess_r_convergence-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DCFT. ODC_GUESS. Whether to perform a guess DC-06 or DC-12 computation for ODC-06 or ODC-12 methods, respectively. Currently only available for ALGORITHM = SIMULTANEOUS. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DCFT. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dcft__odc_guess-1.html:143,perform,perform,143,psi4manual/1.1.0/autodir_options_c/dcft__odc_guess-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dcft__odc_guess-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DCFT. RELAX_GUESS_ORBITALS. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DCFT. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dcft__relax_guess_orbitals-1.html:229,perform,performing,229,psi4manual/1.1.0/autodir_options_c/dcft__relax_guess_orbitals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dcft__relax_guess_orbitals-1.html,2,['perform'],['performing']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DCFT. STABILITY_CHECK. Performs stability analysis of the DCFT energy. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DCFT. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dcft__stability_check-1.html:138,Perform,Performs,138,psi4manual/1.1.0/autodir_options_c/dcft__stability_check-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dcft__stability_check-1.html,2,['Perform'],['Performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DETCI. FOLLOW_ROOT. The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 0. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DETCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/detci__follow_root-1.html:297,optimiz,optimization,297,psi4manual/1.1.0/autodir_options_c/detci__follow_root-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/detci__follow_root-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DETCI. ICORE. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DETCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/detci__icore-1.html:209,perform,perform,209,psi4manual/1.1.0/autodir_options_c/detci__icore-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/detci__icore-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DETCI. LSE_TOLERANCE. Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DETCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/detci__lse_tolerance-1.html:200,perform,performed,200,psi4manual/1.1.0/autodir_options_c/detci__lse_tolerance-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/detci__lse_tolerance-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFMP2. DF_INTS_IO. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFMP2. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfmp2__df_ints_io-1.html:213,LOAD,LOAD,213,psi4manual/1.1.0/autodir_options_c/dfmp2__df_ints_io-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfmp2__df_ints_io-1.html,2,['LOAD'],['LOAD']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. DO_SCS. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__do_scs-1.html:133,perform,perform,133,psi4manual/1.1.0/autodir_options_c/dfocc__do_scs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__do_scs-1.html,6,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. DO_SOS. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__do_sos-1.html:133,perform,perform,133,psi4manual/1.1.0/autodir_options_c/dfocc__do_sos-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__do_sos-1.html,6,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. MO_STEP_MAX. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__mo_step_max-1.html:164,optimiz,optimization,164,psi4manual/1.1.0/autodir_options_c/dfocc__mo_step_max-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__mo_step_max-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. MP2_SOS_SCALE2. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__mp2_sos_scale2-1.html:176,optimiz,optimized-,176,psi4manual/1.1.0/autodir_options_c/dfocc__mp2_sos_scale2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__mp2_sos_scale2-1.html,2,['optimiz'],['optimized-']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. OPT_METHOD. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__opt_method-1.html:146,optimiz,optimization,146,psi4manual/1.1.0/autodir_options_c/dfocc__opt_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__opt_method-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. ORB_OPT. Do optimize the orbitals?. Type: boolean; Default: true. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__orb_opt-1.html:134,optimiz,optimize,134,psi4manual/1.1.0/autodir_options_c/dfocc__orb_opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__orb_opt-1.html,2,['optimiz'],['optimize']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. QCHF. Do perform a QCHF computation?. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__qchf-1.html:131,perform,perform,131,psi4manual/1.1.0/autodir_options_c/dfocc__qchf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/dfocc__qchf-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; FNOCC. BRUECKNER_MAXITER. Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/fnocc__brueckner_maxiter-1.html:193,optimiz,optimization,193,psi4manual/1.1.0/autodir_options_c/fnocc__brueckner_maxiter-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/fnocc__brueckner_maxiter-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. FROZEN_DOCC. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/globals__frozen_docc-1.html:282,optimiz,optimized,282,psi4manual/1.1.0/autodir_options_c/globals__frozen_docc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/globals__frozen_docc-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. FROZEN_UOCC. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/globals__frozen_uocc-1.html:279,optimiz,optimized,279,psi4manual/1.1.0/autodir_options_c/globals__frozen_uocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/globals__frozen_uocc-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. RESTRICTED_DOCC. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/globals__restricted_docc-1.html:271,optimiz,optimized,271,psi4manual/1.1.0/autodir_options_c/globals__restricted_docc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/globals__restricted_docc-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. RESTRICTED_UOCC. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/globals__restricted_uocc-1.html:267,optimiz,optimized,267,psi4manual/1.1.0/autodir_options_c/globals__restricted_uocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/globals__restricted_uocc-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; MCSCF. FAVG. Do use the average Fock matrix during the SCF optimization?. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; MCSCF. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/mcscf__favg-1.html:174,optimiz,optimization,174,psi4manual/1.1.0/autodir_options_c/mcscf__favg-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/mcscf__favg-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; MRCC. MRCC_METHOD. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; MRCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/mrcc__mrcc_method-1.html:211,perform,performed,211,psi4manual/1.1.0/autodir_options_c/mrcc__mrcc_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/mrcc__mrcc_method-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__cachelevel-1.html:120,CACHE,CACHELEVEL,120,psi4manual/1.1.0/autodir_options_c/occ__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. DO_SCS. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__do_scs-1.html:131,perform,perform,131,psi4manual/1.1.0/autodir_options_c/occ__do_scs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__do_scs-1.html,6,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. DO_SOS. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__do_sos-1.html:131,perform,perform,131,psi4manual/1.1.0/autodir_options_c/occ__do_sos-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__do_sos-1.html,6,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. MO_STEP_MAX. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__mo_step_max-1.html:162,optimiz,optimization,162,psi4manual/1.1.0/autodir_options_c/occ__mo_step_max-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__mo_step_max-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. MP2_SOS_SCALE2. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__mp2_sos_scale2-1.html:174,optimiz,optimized-,174,psi4manual/1.1.0/autodir_options_c/occ__mp2_sos_scale2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__mp2_sos_scale2-1.html,2,['optimiz'],['optimized-']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. OPT_METHOD. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__opt_method-1.html:136,optimiz,optimization,136,psi4manual/1.1.0/autodir_options_c/occ__opt_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__opt_method-1.html,4,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. ORB_OPT. Do optimize the orbitals?. Type: boolean; Default: true. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__orb_opt-1.html:132,optimiz,optimize,132,psi4manual/1.1.0/autodir_options_c/occ__orb_opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/occ__orb_opt-1.html,2,['optimiz'],['optimize']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. CONSECUTIVE_BACKSTEPS. Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__consecutive_backsteps-1.html:199,optimiz,optimization,199,psi4manual/1.1.0/autodir_options_c/optking__consecutive_backsteps-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__consecutive_backsteps-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. DYNAMIC_LEVEL. Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__dynamic_level-1.html:166,optimiz,optimization,166,psi4manual/1.1.0/autodir_options_c/optking__dynamic_level-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__dynamic_level-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. FINAL_GEOM_WRITE. Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__final_geom_write-1.html:227,optimiz,optimization,227,psi4manual/1.1.0/autodir_options_c/optking__final_geom_write-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__final_geom_write-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. FIXED_COORD_FORCE_CONSTANT. In constrained optimizations, for coordinates with user-specified equilibrium values, this is the initial force constant (in au) used to apply an additional force to each coordinate. Type: double; Default: 0.5. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__fixed_coord_force_constant-1.html:167,optimiz,optimizations,167,psi4manual/1.1.0/autodir_options_c/optking__fixed_coord_force_constant-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__fixed_coord_force_constant-1.html,2,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. FULL_HESS_EVERY. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__full_hess_every-1.html:218,optimiz,optimization,218,psi4manual/1.1.0/autodir_options_c/optking__full_hess_every-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__full_hess_every-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. GEOM_MAXITER. Maximum number of geometry optimization steps. Type: integer; Default: 50. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__geom_maxiter-1.html:165,optimiz,optimization,165,psi4manual/1.1.0/autodir_options_c/optking__geom_maxiter-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__geom_maxiter-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. G_CONVERGENCE. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__g_convergence-1.html:146,optimiz,optimization,146,psi4manual/1.1.0/autodir_options_c/optking__g_convergence-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__g_convergence-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. OPT_COORDINATES. Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__opt_coordinates-1.html:150,optimiz,optimization,150,psi4manual/1.1.0/autodir_options_c/optking__opt_coordinates-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__opt_coordinates-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. STEP_TYPE. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__step_type-1.html:144,optimiz,optimization,144,psi4manual/1.1.0/autodir_options_c/optking__step_type-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/optking__step_type-1.html,4,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. CORR_CCSD_T. The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/psimrcc__corr_ccsd_t-1.html:172,perform,perform,172,psi4manual/1.1.0/autodir_options_c/psimrcc__corr_ccsd_t-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/psimrcc__corr_ccsd_t-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. DIIS_START. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/psimrcc__diis_start-1.html:194,perform,performed,194,psi4manual/1.1.0/autodir_options_c/psimrcc__diis_start-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/psimrcc__diis_start-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. MP2_CCSD_METHOD. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/psimrcc__mp2_ccsd_method-1.html:148,perform,perform,148,psi4manual/1.1.0/autodir_options_c/psimrcc__mp2_ccsd_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/psimrcc__mp2_ccsd_method-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. PT_ENERGY. The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/psimrcc__pt_energy-1.html:182,perform,perform,182,psi4manual/1.1.0/autodir_options_c/psimrcc__pt_energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/psimrcc__pt_energy-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SAPT. EXCH_SCALE_ALPHA. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SAPT. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/sapt__exch_scale_alpha-1.html:157,perform,perform,157,psi4manual/1.1.0/autodir_options_c/sapt__exch_scale_alpha-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/sapt__exch_scale_alpha-1.html,6,['perform'],"['perform', 'performs']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. BASIS_GUESS. Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__basis_guess-1.html:159,perform,performing,159,psi4manual/1.1.0/autodir_options_c/scf__basis_guess-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__basis_guess-1.html,2,['perform'],['performing']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. DAMPING_CONVERGENCE. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__damping_convergence-1.html:208,perform,performed,208,psi4manual/1.1.0/autodir_options_c/scf__damping_convergence-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__damping_convergence-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. DF_INTS_IO. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__df_ints_io-1.html:211,LOAD,LOAD,211,psi4manual/1.1.0/autodir_options_c/scf__df_ints_io-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__df_ints_io-1.html,2,['LOAD'],['LOAD']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. GUESS. The type of guess orbitals. Defaults to SAD for RHF, GWH for ROHF and UHF, and READ for geometry optimizations after the first step. Type: string; Possible Values: AUTO, CORE, GWH, SAD, READ; Default: AUTO. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__guess-1.html:224,optimiz,optimizations,224,psi4manual/1.1.0/autodir_options_c/scf__guess-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__guess-1.html,2,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. GUESS_PERSIST. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__guess_persist-1.html:239,optimiz,optimization,239,psi4manual/1.1.0/autodir_options_c/scf__guess_persist-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__guess_persist-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. MAX_ATTEMPTS. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__max_attempts-1.html:198,optimiz,optimization,198,psi4manual/1.1.0/autodir_options_c/scf__max_attempts-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__max_attempts-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. QCHF. Do perform a QCHF computation?. Type: boolean; Default: false. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__qchf-1.html:129,perform,perform,129,psi4manual/1.1.0/autodir_options_c/scf__qchf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__qchf-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. SOSCF_MAX_ITER. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__soscf_max_iter-1.html:186,perform,perform,186,psi4manual/1.1.0/autodir_options_c/scf__soscf_max_iter-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__soscf_max_iter-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. SOSCF_MIN_ITER. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__soscf_min_iter-1.html:186,perform,perform,186,psi4manual/1.1.0/autodir_options_c/scf__soscf_min_iter-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__soscf_min_iter-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. STABILITY_ANALYSIS. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__stability_analysis-1.html:151,perform,perform,151,psi4manual/1.1.0/autodir_options_c/scf__stability_analysis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/scf__stability_analysis-1.html,6,['perform'],"['perform', 'performed']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. Input File; Description. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:299,optimiz,optimizations,299,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,6,['optimiz'],"['optimization', 'optimizations']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; ADC. CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; ADC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/adc__cachelevel-1.html:122,CACHE,CACHELEVEL,122,psi4manual/1.2.1/autodir_options_c/adc__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/adc__cachelevel-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCDENSITY. CACHELEVEL. The amount of caching of data to perform. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCDENSITY. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccdensity__cachelevel-1.html:128,CACHE,CACHELEVEL,128,psi4manual/1.2.1/autodir_options_c/ccdensity__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccdensity__cachelevel-1.html,4,"['CACHE', 'perform']","['CACHELEVEL', 'perform']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccenergy__cachelevel-1.html:127,CACHE,CACHELEVEL,127,psi4manual/1.2.1/autodir_options_c/ccenergy__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccenergy__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccenergy__cachetype-1.html:127,CACHE,CACHETYPE,127,psi4manual/1.2.1/autodir_options_c/ccenergy__cachetype-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccenergy__cachetype-1.html,8,"['CACHE', 'cache']","['CACHETYPE', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. RESTART. Do restart the coupled-cluster iterations from old \(t_1\) and \(t_2\) amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccenergy__restart-1.html:232,optimiz,optimizations,232,psi4manual/1.2.1/autodir_options_c/ccenergy__restart-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccenergy__restart-1.html,2,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. SCSN_MP2. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccenergy__scsn_mp2-1.html:164,optimiz,optimized,164,psi4manual/1.2.1/autodir_options_c/ccenergy__scsn_mp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccenergy__scsn_mp2-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCEOM. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCEOM. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cceom__cachelevel-1.html:124,CACHE,CACHELEVEL,124,psi4manual/1.2.1/autodir_options_c/cceom__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cceom__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCEOM. CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCEOM. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cceom__cachetype-1.html:124,CACHE,CACHETYPE,124,psi4manual/1.2.1/autodir_options_c/cceom__cachetype-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cceom__cachetype-1.html,4,"['CACHE', 'cache']","['CACHETYPE', 'cached']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCHBAR. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCHBAR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cchbar__cachelevel-1.html:125,CACHE,CACHELEVEL,125,psi4manual/1.2.1/autodir_options_c/cchbar__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cchbar__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cclambda__cachelevel-1.html:127,CACHE,CACHELEVEL,127,psi4manual/1.2.1/autodir_options_c/cclambda__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cclambda__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. JOBTYPE. Type of job being performed. Type: string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cclambda__jobtype-1.html:154,perform,performed,154,psi4manual/1.2.1/autodir_options_c/cclambda__jobtype-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cclambda__jobtype-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. CACHELEVEL. Caching level for libdpd. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccresponse__cachelevel-1.html:129,CACHE,CACHELEVEL,129,psi4manual/1.2.1/autodir_options_c/ccresponse__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/ccresponse__cachelevel-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCTRANSORT. CACHELEVEL. Caching level for libdpd. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CCTRANSORT. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cctransort__cachelevel-1.html:129,CACHE,CACHELEVEL,129,psi4manual/1.2.1/autodir_options_c/cctransort__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cctransort__cachelevel-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CACHE_RECS. The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_cache_recs-1.html:180,cache,cache,180,psi4manual/1.2.1/autodir_options_c/cfour__cfour_cache_recs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_cache_recs-1.html,2,['cache'],['cache']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CALC_LEVEL. Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Possible Values: SCF, HF, MBPT(2), MP2, MBPT(3), MP3, SDQ-MBPT(4), SDQ-MP4, MBPT(4), MP4, CCD, CCSD, CCSD(T), CCSDT-1, CCSDT-1b, CCSDT-2, CCSDT-3, CCSDT-4, CCSDT, CC2, CC3, QCISD, QCISD(T), CID, CISD, UCC(4), B-CCD; Default: SCF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_calc_level-1.html:181,perform,performed,181,psi4manual/1.2.1/autodir_options_c/cfour__cfour_calc_level-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_calc_level-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CC_PROGRAM. Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, NCC, MRCC, EXTERNAL; Default: VCC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_cc_program-1.html:423,perform,performance,423,psi4manual/1.2.1/autodir_options_c/cfour__cfour_cc_program-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_cc_program-1.html,4,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_COORDINATES. Specifies the type of coordinates used in the input file ZMAT. Value INTERNAL (=0) means that the geometry is supplied in the usual Z-matrix format, while CARTESIAN (=1) means that the geometry is given in Cartesian coordinates. A third option is XYZINT (=2) for which a Z-matrix connectivity is defined, but with values of the internal coordinates defined implicitly by supplying Cartesian coordinates. Note that geometry optimizations are currently only possible for INTERNAL and XYZ2INT. Psi4 Interface: Keyword set from active molecule, always CARTESIAN. Above restrictions on geometry optimizations no longer apply. Type: string; Possible Values: INTERNAL, CARTESIAN, XYZINT; Default: INTERNAL. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_coordinates-1.html:566,optimiz,optimizations,566,psi4manual/1.2.1/autodir_options_c/cfour__cfour_coordinates-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_coordinates-1.html,4,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CURVILINEAR. Specifies whether or not Hessian matrix is transformed (nonlinearly) to curvilinear internal coordinates. A value of 0 (or OFF) turns the transformation off if the analytic force constants are not available, while it is always performed if CURVILINEAR=1 (or ON). Values higher than 1 (or NO) unconditionally turn the transformation off.(Default: ON if analytic Hessian is available, OFF otherwise). Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_curvilinear-1.html:370,perform,performed,370,psi4manual/1.2.1/autodir_options_c/cfour__cfour_curvilinear-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_curvilinear-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_DERIV_LEVEL. Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimization(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_deriv_level-1.html:673,optimiz,optimization,673,psi4manual/1.2.1/autodir_options_c/cfour__cfour_deriv_level-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_deriv_level-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_EVAL_HESS. Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_eval_hess-1.html:188,optimiz,optimization,188,psi4manual/1.2.1/autodir_options_c/cfour__cfour_eval_hess-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_eval_hess-1.html,6,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_EXCITE. Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_excite-1.html:189,perform,performed,189,psi4manual/1.2.1/autodir_options_c/cfour__cfour_excite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_excite-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_FD_IRREPS. Requests that only vibrational frequencies of certain symmetry types are evaluated in a VIBRATION=FINDIF calculation. The numbers of the irreducible representations for which vibrational analysis is to be performed are separated by slashes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_fd_irreps-1.html:346,perform,performed,346,psi4manual/1.2.1/autodir_options_c/cfour__cfour_fd_irreps-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_fd_irreps-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GENBAS_2. This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_genbas_2-1.html:153,perform,performs,153,psi4manual/1.2.1/autodir_options_c/cfour__cfour_genbas_2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_genbas_2-1.html,2,['perform'],['performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GENBAS_3. This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_genbas_3-1.html:153,perform,performs,153,psi4manual/1.2.1/autodir_options_c/cfour__cfour_genbas_3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_genbas_3-1.html,2,['perform'],['performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GENBAS_4. This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_genbas_4-1.html:153,perform,performs,153,psi4manual/1.2.1/autodir_options_c/cfour__cfour_genbas_4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_genbas_4-1.html,2,['perform'],['performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GEO_CONV. Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_conv-1.html:189,optimiz,optimization,189,psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_conv-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_conv-1.html,8,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GEO_MAXCYC. Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_maxcyc-1.html:191,optimiz,optimization,191,psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_maxcyc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_maxcyc-1.html,6,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GEO_MAXSTEP. Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_maxstep-1.html:210,optimiz,optimizations,210,psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_maxstep-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_maxstep-1.html,6,['optimiz'],"['optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_GEO_METHOD. Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_method-1.html:170,optimiz,optimization,170,psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_geo_method-1.html,6,['optimiz'],"['optimization', 'optimized']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_HFSTABILITY. Control analysis of the stability of RHF, ROHF and UHF wavefunctions, as well as a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC , after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_hfstability-1.html:356,perform,performs,356,psi4manual/1.2.1/autodir_options_c/cfour__cfour_hfstability-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_hfstability-1.html,4,['perform'],['performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_JODA_PRINT. Controls amount of debug printing performed by xjoda. The higher the number, the more information is printed. Values of 25 or higher generally do not produce anything of interest to the general user. Do not set JODA_PRINT to 999 as this will cause the core vector to be dumped to disk. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_joda_print-1.html:176,perform,performed,176,psi4manual/1.2.1/autodir_options_c/cfour__cfour_joda_print-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_joda_print-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_LOCK_ORBOCC. This keyword is used by the SCF program to determine if the orbital occupancy (by symmetry block) is allowed to change in the course of the calculation. ON (=1) locks the occupation to that set by the keyword CFOUR_OCCUPATION (or the initial guess if omitted); OFF (= 0) permits the occupation to change. (Default : 1 if the occupation is specified with CFOUR_OCCUPATION and for second and later steps of optimizations; 0 if CFOUR_OCCUPATION omitted.). Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_lock_orbocc-1.html:548,optimiz,optimizations,548,psi4manual/1.2.1/autodir_options_c/cfour__cfour_lock_orbocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_lock_orbocc-1.html,2,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_METHOD. Specifies the geometry optimization strategy. Four values are permitted: NR (=0) – Straightforward Newton-Raphson search for minimum; RFA (=1) – Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_method-1.html:161,optimiz,optimization,161,psi4manual/1.2.1/autodir_options_c/cfour__cfour_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_method-1.html,6,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_MRCC. Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_mrcc-1.html:179,perform,performs,179,psi4manual/1.2.1/autodir_options_c/cfour__cfour_mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_mrcc-1.html,2,['perform'],['performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_NEGEVAL. Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead. Type: string; Possible Values: ABORT, SWITCH, RFA; Default: ABORT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_negeval-1.html:263,optimiz,optimization,263,psi4manual/1.2.1/autodir_options_c/cfour__cfour_negeval-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_negeval-1.html,8,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_QRHFGUES. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_qrhfgues-1.html:576,perform,performed,576,psi4manual/1.2.1/autodir_options_c/cfour__cfour_qrhfgues-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_qrhfgues-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_QRHF_GENERAL. The presence of this keyword specifies that a QRHF based CC calculation, or alternatively, an SCF calculation that uses the CFOUR_QRHFGUES option, is to be performed. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_qrhf_general-1.html:300,perform,performed,300,psi4manual/1.2.1/autodir_options_c/cfour__cfour_qrhf_general-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_qrhf_general-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_REFERENCE. Specifies the type of SCF calculation to be performed. RHF (= 0) requests a restricted Hartree-Fock reference; UHF (= 1) an unrestricted Hartree-Fock reference; ROHF (= 2) a restricted open-shell Hartree-Fock calculation; TCSCF (=3) a two-configurational SCF calculation, and CASSCF (=4) a complete-active space SCF calculations (currently not implemented). Psi4 Interface: Keyword subject to translation from value of REFERENCE unless set explicitly. Type: string; Possible Values: RHF, UHF, ROHF, TCSCF, CASSCF; Default: RHF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_reference-1.html:185,perform,performed,185,psi4manual/1.2.1/autodir_options_c/cfour__cfour_reference-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_reference-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_RES_RAMAN. This option can be used to convert an analytically calculated gradient vector to a particular normal coordinate representation. A useful application is to calculate the gradient of an electronically excited state in the normal coordinate representation of the ground electronic state, as this provides a first approximation to resonance Raman intensities (hence the name of the keyword). Calculations that use the this option require the externally supplied force constant matrix FCMFINAL, which is written to disk during the course of both analytic and finite-difference vibrational frequency calculations. No such transformation is performed if OFF (=0); while ON (=1) directs the program to evaluate the gradient and transform it to the chosen set of normal coordinates. A warning message is printed if the force constant matrix is unavailable. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_res_raman-1.html:775,perform,performed,775,psi4manual/1.2.1/autodir_options_c/cfour__cfour_res_raman-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_res_raman-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_UPDATE_HESSIAN. Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_update_hessian-1.html:342,optimiz,optimization,342,psi4manual/1.2.1/autodir_options_c/cfour__cfour_update_hessian-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_update_hessian-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_VIBRATION. Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF, EXACT; Default: NO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_vibration-1.html:743,perform,performed,743,psi4manual/1.2.1/autodir_options_c/cfour__cfour_vibration-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_vibration-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_VTRAN. This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the \((ab \vert cd)\) integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_vtran-1.html:204,perform,performed,204,psi4manual/1.2.1/autodir_options_c/cfour__cfour_vtran-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/cfour__cfour_vtran-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DCFT. CACHELEVEL. Controls how to cache quantities within the DPD library. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DCFT. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dcft__cachelevel-1.html:123,CACHE,CACHELEVEL,123,psi4manual/1.2.1/autodir_options_c/dcft__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dcft__cachelevel-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DCFT. GUESS_R_CONVERGENCE. Convergence criterion for the density cumulant and orbital guess for the variationally orbital-optimized DCFT methods. Currently only available for ALGORITHM = SIMULTANEOUS. Type: conv double; Default: 1e-3. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DCFT. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dcft__guess_r_convergence-1.html:239,optimiz,optimized,239,psi4manual/1.2.1/autodir_options_c/dcft__guess_r_convergence-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dcft__guess_r_convergence-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DCFT. ODC_GUESS. Whether to perform a guess DC-06 or DC-12 computation for ODC-06 or ODC-12 methods, respectively. Currently only available for ALGORITHM = SIMULTANEOUS. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DCFT. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dcft__odc_guess-1.html:145,perform,perform,145,psi4manual/1.2.1/autodir_options_c/dcft__odc_guess-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dcft__odc_guess-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DCFT. RELAX_GUESS_ORBITALS. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DCFT. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dcft__relax_guess_orbitals-1.html:231,perform,performing,231,psi4manual/1.2.1/autodir_options_c/dcft__relax_guess_orbitals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dcft__relax_guess_orbitals-1.html,2,['perform'],['performing']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DCFT. STABILITY_CHECK. Performs stability analysis of the DCFT energy. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DCFT. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dcft__stability_check-1.html:140,Perform,Performs,140,psi4manual/1.2.1/autodir_options_c/dcft__stability_check-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dcft__stability_check-1.html,2,['Perform'],['Performs']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DETCI. FOLLOW_ROOT. The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DETCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/detci__follow_root-1.html:299,optimiz,optimization,299,psi4manual/1.2.1/autodir_options_c/detci__follow_root-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/detci__follow_root-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DETCI. ICORE. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DETCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/detci__icore-1.html:211,perform,perform,211,psi4manual/1.2.1/autodir_options_c/detci__icore-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/detci__icore-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DETCI. LSE_TOLERANCE. Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DETCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/detci__lse_tolerance-1.html:202,perform,performed,202,psi4manual/1.2.1/autodir_options_c/detci__lse_tolerance-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/detci__lse_tolerance-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFMP2. DF_INTS_IO. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFMP2. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfmp2__df_ints_io-1.html:215,LOAD,LOAD,215,psi4manual/1.2.1/autodir_options_c/dfmp2__df_ints_io-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfmp2__df_ints_io-1.html,2,['LOAD'],['LOAD']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. DO_SCS. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__do_scs-1.html:135,perform,perform,135,psi4manual/1.2.1/autodir_options_c/dfocc__do_scs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__do_scs-1.html,6,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. DO_SOS. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__do_sos-1.html:135,perform,perform,135,psi4manual/1.2.1/autodir_options_c/dfocc__do_sos-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__do_sos-1.html,6,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. MO_STEP_MAX. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__mo_step_max-1.html:166,optimiz,optimization,166,psi4manual/1.2.1/autodir_options_c/dfocc__mo_step_max-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__mo_step_max-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. MP2_SOS_SCALE2. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__mp2_sos_scale2-1.html:178,optimiz,optimized-,178,psi4manual/1.2.1/autodir_options_c/dfocc__mp2_sos_scale2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__mp2_sos_scale2-1.html,2,['optimiz'],['optimized-']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. OPT_METHOD. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__opt_method-1.html:148,optimiz,optimization,148,psi4manual/1.2.1/autodir_options_c/dfocc__opt_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__opt_method-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. ORB_OPT. Do optimize the orbitals?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__orb_opt-1.html:136,optimiz,optimize,136,psi4manual/1.2.1/autodir_options_c/dfocc__orb_opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__orb_opt-1.html,2,['optimiz'],['optimize']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. QCHF. Do perform a QCHF computation?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; DFOCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__qchf-1.html:133,perform,perform,133,psi4manual/1.2.1/autodir_options_c/dfocc__qchf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/dfocc__qchf-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; FNOCC. BRUECKNER_MAXITER. Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; FNOCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/fnocc__brueckner_maxiter-1.html:195,optimiz,optimization,195,psi4manual/1.2.1/autodir_options_c/fnocc__brueckner_maxiter-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/fnocc__brueckner_maxiter-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. FROZEN_DOCC. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/globals__frozen_docc-1.html:284,optimiz,optimized,284,psi4manual/1.2.1/autodir_options_c/globals__frozen_docc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/globals__frozen_docc-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. FROZEN_UOCC. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/globals__frozen_uocc-1.html:281,optimiz,optimized,281,psi4manual/1.2.1/autodir_options_c/globals__frozen_uocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/globals__frozen_uocc-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. RESTRICTED_DOCC. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/globals__restricted_docc-1.html:273,optimiz,optimized,273,psi4manual/1.2.1/autodir_options_c/globals__restricted_docc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/globals__restricted_docc-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. RESTRICTED_UOCC. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; GLOBALS. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/globals__restricted_uocc-1.html:269,optimiz,optimized,269,psi4manual/1.2.1/autodir_options_c/globals__restricted_uocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/globals__restricted_uocc-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; MCSCF. FAVG. Do use the average Fock matrix during the SCF optimization?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; MCSCF. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/mcscf__favg-1.html:176,optimiz,optimization,176,psi4manual/1.2.1/autodir_options_c/mcscf__favg-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/mcscf__favg-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; MRCC. MRCC_METHOD. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; MRCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/mrcc__mrcc_method-1.html:213,perform,performed,213,psi4manual/1.2.1/autodir_options_c/mrcc__mrcc_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/mrcc__mrcc_method-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__cachelevel-1.html:122,CACHE,CACHELEVEL,122,psi4manual/1.2.1/autodir_options_c/occ__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. DO_SCS. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__do_scs-1.html:133,perform,perform,133,psi4manual/1.2.1/autodir_options_c/occ__do_scs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__do_scs-1.html,6,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. DO_SOS. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__do_sos-1.html:133,perform,perform,133,psi4manual/1.2.1/autodir_options_c/occ__do_sos-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__do_sos-1.html,6,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. MO_STEP_MAX. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__mo_step_max-1.html:164,optimiz,optimization,164,psi4manual/1.2.1/autodir_options_c/occ__mo_step_max-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__mo_step_max-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. MP2_SOS_SCALE2. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__mp2_sos_scale2-1.html:176,optimiz,optimized-,176,psi4manual/1.2.1/autodir_options_c/occ__mp2_sos_scale2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__mp2_sos_scale2-1.html,2,['optimiz'],['optimized-']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. OPT_METHOD. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__opt_method-1.html:138,optimiz,optimization,138,psi4manual/1.2.1/autodir_options_c/occ__opt_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__opt_method-1.html,4,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. ORB_OPT. Do optimize the orbitals?. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__orb_opt-1.html:134,optimiz,optimize,134,psi4manual/1.2.1/autodir_options_c/occ__orb_opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/occ__orb_opt-1.html,2,['optimiz'],['optimize']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. CONSECUTIVE_BACKSTEPS. Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__consecutive_backsteps-1.html:201,optimiz,optimization,201,psi4manual/1.2.1/autodir_options_c/optking__consecutive_backsteps-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__consecutive_backsteps-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. DYNAMIC_LEVEL. Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__dynamic_level-1.html:168,optimiz,optimization,168,psi4manual/1.2.1/autodir_options_c/optking__dynamic_level-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__dynamic_level-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. FINAL_GEOM_WRITE. Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__final_geom_write-1.html:229,optimiz,optimization,229,psi4manual/1.2.1/autodir_options_c/optking__final_geom_write-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__final_geom_write-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. FIXED_COORD_FORCE_CONSTANT. In constrained optimizations, for coordinates with user-specified equilibrium values, this is the initial force constant (in au) used to apply an additional force to each coordinate. Type: double; Default: 0.5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__fixed_coord_force_constant-1.html:169,optimiz,optimizations,169,psi4manual/1.2.1/autodir_options_c/optking__fixed_coord_force_constant-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__fixed_coord_force_constant-1.html,2,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. FULL_HESS_EVERY. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__full_hess_every-1.html:220,optimiz,optimization,220,psi4manual/1.2.1/autodir_options_c/optking__full_hess_every-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__full_hess_every-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. GEOM_MAXITER. Maximum number of geometry optimization steps. Type: integer; Default: 50. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__geom_maxiter-1.html:167,optimiz,optimization,167,psi4manual/1.2.1/autodir_options_c/optking__geom_maxiter-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__geom_maxiter-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. G_CONVERGENCE. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__g_convergence-1.html:148,optimiz,optimization,148,psi4manual/1.2.1/autodir_options_c/optking__g_convergence-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__g_convergence-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. OPT_COORDINATES. Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__opt_coordinates-1.html:152,optimiz,optimization,152,psi4manual/1.2.1/autodir_options_c/optking__opt_coordinates-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__opt_coordinates-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. STEP_TYPE. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; OPTKING. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__step_type-1.html:146,optimiz,optimization,146,psi4manual/1.2.1/autodir_options_c/optking__step_type-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/optking__step_type-1.html,4,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. CORR_CCSD_T. The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/psimrcc__corr_ccsd_t-1.html:174,perform,perform,174,psi4manual/1.2.1/autodir_options_c/psimrcc__corr_ccsd_t-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/psimrcc__corr_ccsd_t-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. DIIS_START. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/psimrcc__diis_start-1.html:196,perform,performed,196,psi4manual/1.2.1/autodir_options_c/psimrcc__diis_start-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/psimrcc__diis_start-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. MP2_CCSD_METHOD. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/psimrcc__mp2_ccsd_method-1.html:150,perform,perform,150,psi4manual/1.2.1/autodir_options_c/psimrcc__mp2_ccsd_method-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/psimrcc__mp2_ccsd_method-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. PT_ENERGY. The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; PSIMRCC. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/psimrcc__pt_energy-1.html:184,perform,perform,184,psi4manual/1.2.1/autodir_options_c/psimrcc__pt_energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/psimrcc__pt_energy-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SAPT. EXCH_SCALE_ALPHA. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SAPT. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/sapt__exch_scale_alpha-1.html:159,perform,perform,159,psi4manual/1.2.1/autodir_options_c/sapt__exch_scale_alpha-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/sapt__exch_scale_alpha-1.html,6,['perform'],"['perform', 'performs']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. BASIS_GUESS. Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__basis_guess-1.html:161,perform,performing,161,psi4manual/1.2.1/autodir_options_c/scf__basis_guess-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__basis_guess-1.html,2,['perform'],['performing']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. DAMPING_CONVERGENCE. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__damping_convergence-1.html:210,perform,performed,210,psi4manual/1.2.1/autodir_options_c/scf__damping_convergence-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__damping_convergence-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. DF_INTS_IO. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__df_ints_io-1.html:213,LOAD,LOAD,213,psi4manual/1.2.1/autodir_options_c/scf__df_ints_io-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__df_ints_io-1.html,2,['LOAD'],['LOAD']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. GUESS. The type of guess orbitals. Defaults to SAD for RHF, GWH for ROHF and UHF, and READ for geometry optimizations after the first step. Type: string; Possible Values: AUTO, CORE, GWH, SAD, READ; Default: AUTO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__guess-1.html:226,optimiz,optimizations,226,psi4manual/1.2.1/autodir_options_c/scf__guess-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__guess-1.html,2,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. GUESS_PERSIST. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__guess_persist-1.html:241,optimiz,optimization,241,psi4manual/1.2.1/autodir_options_c/scf__guess_persist-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__guess_persist-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. MAX_ATTEMPTS. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__max_attempts-1.html:200,optimiz,optimization,200,psi4manual/1.2.1/autodir_options_c/scf__max_attempts-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__max_attempts-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. QCHF. Do perform a QCHF computation?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__qchf-1.html:131,perform,perform,131,psi4manual/1.2.1/autodir_options_c/scf__qchf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__qchf-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. SOSCF_MAX_ITER. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__soscf_max_iter-1.html:188,perform,perform,188,psi4manual/1.2.1/autodir_options_c/scf__soscf_max_iter-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__soscf_max_iter-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. SOSCF_MIN_ITER. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__soscf_min_iter-1.html:188,perform,perform,188,psi4manual/1.2.1/autodir_options_c/scf__soscf_min_iter-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__soscf_min_iter-1.html,2,['perform'],['perform']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. STABILITY_ANALYSIS. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module; SCF. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__stability_analysis-1.html:153,perform,perform,153,psi4manual/1.2.1/autodir_options_c/scf__stability_analysis-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/scf__stability_analysis-1.html,6,['perform'],"['perform', 'performed']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. Input File; Description. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dft-jk; DFT JK on-disk test. cbs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:301,optimiz,optimizations,301,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,6,['optimiz'],"['optimization', 'optimizations']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; ADC. CACHELEVEL. How to cache quantities within the DPD library. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; ADC. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/adc__cachelevel-1.html:122,CACHE,CACHELEVEL,122,psi4manual/1.3.2/autodir_options_c/adc__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/adc__cachelevel-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCDENSITY. CACHELEVEL. The amount of caching of data to perform. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCDENSITY. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccdensity__cachelevel-1.html:128,CACHE,CACHELEVEL,128,psi4manual/1.3.2/autodir_options_c/ccdensity__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccdensity__cachelevel-1.html,4,"['CACHE', 'perform']","['CACHELEVEL', 'perform']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCENERGY. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccenergy__cachelevel-1.html:127,CACHE,CACHELEVEL,127,psi4manual/1.3.2/autodir_options_c/ccenergy__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccenergy__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCENERGY. CACHETYPE. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccenergy__cachetype-1.html:127,CACHE,CACHETYPE,127,psi4manual/1.3.2/autodir_options_c/ccenergy__cachetype-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccenergy__cachetype-1.html,8,"['CACHE', 'cache']","['CACHETYPE', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCENERGY. RESTART. Do restart the coupled-cluster iterations from old \(t_1\) and \(t_2\) amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccenergy__restart-1.html:232,optimiz,optimizations,232,psi4manual/1.3.2/autodir_options_c/ccenergy__restart-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccenergy__restart-1.html,2,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCENERGY. SCSN_MP2. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccenergy__scsn_mp2-1.html:164,optimiz,optimized,164,psi4manual/1.3.2/autodir_options_c/ccenergy__scsn_mp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccenergy__scsn_mp2-1.html,2,['optimiz'],['optimized']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCEOM. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCEOM. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cceom__cachelevel-1.html:124,CACHE,CACHELEVEL,124,psi4manual/1.3.2/autodir_options_c/cceom__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cceom__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCEOM. CACHETYPE. The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCEOM. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cceom__cachetype-1.html:124,CACHE,CACHETYPE,124,psi4manual/1.3.2/autodir_options_c/cceom__cachetype-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cceom__cachetype-1.html,4,"['CACHE', 'cache']","['CACHETYPE', 'cached']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCHBAR. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCHBAR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cchbar__cachelevel-1.html:125,CACHE,CACHELEVEL,125,psi4manual/1.3.2/autodir_options_c/cchbar__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cchbar__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. CACHELEVEL. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cclambda__cachelevel-1.html:127,CACHE,CACHELEVEL,127,psi4manual/1.3.2/autodir_options_c/cclambda__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cclambda__cachelevel-1.html,8,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. JOBTYPE. Type of job being performed. Type: string; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cclambda__jobtype-1.html:154,perform,performed,154,psi4manual/1.3.2/autodir_options_c/cclambda__jobtype-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cclambda__jobtype-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. CACHELEVEL. Caching level for libdpd. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccresponse__cachelevel-1.html:129,CACHE,CACHELEVEL,129,psi4manual/1.3.2/autodir_options_c/ccresponse__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/ccresponse__cachelevel-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCTRANSORT. CACHELEVEL. Caching level for libdpd. Type: integer; Default: 2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CCTRANSORT. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cctransort__cachelevel-1.html:129,CACHE,CACHELEVEL,129,psi4manual/1.3.2/autodir_options_c/cctransort__cachelevel-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cctransort__cachelevel-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CACHE_RECS. The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_cache_recs-1.html:180,cache,cache,180,psi4manual/1.3.2/autodir_options_c/cfour__cfour_cache_recs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_cache_recs-1.html,2,['cache'],['cache']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CALC_LEVEL. Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Default: SCF. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_calc_level-1.html:181,perform,performed,181,psi4manual/1.3.2/autodir_options_c/cfour__cfour_calc_level-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_calc_level-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CC_PROGRAM. Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, NCC, MRCC, EXTERNAL; Default: VCC. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_cc_program-1.html:423,perform,performance,423,psi4manual/1.3.2/autodir_options_c/cfour__cfour_cc_program-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_cc_program-1.html,4,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_COORDINATES. Specifies the type of coordinates used in the input file ZMAT. Value INTERNAL (=0) means that the geometry is supplied in the usual Z-matrix format, while CARTESIAN (=1) means that the geometry is given in Cartesian coordinates. A third option is XYZINT (=2) for which a Z-matrix connectivity is defined, but with values of the internal coordinates defined implicitly by supplying Cartesian coordinates. Note that geometry optimizations are currently only possible for INTERNAL and XYZ2INT. Psi4 Interface: Keyword set from active molecule, always CARTESIAN. Above restrictions on geometry optimizations no longer apply. Type: string; Possible Values: INTERNAL, CARTESIAN, XYZINT; Default: INTERNAL. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_coordinates-1.html:566,optimiz,optimizations,566,psi4manual/1.3.2/autodir_options_c/cfour__cfour_coordinates-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_coordinates-1.html,4,['optimiz'],['optimizations']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_CURVILINEAR. Specifies whether or not Hessian matrix is transformed (nonlinearly) to curvilinear internal coordinates. A value of 0 (or OFF) turns the transformation off if the analytic force constants are not available, while it is always performed if CURVILINEAR=1 (or ON). Values higher than 1 (or NO) unconditionally turn the transformation off.(Default: ON if analytic Hessian is available, OFF otherwise). Type: boolean; Default: true. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_curvilinear-1.html:370,perform,performed,370,psi4manual/1.3.2/autodir_options_c/cfour__cfour_curvilinear-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_curvilinear-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_DERIV_LEVEL. Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimization(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_deriv_level-1.html:673,optimiz,optimization,673,psi4manual/1.3.2/autodir_options_c/cfour__cfour_deriv_level-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_deriv_level-1.html,2,['optimiz'],['optimization']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_EVAL_HESS. Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_eval_hess-1.html:188,optimiz,optimization,188,psi4manual/1.3.2/autodir_options_c/cfour__cfour_eval_hess-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_eval_hess-1.html,6,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_EXCITE. Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_excite-1.html:189,perform,performed,189,psi4manual/1.3.2/autodir_options_c/cfour__cfour_excite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_excite-1.html,2,['perform'],['performed']
Performance,"﻿. <no title>. Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. CFOUR_FD_IRREPS. Requests that only vibrational frequencies of certain symmetry types are evaluated in a VIBRATION=FINDIF calculation. The numbers of the irreducible representations for which vibrational analysis is to be performed are separated by slashes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module; CFOUR. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_fd_irreps-1.html:346,perform,performed,346,psi4manual/1.3.2/autodir_options_c/cfour__cfour_fd_irreps-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/cfour__cfour_fd_irreps-1.html,2,['perform'],['performed']
