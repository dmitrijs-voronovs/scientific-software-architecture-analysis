quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability," ID in a generic port map, like the `In()` and `Out()` methods on; `Process` processes. This is so that the methods can show up in the; auto-completion / intellisense function in code editors removing the need to; look up the name of the ports manually in the library code all the time. ## How to create re-usable components in SciPipe. Process processes created with the `scipipe.NewProc()` command, can be turned; into such ""re-usable"" component by using a wrapping strategy, that is; demonstrated in an [example on GitHub](https://github.com/scipipe/scipipe/blob/master/examples/wrapper_procs/wrap.go). The idea is to create a new struct type for the re-usable component, and; then, in the factory method for the process, create an ""inner"" process of; type Process, using `NewProc()` as in the normal case, embedding that in the; outer struct and then adding statically defined accessor methods for each of; the ports in the inner process, with a similar name. So, if the inner process; has an outport named ""foo"", you would define an accessor method named; `myproc.OutFoo()` that returns this port from the inner process. Let's look at a code example of how this works, by creating a process that just; writes ""hi"" to a file:. ```go; type HiWriter struct {; // Embedd a Process struct; 	*sci.Process; }. func NewHiWriter() *HiWriter {; // Initialize a normal ""Process"" to use as an ""inner"" process; 	innerHiWriter := sci.NewProc(""hiwriter"", ""echo hi > {o:hifile}""); 	innerHiWriter.SetOut(""hifile"", ""hi.txt""). // Create a new HiWriter process with the inner process embedded into it; 	return &HiWriter{innerHiWriter}; }. // OutHiFile provides a static version of the ""hifile"" port in the inner; // (embedded) process; func (p *HiWriter) OutHiFile() *sci.OutPort {; // Return the inner process' port named ""hifile""; return p.Out(""hifile""); }; ```. ## See also. - [A full, working, workflow example using this trategy](https://github.com/scipipe/scipipe/blob/master/examples/wrapper_procs/wrap.go); ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md:1754,echo,echo,1754,docs/howtos/reusable_components.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md,1,['echo'],['echo']
Availability," Ubuntu it can be installed with the command: `sudo apt-get install graphviz`). ## How to plot graphs. To write a .dot file in SciPipe, include a line like follows, in your workflow; definition, provided that you have initiated the variable `wf` with a workflow; struct:. ```go; func main() {; wf := scipipe.NewWorkflow(""my workflow"", 4); // Workflow code here; wf.PlotGraph(""my_workflow_graph.dot"") // <-- SEE THIS LINE!; wf.Run(); }; ```. If you want to also convert the dot file to PDF in one go, instead change the; next last line to:. ```go; wf.PlotGraphPDF(""my_workflow_graph.dot""); ```. ## How to plot graphs conditionally based on a flag. Now, you might not want to generate a new plot every time you run your workflow; (although, perhaps you would? ... checking in a .dot version of your workflow; could in fact be a great way to keep a more readable version of your workflow; at hand ... but anyhow), you could make the plotting optional, based on a flag.; This is something we've found ourselves doing quite often at pharmb.io. This; could be done as follows (more complete code example):. ```go; package main. import (; ""flag""; ""github.com/scipipe/scipipe""; ). var (; plotGraph = flag.Bool(""plotgraph"", false, ""Plot a directed graph of the workflow to PDF""); ). func main() {; flag.Parse(). wf := scipipe.NewWorkflow(""testwf"", 4); wf.NewProc(""foo"", ""echo foo > {o:out}""). if *plotGraph {; wf.PlotGraphPDF(""wfgraph.dot""); }; wf.Run(); }; ```. Now, the graph will only plotted if you run your workflow with the; `-plotgraph` flag, e.g:. ```bash; go run myworkflow.go -plotgraph; ```. ## Links. - [GoDoc for Workflow.PlotGraph()](https://godoc.org/github.com/scipipe/scipipe#Workflow.PlotGraph); - [GoDoc for Workflow.PlotGraphPDF()](https://godoc.org/github.com/scipipe/scipipe#Workflow.PlotGraphPDF). ## Footnotes. [1] these are often called ""DAG"" for ""Directed Acyclic Graph"", but; SciPipe does not have a guarantee or requirement on acyclicness of the graph,; thus just ""directed graph"".",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/plot_workflow_graph.md:1802,echo,echo,1802,docs/howtos/plot_workflow_graph.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/plot_workflow_graph.md,1,['echo'],['echo']
Availability,"# Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This library is has been much influenced/inspired also by the; [GoFlow](https://github.com/trustmaster/goflow) library by [Vladimir Sibirov](https://github.com/trustmaster/goflow).; - Thanks to [Egon Elbre](http://twitter.com/egonelbre) for helpful input on the; design of the internals of the pipeline, and processes, which greatly; simplified the implementation.; - This work is financed by faculty grants and other financing for the [Pharmaceutical Bioinformatics group](http://pharmb.io) of [Dept. of; Pharmaceutical Biosciences](http://www.farmbio.uu.se) at [Uppsala University](http://www.uu.se), and by [Swedish Research Council](http://vr.se); through the Swedish [National Bioinformatics Infrastructure Sweden](http://nbis.se).; - Supervisor for the project is [Ola Spjuth](http://www.farmbio.uu.se/research/researchgroups/pb/olaspjuth).; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/acknowledgements.md:420,avail,available,420,docs/acknowledgements.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/acknowledgements.md,1,['avail'],['available']
Availability,"# Contributing to SciPipe. ## Working with forked repository. Unlike other languages like C++/Python, Go requires modules being referenced,; to be placed in a specific location for the import to work. Forking via GitHub; provides a pull request workflow that is well documented but does not work well; with Go import. Documented here is one approach utilizing go modules. First, fork and clone SciPipe the usual way via GitHub to a local file system,; lets call it `<cloned-scipipe-dir>`. To work on and test the changes made to scipipe in the cloned location, create; a directory for your scipipe workflows, lets call it `<workflow-dev-dir>`. In; that directory, you can create a simple `main.go` file with a `package main` so; that you can run your code that exercises the changes you are making at; `<cloned-scipipe-dir>`. Note that if you were to run your code in `main.go` as-is, it would pull down; the code from the repository and cache them and you will not actually be able; to test any local changes in scipipe. To do so, you need to create a file call; `go.mod`. In `<workflow-dev-dir>` run the following:. ```; go mod init <some package name>; ```. Note: The actual name of the package is not critical. Next, define the modules required by your main.go:. ```; go mod edit -require=github.com/scipipe/scipipe@v0.9.10; ```. Note: A the time of this writing, v0.9.10 is the latest published version, this; will change over time and you need to adapt. Next, replace any reference to the previous URL with reference to the; `<cloned-scipipe-dir>` location:. ```; go mod edit -replace=github.com/scipipe/scipipe@v0.9.10=<cloned-scipipe-dir>; ```. Now when you do:. ```; go run main.go; ```. ... it will not be pulling the code from GitHub but references the code you; have cloned locally. Do your development work and push to your forked repository and do a pull; request for the author to review and optionally merge the contribution.; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md:899,down,down,899,docs/contributing.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md,1,['down'],['down']
Availability,"# DNA Reverse complement example. A simple example workflow implemented with SciPipe. The workflow computes the; reverse base complement of a string of DNA, using standard UNIX tools. ## Detailed explanation of the code. See the revcomplement.go file for the source code, or here below:. ```go; package main. import (; 	""github.com/scipipe/scipipe""; ). const dna = ""AAAGCCCGTGGGGGACCTGTTC"". func main() {; 	// Initialize workflow, using max 4 CPU cores; 	wf := scipipe.NewWorkflow(""DNA Base Complement Workflow"", 4). 	// Initialize processes based on shell commands:. 	// makeDNA writes a DNA string to a file; 	makeDNA := wf.NewProc(""Make DNA"", ""echo ""+dna+"" > {o:dna}""); 	makeDNA.SetOut(""dna"", ""dna.txt""). 	// complmt computes the base complement of a DNA string; 	complmt := wf.NewProc(""Base Complement"", ""cat {i:in} | tr ATCG TAGC > {o:compl}""); 	complmt.SetOut(""compl"", ""{i:in|%.txt}.compl.txt""). 	// reverse reverses the input DNA string; 	reverse := wf.NewProc(""Reverse"", ""cat {i:in} | rev > {o:rev}""); 	reverse.SetOut(""rev"", ""{i:in|%.txt}.rev.txt""). 	// Connect data dependencies between out- and in-ports; 	complmt.In(""in"").From(makeDNA.Out(""dna"")); 	reverse.In(""in"").From(complmt.Out(""compl"")). 	// Run the workflow; 	wf.Run(); }; ```. On line 4, the SciPipe library is imported, to be later accessed as scipipe. On; line 7, a short string of DNA is defined. On line 9-33, the full workflow is; implemented in the program’s main() function, meaning that it will be executed; when the resulting program is executed. On line 11, a new workflow object (or; “struct” in Go terms) is initiated with a name and the maximum number of cores; to use. On lines 15-25, the workflow components, or processes, are initiated,; each with a name and a shell command pattern. Input file names are defined with; a placeholder on the form {i:INPORTNAME} and outputs on the form; {o:OUTPORTNAME}. The port-name will be used later to access the corresponding; ports for setting up data dependencies. On line 16, ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md:647,echo,echo,647,examples/revcomplement/README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md,1,['echo'],['echo']
Availability,"# Installing SciPipe. Installing SciPipe means first installing the Go programming langauge, and then; using Go's `go install` command to install the SciPipe library. After this, you will; be able to use Go's `go run` command to run SciPipe workflows. ## Install Go. Install Go by following the instructions [on this page](https://golang.org/doc/install#install), for your operating system. To make sure that everything is installed, run the `go` command in your; terminal, and make sure that it outputs something. To be specific, you can try exetuging `go version`, which sould output something; like the below:. ```bash; $ go version; go version go1.17 linux/amd64; ```; ; ## Install SciPipe. There are two main ways of installing SciPipe, one which is super-easy, and one; which is recommended if you want to make sure that your workflow will never; break because of API changes in SciPipe, and that you always have a copy of the; SciPipe source code available. ### Easy: Using go install. The easiest way to intsall SciPipe is by using the `go install` tool in the Go; tool chain. To install scipipe with `go install`, run the following command in; your terminal:. ```bash; go install github.com/scipipe/scipipe/...@latest; ```. **N.B:** Don't miss the `...`, as otherwise the `scipipe` helper tool will not be installed. ## Initialize a new workflow file. Now, you should be able to write code like in the example below, in files; ending with `.go`. The easiest way to get started is to let the scipipe tool generate a starting point for you:. ```bash; scipipe new myfirstworkflow.go; ```. ... which you can then edit to your liking. ## Create a Go module. Before you can run the workflow, you need to also create a [go module](https://golang.org/ref/mod#introduction). To do this, you can run the following command, in the directory where you; created your first workflow:. ```bash; go mod init <package-name>; ```. For `<module-name>`, you have to replace it with a name of the package.; For a ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:954,avail,available,954,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,1,['avail'],['available']
Availability,"# Writing Workflows - An Overview. In order to give an overview of how to write workflows in SciPipe, let's look; at the example workflow used on the front page again:. ```go; package main. import (; // Import SciPipe; ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and a number for max concurrent tasks, so we; // don't overbook our CPU (it is recommended to set it to the number of CPU; // cores of your computer); wf := scipipe.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. Now let's go through the code example in some detail, to see what we are; actually doing. ## Initializing processes. ```go; // Initialize processes from shell command patterns; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); ```. Here we are initializing two new processes, both of them based on a shell; command, using the `wf.NewProc()` function, which takes a processname, and; a shell command pattern as input. ### The shell command pattern. The shell command patterns, in this case `echo 'Hello ' > {o:out}` and; `echo $(cat {i:in}) World >> {o:out}`, are basically normal bash; shell commands, with the addition of ""placeholders"" for input and output; filenames. Input filename placeholders are on the form `{i:INPORT-NAME}` and the output; filename placeholders are similarly of the form `{o:OUTPORT-NAME}`. These; placeholders will be replaced with actual filenames when the command is; executed later. The reason that it a port-name is used to name them, is that; files will be queued on the channel connecting to the port, and for each set of; files on in-ports, a com",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:574,echo,echo,574,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,2,['echo'],['echo']
Availability,"//en.wikipedia.org/wiki/Flow-based_programming) like; pattern in pure Go presented in; [this](http://blog.gopheracademy.com/composable-pipelines-pattern) and; [this](https://blog.gopheracademy.com/advent-2015/composable-pipelines-improvements/); blog posts on Gopher Academy. ## Citing SciPipe. If you use SciPipe in academic or scholarly work, please cite the following paper as source:. Lampa S, Dahlö M, Alvarsson J, Spjuth O. SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines ; _Gigascience_. 8, 5 (2019). DOI: [10.1093/gigascience/giz044](https://dx.doi.org/10.1093/gigascience/giz044). ## Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This library is has been much influenced/inspired also by the; [GoFlow](https://github.com/trustmaster/goflow) library by [Vladimir Sibirov](https://github.com/trustmaster/goflow).; - Thanks to [Egon Elbre](http://twitter.com/egonelbre) for helpful input on the; design of the internals of the pipeline, and processes, which greatly; simplified the implementation.; - This work is financed by faculty grants and other financing for the [Pharmaceutical Bioinformatics group](http://pharmb.io) of [Dept. of; Pharmaceutical Biosciences](http://www.farmbio.uu.se) at [Uppsala University](http://www.uu.se), and by [Swedish Research Council](http://vr.se); through the Swedish [National Bioinformatics Infrastructure Sweden](http://nbis.se).; - Supervisor for the project is [Ola Spjuth](http://www.farmbio.uu.se/research/researchgroups/pb/olaspjuth). ## Related to",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:12436,avail,available,12436,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['avail'],['available']
Availability,"1256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; - <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a. ## Introduction. <img src=""docs/images/fbp_factory.png"" align=""right"">. SciPipe is a library for writing [Scientific; Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system), sometimes; also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:3594,robust,robust,3594,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['robust'],['robust']
Availability,"; <img src=""images/fbp_factory.png"" style=""width: 30%; float: right; margin: 1em;"">; <h1 style=""margin-bottom: 0;""><img src=""images/scipipe_logo_bluegrey_horiz.svg"" style=""width: 240px; margin-left: -10px; margin-bottom: 0;"" alt=""SciPipe""></h1>. <big>Robust, flexible and resource-efficient pipelines using Go and the commandline</big>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. <strong><small>Project links: [GitHub repo](http://github.com/scipipe/scipipe) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</small></strong>. [![Build Status](https://img.shields.io/circleci/project/github/scipipe/scipipe.svg)](https://circleci.com/gh/scipipe/scipipe); [![Test Coverage](https://img.shields.io/codecov/c/github/scipipe/scipipe.svg)](https://codecov.io/gh/scipipe/scipipe); [![Codebeat Grade](https://codebeat.co/badges/96e93624-2ac8-42c9-9e94-2d6e5325d8ff)](https://codebeat.co/projects/github-com-scipipe-scipipe-master); [![Go Report Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipip",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:922,avail,available,922,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['avail'],['available']
Availability,"It is important to carefully manage how much resources (CPU and memory) your; workflows are using, so that you don't overbook you compute node(s). In SciPipe you can do that using two settings:. - Max concurrent tasks, which is set on the workflow level, when initiating a new workflow.; - Cores per tasks, that can be set on processes after they are initialized. Max concurrent tasks is a required setting when initializing workflows, while; cores per task can be left to the default, which is 1 core per task. You might want to change this number if for example you have a software that; uses more memory than the available memory on your computer divided by the max; concurrent tasks number you have set. For example, if you have 8GB of free memory, and have set max concurrent tasks; on your workflow to 4, but you have a process whose commandline application; uses not 2GB of memory, but 4GB, then you might want to set cores per tasks for; that process to 2, so that it gets the double amount of memory. In practice, you set cores per task by setting the field `CoresPerTask` on the process struct, after it is initiated. . ## Example. ```go; foo := scipipe.NewProc(""foo"", ""echo foo > {o:foofile}""); foo.CoresPerTask = 2; ```; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/constrain_resource_usage.md:616,avail,available,616,docs/howtos/constrain_resource_usage.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/constrain_resource_usage.md,2,"['avail', 'echo']","['available', 'echo']"
Availability,"SciPipe allows you to, on-demand, run only specific parts of a workflow. This; can be useful especially if you are doing modifications far up in an already; developed workflow, and want to run only up to a specific process, rather; than also running all downstream processes, which might be unnecessary heavy. This can be done by using the; [workflow.RunTo()](https://godoc.org/github.com/scipipe/scipipe#Workflow.RunTo); method. By using this instead of the normal `workflow.Run()` method, scipipe; will only run this process and all upstream processes of that one. See also a; [simple&nbsp;example](https://github.com/scipipe/scipipe/blob/master/examples/run_specific_procs/run_specific_procs.go); of where this is used. There are a few other variants for specifying parts of workflows (and more; might be added in the future), such as specifying individual process names,; or providing the process structs themselves. Please refer to the relevant; parts of the; [workflow&nbsp;documentation](https://godoc.org/github.com/scipipe/scipipe#Workflow); for more about that.; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/partial_workflows.md:254,down,downstream,254,docs/howtos/partial_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/partial_workflows.md,1,['down'],['downstream']
Availability,"Sometimes you need to create all the possible combinations of a set of files; that you have as file streams. . For example, say that you have two file streams:. ```; [a.txt b.txt]; [1.txt 2.txt 3.txt]; ```. ... and you want to process all of the combinations of these two sets of files.; So in other words, what you want is:. ```; [a.txt a.txt a.txt b.txt b.txt b.txt]; [1.txt 2.txt 3.txt 1.txt 2.txt 3.txt]; ```. This is something you can accomplish with the [FileCombinator](https://godoc.org/github.com/scipipe/scipipe/components#FileCombinator); component, available in [SciPipe 0.9.1](https://github.com/scipipe/scipipe/releases/tag/v0.9.1); and later. ## Example. Given that you have a set of files:. ```; letterfile_a.txt; letterfile_b.txt; numberfile_1.txt; numberfile_2.txt; numberfile_3.txt; ```. ... and you want to create all combinations of the `letter*` files and the `number*`; files, you can do it as follows:. ```go; package main. import (; ""github.com/scipipe/scipipe""; ""github.com/scipipe/scipipe/components""; ). func main() {; wf := scipipe.NewWorkflow(""wf"", 4). letterGlobber := components.NewFileGlobber(wf, ""letter_globber"", ""letterfile_*.txt""); numberGlobber := components.NewFileGlobber(wf, ""number_globber"", ""numberfile_*.txt""). fileCombiner := components.NewFileCombinator(wf, ""file_combiner""); fileCombiner.In(""letters"").From(letterGlobber.Out()); fileCombiner.In(""numbers"").From(numberGlobber.Out()). catenator := wf.NewProc(""catenator"", ""cat {i:letters} {i:numbers} > {o:combined}""); catenator.In(""letters"").From(fileCombiner.Out(""letters"")); catenator.In(""numbers"").From(fileCombiner.Out(""numbers"")); catenator.SetOut(""combined"", ""{i:letters|basename|%.txt}.{i:numbers|basename|%.txt}.combined.txt""). wf.Run(); }; ```. Note that when accessing an in-port on the FileCombinator with the `In(PORTNAME)` method, this port; will be created automatically, together with a corresponding out-port which can be accessed with the; same name, `Out(PORTNAME)`, as can be seen when ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/file_combinations.md:561,avail,available,561,docs/howtos/file_combinations.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/file_combinations.md,1,['avail'],['available']
Availability,"This is [being worked on right now (issue #38)](https://github.com/scipipe/scipipe/issues/38). What you can do right now, is to use the `Prepend` field in processes, to add a; [salloc](https://slurm.schedmd.com/salloc.html) command string (in the case of; SLURM), or any analogous blocking command to other resource managers. So, something like this (See on the third line how the salloc-line is added to the process):. ```go; wf := scipipe.NewWorkflow(""Hello_World_Workflow"", 4); myProc := wf.NewProc(""hello_world"", ""echo Hello World; sleep 10;""); myProc.Prepend = ""salloc -A projectABC123 -p core -t 1:00 -J HelloWorld""; ```. *(Beware: This is not a full code example, and won't compile without some more boilerplate, which you can find in the introductory examples)*. You can find the updated GoDoc for the process struct [here](http://godoc.org/github.com/scipipe/scipipe#Process).; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/hpc.md:518,echo,echo,518,docs/howtos/hpc.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/hpc.md,1,['echo'],['echo']
Availability,"_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. In the `{i:in...` part, we are re-using the file path from the file received on; the in-port named 'in', and then running a Bash-style trim-from-end command on; it to remove the `.txt` extension. Now, if we run this, the file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; ""hello.txt"": {; ""ID"": ""w4oeiii9h5j7sckq7aqq"",; ""ProcessName"": ""hello"",; ""Command"": ""echo 'Hello ' \u003e hello.txt.tmp/hello.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.950032676+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.95468214+02:00"",; ""ExecTimeNS"": 4000000,; ""Upstream"": {}; }; }; ```. Each such audit-file contains a hierarchic JSON-representation of the full; workflow path that was executed in order to produce this file. On the first; level is the command that directly produced the corresponding file, and then,; indexed by their filenames, under ""Upstream"", there is a similar chunk; describing how all of its input files were generated. This process will be; repeated in a recursive way for large workflows, so that, for each file; generated by the workflow, there is always a full, hierarchic, history of all; the commands run - with their associated metadata - to produce that file. You can find many more examples in the [examples folder](https://github.com/scipipe/scipipe/tree/master/examples) in the GitHub repo. Fo",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:9751,echo,echo,9751,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['echo'],['echo']
Availability,"current tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly as a proper; Hello World example should :). Now, these were a little long and ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:6956,echo,echo,6956,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['echo'],['echo']
Availability,"e files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly as a proper; Hello World example should :). Now, these were a little long and cumbersome filenames, weren't they? SciPipe; gives you very good control over how to name your files, if you don't want to; rely on the automatic file naming. For example, we could set the first filename; to a static one, and then use the first name as a basis for the file name for; the second process, like so:. ```go; package main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. In the `{i:in...` part, we are re-using the file path from the file received on; the in-port named 'in', and then running a Bash-style trim-from-end command on; it to remove the `.txt` extension. Now, if we run this, the file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; """,MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:8654,echo,echo,8654,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['echo'],['echo']
Availability,"eleases/tag/v0.9.1); and later. ## Example. Given that you have a set of files:. ```; letterfile_a.txt; letterfile_b.txt; numberfile_1.txt; numberfile_2.txt; numberfile_3.txt; ```. ... and you want to create all combinations of the `letter*` files and the `number*`; files, you can do it as follows:. ```go; package main. import (; ""github.com/scipipe/scipipe""; ""github.com/scipipe/scipipe/components""; ). func main() {; wf := scipipe.NewWorkflow(""wf"", 4). letterGlobber := components.NewFileGlobber(wf, ""letter_globber"", ""letterfile_*.txt""); numberGlobber := components.NewFileGlobber(wf, ""number_globber"", ""numberfile_*.txt""). fileCombiner := components.NewFileCombinator(wf, ""file_combiner""); fileCombiner.In(""letters"").From(letterGlobber.Out()); fileCombiner.In(""numbers"").From(numberGlobber.Out()). catenator := wf.NewProc(""catenator"", ""cat {i:letters} {i:numbers} > {o:combined}""); catenator.In(""letters"").From(fileCombiner.Out(""letters"")); catenator.In(""numbers"").From(fileCombiner.Out(""numbers"")); catenator.SetOut(""combined"", ""{i:letters|basename|%.txt}.{i:numbers|basename|%.txt}.combined.txt""). wf.Run(); }; ```. Note that when accessing an in-port on the FileCombinator with the `In(PORTNAME)` method, this port; will be created automatically, together with a corresponding out-port which can be accessed with the; same name, `Out(PORTNAME)`, as can be seen when we connect the fileCombinator to the catenator process; further down in the code. The program above, if put in a `.go` file and run with `go run file.go`, will generate the following; files (excluding the accompanying .audit.json files):. ```; letterfile_b.txt; letterfile_a.txt; numberfile_3.txt; numberfile_2.txt; numberfile_1.txt; letterfile_a.numberfile_2.combined.txt; letterfile_a.numberfile_1.combined.txt; letterfile_a.numberfile_3.combined.txt; letterfile_b.numberfile_2.combined.txt; letterfile_b.numberfile_1.combined.txt; letterfile_b.numberfile_3.combined.txt; ```. As you can see, all the combinations of the ; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/file_combinations.md:2065,down,down,2065,docs/howtos/file_combinations.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/file_combinations.md,1,['down'],['down']
Availability,"ello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly as a proper; Hello World example should :). Now, these were a little long and cumbersome filenames, weren't they? SciPipe; gives you very good control over how to name your files, if you don't want to; rely on the automatic file naming. For example, we could set the first filename; to a static one, and then use the first name as a basis for the file name for; the second process, like so:. ```go; package main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. In the `{i:in...` part, we are re-using the file path from the file received on; the in-port named 'in', and then running a Bash-style trim-from-end command on; it to remove the `.txt` extension. Now, if we run this, the file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00""",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:8563,echo,echo,8563,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['echo'],['echo']
Availability,"esses, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly as a proper; Hello World example should :). Now, these were a little long and cumbersome filenames, weren't they? SciPipe; gives you very good control",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:7034,echo,echo,7034,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['echo'],['echo']
Availability,"example workflow used on the front page again:. ```go; package main. import (; // Import SciPipe; ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and a number for max concurrent tasks, so we; // don't overbook our CPU (it is recommended to set it to the number of CPU; // cores of your computer); wf := scipipe.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. Now let's go through the code example in some detail, to see what we are; actually doing. ## Initializing processes. ```go; // Initialize processes from shell command patterns; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); ```. Here we are initializing two new processes, both of them based on a shell; command, using the `wf.NewProc()` function, which takes a processname, and; a shell command pattern as input. ### The shell command pattern. The shell command patterns, in this case `echo 'Hello ' > {o:out}` and; `echo $(cat {i:in}) World >> {o:out}`, are basically normal bash; shell commands, with the addition of ""placeholders"" for input and output; filenames. Input filename placeholders are on the form `{i:INPORT-NAME}` and the output; filename placeholders are similarly of the form `{o:OUTPORT-NAME}`. These; placeholders will be replaced with actual filenames when the command is; executed later. The reason that it a port-name is used to name them, is that; files will be queued on the channel connecting to the port, and for each set of; files on in-ports, a command will be created and executed whereafter new files; will be pulled in on the out-ports, and so on. ## Formatting outp",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:1109,echo,echo,1109,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['echo'],['echo']
Availability,"ipe/issues); for details.; - There is not (yet) support for the [Common Workflow Language](http://common-workflow-language.github.io). ## Installing. For full installation instructions, see the [intallation page](/install).; For quick getting started steps, you can do:. 1. [Download](https://golang.org/dl/) and [install](https://golang.org/doc/install) Go; 2. Run the following command, to install the scipipe Go library (don't miss the; trailing dots!), and create a Go module for your script:. ```bash; go install github.com/scipipe/scipipe/...@latest; go mod init myfirstworkflow-module; ```. ## Hello World example. Let's look at an example workflow to get a feel for what writing workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hell",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:6072,echo,echo,6072,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['echo'],['echo']
Availability,"loop. To avoid this situation, you can do one of two things, of which the latter is; generally recommended:. **1.** Create a new copy of the variable, inside the anonymous function:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); val := val // <- Here we create a new copy of the variable; proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. **2.** ... or, better, access the parameter value via the task which the path function receives:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipeline to the workflow, so that the workflow can pull on this port; (technically pulling on a Go channel), in order to drive the workflow. ```go; // Connect network; world.In(""in"").From(helloWriter.Out(""out"")); ```. ## Running the pipeline. So, the final part probably explains itself, but the workflow component is a; relatively simple one that will start each component in a separate go-routine. For technical reasons, one final process has to be run in the main go-routine; (that where the program's `main()` function runs), but generally you don't; need to think about this, as the workflow will then use an in-built; [sink](https://godoc.org/github.com/scipipe/scipipe#Sink) process for this; purpose. If you for any reason need to customize which process to use as the; ""driver"" process, instead of the in-built sink. see the [`SetDriver` section](h",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:7052,avail,available,7052,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['avail'],['available']
Availability,"mes when the command is; executed later. The reason that it a port-name is used to name them, is that; files will be queued on the channel connecting to the port, and for each set of; files on in-ports, a command will be created and executed whereafter new files; will be pulled in on the out-ports, and so on. ## Formatting output file paths. Now we need to provide some way for scipipe to figure out a suitable file name; for each of the files propagating through the ""network"" of processes. This can; be done using special convenience methods on the processes, starting with; `SetOut...`. There are a few variants, of which two of them are shown here. ```go; // Configure output file path formatters for the processes created above; hello.SetOut(""out"", ""hello.txt""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""); ```. `SetOut` takes a pattern similar to the shell command pattern, with; placeholders, used to define new (shell-based) processes. The available; placeholders that can be used are: `{i:INPORTNAME}`, `{p:PARAMNAME}` and; `{t:TAGNAME}`. An example of a full pattern might be:; `{i:foo}.replace_with_{p:replacement}.txt`, but can also be used for; simple, static paths, like in the example above. The placeholders can also take certain extra ""modifiers"", separated from the; placeholder name by pipe characters, and of which the one used above is; probably the most important one: `%STRING`. It will remove the specified; string from the _end_ of the path. This is useful when we want to avoid; getting too long paths when re-using previous processes' paths. With the; example above, our input file named `hello.txt` will be converted into; `hello_world.txt` by this path pattern. ### Available path modifiers. The currently available path modifiers are:. - `basename` - Removes all folders from the path, leaving only the filename.; - Example: `{i:infile|basename}`, if `infile` has the path `data/file.txt`, will convert it to just `file.txt`.; - `dirname` - Removes the ending file ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:2746,avail,available,2746,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['avail'],['available']
Availability,"mmon Workflow Language](http://common-workflow-language.github.io). ## Installing. For full installation instructions, see the [intallation page](/install).; For quick getting started steps, you can do:. 1. [Download](https://golang.org/dl/) and [install](https://golang.org/doc/install) Go; 2. Run the following command, to install the scipipe Go library (don't miss the; trailing dots!), and create a Go module for your script:. ```bash; go install github.com/scipipe/scipipe/...@latest; go mod init myfirstworkflow-module; ```. ## Hello World example. Let's look at an example workflow to get a feel for what writing workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finishe",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:6134,echo,echo,6134,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['echo'],['echo']
Availability,"o_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. Now let's go through the code example in some detail, to see what we are; actually doing. ## Initializing processes. ```go; // Initialize processes from shell command patterns; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); ```. Here we are initializing two new processes, both of them based on a shell; command, using the `wf.NewProc()` function, which takes a processname, and; a shell command pattern as input. ### The shell command pattern. The shell command patterns, in this case `echo 'Hello ' > {o:out}` and; `echo $(cat {i:in}) World >> {o:out}`, are basically normal bash; shell commands, with the addition of ""placeholders"" for input and output; filenames. Input filename placeholders are on the form `{i:INPORT-NAME}` and the output; filename placeholders are similarly of the form `{o:OUTPORT-NAME}`. These; placeholders will be replaced with actual filenames when the command is; executed later. The reason that it a port-name is used to name them, is that; files will be queued on the channel connecting to the port, and for each set of; files on in-ports, a command will be created and executed whereafter new files; will be pulled in on the out-ports, and so on. ## Formatting output file paths. Now we need to provide some way for scipipe to figure out a suitable file name; for each of the files propagating through the ""network"" of processes. This can; be done using special convenience methods on the processes, starting with; `SetOut...`. There are a few variants, of which two of them are shown here. ```go; // Configure output file ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:1411,echo,echo,1411,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,2,['echo'],['echo']
Availability,"orld"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly as a proper; Hello World example should :). Now, these were a little long and cumbersome filenames, weren't they? SciPipe; gives you very good control over how to name your files, if you don't want to; rely on the automatic file naming. For example, we could set ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:7146,echo,echo,7146,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['echo'],['echo']
Availability,"orresponding GitHub repo, e.g.; `github.com/<your-username>/<your-repository>`. By doing this, two files will be created:. ```; go.mod; go.sum; ```. Make sure to add them to your git repository, with:. ```; git add go.mod go.sum; git commit -m ""Add Go module files""; ```. Now, to make sure that scipipe is included as a dependency in the go.mod file,; run the `go mod tidy` command:. ```bash; go mod tidy; ```. The `go.mod` file should now look something like:. ```; module mylittlemodule. go 1.17. require github.com/scipipe/scipipe v0.10.2; ```. ... and the go.sum file might look something like:. ```; github.com/scipipe/scipipe v0.10.2 h1:crXD1gGh/LuBfWfT4CdXcRFtPjem5weyXN03BDfVOuU=; github.com/scipipe/scipipe v0.10.2/go.mod h1:Nwof+Uimtam7GTpkU6cAf/EOnqvxcOVFytjnYU5I3vY=; ```. ### Optional extra step: Use a copy of SciPipe's source code in your own code. In order to make sure that your workflow will never break because of API; changes in SciPipe, and that you always have a copy of the SciPipe source; code available, we recommend to always include a copy of the SciPipe source; code in your workflow's source code repository. The SciPipe source code is; only around 1500 lines of code, with no external dependencies except Go and; Bash, so this should not increase the size of your repository too much. A simple way to do this, is to use Go's `vendor` tool, which stores a local; copy of the source code of packages used, inside the local directory, in; a sub-directory called ""vendor"". To do this, execute the following command:. ```; go mod vendor; ```. Then, to make sure the code is included in your git history, make sure to add it; to git:. ```bash; git add vendor; git commit -m ""Add vendored version of SciPipe""; ```. ## Run your workflow. Now youa re ready to run the workflow. To run a `.go` file, just use `go run <script-file>`, e.g:; ; ```bash; go run myfirstworkflow.go; ```. ## Some tips about editors. In order to be productive with SciPipe, you will also need a Go editor",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:3187,avail,available,3187,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,1,['avail'],['available']
Availability,"p ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:6879,echo,echo,6879,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['echo'],['echo']
Availability,"rt Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipipe); [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1157941.svg)](https://doi.org/10.5281/zenodo.1157941). <strong>Project links: [Documentation & Main Website](http://scipipe.org) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</strong>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. ## Project updates. - <strong>Jan 2020: New screencast:</strong> <a href=""https://www.youtube.com/watch?v=hi0Uqwddrtg"" target=""_blank"">""Hello World"" scientific workflow in SciPipe</a>; - <strong>May 2019: The SciPipe paper published open access in GigaScience:</strong> <a href=""https://doi.org/10.1093/gigascience/giz044"" target=""_blank"">SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines</a>; - <strong>Nov 2018: Scientific study using SciPipe:</strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Predi",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:1837,avail,available,1837,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['avail'],['available']
Availability,"strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a>; </div>. ## Introduction. SciPipe is a library for writing [Scientific Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system),; sometimes also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:3771,robust,robust,3771,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['robust'],['robust']
Availability,"t(""out"", ""hello.txt""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""); ```. `SetOut` takes a pattern similar to the shell command pattern, with; placeholders, used to define new (shell-based) processes. The available; placeholders that can be used are: `{i:INPORTNAME}`, `{p:PARAMNAME}` and; `{t:TAGNAME}`. An example of a full pattern might be:; `{i:foo}.replace_with_{p:replacement}.txt`, but can also be used for; simple, static paths, like in the example above. The placeholders can also take certain extra ""modifiers"", separated from the; placeholder name by pipe characters, and of which the one used above is; probably the most important one: `%STRING`. It will remove the specified; string from the _end_ of the path. This is useful when we want to avoid; getting too long paths when re-using previous processes' paths. With the; example above, our input file named `hello.txt` will be converted into; `hello_world.txt` by this path pattern. ### Available path modifiers. The currently available path modifiers are:. - `basename` - Removes all folders from the path, leaving only the filename.; - Example: `{i:infile|basename}`, if `infile` has the path `data/file.txt`, will convert it to just `file.txt`.; - `dirname` - Removes the ending file name part from the path, leaving only the folder path.; - Example: `{i:infile|dirname}/newfile.txt`, if `infile` has the path `data/file.txt`, will convert it to `data/newfile.txt`.; - `%.<extension>` - Removes the file extension `<extension>`.; - Example: `{i:infile|%.txt}`, if `infile` has the path `file.txt`, will convert it to just `file`.; - `s/<search>/<replacement>/` - Will do a simple search and replace, from `<search>` to `<replacement>`.; - Example: `{i:infile|s/file/my_file/}`, if `infile` has the path `file.txt`, will convert it to `my_file.txt`. ## Even more control over file formatting. We can actually get even more control over how file names are produced than; this, by manually supplying each process with an anonymous func",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:3533,avail,available,3533,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['avail'],['available']
Availability,"tting up data dependencies. On line 16, a component that writes the; previously defined DNA string to a file is initiated, and on line 17, the file; path pattern for the out-port dna is defined (in this case a static file name).; On line 20, a component that translates each DNA base to its complementary; counterpart is initiated. On line 21, the file path pattern for its only; out-port is defined. In this case, reusing the file path of the file it will; receive on its in-port named in, thus the {i:in} part. The %.txt part removes; .txt from the input path. On line 24, a component that will reverse the DNA; string is initiated. On lines 27-29, data dependencies are defined via the in-; and out-ports defined earlier as part of the shell command patterns. On line; 32, the workflow is being run. ## How to run. To run the example, given that you have the [Go toolchain](https://golang.org); installed (a vertion from at least 1.9), you can run it like this:. ```bash; $ go run revcomplement.go ; ```. You are then expected to see some log output similar to the following:. ```log; AUDIT 2019/03/26 22:59:43 | workflow:DNA Base Complement Workflow | Starting workflow (Writing log to log/scipipe-20190326-225943-dna-base-complement-workflow.log); AUDIT 2019/03/26 22:59:43 | Make DNA | Executing: echo AAAGCCCGTGGGGGACCTGTTC > dna.txt; AUDIT 2019/03/26 22:59:43 | Make DNA | Finished: echo AAAGCCCGTGGGGGACCTGTTC > dna.txt; AUDIT 2019/03/26 22:59:43 | Base Complement | Executing: cat ../dna.txt | tr ATCG TAGC > dna.compl.txt; AUDIT 2019/03/26 22:59:43 | Base Complement | Finished: cat ../dna.txt | tr ATCG TAGC > dna.compl.txt; AUDIT 2019/03/26 22:59:43 | Reverse | Executing: cat ../dna.compl.txt | rev > dna.compl.rev.txt; AUDIT 2019/03/26 22:59:43 | Reverse | Finished: cat ../dna.compl.txt | rev > dna.compl.rev.txt; AUDIT 2019/03/26 22:59:43 | workflow:DNA Base Complement Workflow | Finished workflow (Log written to log/scipipe-20190326-225943-dna-base-complement-workflow.log); ```; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md:3264,echo,echo,3264,examples/revcomplement/README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md,2,['echo'],['echo']
Availability,"ty in how parameters can; be used with shell commands. To keep SciPipe a small and flexible tool, we instead mostly leave the choice; up to the workflow author to create a solution for each case, using a few helper; tools provided with SciPipe, but also all the programming facilities built in to; the Go programming language. Below we will discuss how to handle the most common uses for for parameters in; SciPipe. For any more complicated use cases not covered here, please refer to; the [mailing list](https://groups.google.com/forum/#!forum/scipipe) or the; [chat](https://gitter.im/scipipe/scipipe), to ask your question. ## Static parameters. If parameters in your shell command is always, the same, you can just add them; ""manually"" to the shell command pattern used to create your process. For example, if you always want to write the string ""hello"" to output files,; you could create your processes with this string added manually:. ```go; helloWriter := scipipe.NewProc(""helloWriter"", ""echo hello > {o:outfile}""); ```. ### See also. - [Static parameters example](https://github.com/scipipe/scipipe/blob/master/examples/static_params/staticparams.go). ## Receive parameters dynamically. Receiving parameters dynamically is a much more technically demandning solution; than using static parameters. The idea is that by using placeholders for parameter values in a command, each; parameter for a particular process, will automatically get a channel of type; string, on which it can receive values. When the process is ready to execute; another shell command, it receives one item on each parameter ports, in; addition to receiving one file on each (file-)in-port, and merges the values; into the shell command, before executing it. An example of this would be a little too complicated to cover briefly on this; page, so please instead see the [dynamic parameters example](https://github.com/scipipe/scipipe/blob/master/examples/param_channels/params.go).; In the [Run method of the Combinatori",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/parameters.md:1316,echo,echo,1316,docs/howtos/parameters.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/parameters.md,1,['echo'],['echo']
Availability,"w of how to write workflows in SciPipe, let's look; at the example workflow used on the front page again:. ```go; package main. import (; // Import SciPipe; ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and a number for max concurrent tasks, so we; // don't overbook our CPU (it is recommended to set it to the number of CPU; // cores of your computer); wf := scipipe.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. Now let's go through the code example in some detail, to see what we are; actually doing. ## Initializing processes. ```go; // Initialize processes from shell command patterns; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); ```. Here we are initializing two new processes, both of them based on a shell; command, using the `wf.NewProc()` function, which takes a processname, and; a shell command pattern as input. ### The shell command pattern. The shell command patterns, in this case `echo 'Hello ' > {o:out}` and; `echo $(cat {i:in}) World >> {o:out}`, are basically normal bash; shell commands, with the addition of ""placeholders"" for input and output; filenames. Input filename placeholders are on the form `{i:INPORT-NAME}` and the output; filename placeholders are similarly of the form `{o:OUTPORT-NAME}`. These; placeholders will be replaced with actual filenames when the command is; executed later. The reason that it a port-name is used to name them, is that; files will be queued on the channel connecting to the port, and for each set of; files on in-ports, a command will be created and executed whereafter new files; will b",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:1052,echo,echo,1052,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['echo'],['echo']
Availability,"you always have a copy of the SciPipe source; code available, we recommend to always include a copy of the SciPipe source; code in your workflow's source code repository. The SciPipe source code is; only around 1500 lines of code, with no external dependencies except Go and; Bash, so this should not increase the size of your repository too much. A simple way to do this, is to use Go's `vendor` tool, which stores a local; copy of the source code of packages used, inside the local directory, in; a sub-directory called ""vendor"". To do this, execute the following command:. ```; go mod vendor; ```. Then, to make sure the code is included in your git history, make sure to add it; to git:. ```bash; git add vendor; git commit -m ""Add vendored version of SciPipe""; ```. ## Run your workflow. Now youa re ready to run the workflow. To run a `.go` file, just use `go run <script-file>`, e.g:; ; ```bash; go run myfirstworkflow.go; ```. ## Some tips about editors. In order to be productive with SciPipe, you will also need a Go editor or IDE; with support for auto-completion, sometimes also called ""intellisense"". We can warmly recommend to use one of these editors, sorted by level of endorsement:. 1. [Visual Studio Code](http://code.visualstudio.com) with the [Go plugin](https://github.com/Microsoft/vscode-go) - If you want a very powerful almost IDE-like editor; 2. The [vim-go](https://github.com/fatih/vim-go) plugin by [Fatih](https://twitter.com/fatih) - if you are a Vim power-user, or need a terminal-only complement to VSCode.; 3. JetBrain's [GoLand IDE](https://www.jetbrains.com/go/), if you are ready to pay for maximum code intelligence in a professional IDE.; 4. [LiteIDE](https://github.com/visualfc/liteide) - if you want a simple, robust and fast standalone Go-editor. There are also popular Go-plugins for [Sublime text](https://www.sublimetext.com), [Atom](https://atom.io/) and [IntelliJ IDEA](https://www.jetbrains.com/idea/), and an upcoming Go IDE from JetBrains,; called; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:4888,robust,robust,4888,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,1,['robust'],['robust']
Availability,"{; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. In the `{i:in...` part, we are re-using the file path from the file received on; the in-port named 'in', and then running a Bash-style trim-from-end command on; it to remove the `.txt` extension. Now, if we run this, the file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; ""hello.txt"": {; ""ID"": ""w4oeiii9h5j7sckq7aqq"",; ""ProcessName"": ""hello"",; ""Command"": ""echo 'Hello ' \u003e hello.txt.tmp/hello.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.950032676+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.95468214+02:00"",; ""ExecTimeNS"": 4000000,; ""Upstream"": {}; }; }; ```. Each such audit-file contains a hierarchic JSON-representation of the full; workflow path that was executed in order to produce this file. On the first; level is the command that directly produced the corresponding file, and then,; indexed by their filenames, under ""Upstream"", there is a similar chunk; describing how all of its input files were generated. This process will be; repeated in a recur",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:9413,echo,echo,9413,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['echo'],['echo']
Deployability," command to install the SciPipe library. After this, you will; be able to use Go's `go run` command to run SciPipe workflows. ## Install Go. Install Go by following the instructions [on this page](https://golang.org/doc/install#install), for your operating system. To make sure that everything is installed, run the `go` command in your; terminal, and make sure that it outputs something. To be specific, you can try exetuging `go version`, which sould output something; like the below:. ```bash; $ go version; go version go1.17 linux/amd64; ```; ; ## Install SciPipe. There are two main ways of installing SciPipe, one which is super-easy, and one; which is recommended if you want to make sure that your workflow will never; break because of API changes in SciPipe, and that you always have a copy of the; SciPipe source code available. ### Easy: Using go install. The easiest way to intsall SciPipe is by using the `go install` tool in the Go; tool chain. To install scipipe with `go install`, run the following command in; your terminal:. ```bash; go install github.com/scipipe/scipipe/...@latest; ```. **N.B:** Don't miss the `...`, as otherwise the `scipipe` helper tool will not be installed. ## Initialize a new workflow file. Now, you should be able to write code like in the example below, in files; ending with `.go`. The easiest way to get started is to let the scipipe tool generate a starting point for you:. ```bash; scipipe new myfirstworkflow.go; ```. ... which you can then edit to your liking. ## Create a Go module. Before you can run the workflow, you need to also create a [go module](https://golang.org/ref/mod#introduction). To do this, you can run the following command, in the directory where you; created your first workflow:. ```bash; go mod init <package-name>; ```. For `<module-name>`, you have to replace it with a name of the package.; For a simple script, you can name whatever you want, but if you are thinking; about publishing it online, e.g. on GitHub, you typic",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:1088,install,install,1088,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,2,['install'],['install']
Deployability," of complex and dynamic bioinformatics pipelines</a>; - <strong>Nov 2018: Scientific study using SciPipe:</strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; - <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a. ## Introduction. <img src=""docs/images/fbp_factory.png"" align=""right"">. SciPipe is a library for writing [Scientific; Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system), sometimes; also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of convey",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:3365,pipeline,pipelines,3365,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['pipeline'],['pipelines']
Deployability," will; be able to use Go's `go run` command to run SciPipe workflows. ## Install Go. Install Go by following the instructions [on this page](https://golang.org/doc/install#install), for your operating system. To make sure that everything is installed, run the `go` command in your; terminal, and make sure that it outputs something. To be specific, you can try exetuging `go version`, which sould output something; like the below:. ```bash; $ go version; go version go1.17 linux/amd64; ```; ; ## Install SciPipe. There are two main ways of installing SciPipe, one which is super-easy, and one; which is recommended if you want to make sure that your workflow will never; break because of API changes in SciPipe, and that you always have a copy of the; SciPipe source code available. ### Easy: Using go install. The easiest way to intsall SciPipe is by using the `go install` tool in the Go; tool chain. To install scipipe with `go install`, run the following command in; your terminal:. ```bash; go install github.com/scipipe/scipipe/...@latest; ```. **N.B:** Don't miss the `...`, as otherwise the `scipipe` helper tool will not be installed. ## Initialize a new workflow file. Now, you should be able to write code like in the example below, in files; ending with `.go`. The easiest way to get started is to let the scipipe tool generate a starting point for you:. ```bash; scipipe new myfirstworkflow.go; ```. ... which you can then edit to your liking. ## Create a Go module. Before you can run the workflow, you need to also create a [go module](https://golang.org/ref/mod#introduction). To do this, you can run the following command, in the directory where you; created your first workflow:. ```bash; go mod init <package-name>; ```. For `<module-name>`, you have to replace it with a name of the package.; For a simple script, you can name whatever you want, but if you are thinking; about publishing it online, e.g. on GitHub, you typically want to name it like; the URL of the corresponding ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:1181,install,install,1181,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,1,['install'],['install']
Deployability,"# Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This library is has been much influenced/inspired also by the; [GoFlow](https://github.com/trustmaster/goflow) library by [Vladimir Sibirov](https://github.com/trustmaster/goflow).; - Thanks to [Egon Elbre](http://twitter.com/egonelbre) for helpful input on the; design of the internals of the pipeline, and processes, which greatly; simplified the implementation.; - This work is financed by faculty grants and other financing for the [Pharmaceutical Bioinformatics group](http://pharmb.io) of [Dept. of; Pharmaceutical Biosciences](http://www.farmbio.uu.se) at [Uppsala University](http://www.uu.se), and by [Swedish Research Council](http://vr.se); through the Swedish [National Bioinformatics Infrastructure Sweden](http://nbis.se).; - Supervisor for the project is [Ola Spjuth](http://www.farmbio.uu.se/research/researchgroups/pb/olaspjuth).; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/acknowledgements.md:793,pipeline,pipeline,793,docs/acknowledgements.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/acknowledgements.md,1,['pipeline'],['pipeline']
Deployability,"# Installing SciPipe. Installing SciPipe means first installing the Go programming langauge, and then; using Go's `go install` command to install the SciPipe library. After this, you will; be able to use Go's `go run` command to run SciPipe workflows. ## Install Go. Install Go by following the instructions [on this page](https://golang.org/doc/install#install), for your operating system. To make sure that everything is installed, run the `go` command in your; terminal, and make sure that it outputs something. To be specific, you can try exetuging `go version`, which sould output something; like the below:. ```bash; $ go version; go version go1.17 linux/amd64; ```; ; ## Install SciPipe. There are two main ways of installing SciPipe, one which is super-easy, and one; which is recommended if you want to make sure that your workflow will never; break because of API changes in SciPipe, and that you always have a copy of the; SciPipe source code available. ### Easy: Using go install. The easiest way to intsall SciPipe is by using the `go install` tool in the Go; tool chain. To install scipipe with `go install`, run the following command in; your terminal:. ```bash; go install github.com/scipipe/scipipe/...@latest; ```. **N.B:** Don't miss the `...`, as otherwise the `scipipe` helper tool will not be installed. ## Initialize a new workflow file. Now, you should be able to write code like in the example below, in files; ending with `.go`. The easiest way to get started is to let the scipipe tool generate a starting point for you:. ```bash; scipipe new myfirstworkflow.go; ```. ... which you can then edit to your liking. ## Create a Go module. Before you can run the workflow, you need to also create a [go module](https://golang.org/ref/mod#introduction). To do this, you can run the following command, in the directory where you; created your first workflow:. ```bash; go mod init <package-name>; ```. For `<module-name>`, you have to replace it with a name of the package.; For a ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:53,install,installing,53,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,8,['install'],"['install', 'installed', 'installing']"
Deployability,"## Publications mentioning SciPipe. - <strong>NEW: Scientific study using SciPipe:</strong><br><a href=""https://doi.org/10.3389/fphar.2018.01256"">Predicting off-target binding profiles with confidence using Conformal Prediction</a><br>; - <strong>NEW: Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018"">Presentation on SciPipe and more at Go Stockholm Conference</a><br>; - <strong>Preprint paper on SciPipe:</strong><br><a href=""https://www.biorxiv.org/content/early/2018/08/01/380808"">SciPipe - A workflow library for agile development of complex and dynamic bioinformatics pipelines</a><br>; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific workflows</a> - going into details about how SciPipe is addressing provenance"">Provenance reports in Scientific Workflows<br>; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a>; - <strong>Poster:</strong> [A poster on SciPipe](http://dx.doi.org/10.13140/RG.2.2.34414.61760), presented at the [e-Science Academy in Lund, on Oct 12-13 2016](https://essenceofescience.se/event/swedish-e-science-academy-2016-2/).; - See [slides from a recent presentation of SciPipe for use in a Bioinformatics setting](http://www.slideshare.net/SamuelLampa/scipipe-a-lightweight-workflow-library-inspired-by-flowbased-programming).; - The architecture of SciPipe is based on an [flow-based; programming](https://en.wikipedia.org/wiki/Flow-based_programming) like; pattern in pure Go presented in; [this](https://blog.gopheracademy.com/composable-pipelines-pattern) and; [this](https://blog.gopheracademy.com/advent-2015/composable-pipelines-improvements/); blog posts on Gopher Academy. ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/other_resources.md:596,pipeline,pipelines,596,docs/other_resources.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/other_resources.md,3,['pipeline'],"['pipelines', 'pipelines-improvements', 'pipelines-pattern']"
Deployability,". ## More material on SciPipe. - See [a poster on SciPipe](http://dx.doi.org/10.13140/RG.2.2.34414.61760), presented at the [e-Science Academy in Lund, on Oct 12-13 2016](essenceofescience.se/event/swedish-e-science-academy-2016-2/).; - See [slides from a recent presentation of SciPipe for use in a Bioinformatics setting](http://www.slideshare.net/SamuelLampa/scipipe-a-lightweight-workflow-library-inspired-by-flowbased-programming).; - The architecture of SciPipe is based on an [flow-based programming](https://en.wikipedia.org/wiki/Flow-based_programming) like; pattern in pure Go presented in; [this](http://blog.gopheracademy.com/composable-pipelines-pattern) and; [this](https://blog.gopheracademy.com/advent-2015/composable-pipelines-improvements/); blog posts on Gopher Academy. ## Citing SciPipe. If you use SciPipe in academic or scholarly work, please cite the following paper as source:. Lampa S, Dahlö M, Alvarsson J, Spjuth O. SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines ; _Gigascience_. 8, 5 (2019). DOI: [10.1093/gigascience/giz044](https://dx.doi.org/10.1093/gigascience/giz044). ## Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This library is has been much influenced/inspired also by the; [GoFlow](https://github.com/trustmaster/goflow) library by [Vladimir Sibirov](https://github.com/trustmaster/goflow).; - Thanks to [Egon Elbre](http://twitter.com/egonelbre) for helpful input on the; design of the internals of the pipeline, and processes, which greatly; simplified th",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:11893,pipeline,pipelines,11893,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['pipeline'],['pipelines']
Deployability,"; <img src=""images/fbp_factory.png"" style=""width: 30%; float: right; margin: 1em;"">; <h1 style=""margin-bottom: 0;""><img src=""images/scipipe_logo_bluegrey_horiz.svg"" style=""width: 240px; margin-left: -10px; margin-bottom: 0;"" alt=""SciPipe""></h1>. <big>Robust, flexible and resource-efficient pipelines using Go and the commandline</big>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. <strong><small>Project links: [GitHub repo](http://github.com/scipipe/scipipe) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</small></strong>. [![Build Status](https://img.shields.io/circleci/project/github/scipipe/scipipe.svg)](https://circleci.com/gh/scipipe/scipipe); [![Test Coverage](https://img.shields.io/codecov/c/github/scipipe/scipipe.svg)](https://codecov.io/gh/scipipe/scipipe); [![Codebeat Grade](https://codebeat.co/badges/96e93624-2ac8-42c9-9e94-2d6e5325d8ff)](https://codebeat.co/projects/github-com-scipipe-scipipe-master); [![Go Report Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipip",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:291,pipeline,pipelines,291,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['pipeline'],['pipelines']
Deployability,"<h1 style=""margin-bottom: 0;""><img src=""docs/images/scipipe_logo_bluegrey_horiz_320px.png"" alt=""SciPipe""></h1>. <big>Robust, flexible and resource-efficient pipelines using Go and the commandline</big>. [![Build Status](https://img.shields.io/circleci/project/github/scipipe/scipipe.svg)](https://app.circleci.com/pipelines/github/scipipe); [![Test Coverage](https://img.shields.io/codecov/c/github/scipipe/scipipe.svg)](https://codecov.io/gh/scipipe/scipipe); [![Codebeat Grade](https://codebeat.co/badges/96e93624-2ac8-42c9-9e94-2d6e5325d8ff)](https://codebeat.co/projects/github-com-scipipe-scipipe-master); [![Go Report Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipipe); [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1157941.svg)](https://doi.org/10.5281/zenodo.1157941). <strong>Project links: [Documentation & Main Website](http://scipipe.org) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</strong>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. ## Project updates. - <str",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:157,pipeline,pipelines,157,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['pipeline'],['pipelines']
Deployability,"Func(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. **2.** ... or, better, access the parameter value via the task which the path function receives:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipeline to the workflow, so that the workflow can pull on this port; (technically pulling on a Go channel), in order to drive the workflow. ```go; // Connect network; world.In(""in"").From(helloWriter.Out(""out"")); ```. ## Running the pipeline. So, the final part probably explains itself, but the workflow component is a; relatively simple one that will start each component in a separate go-routine. For technical reasons, one final process has to be run in the main go-routine; (that where the program's `main()` function runs), but generally you don't; need to think about this, as the workflow will then use an in-built; [sink](https://godoc.org/github.com/scipipe/scipipe#Sink) process for this; purpose. If you for any reason need to customize which process to use as the; ""driver"" process, instead of the in-built sink. see the [`SetDriver` section](https://godoc.org/github.com/scipipe/scipipe#Workflow.SetDriver); in the docs. ```go; wf.Run(); ```. ## Summary. So with this, we have done everything needed to set up a file-based batch workflow system. In summary, what we did, was to:. 1. Initialize processes; 2. For each out-port, define a file-naming strategy; 3. Specify dependencies by connecting out- and in-ports; 4",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:7405,pipeline,pipeline,7405,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['pipeline'],['pipeline']
Deployability,"Pipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines ; _Gigascience_. 8, 5 (2019). DOI: [10.1093/gigascience/giz044](https://dx.doi.org/10.1093/gigascience/giz044). ## Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This library is has been much influenced/inspired also by the; [GoFlow](https://github.com/trustmaster/goflow) library by [Vladimir Sibirov](https://github.com/trustmaster/goflow).; - Thanks to [Egon Elbre](http://twitter.com/egonelbre) for helpful input on the; design of the internals of the pipeline, and processes, which greatly; simplified the implementation.; - This work is financed by faculty grants and other financing for the [Pharmaceutical Bioinformatics group](http://pharmb.io) of [Dept. of; Pharmaceutical Biosciences](http://www.farmbio.uu.se) at [Uppsala University](http://www.uu.se), and by [Swedish Research Council](http://vr.se); through the Swedish [National Bioinformatics Infrastructure Sweden](http://nbis.se).; - Supervisor for the project is [Ola Spjuth](http://www.farmbio.uu.se/research/researchgroups/pb/olaspjuth). ## Related tools. Find below a few tools that are more or less similar to SciPipe that are worth worth checking out before; deciding on what tool fits you best (in approximate order of similarity to SciPipe):. - [NextFlow](http://nextflow.io); - [Luigi](https://github.com/spotify/luigi)/[SciLuigi](https://github.com/samuell/sciluigi); - [BPipe](https://code.google.com/p/bpipe/); - [SnakeMake](https://bitbucket.org/johanneskoester/snakemake); ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:12809,pipeline,pipeline,12809,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['pipeline'],['pipeline']
Deployability,"Sometimes you need to create all the possible combinations of a set of files; that you have as file streams. . For example, say that you have two file streams:. ```; [a.txt b.txt]; [1.txt 2.txt 3.txt]; ```. ... and you want to process all of the combinations of these two sets of files.; So in other words, what you want is:. ```; [a.txt a.txt a.txt b.txt b.txt b.txt]; [1.txt 2.txt 3.txt 1.txt 2.txt 3.txt]; ```. This is something you can accomplish with the [FileCombinator](https://godoc.org/github.com/scipipe/scipipe/components#FileCombinator); component, available in [SciPipe 0.9.1](https://github.com/scipipe/scipipe/releases/tag/v0.9.1); and later. ## Example. Given that you have a set of files:. ```; letterfile_a.txt; letterfile_b.txt; numberfile_1.txt; numberfile_2.txt; numberfile_3.txt; ```. ... and you want to create all combinations of the `letter*` files and the `number*`; files, you can do it as follows:. ```go; package main. import (; ""github.com/scipipe/scipipe""; ""github.com/scipipe/scipipe/components""; ). func main() {; wf := scipipe.NewWorkflow(""wf"", 4). letterGlobber := components.NewFileGlobber(wf, ""letter_globber"", ""letterfile_*.txt""); numberGlobber := components.NewFileGlobber(wf, ""number_globber"", ""numberfile_*.txt""). fileCombiner := components.NewFileCombinator(wf, ""file_combiner""); fileCombiner.In(""letters"").From(letterGlobber.Out()); fileCombiner.In(""numbers"").From(numberGlobber.Out()). catenator := wf.NewProc(""catenator"", ""cat {i:letters} {i:numbers} > {o:combined}""); catenator.In(""letters"").From(fileCombiner.Out(""letters"")); catenator.In(""numbers"").From(fileCombiner.Out(""numbers"")); catenator.SetOut(""combined"", ""{i:letters|basename|%.txt}.{i:numbers|basename|%.txt}.combined.txt""). wf.Run(); }; ```. Note that when accessing an in-port on the FileCombinator with the `In(PORTNAME)` method, this port; will be created automatically, together with a corresponding out-port which can be accessed with the; same name, `Out(PORTNAME)`, as can be seen when ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/file_combinations.md:625,release,releases,625,docs/howtos/file_combinations.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/file_combinations.md,1,['release'],['releases']
Deployability,"This is [being worked on right now (issue #38)](https://github.com/scipipe/scipipe/issues/38). What you can do right now, is to use the `Prepend` field in processes, to add a; [salloc](https://slurm.schedmd.com/salloc.html) command string (in the case of; SLURM), or any analogous blocking command to other resource managers. So, something like this (See on the third line how the salloc-line is added to the process):. ```go; wf := scipipe.NewWorkflow(""Hello_World_Workflow"", 4); myProc := wf.NewProc(""hello_world"", ""echo Hello World; sleep 10;""); myProc.Prepend = ""salloc -A projectABC123 -p core -t 1:00 -J HelloWorld""; ```. *(Beware: This is not a full code example, and won't compile without some more boilerplate, which you can find in the introductory examples)*. You can find the updated GoDoc for the process struct [here](http://godoc.org/github.com/scipipe/scipipe#Process).; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/hpc.md:788,update,updated,788,docs/howtos/hpc.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/hpc.md,1,['update'],['updated']
Deployability,"UTPORTNAME}. The port-name will be used later to access the corresponding; ports for setting up data dependencies. On line 16, a component that writes the; previously defined DNA string to a file is initiated, and on line 17, the file; path pattern for the out-port dna is defined (in this case a static file name).; On line 20, a component that translates each DNA base to its complementary; counterpart is initiated. On line 21, the file path pattern for its only; out-port is defined. In this case, reusing the file path of the file it will; receive on its in-port named in, thus the {i:in} part. The %.txt part removes; .txt from the input path. On line 24, a component that will reverse the DNA; string is initiated. On lines 27-29, data dependencies are defined via the in-; and out-ports defined earlier as part of the shell command patterns. On line; 32, the workflow is being run. ## How to run. To run the example, given that you have the [Go toolchain](https://golang.org); installed (a vertion from at least 1.9), you can run it like this:. ```bash; $ go run revcomplement.go ; ```. You are then expected to see some log output similar to the following:. ```log; AUDIT 2019/03/26 22:59:43 | workflow:DNA Base Complement Workflow | Starting workflow (Writing log to log/scipipe-20190326-225943-dna-base-complement-workflow.log); AUDIT 2019/03/26 22:59:43 | Make DNA | Executing: echo AAAGCCCGTGGGGGACCTGTTC > dna.txt; AUDIT 2019/03/26 22:59:43 | Make DNA | Finished: echo AAAGCCCGTGGGGGACCTGTTC > dna.txt; AUDIT 2019/03/26 22:59:43 | Base Complement | Executing: cat ../dna.txt | tr ATCG TAGC > dna.compl.txt; AUDIT 2019/03/26 22:59:43 | Base Complement | Finished: cat ../dna.txt | tr ATCG TAGC > dna.compl.txt; AUDIT 2019/03/26 22:59:43 | Reverse | Executing: cat ../dna.compl.txt | rev > dna.compl.rev.txt; AUDIT 2019/03/26 22:59:43 | Reverse | Finished: cat ../dna.compl.txt | rev > dna.compl.rev.txt; AUDIT 2019/03/26 22:59:43 | workflow:DNA Base Complement Workflow | Finished workflo",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md:2859,install,installed,2859,examples/revcomplement/README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md,1,['install'],['installed']
Deployability,"[SciPipe 0.8.0](https://github.com/scipipe/scipipe/releases/tag/v0.8.0); introduced a feature to plot a directed graph of workflows in SciPipe [1].; This can be done in two ways:. 1. Just producing a DOT text file, with the graph definition; 2. Also converting this DOT file to PDF. Number 1. above can be done without any external dependencies, while number 2; requires that graphviz, with the `dot` command is installed on the system (On; Ubuntu it can be installed with the command: `sudo apt-get install graphviz`). ## How to plot graphs. To write a .dot file in SciPipe, include a line like follows, in your workflow; definition, provided that you have initiated the variable `wf` with a workflow; struct:. ```go; func main() {; wf := scipipe.NewWorkflow(""my workflow"", 4); // Workflow code here; wf.PlotGraph(""my_workflow_graph.dot"") // <-- SEE THIS LINE!; wf.Run(); }; ```. If you want to also convert the dot file to PDF in one go, instead change the; next last line to:. ```go; wf.PlotGraphPDF(""my_workflow_graph.dot""); ```. ## How to plot graphs conditionally based on a flag. Now, you might not want to generate a new plot every time you run your workflow; (although, perhaps you would? ... checking in a .dot version of your workflow; could in fact be a great way to keep a more readable version of your workflow; at hand ... but anyhow), you could make the plotting optional, based on a flag.; This is something we've found ourselves doing quite often at pharmb.io. This; could be done as follows (more complete code example):. ```go; package main. import (; ""flag""; ""github.com/scipipe/scipipe""; ). var (; plotGraph = flag.Bool(""plotgraph"", false, ""Plot a directed graph of the workflow to PDF""); ). func main() {; flag.Parse(). wf := scipipe.NewWorkflow(""testwf"", 4); wf.NewProc(""foo"", ""echo foo > {o:out}""). if *plotGraph {; wf.PlotGraphPDF(""wfgraph.dot""); }; wf.Run(); }; ```. Now, the graph will only plotted if you run your workflow with the; `-plotgraph` flag, e.g:. ```bash; go ru",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/plot_workflow_graph.md:51,release,releases,51,docs/howtos/plot_workflow_graph.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/plot_workflow_graph.md,4,"['install', 'release']","['install', 'installed', 'releases']"
Deployability,"[SciPipe 0.8.0](https://github.com/scipipe/scipipe/releases/tag/v0.8.0); introduced experimental support for converting audit logs (those; `.audit.json` files produced to accompany all output files from SciPipe); into other formats, such as HTML, TeX (for further conversion to PDF) or; even executable Bash-scripts. Here's how to do it. ## Convert audit log to HTML. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2html myfile.audit.json; ```. This will produce an HTML file named `myfile.audit.html`, which you can; view in a web browser. ## Convert audit log to TeX. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2tex myfile.audit.json; ```. This will produce an HTML file named `myfile.audit.tex`, which you can; either edit manually, or convert directly to PDF using the `pdflatex`; command like so:. ```bash; pdflatex myfile.audit.tex; ```. Converting to PDF requires that you have a TeX installation on your system.; On Ubuntu, you can install the base package or TeX live with `sudo apt-get; install texlive-base`. ## Convert audit log to Bash. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2bash myfile.audit.json; ```. This will produce a Bash-file named `myfile.audit.sh`, which you can; execute like so:. ```bash; sh myfile.audit.sh; ```. ... in order to reproduce the file again from scratch, if it is removed,; given that you have all the dependent files and tools installed on your; system.",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/convert_audit_logs.md:51,release,releases,51,docs/howtos/convert_audit_logs.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/convert_audit_logs.md,5,"['install', 'release']","['install', 'installation', 'installed', 'releases']"
Deployability,"`. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; ""hello.txt"": {; ""ID"": ""w4oeiii9h5j7sckq7aqq"",; ""ProcessName"": ""hello"",; ""Command"": ""echo 'Hello ' \u003e hello.txt.tmp/hello.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.950032676+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.95468214+02:00"",; ""ExecTimeNS"": 4000000,; ""Upstream"": {}; }; }; ```. Each such audit-file contains a hierarchic JSON-representation of the full; workflow path that was executed in order to produce this file. On the first; level is the command that directly produced the corresponding file, and then,; indexed by their filenames, under ""Upstream"", there is a similar chunk; describing how all of its input files were generated. This process will be; repeated in a recursive way for large workflows, so that, for each file; generated by the workflow, there is always a full, hierarchic, history of all; the commands run - with their associated metadata - to produce that file. You can find many more examples in the [examples folder](https://github.com/scipipe/scipipe/tree/master/examples) in the GitHub repo. For more information about how to write workflows using SciPipe, use the menu; to the left, to browse the various topics!. ## Citing SciPipe. If you use SciPipe in academic or scholarly work, please cite the following paper as source:. Lampa S, Dahlö M, Alvarsson J, Spjuth O. SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines; _Gigascience_. 8, 5 (2019). DOI: [10.1093/gigascience/giz044](https://dx.doi.org/10.1093/gigascience/giz044); ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:11266,pipeline,pipelines,11266,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['pipeline'],['pipelines']
Deployability,"a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for problems in bioinformatics and; cheminformatics, but works equally well for any problem involving pipelines of; commandline applications. **Project status:** SciPipe pretty stable now, and only very minor API changes; might still occur. We have successfully used SciPipe in a handful of both real; and experimental projects, and it has had occasional use outside the research; group as well. ## Known limitations. - There are still a number of missing good-to-have features for workflow; design. See the [issue tracker](https://github.com/scipipe/scipipe/issues); for details.; - There is not (yet) support for the [Common Workflow Language](http://common-workflow-language.github.io). ## Installing. For full installation instructions, see the [intallation page](/install).; For quick getting started steps, you can do:. 1. [Download](https://golang.org/dl/) and [install](https://golang.org/doc/install) Go; 2. Run the following command, to install the scipipe Go library (don't miss the; trailing dots!), and create a Go module for your script:. ```bash; go install github.com/scipipe/scipipe/...@latest; go mod init myfirstworkflow-module; ```. ## Hello World example. Let's look at an example workflow to get a feel for what writing workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:5234,install,installation,5234,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,4,['install'],"['install', 'installation']"
Deployability,"adge/DOI/10.5281/zenodo.1157941.svg)](https://doi.org/10.5281/zenodo.1157941). <strong>Project links: [Documentation & Main Website](http://scipipe.org) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</strong>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. ## Project updates. - <strong>Jan 2020: New screencast:</strong> <a href=""https://www.youtube.com/watch?v=hi0Uqwddrtg"" target=""_blank"">""Hello World"" scientific workflow in SciPipe</a>; - <strong>May 2019: The SciPipe paper published open access in GigaScience:</strong> <a href=""https://doi.org/10.1093/gigascience/giz044"" target=""_blank"">SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines</a>; - <strong>Nov 2018: Scientific study using SciPipe:</strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; - <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressin",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:1986,update,updates,1986,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['update'],['updates']
Deployability,"ally well for any problem involving pipelines of; commandline applications. **Project status:** SciPipe pretty stable now, and only very minor API changes; might still occur. We have successfully used SciPipe in a handful of both real; and experimental projects, and it has had occasional use outside the research; group as well. ## Known limitations. - There are still a number of missing good-to-have features for workflow; design. See the [issue tracker](https://github.com/scipipe/scipipe/issues); for details.; - There is not (yet) support for the [Common Workflow Language](http://common-workflow-language.github.io). ## Installing. For full installation instructions, see the [intallation page](/install).; For quick getting started steps, you can do:. 1. [Download](https://golang.org/dl/) and [install](https://golang.org/doc/install) Go; 2. Run the following command, to install the scipipe Go library (don't miss the; trailing dots!), and create a Go module for your script:. ```bash; go install github.com/scipipe/scipipe/...@latest; go mod init myfirstworkflow-module; ```. ## Hello World example. Let's look at an example workflow to get a feel for what writing workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can d",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:5585,install,install,5585,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['install'],['install']
Deployability,"ands run - with their associated metadata - to produce that file. You can find many more examples in the [examples folder](https://github.com/scipipe/scipipe/tree/master/examples) in the GitHub repo. For more information about how to write workflows using SciPipe, and much more,; see [SciPipe website (scipipe.org)](http://scipipe.org)!. ## More material on SciPipe. - See [a poster on SciPipe](http://dx.doi.org/10.13140/RG.2.2.34414.61760), presented at the [e-Science Academy in Lund, on Oct 12-13 2016](essenceofescience.se/event/swedish-e-science-academy-2016-2/).; - See [slides from a recent presentation of SciPipe for use in a Bioinformatics setting](http://www.slideshare.net/SamuelLampa/scipipe-a-lightweight-workflow-library-inspired-by-flowbased-programming).; - The architecture of SciPipe is based on an [flow-based programming](https://en.wikipedia.org/wiki/Flow-based_programming) like; pattern in pure Go presented in; [this](http://blog.gopheracademy.com/composable-pipelines-pattern) and; [this](https://blog.gopheracademy.com/advent-2015/composable-pipelines-improvements/); blog posts on Gopher Academy. ## Citing SciPipe. If you use SciPipe in academic or scholarly work, please cite the following paper as source:. Lampa S, Dahlö M, Alvarsson J, Spjuth O. SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines ; _Gigascience_. 8, 5 (2019). DOI: [10.1093/gigascience/giz044](https://dx.doi.org/10.1093/gigascience/giz044). ## Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This libra",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:11510,pipeline,pipelines-pattern,11510,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['pipeline'],['pipelines-pattern']
Deployability,"cipipe/scipipe)</small></strong>. [![Build Status](https://img.shields.io/circleci/project/github/scipipe/scipipe.svg)](https://circleci.com/gh/scipipe/scipipe); [![Test Coverage](https://img.shields.io/codecov/c/github/scipipe/scipipe.svg)](https://codecov.io/gh/scipipe/scipipe); [![Codebeat Grade](https://codebeat.co/badges/96e93624-2ac8-42c9-9e94-2d6e5325d8ff)](https://codebeat.co/projects/github-com-scipipe-scipipe-master); [![Go Report Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipipe); [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1157941.svg)](https://doi.org/10.5281/zenodo.1157941). <div style=""width:37%; float: right; font-size: 0.8em; padding: 1em; margin: 0 0 1em 1em;"">; <h4>Project updates</h4>; <strong>Jan 2020: New screencast:</strong> <a href=""https://www.youtube.com/watch?v=hi0Uqwddrtg"" target=""_blank"">""Hello World"" scientific workflow in SciPipe</a>; <strong>May 2019: The SciPipe paper published open access in GigaScience:</strong> <a href=""https://doi.org/10.1093/gigascience/giz044"" target=""_blank"">SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines</a>; <strong>Nov 2018: Scientific study using SciPipe:</strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; <str",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:2217,update,updates,2217,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['update'],['updates']
Deployability,"command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. ## Project updates. - <strong>Jan 2020: New screencast:</strong> <a href=""https://www.youtube.com/watch?v=hi0Uqwddrtg"" target=""_blank"">""Hello World"" scientific workflow in SciPipe</a>; - <strong>May 2019: The SciPipe paper published open access in GigaScience:</strong> <a href=""https://doi.org/10.1093/gigascience/giz044"" target=""_blank"">SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines</a>; - <strong>Nov 2018: Scientific study using SciPipe:</strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; - <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a. ## Introduction. <img src=""docs/images/fbp_factory.png"" align=""right"">. SciPipe is a library for writing [Scientific; Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system), sometimes; also called ""pipelines"", in the [G",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:2402,pipeline,pipelines,2402,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['pipeline'],['pipelines']
Deployability,"e instructions [on this page](https://golang.org/doc/install#install), for your operating system. To make sure that everything is installed, run the `go` command in your; terminal, and make sure that it outputs something. To be specific, you can try exetuging `go version`, which sould output something; like the below:. ```bash; $ go version; go version go1.17 linux/amd64; ```; ; ## Install SciPipe. There are two main ways of installing SciPipe, one which is super-easy, and one; which is recommended if you want to make sure that your workflow will never; break because of API changes in SciPipe, and that you always have a copy of the; SciPipe source code available. ### Easy: Using go install. The easiest way to intsall SciPipe is by using the `go install` tool in the Go; tool chain. To install scipipe with `go install`, run the following command in; your terminal:. ```bash; go install github.com/scipipe/scipipe/...@latest; ```. **N.B:** Don't miss the `...`, as otherwise the `scipipe` helper tool will not be installed. ## Initialize a new workflow file. Now, you should be able to write code like in the example below, in files; ending with `.go`. The easiest way to get started is to let the scipipe tool generate a starting point for you:. ```bash; scipipe new myfirstworkflow.go; ```. ... which you can then edit to your liking. ## Create a Go module. Before you can run the workflow, you need to also create a [go module](https://golang.org/ref/mod#introduction). To do this, you can run the following command, in the directory where you; created your first workflow:. ```bash; go mod init <package-name>; ```. For `<module-name>`, you have to replace it with a name of the package.; For a simple script, you can name whatever you want, but if you are thinking; about publishing it online, e.g. on GitHub, you typically want to name it like; the URL of the corresponding GitHub repo, e.g.; `github.com/<your-username>/<your-repository>`. By doing this, two files will be created:. `",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:1315,install,installed,1315,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,1,['install'],['installed']
Deployability,"g {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipeline to the workflow, so that the workflow can pull on this port; (technically pulling on a Go channel), in order to drive the workflow. ```go; // Connect network; world.In(""in"").From(helloWriter.Out(""out"")); ```. ## Running the pipeline. So, the final part probably explains itself, but the workflow component is a; relatively simple one that will start each component in a separate go-routine. For technical reasons, one final process has to be run in the main go-routine; (that where the program's `main()` function runs), but generally you don't; need to think about this, as the workflow will then use an in-built; [sink](https://godoc.org/github.com/scipipe/scipipe#Sink) process for this; purpose. If you for any reason need to customize which process to use as the; ""driver"" process, instead of the in-built sink. see the [`SetDriver` section](https://godoc.org/github.com/scipipe/scipipe#Workflow.SetDriver); in the docs. ```go; wf.Run(); ```. ## Summary. So with this, we have done everything needed to set up a file-based batch workflow system. In summary, what we did, was to:. 1. Initialize processes; 2. For each out-port, define a file-naming strategy; 3. Specify dependencies by connecting out- and in-ports; 4. Run the pipeline. This actually turns out to be a fixed set of components that always need to be; included when writing workflows, so it might be good to keep them in mind and; memorize these steps, if needed. For more examples, see the [examples folder](https://github.com/scipipe/scipipe/tree/master/examples); in the GitHub repository.; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:8412,pipeline,pipeline,8412,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['pipeline'],['pipeline']
Deployability,"itially created for problems in bioinformatics and; cheminformatics, but works equally well for any problem involving pipelines of; commandline applications. **Project status:** SciPipe pretty stable now, and only very minor API changes; might still occur. We have successfully used SciPipe in a handful of both real; and experimental projects, and it has had occasional use outside the research; group as well. ## Known limitations. - There are still a number of missing good-to-have features for workflow; design. See the [issue tracker](https://github.com/scipipe/scipipe/issues); for details.; - There is not (yet) support for the [Common Workflow Language](http://common-workflow-language.github.io). ## Installing. For full installation instructions, see the [intallation page](/install).; For quick getting started steps, you can do:. 1. [Download](https://golang.org/dl/) and [install](https://golang.org/doc/install) Go; 2. Run the following command, to install the scipipe Go library (don't miss the; trailing dots!), and create a Go module for your script:. ```bash; go install github.com/scipipe/scipipe/...@latest; go mod init myfirstworkflow-module; ```. ## Hello World example. Let's look at an example workflow to get a feel for what writing workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the depende",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:5467,install,install,5467,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['install'],['install']
Deployability,"lank"">SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines</a>; <strong>Nov 2018: Scientific study using SciPipe:</strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a>; </div>. ## Introduction. SciPipe is a library for writing [Scientific Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system),; sometimes also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of convey",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:3542,pipeline,pipelines,3542,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['pipeline'],['pipelines']
Deployability,"ns; (processes) for processing, as depicted in the picture above. SciPipe was initially created for problems in bioinformatics and; cheminformatics, but works equally well for any problem involving pipelines of; commandline applications. **Project status:** SciPipe pretty stable now, and only very minor API changes; might still occur. We have successfully used SciPipe in a handful of both real; and experimental projects, and it has had occasional use outside the research; group as well. ## Known limitations. - There are still a number of missing good-to-have features for workflow; design. See the [issue tracker](https://github.com/scipipe/scipipe/issues); for details.; - There is not (yet) support for the [Common Workflow Language](http://common-workflow-language.github.io). ## Installing. For full installation instructions, see the [intallation page](/install).; For quick getting started steps, you can do:. 1. [Download](https://golang.org/dl/) and [install](https://golang.org/doc/install) Go; 2. Run the following command, to install the scipipe Go library (don't miss the; trailing dots!), and create a Go module for your script:. ```bash; go install github.com/scipipe/scipipe/...@latest; go mod init myfirstworkflow-module; ```. ## Hello World example. Let's look at an example workflow to get a feel for what writing workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:5421,install,install,5421,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['install'],['install']
Deployability,"o; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); val := val // <- Here we create a new copy of the variable; proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. **2.** ... or, better, access the parameter value via the task which the path function receives:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipeline to the workflow, so that the workflow can pull on this port; (technically pulling on a Go channel), in order to drive the workflow. ```go; // Connect network; world.In(""in"").From(helloWriter.Out(""out"")); ```. ## Running the pipeline. So, the final part probably explains itself, but the workflow component is a; relatively simple one that will start each component in a separate go-routine. For technical reasons, one final process has to be run in the main go-routine; (that where the program's `main()` function runs), but generally you don't; need to think about this, as the workflow will then use an in-built; [sink](https://godoc.org/github.com/scipipe/scipipe#Sink) process for this; purpose. If you for any reason need to customize which process to use as the; ""driver"" process, instead of the in-built sink. see the [`SetDriver` section](https://godoc.org/github.com/scipipe/scipipe#Workflow.SetDriver); in the docs. ```go; wf.Run(); ```. ## Summary. So with this, we have done everything needed to set up a file-based batch w",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:7172,pipeline,pipeline,7172,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['pipeline'],['pipeline']
Deployability,"ojects/github-com-scipipe-scipipe-master); [![Go Report Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipipe); [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1157941.svg)](https://doi.org/10.5281/zenodo.1157941). <div style=""width:37%; float: right; font-size: 0.8em; padding: 1em; margin: 0 0 1em 1em;"">; <h4>Project updates</h4>; <strong>Jan 2020: New screencast:</strong> <a href=""https://www.youtube.com/watch?v=hi0Uqwddrtg"" target=""_blank"">""Hello World"" scientific workflow in SciPipe</a>; <strong>May 2019: The SciPipe paper published open access in GigaScience:</strong> <a href=""https://doi.org/10.1093/gigascience/giz044"" target=""_blank"">SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines</a>; <strong>Nov 2018: Scientific study using SciPipe:</strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a>; </div>. ## Introduction. SciPipe is a library for writing [Scientific Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system),; sometimes also called ""pipelines"", in the [Go programming language](http://golang.org). When you n",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:2634,pipeline,pipelines,2634,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['pipeline'],['pipelines']
Deployability,"ore examples in the [examples folder](https://github.com/scipipe/scipipe/tree/master/examples) in the GitHub repo. For more information about how to write workflows using SciPipe, and much more,; see [SciPipe website (scipipe.org)](http://scipipe.org)!. ## More material on SciPipe. - See [a poster on SciPipe](http://dx.doi.org/10.13140/RG.2.2.34414.61760), presented at the [e-Science Academy in Lund, on Oct 12-13 2016](essenceofescience.se/event/swedish-e-science-academy-2016-2/).; - See [slides from a recent presentation of SciPipe for use in a Bioinformatics setting](http://www.slideshare.net/SamuelLampa/scipipe-a-lightweight-workflow-library-inspired-by-flowbased-programming).; - The architecture of SciPipe is based on an [flow-based programming](https://en.wikipedia.org/wiki/Flow-based_programming) like; pattern in pure Go presented in; [this](http://blog.gopheracademy.com/composable-pipelines-pattern) and; [this](https://blog.gopheracademy.com/advent-2015/composable-pipelines-improvements/); blog posts on Gopher Academy. ## Citing SciPipe. If you use SciPipe in academic or scholarly work, please cite the following paper as source:. Lampa S, Dahlö M, Alvarsson J, Spjuth O. SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines ; _Gigascience_. 8, 5 (2019). DOI: [10.1093/gigascience/giz044](https://dx.doi.org/10.1093/gigascience/giz044). ## Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This library is has been much influenced/inspired also by the; [GoFlow](https://github.com/tru",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:11595,pipeline,pipelines-improvements,11595,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['pipeline'],['pipelines-improvements']
Deployability,"pe means first installing the Go programming langauge, and then; using Go's `go install` command to install the SciPipe library. After this, you will; be able to use Go's `go run` command to run SciPipe workflows. ## Install Go. Install Go by following the instructions [on this page](https://golang.org/doc/install#install), for your operating system. To make sure that everything is installed, run the `go` command in your; terminal, and make sure that it outputs something. To be specific, you can try exetuging `go version`, which sould output something; like the below:. ```bash; $ go version; go version go1.17 linux/amd64; ```; ; ## Install SciPipe. There are two main ways of installing SciPipe, one which is super-easy, and one; which is recommended if you want to make sure that your workflow will never; break because of API changes in SciPipe, and that you always have a copy of the; SciPipe source code available. ### Easy: Using go install. The easiest way to intsall SciPipe is by using the `go install` tool in the Go; tool chain. To install scipipe with `go install`, run the following command in; your terminal:. ```bash; go install github.com/scipipe/scipipe/...@latest; ```. **N.B:** Don't miss the `...`, as otherwise the `scipipe` helper tool will not be installed. ## Initialize a new workflow file. Now, you should be able to write code like in the example below, in files; ending with `.go`. The easiest way to get started is to let the scipipe tool generate a starting point for you:. ```bash; scipipe new myfirstworkflow.go; ```. ... which you can then edit to your liking. ## Create a Go module. Before you can run the workflow, you need to also create a [go module](https://golang.org/ref/mod#introduction). To do this, you can run the following command, in the directory where you; created your first workflow:. ```bash; go mod init <package-name>; ```. For `<module-name>`, you have to replace it with a name of the package.; For a simple script, you can name whatever ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:1048,install,install,1048,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,1,['install'],['install']
Deployability,"rograms; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for problems in bioinformatics and; cheminformatics, but works equally well for any problem involving pipelines of; commandline applications. **Project status:** SciPipe pretty stable now, and only very minor API changes; might still occur. We have successfully used SciPipe in a handful of both real; and experimental projects, and it has had occasional use outside the research; group as well. ## Known limitations. - There are still a number of missing good-to-have features for workflow; design. See the [issue tracker](https://github.com/scipipe/scipipe/issues); for details.; - There is not (yet) support for the [Common Workflow Language](http://common-workflow-language.github.io). ## Installing. For full installation instructions, see the [intallation page](/install).; For quick getting started steps, you can do:. 1. [Download](https://golang.org/dl/) and [install](https://golang.org/doc/install) Go; 2. Run the following command, to install the scipipe Go library (don't miss the; trailing dots!), and create a Go module for your script:. ``",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:4622,pipeline,pipelines,4622,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['pipeline'],['pipelines']
Deployability,"t independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for problems in bioinformatics and; cheminformatics, but works equally well for any problem involving pipelines of; commandline applications. **Project status:** SciPipe pretty stable now, and only very minor API changes; might still occur. We have successfully used SciPipe in a handful of both real; and experimental projects, and it has had occasional use outside the research; group as well. ## Known limitations. - There are still a number of missing good-to-have features for workflow; design. See the [issue tracker](https://github.com/scipipe/scipipe/issues); for details.; - There is not (yet) support for the [Common Workflow Language](http://common-workflow-language.github.io). ## Installing. For full installation instructions, see the [intallation page](/install).; For quick getting started steps, you can do:. 1. [Download](https://golang.org/dl/) and [install](https://golang.org/doc/install) Go; 2. Run the following command, to install the scipipe Go library (don't miss the; trailing dots!), and create a Go module for your script:. ```bash; go install github.com/scipipe/scipipe/...@latest; go mod init myfirstworkflow-module; ```. ## Hello World example. Let's look at an example workflow to get a feel for what writing workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:5389,install,install,5389,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['install'],['install']
Deployability,"trailing dots!), and create a Go module for your script:. ```bash; go install github.com/scipipe/scipipe/...@latest; go mod init myfirstworkflow-module; ```. ## Hello World example. Let's look at an example workflow to get a feel for what writing workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.au",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:6537,install,installed,6537,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['install'],['installed']
Deployability,"which is specialized for executing commandline applications. New; `Process`-es are typically created using the `scipipe.NewProc(procName,; shellPattern)` command. * See [GoDoc for Process](https://godoc.org/github.com/scipipe/scipipe#Process). ## Tasks. The ""long-running"" processes mentioned above, will receive input files on its; in-ports, and for each complete set of input files it receives, it will create; a new **task**. Specifically, `scipipe.Process` will create; [`scipipe.Task`](https://godoc.org/github.com/scipipe/scipipe#Task) objects, and populate it with all data needed for one; particular shell command execution. `Task` objects are executed via their; [`Execute()`](https://godoc.org/github.com/scipipe/scipipe#Task.Execute); method, or `CustomExecute()`, if custom Go code is supposed to be; executed instead of a shell command. The distinction between processes and tasks is important to understand, for; example when doing more advanced configuration of file naming strategies, since; the custom anonymous functions used to format paths are taking a `Task` as; input, even though these functions are saved on the process object. To understand the difference between processes and tasks, it is helpful to; remember that processes are long-running, and typically fixed during the course; of a workflow, while tasks are transient objects, created temporarily as a; container for all data and code needed for each execution of a concrete shell; command. * See [GoDoc for Task](https://godoc.org/github.com/scipipe/scipipe#Task). ## Ports. Central to the way data dependencies are defined in SciPipe, is ports. Ports; are fields on processes, which are connected to other ports via channels (see; separate section on this page). In SciPipe, each port must have a unique name within its process (there can't; be an in-port and out-port named the same), and this name will be used in shell; command patterns, when connecting dependencies / dataflow networks, and when; configuring fil",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md:1588,configurat,configuration,1588,docs/basic_concepts.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md,1,['configurat'],['configuration']
Energy Efficiency,"# Contributing to SciPipe. ## Working with forked repository. Unlike other languages like C++/Python, Go requires modules being referenced,; to be placed in a specific location for the import to work. Forking via GitHub; provides a pull request workflow that is well documented but does not work well; with Go import. Documented here is one approach utilizing go modules. First, fork and clone SciPipe the usual way via GitHub to a local file system,; lets call it `<cloned-scipipe-dir>`. To work on and test the changes made to scipipe in the cloned location, create; a directory for your scipipe workflows, lets call it `<workflow-dev-dir>`. In; that directory, you can create a simple `main.go` file with a `package main` so; that you can run your code that exercises the changes you are making at; `<cloned-scipipe-dir>`. Note that if you were to run your code in `main.go` as-is, it would pull down; the code from the repository and cache them and you will not actually be able; to test any local changes in scipipe. To do so, you need to create a file call; `go.mod`. In `<workflow-dev-dir>` run the following:. ```; go mod init <some package name>; ```. Note: The actual name of the package is not critical. Next, define the modules required by your main.go:. ```; go mod edit -require=github.com/scipipe/scipipe@v0.9.10; ```. Note: A the time of this writing, v0.9.10 is the latest published version, this; will change over time and you need to adapt. Next, replace any reference to the previous URL with reference to the; `<cloned-scipipe-dir>` location:. ```; go mod edit -replace=github.com/scipipe/scipipe@v0.9.10=<cloned-scipipe-dir>; ```. Now when you do:. ```; go run main.go; ```. ... it will not be pulling the code from GitHub but references the code you; have cloned locally. Do your development work and push to your forked repository and do a pull; request for the author to review and optionally merge the contribution.; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md:1453,adapt,adapt,1453,docs/contributing.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md,1,['adapt'],['adapt']
Energy Efficiency,"*Beware: Technical topic, best suited for power-users!*. If you want to write a component with Go code, but would like to have it work; seamlessly with other workflow processes in SciPipe, without reimplementing the; whole [Process](https://godoc.org/github.com/scipipe/scipipe#Process); functionality yourself, there is a way to do it: By using the `CustomExecute`; field of Process. In short, it can be done like this:. ```go; // Initiate task from a ""shell like"" pattern, though here we; // just specify the out-port, and nothing else. We have to; // specify the out-port (and any other ports we plan to use later),; // so that they are correctly initialized.; fooWriter := sci.NewProc(""fooer"", ""{o:foo}""). // Set the output formatter to a static string; fooWriter.SetOut(""foo"", ""foo.txt""). // Create the custom execute function, with pure Go code and; // add it to the CustomExecute field of the fooWriter process; fooWriter.CustomExecute = func(task *sci.Task) {; task.OutIP(""foo"").Write([]byte(""foo\n"")); }; ```. For a more detailed example, see [this example](https://github.com/scipipe/scipipe/blob/master/examples/custom_execution_function/funchook.go); (Have a look at the [NewFooer()](https://github.com/scipipe/scipipe/blob/master/examples/custom_execution_function/funchook.go#L34-L50); and [NewFoo2Barer()](https://github.com/scipipe/scipipe/blob/master/examples/custom_execution_function/funchook.go#L72-L89); factory functions in particular!); ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/golang_components.md:42,power,power-users,42,docs/howtos/golang_components.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/golang_components.md,1,['power'],['power-users']
Energy Efficiency,"; <img src=""images/fbp_factory.png"" style=""width: 30%; float: right; margin: 1em;"">; <h1 style=""margin-bottom: 0;""><img src=""images/scipipe_logo_bluegrey_horiz.svg"" style=""width: 240px; margin-left: -10px; margin-bottom: 0;"" alt=""SciPipe""></h1>. <big>Robust, flexible and resource-efficient pipelines using Go and the commandline</big>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. <strong><small>Project links: [GitHub repo](http://github.com/scipipe/scipipe) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</small></strong>. [![Build Status](https://img.shields.io/circleci/project/github/scipipe/scipipe.svg)](https://circleci.com/gh/scipipe/scipipe); [![Test Coverage](https://img.shields.io/codecov/c/github/scipipe/scipipe.svg)](https://codecov.io/gh/scipipe/scipipe); [![Codebeat Grade](https://codebeat.co/badges/96e93624-2ac8-42c9-9e94-2d6e5325d8ff)](https://codebeat.co/projects/github-com-scipipe-scipipe-master); [![Go Report Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipip",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:281,efficient,efficient,281,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,2,['efficient'],['efficient']
Energy Efficiency,"<h1 style=""margin-bottom: 0;""><img src=""docs/images/scipipe_logo_bluegrey_horiz_320px.png"" alt=""SciPipe""></h1>. <big>Robust, flexible and resource-efficient pipelines using Go and the commandline</big>. [![Build Status](https://img.shields.io/circleci/project/github/scipipe/scipipe.svg)](https://app.circleci.com/pipelines/github/scipipe); [![Test Coverage](https://img.shields.io/codecov/c/github/scipipe/scipipe.svg)](https://codecov.io/gh/scipipe/scipipe); [![Codebeat Grade](https://codebeat.co/badges/96e93624-2ac8-42c9-9e94-2d6e5325d8ff)](https://codebeat.co/projects/github-com-scipipe-scipipe-master); [![Go Report Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipipe); [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1157941.svg)](https://doi.org/10.5281/zenodo.1157941). <strong>Project links: [Documentation & Main Website](http://scipipe.org) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</strong>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. ## Project updates. - <str",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:147,efficient,efficient,147,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['efficient'],['efficient']
Energy Efficiency,"rt Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipipe); [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1157941.svg)](https://doi.org/10.5281/zenodo.1157941). <strong>Project links: [Documentation & Main Website](http://scipipe.org) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</strong>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. ## Project updates. - <strong>Jan 2020: New screencast:</strong> <a href=""https://www.youtube.com/watch?v=hi0Uqwddrtg"" target=""_blank"">""Hello World"" scientific workflow in SciPipe</a>; - <strong>May 2019: The SciPipe paper published open access in GigaScience:</strong> <a href=""https://doi.org/10.1093/gigascience/giz044"" target=""_blank"">SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines</a>; - <strong>Nov 2018: Scientific study using SciPipe:</strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Predi",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:1691,efficient,efficient,1691,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['efficient'],['efficient']
Energy Efficiency,"you always have a copy of the SciPipe source; code available, we recommend to always include a copy of the SciPipe source; code in your workflow's source code repository. The SciPipe source code is; only around 1500 lines of code, with no external dependencies except Go and; Bash, so this should not increase the size of your repository too much. A simple way to do this, is to use Go's `vendor` tool, which stores a local; copy of the source code of packages used, inside the local directory, in; a sub-directory called ""vendor"". To do this, execute the following command:. ```; go mod vendor; ```. Then, to make sure the code is included in your git history, make sure to add it; to git:. ```bash; git add vendor; git commit -m ""Add vendored version of SciPipe""; ```. ## Run your workflow. Now youa re ready to run the workflow. To run a `.go` file, just use `go run <script-file>`, e.g:; ; ```bash; go run myfirstworkflow.go; ```. ## Some tips about editors. In order to be productive with SciPipe, you will also need a Go editor or IDE; with support for auto-completion, sometimes also called ""intellisense"". We can warmly recommend to use one of these editors, sorted by level of endorsement:. 1. [Visual Studio Code](http://code.visualstudio.com) with the [Go plugin](https://github.com/Microsoft/vscode-go) - If you want a very powerful almost IDE-like editor; 2. The [vim-go](https://github.com/fatih/vim-go) plugin by [Fatih](https://twitter.com/fatih) - if you are a Vim power-user, or need a terminal-only complement to VSCode.; 3. JetBrain's [GoLand IDE](https://www.jetbrains.com/go/), if you are ready to pay for maximum code intelligence in a professional IDE.; 4. [LiteIDE](https://github.com/visualfc/liteide) - if you want a simple, robust and fast standalone Go-editor. There are also popular Go-plugins for [Sublime text](https://www.sublimetext.com), [Atom](https://atom.io/) and [IntelliJ IDEA](https://www.jetbrains.com/idea/), and an upcoming Go IDE from JetBrains,; called; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:4472,power,powerful,4472,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,2,['power'],"['power-user', 'powerful']"
Integrability," ID in a generic port map, like the `In()` and `Out()` methods on; `Process` processes. This is so that the methods can show up in the; auto-completion / intellisense function in code editors removing the need to; look up the name of the ports manually in the library code all the time. ## How to create re-usable components in SciPipe. Process processes created with the `scipipe.NewProc()` command, can be turned; into such ""re-usable"" component by using a wrapping strategy, that is; demonstrated in an [example on GitHub](https://github.com/scipipe/scipipe/blob/master/examples/wrapper_procs/wrap.go). The idea is to create a new struct type for the re-usable component, and; then, in the factory method for the process, create an ""inner"" process of; type Process, using `NewProc()` as in the normal case, embedding that in the; outer struct and then adding statically defined accessor methods for each of; the ports in the inner process, with a similar name. So, if the inner process; has an outport named ""foo"", you would define an accessor method named; `myproc.OutFoo()` that returns this port from the inner process. Let's look at a code example of how this works, by creating a process that just; writes ""hi"" to a file:. ```go; type HiWriter struct {; // Embedd a Process struct; 	*sci.Process; }. func NewHiWriter() *HiWriter {; // Initialize a normal ""Process"" to use as an ""inner"" process; 	innerHiWriter := sci.NewProc(""hiwriter"", ""echo hi > {o:hifile}""); 	innerHiWriter.SetOut(""hifile"", ""hi.txt""). // Create a new HiWriter process with the inner process embedded into it; 	return &HiWriter{innerHiWriter}; }. // OutHiFile provides a static version of the ""hifile"" port in the inner; // (embedded) process; func (p *HiWriter) OutHiFile() *sci.OutPort {; // Return the inner process' port named ""hifile""; return p.Out(""hifile""); }; ```. ## See also. - [A full, working, workflow example using this trategy](https://github.com/scipipe/scipipe/blob/master/examples/wrapper_procs/wrap.go); ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md:2298,wrap,wrap,2298,docs/howtos/reusable_components.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md,1,['wrap'],['wrap']
Integrability," and tasks is important to understand, for; example when doing more advanced configuration of file naming strategies, since; the custom anonymous functions used to format paths are taking a `Task` as; input, even though these functions are saved on the process object. To understand the difference between processes and tasks, it is helpful to; remember that processes are long-running, and typically fixed during the course; of a workflow, while tasks are transient objects, created temporarily as a; container for all data and code needed for each execution of a concrete shell; command. * See [GoDoc for Task](https://godoc.org/github.com/scipipe/scipipe#Task). ## Ports. Central to the way data dependencies are defined in SciPipe, is ports. Ports; are fields on processes, which are connected to other ports via channels (see; separate section on this page). In SciPipe, each port must have a unique name within its process (there can't; be an in-port and out-port named the same), and this name will be used in shell; command patterns, when connecting dependencies / dataflow networks, and when; configuring file naming strategies. In `Process` objects, in-ports are are accessed with; `myProcess.In(""my_port"")`, and out-ports are similarly accessed with; `myProcess.Out(""my_other_port"")`. They are of type; [`InPort`](https://godoc.org/github.com/scipipe/scipipe#InPort) and; [`OutPort`](https://godoc.org/github.com/scipipe/scipipe#OutPort) respectively. Some pre-made components might have ports bound to custom field names though,; such as `myFastaReader.InFastaFile`, or `myZipComponent.OutZipFile`. Port objects have some methods bound to them, most importantly the `From()`; method (for in-ports. Out-ports have a corresponding `To()` method), which; takes another port, and connects to it, by stitching a channel between the; ports. On `Process` objects, there is also a third port type, `InParamPort` (and the; accompanying `OutParamPort`), which is used when it is needed to send a; s",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md:2569,depend,dependencies,2569,docs/basic_concepts.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md,1,['depend'],['dependencies']
Integrability," better, access the parameter value via the task which the path function receives:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipeline to the workflow, so that the workflow can pull on this port; (technically pulling on a Go channel), in order to drive the workflow. ```go; // Connect network; world.In(""in"").From(helloWriter.Out(""out"")); ```. ## Running the pipeline. So, the final part probably explains itself, but the workflow component is a; relatively simple one that will start each component in a separate go-routine. For technical reasons, one final process has to be run in the main go-routine; (that where the program's `main()` function runs), but generally you don't; need to think about this, as the workflow will then use an in-built; [sink](https://godoc.org/github.com/scipipe/scipipe#Sink) process for this; purpose. If you for any reason need to customize which process to use as the; ""driver"" process, instead of the in-built sink. see the [`SetDriver` section](https://godoc.org/github.com/scipipe/scipipe#Workflow.SetDriver); in the docs. ```go; wf.Run(); ```. ## Summary. So with this, we have done everything needed to set up a file-based batch workflow system. In summary, what we did, was to:. 1. Initialize processes; 2. For each out-port, define a file-naming strategy; 3. Specify dependencies by connecting out- and in-ports; 4. Run the pipeline. This actually turns out to be a fixed set of components that always nee",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:7563,rout,routine,7563,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['rout'],['routine']
Integrability,"# Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This library is has been much influenced/inspired also by the; [GoFlow](https://github.com/trustmaster/goflow) library by [Vladimir Sibirov](https://github.com/trustmaster/goflow).; - Thanks to [Egon Elbre](http://twitter.com/egonelbre) for helpful input on the; design of the internals of the pipeline, and processes, which greatly; simplified the implementation.; - This work is financed by faculty grants and other financing for the [Pharmaceutical Bioinformatics group](http://pharmb.io) of [Dept. of; Pharmaceutical Biosciences](http://www.farmbio.uu.se) at [Uppsala University](http://www.uu.se), and by [Swedish Research Council](http://vr.se); through the Swedish [National Bioinformatics Infrastructure Sweden](http://nbis.se).; - Supervisor for the project is [Ola Spjuth](http://www.farmbio.uu.se/research/researchgroups/pb/olaspjuth).; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/acknowledgements.md:46,depend,dependent,46,docs/acknowledgements.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/acknowledgements.md,2,['depend'],"['dependency', 'dependent']"
Integrability,"## What are re-usable components. With re-usable components, we mean components that can be stored in a Go; package and imported and used later. In order for components in such a library to be easy to use, the ports need; to be static methods bound to the process struct, rather than just stored by; a string ID in a generic port map, like the `In()` and `Out()` methods on; `Process` processes. This is so that the methods can show up in the; auto-completion / intellisense function in code editors removing the need to; look up the name of the ports manually in the library code all the time. ## How to create re-usable components in SciPipe. Process processes created with the `scipipe.NewProc()` command, can be turned; into such ""re-usable"" component by using a wrapping strategy, that is; demonstrated in an [example on GitHub](https://github.com/scipipe/scipipe/blob/master/examples/wrapper_procs/wrap.go). The idea is to create a new struct type for the re-usable component, and; then, in the factory method for the process, create an ""inner"" process of; type Process, using `NewProc()` as in the normal case, embedding that in the; outer struct and then adding statically defined accessor methods for each of; the ports in the inner process, with a similar name. So, if the inner process; has an outport named ""foo"", you would define an accessor method named; `myproc.OutFoo()` that returns this port from the inner process. Let's look at a code example of how this works, by creating a process that just; writes ""hi"" to a file:. ```go; type HiWriter struct {; // Embedd a Process struct; 	*sci.Process; }. func NewHiWriter() *HiWriter {; // Initialize a normal ""Process"" to use as an ""inner"" process; 	innerHiWriter := sci.NewProc(""hiwriter"", ""echo hi > {o:hifile}""); 	innerHiWriter.SetOut(""hifile"", ""hi.txt""). // Create a new HiWriter process with the inner process embedded into it; 	return &HiWriter{innerHiWriter}; }. // OutHiFile provides a static version of the ""hifile"" port in the in",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md:767,wrap,wrapping,767,docs/howtos/reusable_components.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md,2,['wrap'],"['wrap', 'wrapping']"
Integrability,"//en.wikipedia.org/wiki/Flow-based_programming) like; pattern in pure Go presented in; [this](http://blog.gopheracademy.com/composable-pipelines-pattern) and; [this](https://blog.gopheracademy.com/advent-2015/composable-pipelines-improvements/); blog posts on Gopher Academy. ## Citing SciPipe. If you use SciPipe in academic or scholarly work, please cite the following paper as source:. Lampa S, Dahlö M, Alvarsson J, Spjuth O. SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines ; _Gigascience_. 8, 5 (2019). DOI: [10.1093/gigascience/giz044](https://dx.doi.org/10.1093/gigascience/giz044). ## Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This library is has been much influenced/inspired also by the; [GoFlow](https://github.com/trustmaster/goflow) library by [Vladimir Sibirov](https://github.com/trustmaster/goflow).; - Thanks to [Egon Elbre](http://twitter.com/egonelbre) for helpful input on the; design of the internals of the pipeline, and processes, which greatly; simplified the implementation.; - This work is financed by faculty grants and other financing for the [Pharmaceutical Bioinformatics group](http://pharmb.io) of [Dept. of; Pharmaceutical Biosciences](http://www.farmbio.uu.se) at [Uppsala University](http://www.uu.se), and by [Swedish Research Council](http://vr.se); through the Swedish [National Bioinformatics Infrastructure Sweden](http://nbis.se).; - Supervisor for the project is [Ola Spjuth](http://www.farmbio.uu.se/research/researchgroups/pb/olaspjuth). ## Related to",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:12324,depend,dependency,12324,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['depend'],['dependency']
Integrability,"1256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; - <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a. ## Introduction. <img src=""docs/images/fbp_factory.png"" align=""right"">. SciPipe is a library for writing [Scientific; Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system), sometimes; also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:3482,depend,depend,3482,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['depend'],['depend']
Integrability,"2/).; - See [slides from a recent presentation of SciPipe for use in a Bioinformatics setting](http://www.slideshare.net/SamuelLampa/scipipe-a-lightweight-workflow-library-inspired-by-flowbased-programming).; - The architecture of SciPipe is based on an [flow-based programming](https://en.wikipedia.org/wiki/Flow-based_programming) like; pattern in pure Go presented in; [this](http://blog.gopheracademy.com/composable-pipelines-pattern) and; [this](https://blog.gopheracademy.com/advent-2015/composable-pipelines-improvements/); blog posts on Gopher Academy. ## Citing SciPipe. If you use SciPipe in academic or scholarly work, please cite the following paper as source:. Lampa S, Dahlö M, Alvarsson J, Spjuth O. SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines ; _Gigascience_. 8, 5 (2019). DOI: [10.1093/gigascience/giz044](https://dx.doi.org/10.1093/gigascience/giz044). ## Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This library is has been much influenced/inspired also by the; [GoFlow](https://github.com/trustmaster/goflow) library by [Vladimir Sibirov](https://github.com/trustmaster/goflow).; - Thanks to [Egon Elbre](http://twitter.com/egonelbre) for helpful input on the; design of the internals of the pipeline, and processes, which greatly; simplified the implementation.; - This work is financed by faculty grants and other financing for the [Pharmaceutical Bioinformatics group](http://pharmb.io) of [Dept. of; Pharmaceutical Biosciences](http://www.farmbio.uu.se) at [Uppsala Uni",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:12062,depend,dependent,12062,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['depend'],['dependent']
Integrability,"It is possible in SciPipe to wrap a whole workflow in a process, so that it can be used; as any other process, in larger workflows. This is demonstrated in [this example on GitHub](https://github.com/scipipe/scipipe/blob/master/examples/subworkflow/subworkflow.go).; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/subworkflows.md:29,wrap,wrap,29,docs/howtos/subworkflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/subworkflows.md,1,['wrap'],['wrap']
Integrability,"Parameters are arguments sent to commands as flags, or unnamed values, or; sometimes just the occurance of flags. SciPipe does not provide one unified way to handle parameters, but instead; suggest a few different strategies, dependent on the usage pattern. This is; because it turns out that there is a very large variety in how parameters can; be used with shell commands. To keep SciPipe a small and flexible tool, we instead mostly leave the choice; up to the workflow author to create a solution for each case, using a few helper; tools provided with SciPipe, but also all the programming facilities built in to; the Go programming language. Below we will discuss how to handle the most common uses for for parameters in; SciPipe. For any more complicated use cases not covered here, please refer to; the [mailing list](https://groups.google.com/forum/#!forum/scipipe) or the; [chat](https://gitter.im/scipipe/scipipe), to ask your question. ## Static parameters. If parameters in your shell command is always, the same, you can just add them; ""manually"" to the shell command pattern used to create your process. For example, if you always want to write the string ""hello"" to output files,; you could create your processes with this string added manually:. ```go; helloWriter := scipipe.NewProc(""helloWriter"", ""echo hello > {o:outfile}""); ```. ### See also. - [Static parameters example](https://github.com/scipipe/scipipe/blob/master/examples/static_params/staticparams.go). ## Receive parameters dynamically. Receiving parameters dynamically is a much more technically demandning solution; than using static parameters. The idea is that by using placeholders for parameter values in a command, each; parameter for a particular process, will automatically get a channel of type; string, on which it can receive values. When the process is ready to execute; another shell command, it receives one item on each parameter ports, in; addition to receiving one file on each (file-)in-port, and merges",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/parameters.md:226,depend,dependent,226,docs/howtos/parameters.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/parameters.md,1,['depend'],['dependent']
Integrability,"[SciPipe 0.8.0](https://github.com/scipipe/scipipe/releases/tag/v0.8.0); introduced a feature to plot a directed graph of workflows in SciPipe [1].; This can be done in two ways:. 1. Just producing a DOT text file, with the graph definition; 2. Also converting this DOT file to PDF. Number 1. above can be done without any external dependencies, while number 2; requires that graphviz, with the `dot` command is installed on the system (On; Ubuntu it can be installed with the command: `sudo apt-get install graphviz`). ## How to plot graphs. To write a .dot file in SciPipe, include a line like follows, in your workflow; definition, provided that you have initiated the variable `wf` with a workflow; struct:. ```go; func main() {; wf := scipipe.NewWorkflow(""my workflow"", 4); // Workflow code here; wf.PlotGraph(""my_workflow_graph.dot"") // <-- SEE THIS LINE!; wf.Run(); }; ```. If you want to also convert the dot file to PDF in one go, instead change the; next last line to:. ```go; wf.PlotGraphPDF(""my_workflow_graph.dot""); ```. ## How to plot graphs conditionally based on a flag. Now, you might not want to generate a new plot every time you run your workflow; (although, perhaps you would? ... checking in a .dot version of your workflow; could in fact be a great way to keep a more readable version of your workflow; at hand ... but anyhow), you could make the plotting optional, based on a flag.; This is something we've found ourselves doing quite often at pharmb.io. This; could be done as follows (more complete code example):. ```go; package main. import (; ""flag""; ""github.com/scipipe/scipipe""; ). var (; plotGraph = flag.Bool(""plotgraph"", false, ""Plot a directed graph of the workflow to PDF""); ). func main() {; flag.Parse(). wf := scipipe.NewWorkflow(""testwf"", 4); wf.NewProc(""foo"", ""echo foo > {o:out}""). if *plotGraph {; wf.PlotGraphPDF(""wfgraph.dot""); }; wf.Run(); }; ```. Now, the graph will only plotted if you run your workflow with the; `-plotgraph` flag, e.g:. ```bash; go ru",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/plot_workflow_graph.md:332,depend,dependencies,332,docs/howtos/plot_workflow_graph.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/plot_workflow_graph.md,1,['depend'],['dependencies']
Integrability,"[SciPipe 0.8.0](https://github.com/scipipe/scipipe/releases/tag/v0.8.0); introduced experimental support for converting audit logs (those; `.audit.json` files produced to accompany all output files from SciPipe); into other formats, such as HTML, TeX (for further conversion to PDF) or; even executable Bash-scripts. Here's how to do it. ## Convert audit log to HTML. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2html myfile.audit.json; ```. This will produce an HTML file named `myfile.audit.html`, which you can; view in a web browser. ## Convert audit log to TeX. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2tex myfile.audit.json; ```. This will produce an HTML file named `myfile.audit.tex`, which you can; either edit manually, or convert directly to PDF using the `pdflatex`; command like so:. ```bash; pdflatex myfile.audit.tex; ```. Converting to PDF requires that you have a TeX installation on your system.; On Ubuntu, you can install the base package or TeX live with `sudo apt-get; install texlive-base`. ## Convert audit log to Bash. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2bash myfile.audit.json; ```. This will produce a Bash-file named `myfile.audit.sh`, which you can; execute like so:. ```bash; sh myfile.audit.sh; ```. ... in order to reproduce the file again from scratch, if it is removed,; given that you have all the dependent files and tools installed on your; system.",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/convert_audit_logs.md:1547,depend,dependent,1547,docs/howtos/convert_audit_logs.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/convert_audit_logs.md,1,['depend'],['dependent']
Integrability,"et started is to let the scipipe tool generate a starting point for you:. ```bash; scipipe new myfirstworkflow.go; ```. ... which you can then edit to your liking. ## Create a Go module. Before you can run the workflow, you need to also create a [go module](https://golang.org/ref/mod#introduction). To do this, you can run the following command, in the directory where you; created your first workflow:. ```bash; go mod init <package-name>; ```. For `<module-name>`, you have to replace it with a name of the package.; For a simple script, you can name whatever you want, but if you are thinking; about publishing it online, e.g. on GitHub, you typically want to name it like; the URL of the corresponding GitHub repo, e.g.; `github.com/<your-username>/<your-repository>`. By doing this, two files will be created:. ```; go.mod; go.sum; ```. Make sure to add them to your git repository, with:. ```; git add go.mod go.sum; git commit -m ""Add Go module files""; ```. Now, to make sure that scipipe is included as a dependency in the go.mod file,; run the `go mod tidy` command:. ```bash; go mod tidy; ```. The `go.mod` file should now look something like:. ```; module mylittlemodule. go 1.17. require github.com/scipipe/scipipe v0.10.2; ```. ... and the go.sum file might look something like:. ```; github.com/scipipe/scipipe v0.10.2 h1:crXD1gGh/LuBfWfT4CdXcRFtPjem5weyXN03BDfVOuU=; github.com/scipipe/scipipe v0.10.2/go.mod h1:Nwof+Uimtam7GTpkU6cAf/EOnqvxcOVFytjnYU5I3vY=; ```. ### Optional extra step: Use a copy of SciPipe's source code in your own code. In order to make sure that your workflow will never break because of API; changes in SciPipe, and that you always have a copy of the SciPipe source; code available, we recommend to always include a copy of the SciPipe source; code in your workflow's source code repository. The SciPipe source code is; only around 1500 lines of code, with no external dependencies except Go and; Bash, so this should not increase the size of your repository t",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:2489,depend,dependency,2489,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,1,['depend'],['dependency']
Integrability,"g {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipeline to the workflow, so that the workflow can pull on this port; (technically pulling on a Go channel), in order to drive the workflow. ```go; // Connect network; world.In(""in"").From(helloWriter.Out(""out"")); ```. ## Running the pipeline. So, the final part probably explains itself, but the workflow component is a; relatively simple one that will start each component in a separate go-routine. For technical reasons, one final process has to be run in the main go-routine; (that where the program's `main()` function runs), but generally you don't; need to think about this, as the workflow will then use an in-built; [sink](https://godoc.org/github.com/scipipe/scipipe#Sink) process for this; purpose. If you for any reason need to customize which process to use as the; ""driver"" process, instead of the in-built sink. see the [`SetDriver` section](https://godoc.org/github.com/scipipe/scipipe#Workflow.SetDriver); in the docs. ```go; wf.Run(); ```. ## Summary. So with this, we have done everything needed to set up a file-based batch workflow system. In summary, what we did, was to:. 1. Initialize processes; 2. For each out-port, define a file-naming strategy; 3. Specify dependencies by connecting out- and in-ports; 4. Run the pipeline. This actually turns out to be a fixed set of components that always need to be; included when writing workflows, so it might be good to keep them in mind and; memorize these steps, if needed. For more examples, see the [examples folder](https://github.com/scipipe/scipipe/tree/master/examples); in the GitHub repository.; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:8355,depend,dependencies,8355,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['depend'],['dependencies']
Integrability,"ll return ""bar.txt"", since both funcs were pointing to; the same variable (""var""), which had the value ""bar"" at the end of the loop. To avoid this situation, you can do one of two things, of which the latter is; generally recommended:. **1.** Create a new copy of the variable, inside the anonymous function:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); val := val // <- Here we create a new copy of the variable; proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. **2.** ... or, better, access the parameter value via the task which the path function receives:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipeline to the workflow, so that the workflow can pull on this port; (technically pulling on a Go channel), in order to drive the workflow. ```go; // Connect network; world.In(""in"").From(helloWriter.Out(""out"")); ```. ## Running the pipeline. So, the final part probably explains itself, but the workflow component is a; relatively simple one that will start each component in a separate go-routine. For technical reasons, one final process has to be run in the main go-routine; (that where the program's `main()` function runs), but generally you don't; need to think about this, as the workflow will then use an in-built; [sink](https://godoc.org/github.com/scipipe/scipipe#Sink) process for this; purpose. If you for any reason ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:6903,depend,dependencies,6903,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['depend'],['dependencies']
Integrability,"one; particular shell command execution. `Task` objects are executed via their; [`Execute()`](https://godoc.org/github.com/scipipe/scipipe#Task.Execute); method, or `CustomExecute()`, if custom Go code is supposed to be; executed instead of a shell command. The distinction between processes and tasks is important to understand, for; example when doing more advanced configuration of file naming strategies, since; the custom anonymous functions used to format paths are taking a `Task` as; input, even though these functions are saved on the process object. To understand the difference between processes and tasks, it is helpful to; remember that processes are long-running, and typically fixed during the course; of a workflow, while tasks are transient objects, created temporarily as a; container for all data and code needed for each execution of a concrete shell; command. * See [GoDoc for Task](https://godoc.org/github.com/scipipe/scipipe#Task). ## Ports. Central to the way data dependencies are defined in SciPipe, is ports. Ports; are fields on processes, which are connected to other ports via channels (see; separate section on this page). In SciPipe, each port must have a unique name within its process (there can't; be an in-port and out-port named the same), and this name will be used in shell; command patterns, when connecting dependencies / dataflow networks, and when; configuring file naming strategies. In `Process` objects, in-ports are are accessed with; `myProcess.In(""my_port"")`, and out-ports are similarly accessed with; `myProcess.Out(""my_other_port"")`. They are of type; [`InPort`](https://godoc.org/github.com/scipipe/scipipe#InPort) and; [`OutPort`](https://godoc.org/github.com/scipipe/scipipe#OutPort) respectively. Some pre-made components might have ports bound to custom field names though,; such as `myFastaReader.InFastaFile`, or `myZipComponent.OutZipFile`. Port objects have some methods bound to them, most importantly the `From()`; method (for in-ports. ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md:2210,depend,dependencies,2210,docs/basic_concepts.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md,1,['depend'],['dependencies']
Integrability,"proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipeline to the workflow, so that the workflow can pull on this port; (technically pulling on a Go channel), in order to drive the workflow. ```go; // Connect network; world.In(""in"").From(helloWriter.Out(""out"")); ```. ## Running the pipeline. So, the final part probably explains itself, but the workflow component is a; relatively simple one that will start each component in a separate go-routine. For technical reasons, one final process has to be run in the main go-routine; (that where the program's `main()` function runs), but generally you don't; need to think about this, as the workflow will then use an in-built; [sink](https://godoc.org/github.com/scipipe/scipipe#Sink) process for this; purpose. If you for any reason need to customize which process to use as the; ""driver"" process, instead of the in-built sink. see the [`SetDriver` section](https://godoc.org/github.com/scipipe/scipipe#Workflow.SetDriver); in the docs. ```go; wf.Run(); ```. ## Summary. So with this, we have done everything needed to set up a file-based batch workflow system. In summary, what we did, was to:. 1. Initialize processes; 2. For each out-port, define a file-naming strategy; 3. Specify dependencies by connecting out- and in-ports; 4. Run the pipeline. This actually turns out to be a fixed set of components that always need to be; included when writing workflows, so it might be good to keep them in mind and; memorize these steps, if needed. For more examples, see the [examples folder](https://github.com/scipipe/scipipe/",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:7642,rout,routine,7642,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['rout'],['routine']
Integrability,"s 15-25, the workflow components, or processes, are initiated,; each with a name and a shell command pattern. Input file names are defined with; a placeholder on the form {i:INPORTNAME} and outputs on the form; {o:OUTPORTNAME}. The port-name will be used later to access the corresponding; ports for setting up data dependencies. On line 16, a component that writes the; previously defined DNA string to a file is initiated, and on line 17, the file; path pattern for the out-port dna is defined (in this case a static file name).; On line 20, a component that translates each DNA base to its complementary; counterpart is initiated. On line 21, the file path pattern for its only; out-port is defined. In this case, reusing the file path of the file it will; receive on its in-port named in, thus the {i:in} part. The %.txt part removes; .txt from the input path. On line 24, a component that will reverse the DNA; string is initiated. On lines 27-29, data dependencies are defined via the in-; and out-ports defined earlier as part of the shell command patterns. On line; 32, the workflow is being run. ## How to run. To run the example, given that you have the [Go toolchain](https://golang.org); installed (a vertion from at least 1.9), you can run it like this:. ```bash; $ go run revcomplement.go ; ```. You are then expected to see some log output similar to the following:. ```log; AUDIT 2019/03/26 22:59:43 | workflow:DNA Base Complement Workflow | Starting workflow (Writing log to log/scipipe-20190326-225943-dna-base-complement-workflow.log); AUDIT 2019/03/26 22:59:43 | Make DNA | Executing: echo AAAGCCCGTGGGGGACCTGTTC > dna.txt; AUDIT 2019/03/26 22:59:43 | Make DNA | Finished: echo AAAGCCCGTGGGGGACCTGTTC > dna.txt; AUDIT 2019/03/26 22:59:43 | Base Complement | Executing: cat ../dna.txt | tr ATCG TAGC > dna.compl.txt; AUDIT 2019/03/26 22:59:43 | Base Complement | Finished: cat ../dna.txt | tr ATCG TAGC > dna.compl.txt; AUDIT 2019/03/26 22:59:43 | Reverse | Executing: cat ../dna.c",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md:2617,depend,dependencies,2617,examples/revcomplement/README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md,1,['depend'],['dependencies']
Integrability,"string; 	reverse := wf.NewProc(""Reverse"", ""cat {i:in} | rev > {o:rev}""); 	reverse.SetOut(""rev"", ""{i:in|%.txt}.rev.txt""). 	// Connect data dependencies between out- and in-ports; 	complmt.In(""in"").From(makeDNA.Out(""dna"")); 	reverse.In(""in"").From(complmt.Out(""compl"")). 	// Run the workflow; 	wf.Run(); }; ```. On line 4, the SciPipe library is imported, to be later accessed as scipipe. On; line 7, a short string of DNA is defined. On line 9-33, the full workflow is; implemented in the program’s main() function, meaning that it will be executed; when the resulting program is executed. On line 11, a new workflow object (or; “struct” in Go terms) is initiated with a name and the maximum number of cores; to use. On lines 15-25, the workflow components, or processes, are initiated,; each with a name and a shell command pattern. Input file names are defined with; a placeholder on the form {i:INPORTNAME} and outputs on the form; {o:OUTPORTNAME}. The port-name will be used later to access the corresponding; ports for setting up data dependencies. On line 16, a component that writes the; previously defined DNA string to a file is initiated, and on line 17, the file; path pattern for the out-port dna is defined (in this case a static file name).; On line 20, a component that translates each DNA base to its complementary; counterpart is initiated. On line 21, the file path pattern for its only; out-port is defined. In this case, reusing the file path of the file it will; receive on its in-port named in, thus the {i:in} part. The %.txt part removes; .txt from the input path. On line 24, a component that will reverse the DNA; string is initiated. On lines 27-29, data dependencies are defined via the in-; and out-ports defined earlier as part of the shell command patterns. On line; 32, the workflow is being run. ## How to run. To run the example, given that you have the [Go toolchain](https://golang.org); installed (a vertion from at least 1.9), you can run it like this:. ```bash; $",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md:1975,depend,dependencies,1975,examples/revcomplement/README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md,1,['depend'],['dependencies']
Integrability,"strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a>; </div>. ## Introduction. SciPipe is a library for writing [Scientific Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system),; sometimes also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:3659,depend,depend,3659,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['depend'],['depend']
Integrability,"sum; git commit -m ""Add Go module files""; ```. Now, to make sure that scipipe is included as a dependency in the go.mod file,; run the `go mod tidy` command:. ```bash; go mod tidy; ```. The `go.mod` file should now look something like:. ```; module mylittlemodule. go 1.17. require github.com/scipipe/scipipe v0.10.2; ```. ... and the go.sum file might look something like:. ```; github.com/scipipe/scipipe v0.10.2 h1:crXD1gGh/LuBfWfT4CdXcRFtPjem5weyXN03BDfVOuU=; github.com/scipipe/scipipe v0.10.2/go.mod h1:Nwof+Uimtam7GTpkU6cAf/EOnqvxcOVFytjnYU5I3vY=; ```. ### Optional extra step: Use a copy of SciPipe's source code in your own code. In order to make sure that your workflow will never break because of API; changes in SciPipe, and that you always have a copy of the SciPipe source; code available, we recommend to always include a copy of the SciPipe source; code in your workflow's source code repository. The SciPipe source code is; only around 1500 lines of code, with no external dependencies except Go and; Bash, so this should not increase the size of your repository too much. A simple way to do this, is to use Go's `vendor` tool, which stores a local; copy of the source code of packages used, inside the local directory, in; a sub-directory called ""vendor"". To do this, execute the following command:. ```; go mod vendor; ```. Then, to make sure the code is included in your git history, make sure to add it; to git:. ```bash; git add vendor; git commit -m ""Add vendored version of SciPipe""; ```. ## Run your workflow. Now youa re ready to run the workflow. To run a `.go` file, just use `go run <script-file>`, e.g:; ; ```bash; go run myfirstworkflow.go; ```. ## Some tips about editors. In order to be productive with SciPipe, you will also need a Go editor or IDE; with support for auto-completion, sometimes also called ""intellisense"". We can warmly recommend to use one of these editors, sorted by level of endorsement:. 1. [Visual Studio Code](http://code.visualstudio.com) with ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:3384,depend,dependencies,3384,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,1,['depend'],['dependencies']
Integrability,"trailing dots!), and create a Go module for your script:. ```bash; go install github.com/scipipe/scipipe/...@latest; go mod init myfirstworkflow-module; ```. ## Hello World example. Let's look at an example workflow to get a feel for what writing workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.au",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:6497,depend,dependencies,6497,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['depend'],['dependencies']
Integrability,"workflow computes the; reverse base complement of a string of DNA, using standard UNIX tools. ## Detailed explanation of the code. See the revcomplement.go file for the source code, or here below:. ```go; package main. import (; 	""github.com/scipipe/scipipe""; ). const dna = ""AAAGCCCGTGGGGGACCTGTTC"". func main() {; 	// Initialize workflow, using max 4 CPU cores; 	wf := scipipe.NewWorkflow(""DNA Base Complement Workflow"", 4). 	// Initialize processes based on shell commands:. 	// makeDNA writes a DNA string to a file; 	makeDNA := wf.NewProc(""Make DNA"", ""echo ""+dna+"" > {o:dna}""); 	makeDNA.SetOut(""dna"", ""dna.txt""). 	// complmt computes the base complement of a DNA string; 	complmt := wf.NewProc(""Base Complement"", ""cat {i:in} | tr ATCG TAGC > {o:compl}""); 	complmt.SetOut(""compl"", ""{i:in|%.txt}.compl.txt""). 	// reverse reverses the input DNA string; 	reverse := wf.NewProc(""Reverse"", ""cat {i:in} | rev > {o:rev}""); 	reverse.SetOut(""rev"", ""{i:in|%.txt}.rev.txt""). 	// Connect data dependencies between out- and in-ports; 	complmt.In(""in"").From(makeDNA.Out(""dna"")); 	reverse.In(""in"").From(complmt.Out(""compl"")). 	// Run the workflow; 	wf.Run(); }; ```. On line 4, the SciPipe library is imported, to be later accessed as scipipe. On; line 7, a short string of DNA is defined. On line 9-33, the full workflow is; implemented in the program’s main() function, meaning that it will be executed; when the resulting program is executed. On line 11, a new workflow object (or; “struct” in Go terms) is initiated with a name and the maximum number of cores; to use. On lines 15-25, the workflow components, or processes, are initiated,; each with a name and a shell command pattern. Input file names are defined with; a placeholder on the form {i:INPORTNAME} and outputs on the form; {o:OUTPORTNAME}. The port-name will be used later to access the corresponding; ports for setting up data dependencies. On line 16, a component that writes the; previously defined DNA string to a file is initiated, and on ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md:1075,depend,dependencies,1075,examples/revcomplement/README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md,1,['depend'],['dependencies']
Modifiability," and tasks is important to understand, for; example when doing more advanced configuration of file naming strategies, since; the custom anonymous functions used to format paths are taking a `Task` as; input, even though these functions are saved on the process object. To understand the difference between processes and tasks, it is helpful to; remember that processes are long-running, and typically fixed during the course; of a workflow, while tasks are transient objects, created temporarily as a; container for all data and code needed for each execution of a concrete shell; command. * See [GoDoc for Task](https://godoc.org/github.com/scipipe/scipipe#Task). ## Ports. Central to the way data dependencies are defined in SciPipe, is ports. Ports; are fields on processes, which are connected to other ports via channels (see; separate section on this page). In SciPipe, each port must have a unique name within its process (there can't; be an in-port and out-port named the same), and this name will be used in shell; command patterns, when connecting dependencies / dataflow networks, and when; configuring file naming strategies. In `Process` objects, in-ports are are accessed with; `myProcess.In(""my_port"")`, and out-ports are similarly accessed with; `myProcess.Out(""my_other_port"")`. They are of type; [`InPort`](https://godoc.org/github.com/scipipe/scipipe#InPort) and; [`OutPort`](https://godoc.org/github.com/scipipe/scipipe#OutPort) respectively. Some pre-made components might have ports bound to custom field names though,; such as `myFastaReader.InFastaFile`, or `myZipComponent.OutZipFile`. Port objects have some methods bound to them, most importantly the `From()`; method (for in-ports. Out-ports have a corresponding `To()` method), which; takes another port, and connects to it, by stitching a channel between the; ports. On `Process` objects, there is also a third port type, `InParamPort` (and the; accompanying `OutParamPort`), which is used when it is needed to send a; s",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md:2613,config,configuring,2613,docs/basic_concepts.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md,1,['config'],['configuring']
Modifiability,"# Contributing to SciPipe. ## Working with forked repository. Unlike other languages like C++/Python, Go requires modules being referenced,; to be placed in a specific location for the import to work. Forking via GitHub; provides a pull request workflow that is well documented but does not work well; with Go import. Documented here is one approach utilizing go modules. First, fork and clone SciPipe the usual way via GitHub to a local file system,; lets call it `<cloned-scipipe-dir>`. To work on and test the changes made to scipipe in the cloned location, create; a directory for your scipipe workflows, lets call it `<workflow-dev-dir>`. In; that directory, you can create a simple `main.go` file with a `package main` so; that you can run your code that exercises the changes you are making at; `<cloned-scipipe-dir>`. Note that if you were to run your code in `main.go` as-is, it would pull down; the code from the repository and cache them and you will not actually be able; to test any local changes in scipipe. To do so, you need to create a file call; `go.mod`. In `<workflow-dev-dir>` run the following:. ```; go mod init <some package name>; ```. Note: The actual name of the package is not critical. Next, define the modules required by your main.go:. ```; go mod edit -require=github.com/scipipe/scipipe@v0.9.10; ```. Note: A the time of this writing, v0.9.10 is the latest published version, this; will change over time and you need to adapt. Next, replace any reference to the previous URL with reference to the; `<cloned-scipipe-dir>` location:. ```; go mod edit -replace=github.com/scipipe/scipipe@v0.9.10=<cloned-scipipe-dir>; ```. Now when you do:. ```; go run main.go; ```. ... it will not be pulling the code from GitHub but references the code you; have cloned locally. Do your development work and push to your forked repository and do a pull; request for the author to review and optionally merge the contribution.; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md:1453,adapt,adapt,1453,docs/contributing.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md,1,['adapt'],['adapt']
Modifiability,"1256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; - <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a. ## Introduction. <img src=""docs/images/fbp_factory.png"" align=""right"">. SciPipe is a library for writing [Scientific; Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system), sometimes; also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:3584,flexible,flexible,3584,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['flexible'],['flexible']
Modifiability,"; <img src=""images/fbp_factory.png"" style=""width: 30%; float: right; margin: 1em;"">; <h1 style=""margin-bottom: 0;""><img src=""images/scipipe_logo_bluegrey_horiz.svg"" style=""width: 240px; margin-left: -10px; margin-bottom: 0;"" alt=""SciPipe""></h1>. <big>Robust, flexible and resource-efficient pipelines using Go and the commandline</big>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. <strong><small>Project links: [GitHub repo](http://github.com/scipipe/scipipe) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</small></strong>. [![Build Status](https://img.shields.io/circleci/project/github/scipipe/scipipe.svg)](https://circleci.com/gh/scipipe/scipipe); [![Test Coverage](https://img.shields.io/codecov/c/github/scipipe/scipipe.svg)](https://codecov.io/gh/scipipe/scipipe); [![Codebeat Grade](https://codebeat.co/badges/96e93624-2ac8-42c9-9e94-2d6e5325d8ff)](https://codebeat.co/projects/github-com-scipipe-scipipe-master); [![Go Report Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipip",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:259,flexible,flexible,259,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['flexible'],['flexible']
Modifiability,"<h1 style=""margin-bottom: 0;""><img src=""docs/images/scipipe_logo_bluegrey_horiz_320px.png"" alt=""SciPipe""></h1>. <big>Robust, flexible and resource-efficient pipelines using Go and the commandline</big>. [![Build Status](https://img.shields.io/circleci/project/github/scipipe/scipipe.svg)](https://app.circleci.com/pipelines/github/scipipe); [![Test Coverage](https://img.shields.io/codecov/c/github/scipipe/scipipe.svg)](https://codecov.io/gh/scipipe/scipipe); [![Codebeat Grade](https://codebeat.co/badges/96e93624-2ac8-42c9-9e94-2d6e5325d8ff)](https://codebeat.co/projects/github-com-scipipe-scipipe-master); [![Go Report Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipipe); [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1157941.svg)](https://doi.org/10.5281/zenodo.1157941). <strong>Project links: [Documentation & Main Website](http://scipipe.org) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</strong>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. ## Project updates. - <str",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:125,flexible,flexible,125,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['flexible'],['flexible']
Modifiability,"Parameters are arguments sent to commands as flags, or unnamed values, or; sometimes just the occurance of flags. SciPipe does not provide one unified way to handle parameters, but instead; suggest a few different strategies, dependent on the usage pattern. This is; because it turns out that there is a very large variety in how parameters can; be used with shell commands. To keep SciPipe a small and flexible tool, we instead mostly leave the choice; up to the workflow author to create a solution for each case, using a few helper; tools provided with SciPipe, but also all the programming facilities built in to; the Go programming language. Below we will discuss how to handle the most common uses for for parameters in; SciPipe. For any more complicated use cases not covered here, please refer to; the [mailing list](https://groups.google.com/forum/#!forum/scipipe) or the; [chat](https://gitter.im/scipipe/scipipe), to ask your question. ## Static parameters. If parameters in your shell command is always, the same, you can just add them; ""manually"" to the shell command pattern used to create your process. For example, if you always want to write the string ""hello"" to output files,; you could create your processes with this string added manually:. ```go; helloWriter := scipipe.NewProc(""helloWriter"", ""echo hello > {o:outfile}""); ```. ### See also. - [Static parameters example](https://github.com/scipipe/scipipe/blob/master/examples/static_params/staticparams.go). ## Receive parameters dynamically. Receiving parameters dynamically is a much more technically demandning solution; than using static parameters. The idea is that by using placeholders for parameter values in a command, each; parameter for a particular process, will automatically get a channel of type; string, on which it can receive values. When the process is ready to execute; another shell command, it receives one item on each parameter ports, in; addition to receiving one file on each (file-)in-port, and merges",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/parameters.md:403,flexible,flexible,403,docs/howtos/parameters.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/parameters.md,1,['flexible'],['flexible']
Modifiability,"[SciPipe 0.8.0](https://github.com/scipipe/scipipe/releases/tag/v0.8.0); introduced a feature to plot a directed graph of workflows in SciPipe [1].; This can be done in two ways:. 1. Just producing a DOT text file, with the graph definition; 2. Also converting this DOT file to PDF. Number 1. above can be done without any external dependencies, while number 2; requires that graphviz, with the `dot` command is installed on the system (On; Ubuntu it can be installed with the command: `sudo apt-get install graphviz`). ## How to plot graphs. To write a .dot file in SciPipe, include a line like follows, in your workflow; definition, provided that you have initiated the variable `wf` with a workflow; struct:. ```go; func main() {; wf := scipipe.NewWorkflow(""my workflow"", 4); // Workflow code here; wf.PlotGraph(""my_workflow_graph.dot"") // <-- SEE THIS LINE!; wf.Run(); }; ```. If you want to also convert the dot file to PDF in one go, instead change the; next last line to:. ```go; wf.PlotGraphPDF(""my_workflow_graph.dot""); ```. ## How to plot graphs conditionally based on a flag. Now, you might not want to generate a new plot every time you run your workflow; (although, perhaps you would? ... checking in a .dot version of your workflow; could in fact be a great way to keep a more readable version of your workflow; at hand ... but anyhow), you could make the plotting optional, based on a flag.; This is something we've found ourselves doing quite often at pharmb.io. This; could be done as follows (more complete code example):. ```go; package main. import (; ""flag""; ""github.com/scipipe/scipipe""; ). var (; plotGraph = flag.Bool(""plotgraph"", false, ""Plot a directed graph of the workflow to PDF""); ). func main() {; flag.Parse(). wf := scipipe.NewWorkflow(""testwf"", 4); wf.NewProc(""foo"", ""echo foo > {o:out}""). if *plotGraph {; wf.PlotGraphPDF(""wfgraph.dot""); }; wf.Run(); }; ```. Now, the graph will only plotted if you run your workflow with the; `-plotgraph` flag, e.g:. ```bash; go ru",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/plot_workflow_graph.md:672,variab,variable,672,docs/howtos/plot_workflow_graph.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/plot_workflow_graph.md,1,['variab'],['variable']
Modifiability,"`.; - Example: `{i:infile|s/file/my_file/}`, if `infile` has the path `file.txt`, will convert it to `my_file.txt`. ## Even more control over file formatting. We can actually get even more control over how file names are produced than; this, by manually supplying each process with an anonymous function that; returns file paths given a `scipipe.Task` object, which will be produced for; each command execution. In order to implement the same path patterns as above, using this method, we; would write like this:. ```go; // Configure output file path formatters for the processes created above; hello.SetOutFunc(""out"", func(t *scipipe.Task) string {; return ""hello.txt""; }); world.SetOutFunc(""out"", func(t *scipipe.Task) string {; return strings.Replace(t.InPath(""in""), "".txt"", ""_world.txt"", -1); }); ```. As you can see, this is a much more complicated way to format paths, but it can; be useful for example when needing to incorporate parameter values into file; names. ### A caveat about using variables in anonymous functions. Note that when using anonymous functions, you have to be careful to not re-use; the same variable (even with different values) in multiple functions, due to; the [subtle ways in which closures work in Go](https://golang.org/doc/faq#closures_and_goroutines). For example, if you create multiple new processes with separate formatting; functions in a loop, that uses a shared variable, like this:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. ... then, both functions will return ""bar.txt"", since both funcs were pointing to; the same variable (""var""), which had the value ""bar"" at the end of the loop. To avoid this situation, you can do one of two things, of which the latter is; generally recommended:. **1.** Create a new copy of the variable, inside the anonymous function:. ```go; for _, val := range []st",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:5239,variab,variables,5239,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['variab'],['variables']
Modifiability,"he OutPort struct type](https://godoc.org/github.com/scipipe/scipipe#OutPort); * See [GoDoc for the InParamPort struct type](https://godoc.org/github.com/scipipe/scipipe#InParamPort); * See [GoDoc for the OutParamPort struct type](https://godoc.org/github.com/scipipe/scipipe#OutParamPort). ## Channels. Ports in SciPipe are connected via channels. Channels are [plain Go channels](https://tour.golang.org/concurrency/2); and nothing more. Most of the time, one will not need to deal with the channels; directly though, since the port objects (see separate section for ports) have; all the logic to connect to other ports via channels, but it can be good to; know that they are there, in case you need to do something more advanced. ## Workflow. The [`Workflow`](https://godoc.org/github.com/scipipe/scipipe#Workflow); is a special object in SciPipe, that just takes care of running a set of; components making up a workflow. There is not much to say about the workflow component, other than that it is; created with `scipipe.NewWorkflow(workflowName, maxConcurrentTasks)`, that all processes need to be added; to it with `wf.AddProc(proc)` while the ""last"", or ""driving"" process needs to be specified with `wf.SetDriver(driverProcess)`, and that it should be run with; `wf.Run()`. But this is already covered in the other examples and; tutorials. * See [GoDoc for Workflow](https://godoc.org/github.com/scipipe/scipipe#Workflow). ## Shell command pattern. The `Process` has the speciality that it can be configured using a special; shell command pattern, supplied to the [`NewProc()`](https://godoc.org/github.com/scipipe/scipipe#NewProc); factory function. It is already explained in the section ""writing workflows"",; but in brief, it is a normal shell command, with placeholders for in-ports,; out-ports and parameter ports, on the form `{i:inportname}`, `{o:outportname}`,; and `{p:paramportname}`, respectively. * See [GoDoc for NewProc()](https://godoc.org/github.com/scipipe/scipipe#NewProc); ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md:5225,config,configured,5225,docs/basic_concepts.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md,1,['config'],['configured']
Modifiability,"r file formatting. We can actually get even more control over how file names are produced than; this, by manually supplying each process with an anonymous function that; returns file paths given a `scipipe.Task` object, which will be produced for; each command execution. In order to implement the same path patterns as above, using this method, we; would write like this:. ```go; // Configure output file path formatters for the processes created above; hello.SetOutFunc(""out"", func(t *scipipe.Task) string {; return ""hello.txt""; }); world.SetOutFunc(""out"", func(t *scipipe.Task) string {; return strings.Replace(t.InPath(""in""), "".txt"", ""_world.txt"", -1); }); ```. As you can see, this is a much more complicated way to format paths, but it can; be useful for example when needing to incorporate parameter values into file; names. ### A caveat about using variables in anonymous functions. Note that when using anonymous functions, you have to be careful to not re-use; the same variable (even with different values) in multiple functions, due to; the [subtle ways in which closures work in Go](https://golang.org/doc/faq#closures_and_goroutines). For example, if you create multiple new processes with separate formatting; functions in a loop, that uses a shared variable, like this:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. ... then, both functions will return ""bar.txt"", since both funcs were pointing to; the same variable (""var""), which had the value ""bar"" at the end of the loop. To avoid this situation, you can do one of two things, of which the latter is; generally recommended:. **1.** Create a new copy of the variable, inside the anonymous function:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); val := val // <- Here we create a new copy of the var",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:5362,variab,variable,5362,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['variab'],['variable']
Modifiability,"strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a>; </div>. ## Introduction. SciPipe is a library for writing [Scientific Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system),; sometimes also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:3761,flexible,flexible,3761,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['flexible'],['flexible']
Modifiability,"t, which will be produced for; each command execution. In order to implement the same path patterns as above, using this method, we; would write like this:. ```go; // Configure output file path formatters for the processes created above; hello.SetOutFunc(""out"", func(t *scipipe.Task) string {; return ""hello.txt""; }); world.SetOutFunc(""out"", func(t *scipipe.Task) string {; return strings.Replace(t.InPath(""in""), "".txt"", ""_world.txt"", -1); }); ```. As you can see, this is a much more complicated way to format paths, but it can; be useful for example when needing to incorporate parameter values into file; names. ### A caveat about using variables in anonymous functions. Note that when using anonymous functions, you have to be careful to not re-use; the same variable (even with different values) in multiple functions, due to; the [subtle ways in which closures work in Go](https://golang.org/doc/faq#closures_and_goroutines). For example, if you create multiple new processes with separate formatting; functions in a loop, that uses a shared variable, like this:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. ... then, both functions will return ""bar.txt"", since both funcs were pointing to; the same variable (""var""), which had the value ""bar"" at the end of the loop. To avoid this situation, you can do one of two things, of which the latter is; generally recommended:. **1.** Create a new copy of the variable, inside the anonymous function:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); val := val // <- Here we create a new copy of the variable; proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. **2.** ... or, better, access the parameter value via the task which the path function receives:. ```go; for _, val := ra",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:5647,variab,variable,5647,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['variab'],['variable']
Modifiability,"te parameter values into file; names. ### A caveat about using variables in anonymous functions. Note that when using anonymous functions, you have to be careful to not re-use; the same variable (even with different values) in multiple functions, due to; the [subtle ways in which closures work in Go](https://golang.org/doc/faq#closures_and_goroutines). For example, if you create multiple new processes with separate formatting; functions in a loop, that uses a shared variable, like this:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. ... then, both functions will return ""bar.txt"", since both funcs were pointing to; the same variable (""var""), which had the value ""bar"" at the end of the loop. To avoid this situation, you can do one of two things, of which the latter is; generally recommended:. **1.** Create a new copy of the variable, inside the anonymous function:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); val := val // <- Here we create a new copy of the variable; proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. **2.** ... or, better, access the parameter value via the task which the path function receives:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipel",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:6170,variab,variable,6170,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['variab'],['variable']
Modifiability,"to not re-use; the same variable (even with different values) in multiple functions, due to; the [subtle ways in which closures work in Go](https://golang.org/doc/faq#closures_and_goroutines). For example, if you create multiple new processes with separate formatting; functions in a loop, that uses a shared variable, like this:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. ... then, both functions will return ""bar.txt"", since both funcs were pointing to; the same variable (""var""), which had the value ""bar"" at the end of the loop. To avoid this situation, you can do one of two things, of which the latter is; generally recommended:. **1.** Create a new copy of the variable, inside the anonymous function:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); val := val // <- Here we create a new copy of the variable; proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. **2.** ... or, better, access the parameter value via the task which the path function receives:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipeline to the workflow, so that the workflow can pull on this port; (technically pulling on a Go channel), in order to drive the workflow. ```go; // Connect network",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:6380,variab,variable,6380,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['variab'],['variable']
Modifiability,"turn strings.Replace(t.InPath(""in""), "".txt"", ""_world.txt"", -1); }); ```. As you can see, this is a much more complicated way to format paths, but it can; be useful for example when needing to incorporate parameter values into file; names. ### A caveat about using variables in anonymous functions. Note that when using anonymous functions, you have to be careful to not re-use; the same variable (even with different values) in multiple functions, due to; the [subtle ways in which closures work in Go](https://golang.org/doc/faq#closures_and_goroutines). For example, if you create multiple new processes with separate formatting; functions in a loop, that uses a shared variable, like this:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. ... then, both functions will return ""bar.txt"", since both funcs were pointing to; the same variable (""var""), which had the value ""bar"" at the end of the loop. To avoid this situation, you can do one of two things, of which the latter is; generally recommended:. **1.** Create a new copy of the variable, inside the anonymous function:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); val := val // <- Here we create a new copy of the variable; proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. **2.** ... or, better, access the parameter value via the task which the path function receives:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outport",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:5967,variab,variable,5967,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['variab'],['variable']
Modifiability,"which is specialized for executing commandline applications. New; `Process`-es are typically created using the `scipipe.NewProc(procName,; shellPattern)` command. * See [GoDoc for Process](https://godoc.org/github.com/scipipe/scipipe#Process). ## Tasks. The ""long-running"" processes mentioned above, will receive input files on its; in-ports, and for each complete set of input files it receives, it will create; a new **task**. Specifically, `scipipe.Process` will create; [`scipipe.Task`](https://godoc.org/github.com/scipipe/scipipe#Task) objects, and populate it with all data needed for one; particular shell command execution. `Task` objects are executed via their; [`Execute()`](https://godoc.org/github.com/scipipe/scipipe#Task.Execute); method, or `CustomExecute()`, if custom Go code is supposed to be; executed instead of a shell command. The distinction between processes and tasks is important to understand, for; example when doing more advanced configuration of file naming strategies, since; the custom anonymous functions used to format paths are taking a `Task` as; input, even though these functions are saved on the process object. To understand the difference between processes and tasks, it is helpful to; remember that processes are long-running, and typically fixed during the course; of a workflow, while tasks are transient objects, created temporarily as a; container for all data and code needed for each execution of a concrete shell; command. * See [GoDoc for Task](https://godoc.org/github.com/scipipe/scipipe#Task). ## Ports. Central to the way data dependencies are defined in SciPipe, is ports. Ports; are fields on processes, which are connected to other ports via channels (see; separate section on this page). In SciPipe, each port must have a unique name within its process (there can't; be an in-port and out-port named the same), and this name will be used in shell; command patterns, when connecting dependencies / dataflow networks, and when; configuring fil",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md:1588,config,configuration,1588,docs/basic_concepts.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md,1,['config'],['configuration']
Modifiability,"you always have a copy of the SciPipe source; code available, we recommend to always include a copy of the SciPipe source; code in your workflow's source code repository. The SciPipe source code is; only around 1500 lines of code, with no external dependencies except Go and; Bash, so this should not increase the size of your repository too much. A simple way to do this, is to use Go's `vendor` tool, which stores a local; copy of the source code of packages used, inside the local directory, in; a sub-directory called ""vendor"". To do this, execute the following command:. ```; go mod vendor; ```. Then, to make sure the code is included in your git history, make sure to add it; to git:. ```bash; git add vendor; git commit -m ""Add vendored version of SciPipe""; ```. ## Run your workflow. Now youa re ready to run the workflow. To run a `.go` file, just use `go run <script-file>`, e.g:; ; ```bash; go run myfirstworkflow.go; ```. ## Some tips about editors. In order to be productive with SciPipe, you will also need a Go editor or IDE; with support for auto-completion, sometimes also called ""intellisense"". We can warmly recommend to use one of these editors, sorted by level of endorsement:. 1. [Visual Studio Code](http://code.visualstudio.com) with the [Go plugin](https://github.com/Microsoft/vscode-go) - If you want a very powerful almost IDE-like editor; 2. The [vim-go](https://github.com/fatih/vim-go) plugin by [Fatih](https://twitter.com/fatih) - if you are a Vim power-user, or need a terminal-only complement to VSCode.; 3. JetBrain's [GoLand IDE](https://www.jetbrains.com/go/), if you are ready to pay for maximum code intelligence in a professional IDE.; 4. [LiteIDE](https://github.com/visualfc/liteide) - if you want a simple, robust and fast standalone Go-editor. There are also popular Go-plugins for [Sublime text](https://www.sublimetext.com), [Atom](https://atom.io/) and [IntelliJ IDEA](https://www.jetbrains.com/idea/), and an upcoming Go IDE from JetBrains,; called; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:4403,plugin,plugin,4403,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,3,['plugin'],"['plugin', 'plugins']"
Performance," // Initialize processes from shell command patterns; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); ```. Here we are initializing two new processes, both of them based on a shell; command, using the `wf.NewProc()` function, which takes a processname, and; a shell command pattern as input. ### The shell command pattern. The shell command patterns, in this case `echo 'Hello ' > {o:out}` and; `echo $(cat {i:in}) World >> {o:out}`, are basically normal bash; shell commands, with the addition of ""placeholders"" for input and output; filenames. Input filename placeholders are on the form `{i:INPORT-NAME}` and the output; filename placeholders are similarly of the form `{o:OUTPORT-NAME}`. These; placeholders will be replaced with actual filenames when the command is; executed later. The reason that it a port-name is used to name them, is that; files will be queued on the channel connecting to the port, and for each set of; files on in-ports, a command will be created and executed whereafter new files; will be pulled in on the out-ports, and so on. ## Formatting output file paths. Now we need to provide some way for scipipe to figure out a suitable file name; for each of the files propagating through the ""network"" of processes. This can; be done using special convenience methods on the processes, starting with; `SetOut...`. There are a few variants, of which two of them are shown here. ```go; // Configure output file path formatters for the processes created above; hello.SetOut(""out"", ""hello.txt""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""); ```. `SetOut` takes a pattern similar to the shell command pattern, with; placeholders, used to define new (shell-based) processes. The available; placeholders that can be used are: `{i:INPORTNAME}`, `{p:PARAMNAME}` and; `{t:TAGNAME}`. An example of a full pattern might be:; `{i:foo}.replace_with_{p:replacement}.txt`, but can also be used for; simple, stat",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:1910,queue,queued,1910,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['queue'],['queued']
Performance,"# Contributing to SciPipe. ## Working with forked repository. Unlike other languages like C++/Python, Go requires modules being referenced,; to be placed in a specific location for the import to work. Forking via GitHub; provides a pull request workflow that is well documented but does not work well; with Go import. Documented here is one approach utilizing go modules. First, fork and clone SciPipe the usual way via GitHub to a local file system,; lets call it `<cloned-scipipe-dir>`. To work on and test the changes made to scipipe in the cloned location, create; a directory for your scipipe workflows, lets call it `<workflow-dev-dir>`. In; that directory, you can create a simple `main.go` file with a `package main` so; that you can run your code that exercises the changes you are making at; `<cloned-scipipe-dir>`. Note that if you were to run your code in `main.go` as-is, it would pull down; the code from the repository and cache them and you will not actually be able; to test any local changes in scipipe. To do so, you need to create a file call; `go.mod`. In `<workflow-dev-dir>` run the following:. ```; go mod init <some package name>; ```. Note: The actual name of the package is not critical. Next, define the modules required by your main.go:. ```; go mod edit -require=github.com/scipipe/scipipe@v0.9.10; ```. Note: A the time of this writing, v0.9.10 is the latest published version, this; will change over time and you need to adapt. Next, replace any reference to the previous URL with reference to the; `<cloned-scipipe-dir>` location:. ```; go mod edit -replace=github.com/scipipe/scipipe@v0.9.10=<cloned-scipipe-dir>; ```. Now when you do:. ```; go run main.go; ```. ... it will not be pulling the code from GitHub but references the code you; have cloned locally. Do your development work and push to your forked repository and do a pull; request for the author to review and optionally merge the contribution.; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md:938,cache,cache,938,docs/contributing.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md,1,['cache'],['cache']
Performance,"# Writing Workflows - An Overview. In order to give an overview of how to write workflows in SciPipe, let's look; at the example workflow used on the front page again:. ```go; package main. import (; // Import SciPipe; ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and a number for max concurrent tasks, so we; // don't overbook our CPU (it is recommended to set it to the number of CPU; // cores of your computer); wf := scipipe.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. Now let's go through the code example in some detail, to see what we are; actually doing. ## Initializing processes. ```go; // Initialize processes from shell command patterns; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); ```. Here we are initializing two new processes, both of them based on a shell; command, using the `wf.NewProc()` function, which takes a processname, and; a shell command pattern as input. ### The shell command pattern. The shell command patterns, in this case `echo 'Hello ' > {o:out}` and; `echo $(cat {i:in}) World >> {o:out}`, are basically normal bash; shell commands, with the addition of ""placeholders"" for input and output; filenames. Input filename placeholders are on the form `{i:INPORT-NAME}` and the output; filename placeholders are similarly of the form `{o:OUTPORT-NAME}`. These; placeholders will be replaced with actual filenames when the command is; executed later. The reason that it a port-name is used to name them, is that; files will be queued on the channel connecting to the port, and for each set of; files on in-ports, a com",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:318,concurren,concurrent,318,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['concurren'],['concurrent']
Performance,"It is important to carefully manage how much resources (CPU and memory) your; workflows are using, so that you don't overbook you compute node(s). In SciPipe you can do that using two settings:. - Max concurrent tasks, which is set on the workflow level, when initiating a new workflow.; - Cores per tasks, that can be set on processes after they are initialized. Max concurrent tasks is a required setting when initializing workflows, while; cores per task can be left to the default, which is 1 core per task. You might want to change this number if for example you have a software that; uses more memory than the available memory on your computer divided by the max; concurrent tasks number you have set. For example, if you have 8GB of free memory, and have set max concurrent tasks; on your workflow to 4, but you have a process whose commandline application; uses not 2GB of memory, but 4GB, then you might want to set cores per tasks for; that process to 2, so that it gets the double amount of memory. In practice, you set cores per task by setting the field `CoresPerTask` on the process struct, after it is initiated. . ## Example. ```go; foo := scipipe.NewProc(""foo"", ""echo foo > {o:foofile}""); foo.CoresPerTask = 2; ```; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/constrain_resource_usage.md:201,concurren,concurrent,201,docs/howtos/constrain_resource_usage.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/constrain_resource_usage.md,4,['concurren'],['concurrent']
Performance,"lo*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly as a proper; Hello World example should :). Now, these were a little long and cumbersome filenames, weren't they? SciPipe; gives you very good control over how to name your files, if you don't want to; rely on the automatic file naming. For example, we could set the first filename; to a static one, and then use the first name as a basis for the file name for; the second process, like so:. ```go; package main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. In the `{i:in...` part, we are re-using the file path from the file received on; the in-port named 'in', and then running a Bash-style trim-from-end command on; it to remove the `.txt` extension. Now, if we run this, the file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"":",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:8424,concurren,concurrent,8424,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['concurren'],['concurrent']
Performance,"some methods bound to them, most importantly the `From()`; method (for in-ports. Out-ports have a corresponding `To()` method), which; takes another port, and connects to it, by stitching a channel between the; ports. On `Process` objects, there is also a third port type, `InParamPort` (and the; accompanying `OutParamPort`), which is used when it is needed to send a; stream of parameter values (in string format) to be supplied to as arguments; to shell commands. * See [GoDoc for the InPort struct type](https://godoc.org/github.com/scipipe/scipipe#InPort); * See [GoDoc for the OutPort struct type](https://godoc.org/github.com/scipipe/scipipe#OutPort); * See [GoDoc for the InParamPort struct type](https://godoc.org/github.com/scipipe/scipipe#InParamPort); * See [GoDoc for the OutParamPort struct type](https://godoc.org/github.com/scipipe/scipipe#OutParamPort). ## Channels. Ports in SciPipe are connected via channels. Channels are [plain Go channels](https://tour.golang.org/concurrency/2); and nothing more. Most of the time, one will not need to deal with the channels; directly though, since the port objects (see separate section for ports) have; all the logic to connect to other ports via channels, but it can be good to; know that they are there, in case you need to do something more advanced. ## Workflow. The [`Workflow`](https://godoc.org/github.com/scipipe/scipipe#Workflow); is a special object in SciPipe, that just takes care of running a set of; components making up a workflow. There is not much to say about the workflow component, other than that it is; created with `scipipe.NewWorkflow(workflowName, maxConcurrentTasks)`, that all processes need to be added; to it with `wf.AddProc(proc)` while the ""last"", or ""driving"" process needs to be specified with `wf.SetDriver(driverProcess)`, and that it should be run with; `wf.Run()`. But this is already covered in the other examples and; tutorials. * See [GoDoc for Workflow](https://godoc.org/github.com/scipipe/scipipe#W",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md:4126,concurren,concurrency,4126,docs/basic_concepts.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md,1,['concurren'],['concurrency']
Performance,"tions. - There are still a number of missing good-to-have features for workflow; design. See the [issue tracker](https://github.com/scipipe/scipipe/issues); for details.; - There is not (yet) support for the [Common Workflow Language](http://common-workflow-language.github.io). ## Installing. For full installation instructions, see the [intallation page](/install).; For quick getting started steps, you can do:. 1. [Download](https://golang.org/dl/) and [install](https://golang.org/doc/install) Go; 2. Run the following command, to install the scipipe Go library (don't miss the; trailing dots!), and create a Go module for your script:. ```bash; go install github.com/scipipe/scipipe/...@latest; go mod init myfirstworkflow-module; ```. ## Hello World example. Let's look at an example workflow to get a feel for what writing workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:4",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:5938,concurren,concurrent,5938,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['concurren'],['concurrent']
Safety,"; <img src=""images/fbp_factory.png"" style=""width: 30%; float: right; margin: 1em;"">; <h1 style=""margin-bottom: 0;""><img src=""images/scipipe_logo_bluegrey_horiz.svg"" style=""width: 240px; margin-left: -10px; margin-bottom: 0;"" alt=""SciPipe""></h1>. <big>Robust, flexible and resource-efficient pipelines using Go and the commandline</big>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. <strong><small>Project links: [GitHub repo](http://github.com/scipipe/scipipe) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</small></strong>. [![Build Status](https://img.shields.io/circleci/project/github/scipipe/scipipe.svg)](https://circleci.com/gh/scipipe/scipipe); [![Test Coverage](https://img.shields.io/codecov/c/github/scipipe/scipipe.svg)](https://codecov.io/gh/scipipe/scipipe); [![Codebeat Grade](https://codebeat.co/badges/96e93624-2ac8-42c9-9e94-2d6e5325d8ff)](https://codebeat.co/projects/github-com-scipipe-scipipe-master); [![Go Report Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipip",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:871,avoid,avoid,871,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['avoid'],['avoid']
Safety,"ial convenience methods on the processes, starting with; `SetOut...`. There are a few variants, of which two of them are shown here. ```go; // Configure output file path formatters for the processes created above; hello.SetOut(""out"", ""hello.txt""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""); ```. `SetOut` takes a pattern similar to the shell command pattern, with; placeholders, used to define new (shell-based) processes. The available; placeholders that can be used are: `{i:INPORTNAME}`, `{p:PARAMNAME}` and; `{t:TAGNAME}`. An example of a full pattern might be:; `{i:foo}.replace_with_{p:replacement}.txt`, but can also be used for; simple, static paths, like in the example above. The placeholders can also take certain extra ""modifiers"", separated from the; placeholder name by pipe characters, and of which the one used above is; probably the most important one: `%STRING`. It will remove the specified; string from the _end_ of the path. This is useful when we want to avoid; getting too long paths when re-using previous processes' paths. With the; example above, our input file named `hello.txt` will be converted into; `hello_world.txt` by this path pattern. ### Available path modifiers. The currently available path modifiers are:. - `basename` - Removes all folders from the path, leaving only the filename.; - Example: `{i:infile|basename}`, if `infile` has the path `data/file.txt`, will convert it to just `file.txt`.; - `dirname` - Removes the ending file name part from the path, leaving only the folder path.; - Example: `{i:infile|dirname}/newfile.txt`, if `infile` has the path `data/file.txt`, will convert it to `data/newfile.txt`.; - `%.<extension>` - Removes the file extension `<extension>`.; - Example: `{i:infile|%.txt}`, if `infile` has the path `file.txt`, will convert it to just `file`.; - `s/<search>/<replacement>/` - Will do a simple search and replace, from `<search>` to `<replacement>`.; - Example: `{i:infile|s/file/my_file/}`, if `infile` has the path `fi",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:3296,avoid,avoid,3296,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['avoid'],['avoid']
Safety,"omplicated way to format paths, but it can; be useful for example when needing to incorporate parameter values into file; names. ### A caveat about using variables in anonymous functions. Note that when using anonymous functions, you have to be careful to not re-use; the same variable (even with different values) in multiple functions, due to; the [subtle ways in which closures work in Go](https://golang.org/doc/faq#closures_and_goroutines). For example, if you create multiple new processes with separate formatting; functions in a loop, that uses a shared variable, like this:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. ... then, both functions will return ""bar.txt"", since both funcs were pointing to; the same variable (""var""), which had the value ""bar"" at the end of the loop. To avoid this situation, you can do one of two things, of which the latter is; generally recommended:. **1.** Create a new copy of the variable, inside the anonymous function:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); val := val // <- Here we create a new copy of the variable; proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. **2.** ... or, better, access the parameter value via the task which the path function receives:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:6038,avoid,avoid,6038,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['avoid'],['avoid']
Safety,"rt Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipipe); [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1157941.svg)](https://doi.org/10.5281/zenodo.1157941). <strong>Project links: [Documentation & Main Website](http://scipipe.org) | [Issue Tracker](https://github.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</strong>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. ## Project updates. - <strong>Jan 2020: New screencast:</strong> <a href=""https://www.youtube.com/watch?v=hi0Uqwddrtg"" target=""_blank"">""Hello World"" scientific workflow in SciPipe</a>; - <strong>May 2019: The SciPipe paper published open access in GigaScience:</strong> <a href=""https://doi.org/10.1093/gigascience/giz044"" target=""_blank"">SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines</a>; - <strong>Nov 2018: Scientific study using SciPipe:</strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Predi",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:1786,avoid,avoid,1786,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['avoid'],['avoid']
Security," ID in a generic port map, like the `In()` and `Out()` methods on; `Process` processes. This is so that the methods can show up in the; auto-completion / intellisense function in code editors removing the need to; look up the name of the ports manually in the library code all the time. ## How to create re-usable components in SciPipe. Process processes created with the `scipipe.NewProc()` command, can be turned; into such ""re-usable"" component by using a wrapping strategy, that is; demonstrated in an [example on GitHub](https://github.com/scipipe/scipipe/blob/master/examples/wrapper_procs/wrap.go). The idea is to create a new struct type for the re-usable component, and; then, in the factory method for the process, create an ""inner"" process of; type Process, using `NewProc()` as in the normal case, embedding that in the; outer struct and then adding statically defined accessor methods for each of; the ports in the inner process, with a similar name. So, if the inner process; has an outport named ""foo"", you would define an accessor method named; `myproc.OutFoo()` that returns this port from the inner process. Let's look at a code example of how this works, by creating a process that just; writes ""hi"" to a file:. ```go; type HiWriter struct {; // Embedd a Process struct; 	*sci.Process; }. func NewHiWriter() *HiWriter {; // Initialize a normal ""Process"" to use as an ""inner"" process; 	innerHiWriter := sci.NewProc(""hiwriter"", ""echo hi > {o:hifile}""); 	innerHiWriter.SetOut(""hifile"", ""hi.txt""). // Create a new HiWriter process with the inner process embedded into it; 	return &HiWriter{innerHiWriter}; }. // OutHiFile provides a static version of the ""hifile"" port in the inner; // (embedded) process; func (p *HiWriter) OutHiFile() *sci.OutPort {; // Return the inner process' port named ""hifile""; return p.Out(""hifile""); }; ```. ## See also. - [A full, working, workflow example using this trategy](https://github.com/scipipe/scipipe/blob/master/examples/wrapper_procs/wrap.go); ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md:1346,access,accessor,1346,docs/howtos/reusable_components.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md,1,['access'],['accessor']
Security," and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly as a proper; Hello World example should :). Now, these were a little long and cumbersome filenames, weren't they? SciPipe; gives you very good control over how to name your files, if you don't want to; rely on the automatic file naming. For example, we could set the first filename; to a static one, and then use the first name as a basis for the file name for; the second process, like so:. ```go; package main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf :=",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:7444,audit,audit,7444,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['audit'],['audit']
Security," paths are taking a `Task` as; input, even though these functions are saved on the process object. To understand the difference between processes and tasks, it is helpful to; remember that processes are long-running, and typically fixed during the course; of a workflow, while tasks are transient objects, created temporarily as a; container for all data and code needed for each execution of a concrete shell; command. * See [GoDoc for Task](https://godoc.org/github.com/scipipe/scipipe#Task). ## Ports. Central to the way data dependencies are defined in SciPipe, is ports. Ports; are fields on processes, which are connected to other ports via channels (see; separate section on this page). In SciPipe, each port must have a unique name within its process (there can't; be an in-port and out-port named the same), and this name will be used in shell; command patterns, when connecting dependencies / dataflow networks, and when; configuring file naming strategies. In `Process` objects, in-ports are are accessed with; `myProcess.In(""my_port"")`, and out-ports are similarly accessed with; `myProcess.Out(""my_other_port"")`. They are of type; [`InPort`](https://godoc.org/github.com/scipipe/scipipe#InPort) and; [`OutPort`](https://godoc.org/github.com/scipipe/scipipe#OutPort) respectively. Some pre-made components might have ports bound to custom field names though,; such as `myFastaReader.InFastaFile`, or `myZipComponent.OutZipFile`. Port objects have some methods bound to them, most importantly the `From()`; method (for in-ports. Out-ports have a corresponding `To()` method), which; takes another port, and connects to it, by stitching a channel between the; ports. On `Process` objects, there is also a third port type, `InParamPort` (and the; accompanying `OutParamPort`), which is used when it is needed to send a; stream of parameter values (in string format) to be supplied to as arguments; to shell commands. * See [GoDoc for the InPort struct type](https://godoc.org/github.com/scip",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md:2688,access,accessed,2688,docs/basic_concepts.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md,1,['access'],['accessed']
Security,"## Video tutorials covering SciPipe usage. - [Screencast: ""Hello World"" scientific workflow in SciPipe](https://www.youtube.com/watch?v=hi0Uqwddrtg). <iframe width=""560"" height=""315"" src=""https://www.youtube.com/embed/hi0Uqwddrtg"" frameborder=""0"" allow=""accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/videos.md:279,encrypt,encrypted-media,279,docs/videos.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/videos.md,1,['encrypt'],['encrypted-media']
Security,"/strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a>; </div>. ## Introduction. SciPipe is a library for writing [Scientific Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system),; sometimes also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for problems in bioinformatics and; cheminformatics, but works equally well for any problem involving pipelines of; commandline applications. **Project status:** SciPipe pretty stabl",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:3907,audit,audit,3907,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['audit'],['audit']
Security,"; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. In the `{i:in...` part, we are re-using the file path from the file received on; the in-port named 'in', and then running a Bash-style trim-from-end command on; it to remove the `.txt` extension. Now, if we run this, the file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; ""hello.txt"": {; ""ID"": ""w4oeiii9h5j7sckq7aqq"",; ""ProcessName"": ""hello"",; ""Command"": ""echo 'Hello ' \u003e hello.txt.tmp/hello.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.950032676+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.95468214+02:00"",; ""ExecTimeNS"": 4000000,; ""Upstream"": {}; }; }; ```. Each such audit-file contains a hierarchic JSON-representation of the full; workflow path that was executed in order to produce this file. On the first; level is the command that directly produced the corresponding file, and then,; indexed by their filenames, under ""Upstream"", there is a similar chunk; describing how all of its input files were ge",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:9330,audit,audit,9330,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['audit'],['audit']
Security,"For example, if you create multiple new processes with separate formatting; functions in a loop, that uses a shared variable, like this:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. ... then, both functions will return ""bar.txt"", since both funcs were pointing to; the same variable (""var""), which had the value ""bar"" at the end of the loop. To avoid this situation, you can do one of two things, of which the latter is; generally recommended:. **1.** Create a new copy of the variable, inside the anonymous function:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); val := val // <- Here we create a new copy of the variable; proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return val + "".txt""; }); }; ```. **2.** ... or, better, access the parameter value via the task which the path function receives:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipeline to the workflow, so that the workflow can pull on this port; (technically pulling on a Go channel), in order to drive the workflow. ```go; // Connect network; world.In(""in"").From(helloWriter.Out(""out"")); ```. ## Running the pipeline. So, the final part probably explains itself, but the workflow component is a; relatively simple one that will start e",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:6501,access,access,6501,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['access'],['access']
Security,"SciPipe can stream the output via UNIX [named pipes (or ""FIFO files"")](https://en.wikipedia.org/wiki/Named_pipe). Streaming can be turned on, on out-ports when creating processes with; `NewProc()`, by using `{os:outport_name}` as placeholder, instead of the; normal `{o:outport_name}` (note the addisional ""s""). You can see how this is used in [this example on GitHub](https://github.com/scipipe/scipipe/blob/master/examples/fifo/fifo.go#L14). Note that when streaming, you will not get an output file for the output in; question. Note also that you still have to provide a path formatting strategy (via some; of the `Process.SetOut...()` functions, or by manually adding one to; `Process.PathFuncs`. This is because a uniqe file name is needed in; order to create any audit files, as well as to give a unique name for the named; pipe. ## See also. - [Streaming example on GitHub](https://github.com/scipipe/scipipe/blob/master/examples/fifo/fifo.go#L14).; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/streaming.md:769,audit,audit,769,docs/howtos/streaming.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/streaming.md,1,['audit'],['audit']
Security,"[SciPipe 0.8.0](https://github.com/scipipe/scipipe/releases/tag/v0.8.0); introduced experimental support for converting audit logs (those; `.audit.json` files produced to accompany all output files from SciPipe); into other formats, such as HTML, TeX (for further conversion to PDF) or; even executable Bash-scripts. Here's how to do it. ## Convert audit log to HTML. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2html myfile.audit.json; ```. This will produce an HTML file named `myfile.audit.html`, which you can; view in a web browser. ## Convert audit log to TeX. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2tex myfile.audit.json; ```. This will produce an HTML file named `myfile.audit.tex`, which you can; either edit manually, or convert directly to PDF using the `pdflatex`; command like so:. ```bash; pdflatex myfile.audit.tex; ```. Converting to PDF requires that you have a TeX installation on your system.; On Ubuntu, you can install the base package or TeX live with `sudo apt-get; install texlive-base`. ## Convert audit log to Bash. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2bash myfile.audit.json; ```. This will produce a Bash-file named `myfile.audit.sh`, which you can; execute like so:. ```bash; sh myfile.audit.sh; ```. ... in order to reproduce the file again from scratch, if it is removed,; given that you have all the dependent files and tools installed on your; system.",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/convert_audit_logs.md:120,audit,audit,120,docs/howtos/convert_audit_logs.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/convert_audit_logs.md,19,['audit'],['audit']
Security,"ackage main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. In the `{i:in...` part, we are re-using the file path from the file received on; the in-port named 'in', and then running a Bash-style trim-from-end command on; it to remove the `.txt` extension. Now, if we run this, the file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; ""hello.txt"": {; ""ID"": ""w4oeiii9h5j7sckq7aqq"",; ""ProcessName"": ""hello"",; ""Command"": ""echo 'Hello ' \u003e hello.txt.tmp/hello.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.950032676+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.95468214+02:00"",; ""ExecTimeNS"": 4000000,; ""Upstream"": {}; }; }; ```. Each such audit-file contains a hierarchic JSON-representation of the full; workflow path that was executed in order to produce this file. On the first; level is the command that directly produced the corresponding file, and then,; indexed by their filenames, under ""Upstream"", the",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:9278,audit,audit,9278,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['audit'],['audit']
Security,"ckholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a. ## Introduction. <img src=""docs/images/fbp_factory.png"" align=""right"">. SciPipe is a library for writing [Scientific; Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system), sometimes; also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for problems in bioinformatics and; cheminformatics, but works equally well for any problem involving pipelines of; commandline applications. **Project status:** SciPipe pretty stabl",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:3730,audit,audit,3730,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['audit'],['audit']
Security,"d and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly as a proper; Hello World example should :). Now, these were a little long and cumbersome filenames, weren't they? SciPipe; gives you very good control over how to name your files, if you don't want to; rely on the automatic file naming. For example, we could set the first filename; to a static one, and then use the first name as a basis for the file name for; the second process, like so:. ```go; package main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewPro",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:7639,audit,audit,7639,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['audit'],['audit']
Security,"e saved on the process object. To understand the difference between processes and tasks, it is helpful to; remember that processes are long-running, and typically fixed during the course; of a workflow, while tasks are transient objects, created temporarily as a; container for all data and code needed for each execution of a concrete shell; command. * See [GoDoc for Task](https://godoc.org/github.com/scipipe/scipipe#Task). ## Ports. Central to the way data dependencies are defined in SciPipe, is ports. Ports; are fields on processes, which are connected to other ports via channels (see; separate section on this page). In SciPipe, each port must have a unique name within its process (there can't; be an in-port and out-port named the same), and this name will be used in shell; command patterns, when connecting dependencies / dataflow networks, and when; configuring file naming strategies. In `Process` objects, in-ports are are accessed with; `myProcess.In(""my_port"")`, and out-ports are similarly accessed with; `myProcess.Out(""my_other_port"")`. They are of type; [`InPort`](https://godoc.org/github.com/scipipe/scipipe#InPort) and; [`OutPort`](https://godoc.org/github.com/scipipe/scipipe#OutPort) respectively. Some pre-made components might have ports bound to custom field names though,; such as `myFastaReader.InFastaFile`, or `myZipComponent.OutZipFile`. Port objects have some methods bound to them, most importantly the `From()`; method (for in-ports. Out-ports have a corresponding `To()` method), which; takes another port, and connects to it, by stitching a channel between the; ports. On `Process` objects, there is also a third port type, `InParamPort` (and the; accompanying `OutParamPort`), which is used when it is needed to send a; stream of parameter values (in string format) to be supplied to as arguments; to shell commands. * See [GoDoc for the InPort struct type](https://godoc.org/github.com/scipipe/scipipe#InPort); * See [GoDoc for the OutPort struct type](https",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md:2758,access,accessed,2758,docs/basic_concepts.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md,1,['access'],['accessed']
Security,"eleases/tag/v0.9.1); and later. ## Example. Given that you have a set of files:. ```; letterfile_a.txt; letterfile_b.txt; numberfile_1.txt; numberfile_2.txt; numberfile_3.txt; ```. ... and you want to create all combinations of the `letter*` files and the `number*`; files, you can do it as follows:. ```go; package main. import (; ""github.com/scipipe/scipipe""; ""github.com/scipipe/scipipe/components""; ). func main() {; wf := scipipe.NewWorkflow(""wf"", 4). letterGlobber := components.NewFileGlobber(wf, ""letter_globber"", ""letterfile_*.txt""); numberGlobber := components.NewFileGlobber(wf, ""number_globber"", ""numberfile_*.txt""). fileCombiner := components.NewFileCombinator(wf, ""file_combiner""); fileCombiner.In(""letters"").From(letterGlobber.Out()); fileCombiner.In(""numbers"").From(numberGlobber.Out()). catenator := wf.NewProc(""catenator"", ""cat {i:letters} {i:numbers} > {o:combined}""); catenator.In(""letters"").From(fileCombiner.Out(""letters"")); catenator.In(""numbers"").From(fileCombiner.Out(""numbers"")); catenator.SetOut(""combined"", ""{i:letters|basename|%.txt}.{i:numbers|basename|%.txt}.combined.txt""). wf.Run(); }; ```. Note that when accessing an in-port on the FileCombinator with the `In(PORTNAME)` method, this port; will be created automatically, together with a corresponding out-port which can be accessed with the; same name, `Out(PORTNAME)`, as can be seen when we connect the fileCombinator to the catenator process; further down in the code. The program above, if put in a `.go` file and run with `go run file.go`, will generate the following; files (excluding the accompanying .audit.json files):. ```; letterfile_b.txt; letterfile_a.txt; numberfile_3.txt; numberfile_2.txt; numberfile_1.txt; letterfile_a.numberfile_2.combined.txt; letterfile_a.numberfile_1.combined.txt; letterfile_a.numberfile_3.combined.txt; letterfile_b.numberfile_2.combined.txt; letterfile_b.numberfile_1.combined.txt; letterfile_b.numberfile_3.combined.txt; ```. As you can see, all the combinations of the ; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/file_combinations.md:1765,access,accessing,1765,docs/howtos/file_combinations.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/file_combinations.md,3,"['access', 'audit']","['accessed', 'accessing', 'audit']"
Security,"for; the second process, like so:. ```go; package main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. In the `{i:in...` part, we are re-using the file path from the file received on; the in-port named 'in', and then running a Bash-style trim-from-end command on; it to remove the `.txt` extension. Now, if we run this, the file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; ""hello.txt"": {; ""ID"": ""w4oeiii9h5j7sckq7aqq"",; ""ProcessName"": ""hello"",; ""Command"": ""echo 'Hello ' \u003e hello.txt.tmp/hello.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.950032676+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.95468214+02:00"",; ""ExecTimeNS"": 4000000,; ""Upstream"": {}; }; }; ```. Each such audit-file contains a hierarchic JSON-representation of the full; workflow path that was executed in order to produce this file. On the first; level is the command that directly produced the corresponding file, and then,; indexe",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:9220,audit,audit,9220,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['audit'],['audit']
Security,"he file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; ""hello.txt"": {; ""ID"": ""w4oeiii9h5j7sckq7aqq"",; ""ProcessName"": ""hello"",; ""Command"": ""echo 'Hello ' \u003e hello.txt.tmp/hello.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.950032676+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.95468214+02:00"",; ""ExecTimeNS"": 4000000,; ""Upstream"": {}; }; }; ```. Each such audit-file contains a hierarchic JSON-representation of the full; workflow path that was executed in order to produce this file. On the first; level is the command that directly produced the corresponding file, and then,; indexed by their filenames, under ""Upstream"", there is a similar chunk; describing how all of its input files were generated. This process will be; repeated in a recursive way for large workflows, so that, for each file; generated by the workflow, there is always a full, hierarchic, history of all; the commands run - with their associated metadata - to produce that file. You can find many more examples in the [examples folder](https://github.com/scipipe/scipipe/tree/master/examples) in the GitHub repo. For more information about how to write workflows using SciPipe, and much more,; see [SciPipe website (scipipe.org)](http://scipipe.org)!. ## More material on SciPipe. - See [a poster on SciPipe](http://dx.doi.org/10.13140/RG.2.2.34414.61760), presented at the [e-Science Academy in Lund, on Oct 12-13 2016](essenceofescience.se/",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:9994,audit,audit-file,9994,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['audit'],['audit-file']
Security,"he file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; ""hello.txt"": {; ""ID"": ""w4oeiii9h5j7sckq7aqq"",; ""ProcessName"": ""hello"",; ""Command"": ""echo 'Hello ' \u003e hello.txt.tmp/hello.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.950032676+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.95468214+02:00"",; ""ExecTimeNS"": 4000000,; ""Upstream"": {}; }; }; ```. Each such audit-file contains a hierarchic JSON-representation of the full; workflow path that was executed in order to produce this file. On the first; level is the command that directly produced the corresponding file, and then,; indexed by their filenames, under ""Upstream"", there is a similar chunk; describing how all of its input files were generated. This process will be; repeated in a recursive way for large workflows, so that, for each file; generated by the workflow, there is always a full, hierarchic, history of all; the commands run - with their associated metadata - to produce that file. You can find many more examples in the [examples folder](https://github.com/scipipe/scipipe/tree/master/examples) in the GitHub repo. For more information about how to write workflows using SciPipe, use the menu; to the left, to browse the various topics!. ## Citing SciPipe. If you use SciPipe in academic or scholarly work, please cite the following paper as source:. Lampa S, Dahlö M, Alvarsson J, Spjuth O. SciPipe: A workflow library for agile development of",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:10171,audit,audit-file,10171,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['audit'],['audit-file']
Security,"ilename; to a static one, and then use the first name as a basis for the file name for; the second process, like so:. ```go; package main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. In the `{i:in...` part, we are re-using the file path from the file received on; the in-port named 'in', and then running a Bash-style trim-from-end command on; it to remove the `.txt` extension. Now, if we run this, the file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; ""hello.txt"": {; ""ID"": ""w4oeiii9h5j7sckq7aqq"",; ""ProcessName"": ""hello"",; ""Command"": ""echo 'Hello ' \u003e hello.txt.tmp/hello.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.950032676+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.95468214+02:00"",; ""ExecTimeNS"": 4000000,; ""Upstream"": {}; }; }; ```. Each such audit-file contains a hierarchic JSON-representation of the full; workflow path that was executed in order to produce this file. On the first; l",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:9135,audit,audit,9135,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['audit'],['audit']
Security,"ow:. ```go; package main. import (; 	""github.com/scipipe/scipipe""; ). const dna = ""AAAGCCCGTGGGGGACCTGTTC"". func main() {; 	// Initialize workflow, using max 4 CPU cores; 	wf := scipipe.NewWorkflow(""DNA Base Complement Workflow"", 4). 	// Initialize processes based on shell commands:. 	// makeDNA writes a DNA string to a file; 	makeDNA := wf.NewProc(""Make DNA"", ""echo ""+dna+"" > {o:dna}""); 	makeDNA.SetOut(""dna"", ""dna.txt""). 	// complmt computes the base complement of a DNA string; 	complmt := wf.NewProc(""Base Complement"", ""cat {i:in} | tr ATCG TAGC > {o:compl}""); 	complmt.SetOut(""compl"", ""{i:in|%.txt}.compl.txt""). 	// reverse reverses the input DNA string; 	reverse := wf.NewProc(""Reverse"", ""cat {i:in} | rev > {o:rev}""); 	reverse.SetOut(""rev"", ""{i:in|%.txt}.rev.txt""). 	// Connect data dependencies between out- and in-ports; 	complmt.In(""in"").From(makeDNA.Out(""dna"")); 	reverse.In(""in"").From(complmt.Out(""compl"")). 	// Run the workflow; 	wf.Run(); }; ```. On line 4, the SciPipe library is imported, to be later accessed as scipipe. On; line 7, a short string of DNA is defined. On line 9-33, the full workflow is; implemented in the program’s main() function, meaning that it will be executed; when the resulting program is executed. On line 11, a new workflow object (or; “struct” in Go terms) is initiated with a name and the maximum number of cores; to use. On lines 15-25, the workflow components, or processes, are initiated,; each with a name and a shell command pattern. Input file names are defined with; a placeholder on the form {i:INPORTNAME} and outputs on the form; {o:OUTPORTNAME}. The port-name will be used later to access the corresponding; ports for setting up data dependencies. On line 16, a component that writes the; previously defined DNA string to a file is initiated, and on line 17, the file; path pattern for the out-port dna is defined (in this case a static file name).; On line 20, a component that translates each DNA base to its complementary; counterpart is in",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md:1302,access,accessed,1302,examples/revcomplement/README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md,1,['access'],['accessed']
Security,"pe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly as a proper; Hello World example should :). Now, these were a little long and cumbersome filenames, weren't they? SciPipe; gives you very good control over how to name your files, if you don't want to; rely on the automatic file naming. For example, we could set the first filename; to a static one, and then use the first name as a basis for the file name for; the second process, like so:. ```go; package main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set ou",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:7513,audit,audit,7513,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['audit'],['audit']
Security,"sis for the file name for; the second process, like so:. ```go; package main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. In the `{i:in...` part, we are re-using the file path from the file received on; the in-port named 'in', and then running a Bash-style trim-from-end command on; it to remove the `.txt` extension. Now, if we run this, the file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; ""hello.txt"": {; ""ID"": ""w4oeiii9h5j7sckq7aqq"",; ""ProcessName"": ""hello"",; ""Command"": ""echo 'Hello ' \u003e hello.txt.tmp/hello.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.950032676+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.95468214+02:00"",; ""ExecTimeNS"": 4000000,; ""Upstream"": {}; }; }; ```. Each such audit-file contains a hierarchic JSON-representation of the full; workflow path that was executed in order to produce this file. On the first; level is the command that directly produced the corresponding ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:9196,audit,audit,9196,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['audit'],['audit']
Security,"stored in a Go; package and imported and used later. In order for components in such a library to be easy to use, the ports need; to be static methods bound to the process struct, rather than just stored by; a string ID in a generic port map, like the `In()` and `Out()` methods on; `Process` processes. This is so that the methods can show up in the; auto-completion / intellisense function in code editors removing the need to; look up the name of the ports manually in the library code all the time. ## How to create re-usable components in SciPipe. Process processes created with the `scipipe.NewProc()` command, can be turned; into such ""re-usable"" component by using a wrapping strategy, that is; demonstrated in an [example on GitHub](https://github.com/scipipe/scipipe/blob/master/examples/wrapper_procs/wrap.go). The idea is to create a new struct type for the re-usable component, and; then, in the factory method for the process, create an ""inner"" process of; type Process, using `NewProc()` as in the normal case, embedding that in the; outer struct and then adding statically defined accessor methods for each of; the ports in the inner process, with a similar name. So, if the inner process; has an outport named ""foo"", you would define an accessor method named; `myproc.OutFoo()` that returns this port from the inner process. Let's look at a code example of how this works, by creating a process that just; writes ""hi"" to a file:. ```go; type HiWriter struct {; // Embedd a Process struct; 	*sci.Process; }. func NewHiWriter() *HiWriter {; // Initialize a normal ""Process"" to use as an ""inner"" process; 	innerHiWriter := sci.NewProc(""hiwriter"", ""echo hi > {o:hifile}""); 	innerHiWriter.SetOut(""hifile"", ""hi.txt""). // Create a new HiWriter process with the inner process embedded into it; 	return &HiWriter{innerHiWriter}; }. // OutHiFile provides a static version of the ""hifile"" port in the inner; // (embedded) process; func (p *HiWriter) OutHiFile() *sci.OutPort {; // Return the in",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md:1189,access,accessor,1189,docs/howtos/reusable_components.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md,1,['access'],['accessor']
Security,"string; 	reverse := wf.NewProc(""Reverse"", ""cat {i:in} | rev > {o:rev}""); 	reverse.SetOut(""rev"", ""{i:in|%.txt}.rev.txt""). 	// Connect data dependencies between out- and in-ports; 	complmt.In(""in"").From(makeDNA.Out(""dna"")); 	reverse.In(""in"").From(complmt.Out(""compl"")). 	// Run the workflow; 	wf.Run(); }; ```. On line 4, the SciPipe library is imported, to be later accessed as scipipe. On; line 7, a short string of DNA is defined. On line 9-33, the full workflow is; implemented in the program’s main() function, meaning that it will be executed; when the resulting program is executed. On line 11, a new workflow object (or; “struct” in Go terms) is initiated with a name and the maximum number of cores; to use. On lines 15-25, the workflow components, or processes, are initiated,; each with a name and a shell command pattern. Input file names are defined with; a placeholder on the form {i:INPORTNAME} and outputs on the form; {o:OUTPORTNAME}. The port-name will be used later to access the corresponding; ports for setting up data dependencies. On line 16, a component that writes the; previously defined DNA string to a file is initiated, and on line 17, the file; path pattern for the out-port dna is defined (in this case a static file name).; On line 20, a component that translates each DNA base to its complementary; counterpart is initiated. On line 21, the file path pattern for its only; out-port is defined. In this case, reusing the file path of the file it will; receive on its in-port named in, thus the {i:in} part. The %.txt part removes; .txt from the input path. On line 24, a component that will reverse the DNA; string is initiated. On lines 27-29, data dependencies are defined via the in-; and out-ports defined earlier as part of the shell command patterns. On line; 32, the workflow is being run. ## How to run. To run the example, given that you have the [Go toolchain](https://golang.org); installed (a vertion from at least 1.9), you can run it like this:. ```bash; $",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md:1923,access,access,1923,examples/revcomplement/README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md,1,['access'],['access']
Security,"ub.com/scipipe/scipipe/issues) | [Chat](https://gitter.im/scipipe/scipipe)</strong>. ## Why SciPipe?. - **Intuitive:** SciPipe works by flowing data through a network of channels; and processes; - **Flexible:** Wrapped command-line programs can be combined with processes in; Go; - **Convenient:** Full control over how your files are named; - **Efficient:** Workflows are compiled to binary code that run fast; - **Parallel:** Pipeline paralellism between processes as well as task; parallelism for multiple inputs, making efficient use of multiple CPU cores; - **Supports streaming:** Stream data between programs to avoid wasting disk space; - **Easy to debug:** Use available Go debugging tools or just `println()`; - **Portable:** Distribute workflows as Go code or as self-contained executable; files. ## Project updates. - <strong>Jan 2020: New screencast:</strong> <a href=""https://www.youtube.com/watch?v=hi0Uqwddrtg"" target=""_blank"">""Hello World"" scientific workflow in SciPipe</a>; - <strong>May 2019: The SciPipe paper published open access in GigaScience:</strong> <a href=""https://doi.org/10.1093/gigascience/giz044"" target=""_blank"">SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines</a>; - <strong>Nov 2018: Scientific study using SciPipe:</strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; - <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; - <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a. ## Introduction",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:2213,access,access,2213,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['access'],['access']
Security,"verage](https://img.shields.io/codecov/c/github/scipipe/scipipe.svg)](https://codecov.io/gh/scipipe/scipipe); [![Codebeat Grade](https://codebeat.co/badges/96e93624-2ac8-42c9-9e94-2d6e5325d8ff)](https://codebeat.co/projects/github-com-scipipe-scipipe-master); [![Go Report Card](https://goreportcard.com/badge/github.com/scipipe/scipipe)](https://goreportcard.com/report/github.com/scipipe/scipipe); [![GoDoc](https://godoc.org/github.com/scipipe/scipipe?status.svg)](https://godoc.org/github.com/scipipe/scipipe); [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/scipipe/scipipe); [![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1157941.svg)](https://doi.org/10.5281/zenodo.1157941). <div style=""width:37%; float: right; font-size: 0.8em; padding: 1em; margin: 0 0 1em 1em;"">; <h4>Project updates</h4>; <strong>Jan 2020: New screencast:</strong> <a href=""https://www.youtube.com/watch?v=hi0Uqwddrtg"" target=""_blank"">""Hello World"" scientific workflow in SciPipe</a>; <strong>May 2019: The SciPipe paper published open access in GigaScience:</strong> <a href=""https://doi.org/10.1093/gigascience/giz044"" target=""_blank"">SciPipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines</a>; <strong>Nov 2018: Scientific study using SciPipe:</strong> <a href=""https://doi.org/10.3389/fphar.2018.01256"" target=""_blank"">Predicting off-target binding profiles with confidence using Conformal Prediction</a>; <strong>Slides:</strong> <a href=""https://pharmb.io/blog/saml-gostockholm2018/"">Presentation on SciPipe and more at Go Stockholm Conference</a>; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/provenance-reports-in-scientific-workflows"">Provenance reports in Scientific Workflows</a> - going into details about how SciPipe is addressing provenance.; <strong>Blog post:</strong> <a href=""http://bionics.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a>; </div>. ## Introduction",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:2445,access,access,2445,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['access'],['access']
Testability," Ubuntu it can be installed with the command: `sudo apt-get install graphviz`). ## How to plot graphs. To write a .dot file in SciPipe, include a line like follows, in your workflow; definition, provided that you have initiated the variable `wf` with a workflow; struct:. ```go; func main() {; wf := scipipe.NewWorkflow(""my workflow"", 4); // Workflow code here; wf.PlotGraph(""my_workflow_graph.dot"") // <-- SEE THIS LINE!; wf.Run(); }; ```. If you want to also convert the dot file to PDF in one go, instead change the; next last line to:. ```go; wf.PlotGraphPDF(""my_workflow_graph.dot""); ```. ## How to plot graphs conditionally based on a flag. Now, you might not want to generate a new plot every time you run your workflow; (although, perhaps you would? ... checking in a .dot version of your workflow; could in fact be a great way to keep a more readable version of your workflow; at hand ... but anyhow), you could make the plotting optional, based on a flag.; This is something we've found ourselves doing quite often at pharmb.io. This; could be done as follows (more complete code example):. ```go; package main. import (; ""flag""; ""github.com/scipipe/scipipe""; ). var (; plotGraph = flag.Bool(""plotgraph"", false, ""Plot a directed graph of the workflow to PDF""); ). func main() {; flag.Parse(). wf := scipipe.NewWorkflow(""testwf"", 4); wf.NewProc(""foo"", ""echo foo > {o:out}""). if *plotGraph {; wf.PlotGraphPDF(""wfgraph.dot""); }; wf.Run(); }; ```. Now, the graph will only plotted if you run your workflow with the; `-plotgraph` flag, e.g:. ```bash; go run myworkflow.go -plotgraph; ```. ## Links. - [GoDoc for Workflow.PlotGraph()](https://godoc.org/github.com/scipipe/scipipe#Workflow.PlotGraph); - [GoDoc for Workflow.PlotGraphPDF()](https://godoc.org/github.com/scipipe/scipipe#Workflow.PlotGraphPDF). ## Footnotes. [1] these are often called ""DAG"" for ""Directed Acyclic Graph"", but; SciPipe does not have a guarantee or requirement on acyclicness of the graph,; thus just ""directed graph"".",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/plot_workflow_graph.md:1770,test,testwf,1770,docs/howtos/plot_workflow_graph.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/plot_workflow_graph.md,1,['test'],['testwf']
Testability," workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:6779,log,log,6779,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,4,['log'],['log']
Testability,"# Contributing to SciPipe. ## Working with forked repository. Unlike other languages like C++/Python, Go requires modules being referenced,; to be placed in a specific location for the import to work. Forking via GitHub; provides a pull request workflow that is well documented but does not work well; with Go import. Documented here is one approach utilizing go modules. First, fork and clone SciPipe the usual way via GitHub to a local file system,; lets call it `<cloned-scipipe-dir>`. To work on and test the changes made to scipipe in the cloned location, create; a directory for your scipipe workflows, lets call it `<workflow-dev-dir>`. In; that directory, you can create a simple `main.go` file with a `package main` so; that you can run your code that exercises the changes you are making at; `<cloned-scipipe-dir>`. Note that if you were to run your code in `main.go` as-is, it would pull down; the code from the repository and cache them and you will not actually be able; to test any local changes in scipipe. To do so, you need to create a file call; `go.mod`. In `<workflow-dev-dir>` run the following:. ```; go mod init <some package name>; ```. Note: The actual name of the package is not critical. Next, define the modules required by your main.go:. ```; go mod edit -require=github.com/scipipe/scipipe@v0.9.10; ```. Note: A the time of this writing, v0.9.10 is the latest published version, this; will change over time and you need to adapt. Next, replace any reference to the previous URL with reference to the; `<cloned-scipipe-dir>` location:. ```; go mod edit -replace=github.com/scipipe/scipipe@v0.9.10=<cloned-scipipe-dir>; ```. Now when you do:. ```; go run main.go; ```. ... it will not be pulling the code from GitHub but references the code you; have cloned locally. Do your development work and push to your forked repository and do a pull; request for the author to review and optionally merge the contribution.; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md:504,test,test,504,docs/contributing.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md,2,['test'],['test']
Testability,"To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly as a proper; Hello World example should :). Now, these were a little long and cumbersome filenames, weren't they? SciPipe; gives you very good control over how to name your files, if you don't want to; rely on the automatic file naming. For example, we could set the first filename; to a static one, and then use the first name as a basis for the file name for; the second process, like so:. ```go; package m",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:7297,log,log,7297,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['log'],['log']
Testability,"[SciPipe 0.8.0](https://github.com/scipipe/scipipe/releases/tag/v0.8.0); introduced experimental support for converting audit logs (those; `.audit.json` files produced to accompany all output files from SciPipe); into other formats, such as HTML, TeX (for further conversion to PDF) or; even executable Bash-scripts. Here's how to do it. ## Convert audit log to HTML. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2html myfile.audit.json; ```. This will produce an HTML file named `myfile.audit.html`, which you can; view in a web browser. ## Convert audit log to TeX. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2tex myfile.audit.json; ```. This will produce an HTML file named `myfile.audit.tex`, which you can; either edit manually, or convert directly to PDF using the `pdflatex`; command like so:. ```bash; pdflatex myfile.audit.tex; ```. Converting to PDF requires that you have a TeX installation on your system.; On Ubuntu, you can install the base package or TeX live with `sudo apt-get; install texlive-base`. ## Convert audit log to Bash. Given that you have an audit log file with the name `myfile.audit.json`,; then execute:. ```bash; scipipe audit2bash myfile.audit.json; ```. This will produce a Bash-file named `myfile.audit.sh`, which you can; execute like so:. ```bash; sh myfile.audit.sh; ```. ... in order to reproduce the file again from scratch, if it is removed,; given that you have all the dependent files and tools installed on your; system.",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/convert_audit_logs.md:126,log,logs,126,docs/howtos/convert_audit_logs.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/convert_audit_logs.md,7,['log'],"['log', 'logs']"
Testability,"for; the second process, like so:. ```go; package main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow with a name, and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes and set output file paths; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out}""); hello.SetOut(""out"", ""hello.txt""). world := wf.NewProc(""world"", ""echo $(cat {i:in}) World >> {o:out}""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""). // Connect network; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. In the `{i:in...` part, we are re-using the file path from the file received on; the in-port named 'in', and then running a Bash-style trim-from-end command on; it to remove the `.txt` extension. Now, if we run this, the file names get a little cleaner:. ```bash; $ ls -1 hello*; hello.txt; hello.txt.audit.json; hello_world.go; hello_world.txt; hello_world.txt.audit.json; ```. ## The audit logs. Finally, we could have a look at one of those audit file created:. ```bash; $ cat hello_world.txt.audit.json; {; ""ID"": ""99i5vxhtd41pmaewc8pr"",; ""ProcessName"": ""world"",; ""Command"": ""echo $(cat hello.txt) World \u003e\u003e hello_world.txt.tmp/hello_world.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.955602979+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.959410102+02:00"",; ""ExecTimeNS"": 3000000,; ""Upstream"": {; ""hello.txt"": {; ""ID"": ""w4oeiii9h5j7sckq7aqq"",; ""ProcessName"": ""hello"",; ""Command"": ""echo 'Hello ' \u003e hello.txt.tmp/hello.txt"",; ""Params"": {},; ""Tags"": {},; ""StartTime"": ""2018-06-15T19:10:37.950032676+02:00"",; ""FinishTime"": ""2018-06-15T19:10:37.95468214+02:00"",; ""ExecTimeNS"": 4000000,; ""Upstream"": {}; }; }; ```. Each such audit-file contains a hierarchic JSON-representation of the full; workflow path that was executed in order to produce this file. On the first; level is the command that directly produced the corresponding file, and then,; indexe",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:9226,log,logs,9226,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['log'],['logs']
Testability,"p ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:6826,log,log,6826,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['log'],['log']
Testability,"pipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/scipipe-20180717-214226-hello_world.log); ```. Let's check what file SciPipe has generated:. ```; $ ls -1 hello*; hello.out.txt; hello.out.txt.audit.json; hello.out.txt.world.out.txt; hello.out.txt.world.out.txt.audit.json; ```. As you can see, it has created a file `hello.out.txt`, and `hello.out.world.out.txt`, and; an accompanying `.audit.json` for each of these files. Now, let's check the output of the final resulting file:. ```bash; $ cat hello.out.txt.world.out.txt; Hello World; ```. Now we can rejoice that it contains the text ""Hello World"", exactly as a proper; Hello World example should :). Now, these were a little long and cumbersome filenames, weren't they? SciPipe; gives you very good control over how to name your files, if you don't want to; rely on the automatic file naming. For example, we could set the first filename; to a static one, and then use the first name as a basis for the file name for; the second process, like so:. ```go; package main. import (; // Import the SciPipe package, aliased to 'sp'; sp ""git",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:7337,log,log,7337,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['log'],['log']
Testability,"ts to it, by stitching a channel between the; ports. On `Process` objects, there is also a third port type, `InParamPort` (and the; accompanying `OutParamPort`), which is used when it is needed to send a; stream of parameter values (in string format) to be supplied to as arguments; to shell commands. * See [GoDoc for the InPort struct type](https://godoc.org/github.com/scipipe/scipipe#InPort); * See [GoDoc for the OutPort struct type](https://godoc.org/github.com/scipipe/scipipe#OutPort); * See [GoDoc for the InParamPort struct type](https://godoc.org/github.com/scipipe/scipipe#InParamPort); * See [GoDoc for the OutParamPort struct type](https://godoc.org/github.com/scipipe/scipipe#OutParamPort). ## Channels. Ports in SciPipe are connected via channels. Channels are [plain Go channels](https://tour.golang.org/concurrency/2); and nothing more. Most of the time, one will not need to deal with the channels; directly though, since the port objects (see separate section for ports) have; all the logic to connect to other ports via channels, but it can be good to; know that they are there, in case you need to do something more advanced. ## Workflow. The [`Workflow`](https://godoc.org/github.com/scipipe/scipipe#Workflow); is a special object in SciPipe, that just takes care of running a set of; components making up a workflow. There is not much to say about the workflow component, other than that it is; created with `scipipe.NewWorkflow(workflowName, maxConcurrentTasks)`, that all processes need to be added; to it with `wf.AddProc(proc)` while the ""last"", or ""driving"" process needs to be specified with `wf.SetDriver(driverProcess)`, and that it should be run with; `wf.Run()`. But this is already covered in the other examples and; tutorials. * See [GoDoc for Workflow](https://godoc.org/github.com/scipipe/scipipe#Workflow). ## Shell command pattern. The `Process` has the speciality that it can be configured using a special; shell command pattern, supplied to the [`NewProc()`](",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md:4310,log,logic,4310,docs/basic_concepts.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/basic_concepts.md,1,['log'],['logic']
Testability,"tting up data dependencies. On line 16, a component that writes the; previously defined DNA string to a file is initiated, and on line 17, the file; path pattern for the out-port dna is defined (in this case a static file name).; On line 20, a component that translates each DNA base to its complementary; counterpart is initiated. On line 21, the file path pattern for its only; out-port is defined. In this case, reusing the file path of the file it will; receive on its in-port named in, thus the {i:in} part. The %.txt part removes; .txt from the input path. On line 24, a component that will reverse the DNA; string is initiated. On lines 27-29, data dependencies are defined via the in-; and out-ports defined earlier as part of the shell command patterns. On line; 32, the workflow is being run. ## How to run. To run the example, given that you have the [Go toolchain](https://golang.org); installed (a vertion from at least 1.9), you can run it like this:. ```bash; $ go run revcomplement.go ; ```. You are then expected to see some log output similar to the following:. ```log; AUDIT 2019/03/26 22:59:43 | workflow:DNA Base Complement Workflow | Starting workflow (Writing log to log/scipipe-20190326-225943-dna-base-complement-workflow.log); AUDIT 2019/03/26 22:59:43 | Make DNA | Executing: echo AAAGCCCGTGGGGGACCTGTTC > dna.txt; AUDIT 2019/03/26 22:59:43 | Make DNA | Finished: echo AAAGCCCGTGGGGGACCTGTTC > dna.txt; AUDIT 2019/03/26 22:59:43 | Base Complement | Executing: cat ../dna.txt | tr ATCG TAGC > dna.compl.txt; AUDIT 2019/03/26 22:59:43 | Base Complement | Finished: cat ../dna.txt | tr ATCG TAGC > dna.compl.txt; AUDIT 2019/03/26 22:59:43 | Reverse | Executing: cat ../dna.compl.txt | rev > dna.compl.rev.txt; AUDIT 2019/03/26 22:59:43 | Reverse | Finished: cat ../dna.compl.txt | rev > dna.compl.rev.txt; AUDIT 2019/03/26 22:59:43 | workflow:DNA Base Complement Workflow | Finished workflow (Log written to log/scipipe-20190326-225943-dna-base-complement-workflow.log); ```; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md:3003,log,log,3003,examples/revcomplement/README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md,7,['log'],['log']
Usability," better, access the parameter value via the task which the path function receives:. ```go; for _, val := range []string{""foo"", ""bar""} {; proc := scipipe.NewProc(val + ""_proc"", ""cat {p:val} > {o:out}""); proc.SetOutFunc(""out"", func(t *scipipe.Task) string {; return t.Param(""val"") + "".txt"" // Access param via the task (`t`); }); }; ```. ## Connecting processes into a network. Finally we need to define the data dependencies between our processes. We do; this by connecting the outports of one process to the inport of another; process, using the `From` method available on each in-port object (Or the; `To` method on out-ports). We also need to connect the final out-port of the; pipeline to the workflow, so that the workflow can pull on this port; (technically pulling on a Go channel), in order to drive the workflow. ```go; // Connect network; world.In(""in"").From(helloWriter.Out(""out"")); ```. ## Running the pipeline. So, the final part probably explains itself, but the workflow component is a; relatively simple one that will start each component in a separate go-routine. For technical reasons, one final process has to be run in the main go-routine; (that where the program's `main()` function runs), but generally you don't; need to think about this, as the workflow will then use an in-built; [sink](https://godoc.org/github.com/scipipe/scipipe#Sink) process for this; purpose. If you for any reason need to customize which process to use as the; ""driver"" process, instead of the in-built sink. see the [`SetDriver` section](https://godoc.org/github.com/scipipe/scipipe#Workflow.SetDriver); in the docs. ```go; wf.Run(); ```. ## Summary. So with this, we have done everything needed to set up a file-based batch workflow system. In summary, what we did, was to:. 1. Initialize processes; 2. For each out-port, define a file-naming strategy; 3. Specify dependencies by connecting out- and in-ports; 4. Run the pipeline. This actually turns out to be a fixed set of components that always nee",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:7504,simpl,simple,7504,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['simpl'],['simple']
Usability," example](https://github.com/scipipe/scipipe/blob/master/examples/static_params/staticparams.go). ## Receive parameters dynamically. Receiving parameters dynamically is a much more technically demandning solution; than using static parameters. The idea is that by using placeholders for parameter values in a command, each; parameter for a particular process, will automatically get a channel of type; string, on which it can receive values. When the process is ready to execute; another shell command, it receives one item on each parameter ports, in; addition to receiving one file on each (file-)in-port, and merges the values; into the shell command, before executing it. An example of this would be a little too complicated to cover briefly on this; page, so please instead see the [dynamic parameters example](https://github.com/scipipe/scipipe/blob/master/examples/param_channels/params.go).; In the [Run method of the Combinatorics task](https://github.com/scipipe/scipipe/blob/master/examples/param_channels/params.go#L58-L70); you will find the code used to send values (all combinations of values in three; arrays of lenght 3, in this case). ### See also. - [Dynamic parameters example](https://github.com/scipipe/scipipe/blob/master/examples/param_channels/params.go). ## Handle boolean flags. *Topic coming soon. Please add it as a support request in the [issue tracker](https://github.com/scipipe/scipipe/issues); if you need this information fast, and we can prioritize writing it asap.*. ## Handling parameters in re-usable components. *Topic coming soon. Please add it as a support request in the [issue tracker](https://github.com/scipipe/scipipe/issues); if you need this information fast, and we can prioritize writing it asap.*. ## Relevant examples. - [Static parameters](https://github.com/scipipe/scipipe/blob/master/examples/static_params/staticparams.go); - [Receive parameters dynamically](https://github.com/scipipe/scipipe/blob/master/examples/param_channels/params.go); ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/parameters.md:2916,usab,usable,2916,docs/howtos/parameters.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/parameters.md,1,['usab'],['usable']
Usability,"# Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This library is has been much influenced/inspired also by the; [GoFlow](https://github.com/trustmaster/goflow) library by [Vladimir Sibirov](https://github.com/trustmaster/goflow).; - Thanks to [Egon Elbre](http://twitter.com/egonelbre) for helpful input on the; design of the internals of the pipeline, and processes, which greatly; simplified the implementation.; - This work is financed by faculty grants and other financing for the [Pharmaceutical Bioinformatics group](http://pharmb.io) of [Dept. of; Pharmaceutical Biosciences](http://www.farmbio.uu.se) at [Uppsala University](http://www.uu.se), and by [Swedish Research Council](http://vr.se); through the Swedish [National Bioinformatics Infrastructure Sweden](http://nbis.se).; - Supervisor for the project is [Ola Spjuth](http://www.farmbio.uu.se/research/researchgroups/pb/olaspjuth).; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/acknowledgements.md:833,simpl,simplified,833,docs/acknowledgements.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/acknowledgements.md,1,['simpl'],['simplified']
Usability,"# Contributing to SciPipe. ## Working with forked repository. Unlike other languages like C++/Python, Go requires modules being referenced,; to be placed in a specific location for the import to work. Forking via GitHub; provides a pull request workflow that is well documented but does not work well; with Go import. Documented here is one approach utilizing go modules. First, fork and clone SciPipe the usual way via GitHub to a local file system,; lets call it `<cloned-scipipe-dir>`. To work on and test the changes made to scipipe in the cloned location, create; a directory for your scipipe workflows, lets call it `<workflow-dev-dir>`. In; that directory, you can create a simple `main.go` file with a `package main` so; that you can run your code that exercises the changes you are making at; `<cloned-scipipe-dir>`. Note that if you were to run your code in `main.go` as-is, it would pull down; the code from the repository and cache them and you will not actually be able; to test any local changes in scipipe. To do so, you need to create a file call; `go.mod`. In `<workflow-dev-dir>` run the following:. ```; go mod init <some package name>; ```. Note: The actual name of the package is not critical. Next, define the modules required by your main.go:. ```; go mod edit -require=github.com/scipipe/scipipe@v0.9.10; ```. Note: A the time of this writing, v0.9.10 is the latest published version, this; will change over time and you need to adapt. Next, replace any reference to the previous URL with reference to the; `<cloned-scipipe-dir>` location:. ```; go mod edit -replace=github.com/scipipe/scipipe@v0.9.10=<cloned-scipipe-dir>; ```. Now when you do:. ```; go run main.go; ```. ... it will not be pulling the code from GitHub but references the code you; have cloned locally. Do your development work and push to your forked repository and do a pull; request for the author to review and optionally merge the contribution.; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md:681,simpl,simple,681,docs/contributing.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/contributing.md,1,['simpl'],['simple']
Usability,"# DNA Reverse complement example. A simple example workflow implemented with SciPipe. The workflow computes the; reverse base complement of a string of DNA, using standard UNIX tools. ## Detailed explanation of the code. See the revcomplement.go file for the source code, or here below:. ```go; package main. import (; 	""github.com/scipipe/scipipe""; ). const dna = ""AAAGCCCGTGGGGGACCTGTTC"". func main() {; 	// Initialize workflow, using max 4 CPU cores; 	wf := scipipe.NewWorkflow(""DNA Base Complement Workflow"", 4). 	// Initialize processes based on shell commands:. 	// makeDNA writes a DNA string to a file; 	makeDNA := wf.NewProc(""Make DNA"", ""echo ""+dna+"" > {o:dna}""); 	makeDNA.SetOut(""dna"", ""dna.txt""). 	// complmt computes the base complement of a DNA string; 	complmt := wf.NewProc(""Base Complement"", ""cat {i:in} | tr ATCG TAGC > {o:compl}""); 	complmt.SetOut(""compl"", ""{i:in|%.txt}.compl.txt""). 	// reverse reverses the input DNA string; 	reverse := wf.NewProc(""Reverse"", ""cat {i:in} | rev > {o:rev}""); 	reverse.SetOut(""rev"", ""{i:in|%.txt}.rev.txt""). 	// Connect data dependencies between out- and in-ports; 	complmt.In(""in"").From(makeDNA.Out(""dna"")); 	reverse.In(""in"").From(complmt.Out(""compl"")). 	// Run the workflow; 	wf.Run(); }; ```. On line 4, the SciPipe library is imported, to be later accessed as scipipe. On; line 7, a short string of DNA is defined. On line 9-33, the full workflow is; implemented in the program’s main() function, meaning that it will be executed; when the resulting program is executed. On line 11, a new workflow object (or; “struct” in Go terms) is initiated with a name and the maximum number of cores; to use. On lines 15-25, the workflow components, or processes, are initiated,; each with a name and a shell command pattern. Input file names are defined with; a placeholder on the form {i:INPORTNAME} and outputs on the form; {o:OUTPORTNAME}. The port-name will be used later to access the corresponding; ports for setting up data dependencies. On line 16, ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md:36,simpl,simple,36,examples/revcomplement/README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/examples/revcomplement/README.md,1,['simpl'],['simple']
Usability,"## What are re-usable components. With re-usable components, we mean components that can be stored in a Go; package and imported and used later. In order for components in such a library to be easy to use, the ports need; to be static methods bound to the process struct, rather than just stored by; a string ID in a generic port map, like the `In()` and `Out()` methods on; `Process` processes. This is so that the methods can show up in the; auto-completion / intellisense function in code editors removing the need to; look up the name of the ports manually in the library code all the time. ## How to create re-usable components in SciPipe. Process processes created with the `scipipe.NewProc()` command, can be turned; into such ""re-usable"" component by using a wrapping strategy, that is; demonstrated in an [example on GitHub](https://github.com/scipipe/scipipe/blob/master/examples/wrapper_procs/wrap.go). The idea is to create a new struct type for the re-usable component, and; then, in the factory method for the process, create an ""inner"" process of; type Process, using `NewProc()` as in the normal case, embedding that in the; outer struct and then adding statically defined accessor methods for each of; the ports in the inner process, with a similar name. So, if the inner process; has an outport named ""foo"", you would define an accessor method named; `myproc.OutFoo()` that returns this port from the inner process. Let's look at a code example of how this works, by creating a process that just; writes ""hi"" to a file:. ```go; type HiWriter struct {; // Embedd a Process struct; 	*sci.Process; }. func NewHiWriter() *HiWriter {; // Initialize a normal ""Process"" to use as an ""inner"" process; 	innerHiWriter := sci.NewProc(""hiwriter"", ""echo hi > {o:hifile}""); 	innerHiWriter.SetOut(""hifile"", ""hi.txt""). // Create a new HiWriter process with the inner process embedded into it; 	return &HiWriter{innerHiWriter}; }. // OutHiFile provides a static version of the ""hifile"" port in the in",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md:15,usab,usable,15,docs/howtos/reusable_components.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md,4,['usab'],['usable']
Usability,"Pipe: A workflow library for agile development of complex and dynamic bioinformatics pipelines ; _Gigascience_. 8, 5 (2019). DOI: [10.1093/gigascience/giz044](https://dx.doi.org/10.1093/gigascience/giz044). ## Acknowledgements. - SciPipe is very heavily dependent on the proven principles form [Flow-Based; Programming (FBP)](http://www.jpaulmorrison.com/fbp), as invented by [John Paul Morrison](http://www.jpaulmorrison.com/fbp).; From Flow-based programming, SciPipe uses the ideas of separate network; (workflow dependency graph) definition, named in- and out-ports,; sub-networks/sub-workflows and bounded buffers (already available in Go's; channels) to make writing workflows as easy as possible.; - This library is has been much influenced/inspired also by the; [GoFlow](https://github.com/trustmaster/goflow) library by [Vladimir Sibirov](https://github.com/trustmaster/goflow).; - Thanks to [Egon Elbre](http://twitter.com/egonelbre) for helpful input on the; design of the internals of the pipeline, and processes, which greatly; simplified the implementation.; - This work is financed by faculty grants and other financing for the [Pharmaceutical Bioinformatics group](http://pharmb.io) of [Dept. of; Pharmaceutical Biosciences](http://www.farmbio.uu.se) at [Uppsala University](http://www.uu.se), and by [Swedish Research Council](http://vr.se); through the Swedish [National Bioinformatics Infrastructure Sweden](http://nbis.se).; - Supervisor for the project is [Ola Spjuth](http://www.farmbio.uu.se/research/researchgroups/pb/olaspjuth). ## Related tools. Find below a few tools that are more or less similar to SciPipe that are worth worth checking out before; deciding on what tool fits you best (in approximate order of similarity to SciPipe):. - [NextFlow](http://nextflow.io); - [Luigi](https://github.com/spotify/luigi)/[SciLuigi](https://github.com/samuell/sciluigi); - [BPipe](https://code.google.com/p/bpipe/); - [SnakeMake](https://bitbucket.org/johanneskoester/snakemake); ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:12849,simpl,simplified,12849,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['simpl'],['simplified']
Usability,"STRING`. It will remove the specified; string from the _end_ of the path. This is useful when we want to avoid; getting too long paths when re-using previous processes' paths. With the; example above, our input file named `hello.txt` will be converted into; `hello_world.txt` by this path pattern. ### Available path modifiers. The currently available path modifiers are:. - `basename` - Removes all folders from the path, leaving only the filename.; - Example: `{i:infile|basename}`, if `infile` has the path `data/file.txt`, will convert it to just `file.txt`.; - `dirname` - Removes the ending file name part from the path, leaving only the folder path.; - Example: `{i:infile|dirname}/newfile.txt`, if `infile` has the path `data/file.txt`, will convert it to `data/newfile.txt`.; - `%.<extension>` - Removes the file extension `<extension>`.; - Example: `{i:infile|%.txt}`, if `infile` has the path `file.txt`, will convert it to just `file`.; - `s/<search>/<replacement>/` - Will do a simple search and replace, from `<search>` to `<replacement>`.; - Example: `{i:infile|s/file/my_file/}`, if `infile` has the path `file.txt`, will convert it to `my_file.txt`. ## Even more control over file formatting. We can actually get even more control over how file names are produced than; this, by manually supplying each process with an anonymous function that; returns file paths given a `scipipe.Task` object, which will be produced for; each command execution. In order to implement the same path patterns as above, using this method, we; would write like this:. ```go; // Configure output file path formatters for the processes created above; hello.SetOutFunc(""out"", func(t *scipipe.Task) string {; return ""hello.txt""; }); world.SetOutFunc(""out"", func(t *scipipe.Task) string {; return strings.Replace(t.InPath(""in""), "".txt"", ""_world.txt"", -1); }); ```. As you can see, this is a much more complicated way to format paths, but it can; be useful for example when needing to incorporate parameter va",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:4182,simpl,simple,4182,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['simpl'],['simple']
Usability,"SciPipe allows you to, on-demand, run only specific parts of a workflow. This; can be useful especially if you are doing modifications far up in an already; developed workflow, and want to run only up to a specific process, rather; than also running all downstream processes, which might be unnecessary heavy. This can be done by using the; [workflow.RunTo()](https://godoc.org/github.com/scipipe/scipipe#Workflow.RunTo); method. By using this instead of the normal `workflow.Run()` method, scipipe; will only run this process and all upstream processes of that one. See also a; [simple&nbsp;example](https://github.com/scipipe/scipipe/blob/master/examples/run_specific_procs/run_specific_procs.go); of where this is used. There are a few other variants for specifying parts of workflows (and more; might be added in the future), such as specifying individual process names,; or providing the process structs themselves. Please refer to the relevant; parts of the; [workflow&nbsp;documentation](https://godoc.org/github.com/scipipe/scipipe#Workflow); for more about that.; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/partial_workflows.md:580,simpl,simple,580,docs/howtos/partial_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/partial_workflows.md,1,['simpl'],['simple']
Usability,"```. The `go.mod` file should now look something like:. ```; module mylittlemodule. go 1.17. require github.com/scipipe/scipipe v0.10.2; ```. ... and the go.sum file might look something like:. ```; github.com/scipipe/scipipe v0.10.2 h1:crXD1gGh/LuBfWfT4CdXcRFtPjem5weyXN03BDfVOuU=; github.com/scipipe/scipipe v0.10.2/go.mod h1:Nwof+Uimtam7GTpkU6cAf/EOnqvxcOVFytjnYU5I3vY=; ```. ### Optional extra step: Use a copy of SciPipe's source code in your own code. In order to make sure that your workflow will never break because of API; changes in SciPipe, and that you always have a copy of the SciPipe source; code available, we recommend to always include a copy of the SciPipe source; code in your workflow's source code repository. The SciPipe source code is; only around 1500 lines of code, with no external dependencies except Go and; Bash, so this should not increase the size of your repository too much. A simple way to do this, is to use Go's `vendor` tool, which stores a local; copy of the source code of packages used, inside the local directory, in; a sub-directory called ""vendor"". To do this, execute the following command:. ```; go mod vendor; ```. Then, to make sure the code is included in your git history, make sure to add it; to git:. ```bash; git add vendor; git commit -m ""Add vendored version of SciPipe""; ```. ## Run your workflow. Now youa re ready to run the workflow. To run a `.go` file, just use `go run <script-file>`, e.g:; ; ```bash; go run myfirstworkflow.go; ```. ## Some tips about editors. In order to be productive with SciPipe, you will also need a Go editor or IDE; with support for auto-completion, sometimes also called ""intellisense"". We can warmly recommend to use one of these editors, sorted by level of endorsement:. 1. [Visual Studio Code](http://code.visualstudio.com) with the [Go plugin](https://github.com/Microsoft/vscode-go) - If you want a very powerful almost IDE-like editor; 2. The [vim-go](https://github.com/fatih/vim-go) plugin by [Fatih](htt",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:3486,simpl,simple,3486,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,1,['simpl'],['simple']
Usability,"cs.it/posts/first-production-workflow-run-with-scipipe"">First production workflow run with SciPipe</a>; </div>. ## Introduction. SciPipe is a library for writing [Scientific Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system),; sometimes also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for problems in bioinformatics and; cheminformatics, but works equally well for any problem involving pipelines of; commandline applications. **Project status:** SciPipe pretty stable now, and only very minor API changes; might still occur. We have successfully used SciPipe in a handful of both real; and experimental projects, and it has had occasional use outside the research; group as well. ## Known limitations. - There are still a number of missing good-to-have features for workflow; design. See the [issue tracker](https://github.com/scipipe/scipipe/issues); for detai",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md:4298,usab,usable,4298,docs/index.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/index.md,1,['usab'],['usable']
Usability,"each set of; files on in-ports, a command will be created and executed whereafter new files; will be pulled in on the out-ports, and so on. ## Formatting output file paths. Now we need to provide some way for scipipe to figure out a suitable file name; for each of the files propagating through the ""network"" of processes. This can; be done using special convenience methods on the processes, starting with; `SetOut...`. There are a few variants, of which two of them are shown here. ```go; // Configure output file path formatters for the processes created above; hello.SetOut(""out"", ""hello.txt""); world.SetOut(""out"", ""{i:in|%.txt}_world.txt""); ```. `SetOut` takes a pattern similar to the shell command pattern, with; placeholders, used to define new (shell-based) processes. The available; placeholders that can be used are: `{i:INPORTNAME}`, `{p:PARAMNAME}` and; `{t:TAGNAME}`. An example of a full pattern might be:; `{i:foo}.replace_with_{p:replacement}.txt`, but can also be used for; simple, static paths, like in the example above. The placeholders can also take certain extra ""modifiers"", separated from the; placeholder name by pipe characters, and of which the one used above is; probably the most important one: `%STRING`. It will remove the specified; string from the _end_ of the path. This is useful when we want to avoid; getting too long paths when re-using previous processes' paths. With the; example above, our input file named `hello.txt` will be converted into; `hello_world.txt` by this path pattern. ### Available path modifiers. The currently available path modifiers are:. - `basename` - Removes all folders from the path, leaving only the filename.; - Example: `{i:infile|basename}`, if `infile` has the path `data/file.txt`, will convert it to just `file.txt`.; - `dirname` - Removes the ending file name part from the path, leaving only the folder path.; - Example: `{i:infile|dirname}/newfile.txt`, if `infile` has the path `data/file.txt`, will convert it to `data/new",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md:2956,simpl,simple,2956,docs/writing_workflows.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/writing_workflows.md,1,['simpl'],['simple']
Usability,"install` tool in the Go; tool chain. To install scipipe with `go install`, run the following command in; your terminal:. ```bash; go install github.com/scipipe/scipipe/...@latest; ```. **N.B:** Don't miss the `...`, as otherwise the `scipipe` helper tool will not be installed. ## Initialize a new workflow file. Now, you should be able to write code like in the example below, in files; ending with `.go`. The easiest way to get started is to let the scipipe tool generate a starting point for you:. ```bash; scipipe new myfirstworkflow.go; ```. ... which you can then edit to your liking. ## Create a Go module. Before you can run the workflow, you need to also create a [go module](https://golang.org/ref/mod#introduction). To do this, you can run the following command, in the directory where you; created your first workflow:. ```bash; go mod init <package-name>; ```. For `<module-name>`, you have to replace it with a name of the package.; For a simple script, you can name whatever you want, but if you are thinking; about publishing it online, e.g. on GitHub, you typically want to name it like; the URL of the corresponding GitHub repo, e.g.; `github.com/<your-username>/<your-repository>`. By doing this, two files will be created:. ```; go.mod; go.sum; ```. Make sure to add them to your git repository, with:. ```; git add go.mod go.sum; git commit -m ""Add Go module files""; ```. Now, to make sure that scipipe is included as a dependency in the go.mod file,; run the `go mod tidy` command:. ```bash; go mod tidy; ```. The `go.mod` file should now look something like:. ```; module mylittlemodule. go 1.17. require github.com/scipipe/scipipe v0.10.2; ```. ... and the go.sum file might look something like:. ```; github.com/scipipe/scipipe v0.10.2 h1:crXD1gGh/LuBfWfT4CdXcRFtPjem5weyXN03BDfVOuU=; github.com/scipipe/scipipe v0.10.2/go.mod h1:Nwof+Uimtam7GTpkU6cAf/EOnqvxcOVFytjnYU5I3vY=; ```. ### Optional extra step: Use a copy of SciPipe's source code in your own code. In order to mak",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:2001,simpl,simple,2001,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,1,['simpl'],['simple']
Usability,"r quick getting started steps, you can do:. 1. [Download](https://golang.org/dl/) and [install](https://golang.org/doc/install) Go; 2. Run the following command, to install the scipipe Go library (don't miss the; trailing dots!), and create a Go module for your script:. ```bash; go install github.com/scipipe/scipipe/...@latest; go mod init myfirstworkflow-module; ```. ## Hello World example. Let's look at an example workflow to get a feel for what writing workflows in; SciPipe looks like:. ```go; package main. import (; // Import SciPipe, aliased to sp; sp ""github.com/scipipe/scipipe""; ). func main() {; // Init workflow and max concurrent tasks; wf := sp.NewWorkflow(""hello_world"", 4). // Initialize processes, and file extensions; hello := wf.NewProc(""hello"", ""echo 'Hello ' > {o:out|.txt}""); world := wf.NewProc(""world"", ""echo $(cat {i:in}) World > {o:out|.txt}""). // Define data flow; world.In(""in"").From(hello.Out(""out"")). // Run workflow; wf.Run(); }; ```. To create a file with a similar simple example, you can run:. ```; scipipe new hello_world.go; ```. ## Running the example. Let's put the code in a file named `hello_world.go` and run it. First you need to make sure that the dependencies (SciPipe in this case) is; installed in your local Go module. This you can do with:. ```bash; go mod tidy; ```. Then you can go ahead and run the workflow:. ```bash; $ go run hello_world.go; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Starting workflow (Writing log to log/scipipe-20180717-214226-hello_world.log); AUDIT 2018/07/17 21:42:26 | hello | Executing: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | hello | Finished: echo 'Hello ' > hello.out.txt; AUDIT 2018/07/17 21:42:26 | world | Executing: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | world | Finished: echo $(cat ../hello.out.txt) World > hello.out.txt.world.out.txt; AUDIT 2018/07/17 21:42:26 | workflow:hello_world | Finished workflow (Log written to log/s",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:6304,simpl,simple,6304,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,2,['simpl'],['simple']
Usability,"scipipe"">First production workflow run with SciPipe</a. ## Introduction. <img src=""docs/images/fbp_factory.png"" align=""right"">. SciPipe is a library for writing [Scientific; Workflows](https://en.wikipedia.org/wiki/Scientific_workflow_system), sometimes; also called ""pipelines"", in the [Go programming language](http://golang.org). When you need to run many commandline programs that depend on each other in; complex ways, SciPipe helps by making the process of running these programs; flexible, robust and reproducible. SciPipe also lets you restart an interrupted; run without over-writing already produced output and produces an audit report; of what was run, among many other things. SciPipe is built on the proven principles of [Flow-Based Programming](https://en.wikipedia.org/wiki/Flow-based_programming); (FBP) to achieve maximum flexibility, productivity and agility when designing; workflows. Compared to plain dataflow, FBP provides the benefits that; processes are fully self-contained, so that a library of re-usable components; can be created, and plugged into new workflows ad-hoc. Similar to other FBP systems, SciPipe workflows can be likened to a network of; assembly lines in a factory, where items (files) are flowing through a network; of conveyor belts, stopping at different independently running stations; (processes) for processing, as depicted in the picture above. SciPipe was initially created for problems in bioinformatics and; cheminformatics, but works equally well for any problem involving pipelines of; commandline applications. **Project status:** SciPipe pretty stable now, and only very minor API changes; might still occur. We have successfully used SciPipe in a handful of both real; and experimental projects, and it has had occasional use outside the research; group as well. ## Known limitations. - There are still a number of missing good-to-have features for workflow; design. See the [issue tracker](https://github.com/scipipe/scipipe/issues); for detai",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md:4121,usab,usable,4121,README.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/README.md,1,['usab'],['usable']
Usability,"stored in a Go; package and imported and used later. In order for components in such a library to be easy to use, the ports need; to be static methods bound to the process struct, rather than just stored by; a string ID in a generic port map, like the `In()` and `Out()` methods on; `Process` processes. This is so that the methods can show up in the; auto-completion / intellisense function in code editors removing the need to; look up the name of the ports manually in the library code all the time. ## How to create re-usable components in SciPipe. Process processes created with the `scipipe.NewProc()` command, can be turned; into such ""re-usable"" component by using a wrapping strategy, that is; demonstrated in an [example on GitHub](https://github.com/scipipe/scipipe/blob/master/examples/wrapper_procs/wrap.go). The idea is to create a new struct type for the re-usable component, and; then, in the factory method for the process, create an ""inner"" process of; type Process, using `NewProc()` as in the normal case, embedding that in the; outer struct and then adding statically defined accessor methods for each of; the ports in the inner process, with a similar name. So, if the inner process; has an outport named ""foo"", you would define an accessor method named; `myproc.OutFoo()` that returns this port from the inner process. Let's look at a code example of how this works, by creating a process that just; writes ""hi"" to a file:. ```go; type HiWriter struct {; // Embedd a Process struct; 	*sci.Process; }. func NewHiWriter() *HiWriter {; // Initialize a normal ""Process"" to use as an ""inner"" process; 	innerHiWriter := sci.NewProc(""hiwriter"", ""echo hi > {o:hifile}""); 	innerHiWriter.SetOut(""hifile"", ""hi.txt""). // Create a new HiWriter process with the inner process embedded into it; 	return &HiWriter{innerHiWriter}; }. // OutHiFile provides a static version of the ""hifile"" port in the inner; // (embedded) process; func (p *HiWriter) OutHiFile() *sci.OutPort {; // Return the in",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md:965,usab,usable,965,docs/howtos/reusable_components.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/howtos/reusable_components.md,1,['usab'],['usable']
Usability,"you always have a copy of the SciPipe source; code available, we recommend to always include a copy of the SciPipe source; code in your workflow's source code repository. The SciPipe source code is; only around 1500 lines of code, with no external dependencies except Go and; Bash, so this should not increase the size of your repository too much. A simple way to do this, is to use Go's `vendor` tool, which stores a local; copy of the source code of packages used, inside the local directory, in; a sub-directory called ""vendor"". To do this, execute the following command:. ```; go mod vendor; ```. Then, to make sure the code is included in your git history, make sure to add it; to git:. ```bash; git add vendor; git commit -m ""Add vendored version of SciPipe""; ```. ## Run your workflow. Now youa re ready to run the workflow. To run a `.go` file, just use `go run <script-file>`, e.g:; ; ```bash; go run myfirstworkflow.go; ```. ## Some tips about editors. In order to be productive with SciPipe, you will also need a Go editor or IDE; with support for auto-completion, sometimes also called ""intellisense"". We can warmly recommend to use one of these editors, sorted by level of endorsement:. 1. [Visual Studio Code](http://code.visualstudio.com) with the [Go plugin](https://github.com/Microsoft/vscode-go) - If you want a very powerful almost IDE-like editor; 2. The [vim-go](https://github.com/fatih/vim-go) plugin by [Fatih](https://twitter.com/fatih) - if you are a Vim power-user, or need a terminal-only complement to VSCode.; 3. JetBrain's [GoLand IDE](https://www.jetbrains.com/go/), if you are ready to pay for maximum code intelligence in a professional IDE.; 4. [LiteIDE](https://github.com/visualfc/liteide) - if you want a simple, robust and fast standalone Go-editor. There are also popular Go-plugins for [Sublime text](https://www.sublimetext.com), [Atom](https://atom.io/) and [IntelliJ IDEA](https://www.jetbrains.com/idea/), and an upcoming Go IDE from JetBrains,; called; ",MatchSource.DOCS,scipipe,scipipe,v0.12.0,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md:4880,simpl,simple,4880,docs/install.md,https://scipipe.org,https://github.com/scipipe/scipipe/tree/v0.12.0/docs/install.md,1,['simpl'],['simple']
