quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance," is applied. copy()[source]¶; Function to return a copy of the Table object. format_label()[source]¶; Function to pad the width of Table object labels. format_values(values)[source]¶; Function to pad the width of Table object data cells. save(file)[source]¶; Function to save string of the Table object to file. scale(Factor=627.5095)[source]¶; Function to apply a scaling factor Factor to the; data of the Table object. banner(text, type=1, width=35)[source]¶; Function to print text to output file in a banner of; minimum width width and minimum three-line height for; type = 1 or one-line height for type = 2. print_stderr(stuff)[source]¶; Function to print stuff to standard error stream. print_stdout(stuff)[source]¶; Function to print stuff to standard output stream. Module with utility functions for use in input files. compare_integers(expected, computed, label)[source]¶; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_strings(expected, computed, label)[source]¶; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. compare_values(expected, computed, digits, label)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits.; Performs a system exit on failure. Used in input files in the test suite. compare_vectors(expected, computed, digits, label)[source]¶; Function to compare two vectors. Prints util.su",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:34630,Perform,Performs,34630,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['Perform'],['Performs']
Performance," is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. HESS_TYPE¶. Type Hessian matrix will be used in orbital optimization procedure. Type: string; Possible Values: NONE; Default: NONE. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OMP2_ORBS_PRINT¶. Do print OMP2 orbital energies?. Type: boolean; Default: false. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html:2422,optimiz,optimization,2422,psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,2,['optimiz'],['optimization']
Performance," is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:17871,optimiz,optimization,17871,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance," is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:20999,optimiz,optimization,20999,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance," is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import absolute_import. import numpy as np. from psi4 import core; from psi4.driver import constants; from psi4.driver.p4util.exceptions import *. def least_squares_fit_polynomial(xvals, fvals, localization_point, no_factorials=True, weighted=True, polynomial_order=4):; """"""Performs and unweighted least squares fit of a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See http://dx.doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]def anharmonicity(rvals, energies, plot_fit='', mol = None):; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. http://dx.doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/diatomic.html:1365,Perform,Performs,1365,psi4manual/1.2.1/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/diatomic.html,1,['Perform'],['Performs']
Performance," is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude, not amp) for amplitudes; NUM_ (not n) for number (e.g., NUM_AMPS_PRINT, MAX_NUM_VECS,; NUM_THREADS); Some names that could be split into multiple words are staying as one.; Use MAXITER, CACHELEVEL, PUREAM, DERTYPE.; INTS (not integrals), also OEI (not oe_integrals) for; one-electron integrals and TEI (not te_integrals) for two-electron; integrals; PERTURB (not pert) for perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it. If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being tested",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_addon.html:7808,optimiz,optimizations,7808,psi4manual/master/manage_addon.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_addon.html,9,['optimiz'],['optimizations']
Performance," is the iteration at which to start saving vectors for diis. Not all; modules conform to all these at present, but they’re as standardized as; they can be without changing code.; AMPS (not amplitude, not amp) for amplitudes; NUM_ (not n) for number (e.g., NUM_AMPS_PRINT, MAX_NUM_VECS,; NUM_THREADS); Some names that could be split into multiple words are staying as one.; Use MAXITER, CACHELEVEL, PUREAM, DERTYPE.; INTS (not integrals), also OEI (not oe_integrals) for; one-electron integrals and TEI (not te_integrals) for two-electron; integrals; PERTURB (not pert) for perturbation; Use PRINT options to indicate printing to output file. Use WRITE; options to indicate printing to another file. This probably isn’t; entirely valid now but should be observed in future. The complement to; WRITE is READ. PRINT, READ, and WRITE will usually; be the last words in an option name.; Use FOLLOW_ROOT for the state to be followed in geometry optimizations; WFN (not wavefunction); You’re welcome to use WFN and DERTYPE as internal options, but; plan to have these set by the python driver and mark them as !expert; options. Really avoid using JOBTYPE.; You’re not welcome to add CHARGE or MULTP options. Plan to get; these quantities from the molecule object. Since we frequently use subsets; of systems (with their own charge and multiplicity), this is safer.; Conform. Just grep 'add' psi4/src/read_options.cc to get a list of; all the option names in PSI4 and try to match any conventions you; find.; If you have a quantity you’d like to call a cutoff, a threshold, a; tolerance, or a convergence, consider the following guidelines in naming; it.; If its value is typically greater than ~0.001, give it a name with CUTOFF.; If its value is typically less than ~0.001 and quantities being tested; against the option are more valuable with larger values (e.g.,; integrals, occupations, eigenvectors), give it a name with TOLERANCE.; If its value is typically less than ~0.001 and quantities being teste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/manage_addon-1.html:7792,optimiz,optimizations,7792,psi4manual/1.2.1/manage_addon-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/manage_addon-1.html,4,['optimiz'],['optimizations']
Performance," is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via options. ADIIS [On by Default]ADIIS uses previous iterates of the Fock and density matrices to produce an; informed estimate of the next Fock matrix. ADIIS estimates are based on minimizing; an energy estimate rather than zeroing the residual, so this performs best in the early; iterations. By default, Psi will start using ADIIS before blending the ADIIS step with; the DIIS step, eventually using the pure DIIS step. The closely-related EDIIS procedure; may be used instead by setting SCF_INITIAL_ACCELERATOR. This is formally identical; to ADIIS for HF, but the methods will differ for more general DFT. MOM [Off by Default]MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations \(N,N+2,\ldots\), invoking; MOM_START N can often rescue the convergence of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:23193,optimiz,optimized,23193,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,5,['optimiz'],['optimized']
Performance," is_libxc_func() psi4.core.SuperFunctional method. is_lrc() psi4.core.Functional method. is_meta() psi4.core.Functional method. psi4.core.SuperFunctional method. is_poisson() psi4.core.FittingMetric method. is_pure() psi4.core.GaussianShell method. is_variable() psi4.core.Molecule method. is_x_hybrid() psi4.core.SuperFunctional method. is_x_lrc() psi4.core.SuperFunctional method. ISA. ; MBIS. Isotopes. ISOTROPIC_POL (PE). ISTOP (DETCI). iteration psi4.driver.ConvergenceError attribute. psi4.driver.OptimizationConvergenceError attribute. psi4.driver.SCFConvergenceError attribute. psi4.driver.TDSCFConvergenceError attribute. iteration_ psi4.core.HF attribute. iterations() psi4.core.HF method. J. J() psi4.core.JK method. JK class in psi4.core. jk() psi4.core.HF method. JOBTYPE (CCLAMBDA). K. K() psi4.core.JK method. keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. keywords psi4.driver.AtomicComputer attribute. psi4.driver.driver_cbs.CompositeComputer attribute. psi4.driver.driver_nbody.ManyBodyComputer attribute. KIND (ADC). kinetic() psi4.core.FISAPT method. kinetic_grad() psi4.core.MintsHelper method. KineticInt class in psi4.core. kwargs_lower() in module psi4.driver.p4util. L. L psi4.core.Localizer attribute. label() psi4.core.Molecule method. psi4.core.MOSpace method. lagrangian() psi4.core.Wavefunction method. LaplaceDenominator class in psi4.core. LCC2 (+LMP2) TOTAL ENERGY. LCCD CORRELATION ENERGY. LCCD DOUBLES ENERGY. LCCD OPPOSITE-SPIN CORRELATION ENERGY. LCCD SAME-SPIN CORRELATION ENERGY. LCCD SINGLES ENERGY. LCCD TOTAL ENERGY. LCCSD. (+LMP2). LCCSD CORRELATION ENERGY. LCCSD DOUBLES ENERGY. LCCSD OPPOSITE-SPIN CORRELATION ENERGY. LCCSD SAME-SPIN CORRELATION ENERGY. LCCSD SINGLES ENERGY. LCCSD TOTAL ENERGY. LEFT-RIGHT CC2 EIGENVECTOR OVERLAP. LEFT-RIGHT CC3 EIGENVECTOR OVERLAP. LEFT-RIGHT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:66593,optimiz,optimize,66593,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['optimiz'],['optimize']
Performance," it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT auxiliary; basis for the Hartree-Fock, and the jun-cc-pVDZ-RI basis set for the; SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons by adding 'freeze_core': 'true' to the; dictionary passed to psi4.set_options(). The SAPT procedure is; invoked by psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Here,; Psi4 knows to automatically run two mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:14143,perform,performed,14143,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['perform'],['performed']
Performance," it is preferred to use s-dftd3 for ATM since the 3-body can be run concurrent; with the 2-body contribution.; Footnotes. [1]; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. [2]; [Grimme:2004:1463]. [3]; [Grimme:2006:1787]. [4]; (1,2); [Grimme:2010:154104]. [5]; (1,2); [Grimme:2011:1456]. [6]; (1,2,3,4); [Smith:2016:2197]. [7]; [Hujo:2011:3866]. [8]; [Chai:2010:6615]. [9]; [Pernal:2009:263201]. [10]; [Podeszwa:2010:550]. [11]; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. [12]; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4‘s libdisp; energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dispersion programs can be run independently of the scf; through the python function run_dftd3() or run_dftd4(). (These functions; call QCEngine, which is the same PSI4 + dftd3/dftd4 interface that is called during an scf job.); This “D-only” route is much faster than running a DFT-D energy.; This route is NOT available for s-dftd3. File an issue if a definite need arises.; Note that in a DFT+D energy or gradient calculation, user-specified; dispersion parameters override any information provided about the; functional. The same holds true for a dftd3 “D-only” calculation. But; in a dftd4 “D-only” calculation, functional information overrides; any ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dftd3.html:12118,optimiz,optimize,12118,psi4manual/master/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/master/dftd3.html,4,['optimiz'],['optimize']
Performance," it. Basis set and auxiliary basis sets are assigned by atom type. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_cfour-1.html:4359,optimiz,optimization,4359,psi4manual/1.3.2/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_cfour-1.html,4,['optimiz'],['optimization']
Performance," keyword must match the database python file. Examples. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the dat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:6349,perform,performed,6349,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,5,['perform'],['performed']
Performance," keywords. theory. OCEPA(0)CORRELATIONENERGY. OCEPA(0)TOTALENERGY. OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OEProp. theory. oeprop() in module p4util.util. OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (CPHF). (DETCI). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (CPHF). (DFMP2). opt(); . see optimize(); . OPT_METHOD (OCC). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in p4util.optproc. OptionState class in p4util.optproc. ORB_OPT (OCC). ORB_RESP_SOLVER (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OCEPA. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OCC). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). p4const module. p4const.__init__ module. p4const.physconst module. p4const.psifiles module. p4regex module. p4util module. p4util.__init__ module. p4util.basislist module. p4util.basislistdunning module. p4util.basislistother module. p4util.optproc module. p4util.procutil module. p4util.text module. p4util.util module. PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_error() in module pcmgetkw. parse_multiline_array() in module inputparser. parseFile() G",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:33579,optimiz,optimize,33579,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['optimiz'],['optimize']
Performance," labels are present and whether; # all the findif[displacement][energy-or-gradient] values; # are ready. Not sure what type of error/query is best,; # so deferring for now. Also, possibly need to check if; # step size matches before using values from one findifrec; # to construct another quantity.; else:; self.findifrec[""reference""][""gradient""] = G0. if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs] def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # load QCVariables & properties; qcvars = self.task_list['reference'].get_results().extras['qcvars']; E0 = self.findifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:50216,load,load,50216,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,1,['load'],['load']
Performance," language can differ in the details. If you; want to overload on pointer types and/or use pointer types with templates,; use nullptr to signal the null pointer. The correct overload/template; parameter will then be deduced. Using nullptr also makes the code more; readable, especially if auto is used consistently throughout.; Reference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:; 1; 2; 3std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso)); // Type information written down 3 TIMES!!!; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!!!!. Ensures exception safety and prevents resource leaks. Improves efficiency:; 1; 2; 3; 4// Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));; // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:; 1; 2std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:; 1; 2; 3int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:; 1; 2; 3; 4std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND architecture-DEPENDENT; unsigned sz = v.size(); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/style_c-1.html:1175,Perform,Performs,1175,psi4manual/1.2.1/style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/style_c-1.html,4,['Perform'],['Performs']
Performance," least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/testsuite-1.html:18097,optimiz,optimization,18097,psi4manual/4.0b3/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/testsuite-1.html,4,['optimiz'],['optimization']
Performance," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:2773,optimiz,optimized,2773,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,4,['optimiz'],['optimized']
Performance," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:2771,optimiz,optimized,2771,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,2,['optimiz'],['optimized']
Performance," less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:2852,optimiz,optimized,2852,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['optimiz'],['optimized']
Performance," levels print more information. A value of 5 will print very large amounts of debugging information. Type: integer; Default: 1. PRINT_MOS¶. Do print MOs?. Type: boolean; Default: false. PRINT_OE_INTEGRALS¶. Do print one-electron integrals?. Type: boolean; Default: false. PRINT_REORDER¶. Do print reordered MOs?. Type: boolean; Default: false. PRINT_SORTED_OE_INTS¶. Do print sorted one-electron integrals?. Type: boolean; Default: false. PRINT_SORTED_TE_INTS¶. Do print sorted two-electron integrals (TEIs)?. Type: boolean; Default: false. PRINT_TE_INTEGRALS¶. Do print two-electron integrals?. Type: boolean; Default: false. PSIMRCC¶. Do specific arrangements for PSIMRCC?. Type: boolean; Default: false. QRHF¶. Do form quasi RHF (QRHF) orbitals?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. REORDER¶. Do reorder MOs?. Type: boolean; Default: false. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SORTED_TEI_FILE¶. MO-basis sorted two-electron integrals file. Type: integer; Default: PSIF_MO_TEI. SO_S_FILE¶. SO basis overlap matrix file. Type: integer; Default: PSIF_OEI. SO_TEI_FILE¶. SO basis two-electron integrals file. Type: integer; Default: PSIF_SO_TEI. SO_T_FILE¶. SO basis kinetic energy matrix file. Type: integer; Default: PSIF_OEI. SO_V_FILE¶. SO basis potential energy matrix file. Type: integer; Default: PSIF_OEI. TPDM_ADD_REF¶. Do add reference contribution to TPDM?. Type: boolean; Default: false. TPDM_FILE¶. MO-basis two-particle density matrix file. Type: integer; Default: PSIF_MO_TPDM. Expert¶. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__transqt-1.html:4275,optimiz,optimized,4275,psi4manual/4.0b3/autodir_options_c/module__transqt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__transqt-1.html,6,['optimiz'],['optimized']
Performance," likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between PSI4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM (as opposed to CFOUR_SPHERICAL). Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. PSI4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles. Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; qcdb.cfour.muster_modelchem() for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; 1; 2set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; 1; 2; 3set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; 1energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; 1; 2set cfour_cc_program vcc; energy('c4-ccsd'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:30502,optimiz,optimization,30502,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['optimiz'],['optimization']
Performance," likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between Psi4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM (as opposed to CFOUR_SPHERICAL). Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. Psi4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles. Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; qcdb.cfour.muster_modelchem() for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; set cfour_cc_program vcc; energy('c4-ccsd'). Specifying ce",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:31526,optimiz,optimization,31526,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['optimiz'],['optimization']
Performance," limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.prop-1.html:1310,optimiz,optimized,1310,psi4manual/1.4.0/api/psi4.driver.prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.prop-1.html,15,['optimiz'],['optimized']
Performance," limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability', 'oscillator_strength', 'roa'] || etc.; Indicates which properties should be computed. Defaults to dipole a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prop.html:1361,optimiz,optimized,1361,psi4manual/master/prop.html,https://psicode.org,https://psicode.org/psi4manual/master/prop.html,12,['optimiz'],['optimized']
Performance," limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 0.50. HESS_UPDATE_USE_LAST (OPTKING)¶OPTKING — Number of previous steps to use in Hessian update, 0 uses all. Type: integer; Default: 2. HESSIAN_WRITE (FINDIF)¶FINDIF — Do write a hessian output file? If so, the filename will end in .hess, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ICORE (DETCI)¶DETCI — Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. INCFOCK (SCF)¶SCF — Do Perform Incremental Fock Build?. Type: boolean; Default: false. INCFOCK_FULL_FOCK_EVERY (SCF)¶SCF — Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. INDUCED_CONVERGENCE (PE)¶PE — Threshold for induced moments convergence. Type: conv double; Default: 1e-8. INTCOS_GENERATE_EXIT (OPTKING)¶OPTKING — Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. INTEGRAL_CUTOFF (DFOCC)¶DFOCC — Cutoff value for DF integrals. Type: integer; Default: 9. INTEGRAL_PACKAGE (GLOBALS)¶GLOBALS — Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT1, SIMINT, LIBINT2; Default: LIBINT2. INTERFRAG_DIST_INV (OPTKING)¶OPTKING — Do use \(\frac{1}{R_{AB}}\) for the stretching coordinate between fragments? Otherwise, use \(R_{AB}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:145688,Perform,Perform,145688,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,2,['Perform'],['Perform']
Performance," limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 0.50. HESS_UPDATE_USE_LAST (OPTKING)¶OPTKING — Number of previous steps to use in Hessian update, 0 uses all. Type: integer; Default: 2. HESSIAN_WRITE (FINDIF)¶FINDIF — Do write a hessian output file? If so, the filename will end in .hess, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ICORE (DETCI)¶DETCI — Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. INCFOCK (SCF)¶SCF — Do perform incremental Fock build?. Type: boolean; Default: false. INCFOCK_CONVERGENCE (SCF)¶SCF — The density threshold at which to stop building the Fock matrix incrementally. Type: conv double; Default: 1.0e-5. INCFOCK_FULL_FOCK_EVERY (SCF)¶SCF — Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. INDUCED_CONVERGENCE (PE)¶PE — Threshold for induced moments convergence. Type: conv double; Default: 1e-8. INTCOS_GENERATE_EXIT (OPTKING)¶OPTKING — Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. INTEGRAL_CUTOFF (DFOCC)¶DFOCC — Cutoff value for DF integrals. Type: integer; Default: 9. INTEGRAL_PACKAGE (GLOBALS)¶GLOBALS — Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT1, SIMINT, LIBINT2; Default: L",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:147412,perform,perform,147412,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['perform'],['perform']
Performance," limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 0.50. HESS_UPDATE_USE_LAST (OPTKING)¶OPTKING — Number of previous steps to use in Hessian update, 0 uses all. Type: integer; Default: 4. HESSIAN_WRITE (FINDIF)¶FINDIF — Do write a hessian output file? If so, the filename will end in .hess, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ICORE (DETCI)¶DETCI — Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. INCFOCK (SCF)¶SCF — Do perform incremental Fock build?. Type: boolean; Default: false. INCFOCK_CONVERGENCE (SCF)¶SCF — The density threshold at which to stop building the Fock matrix incrementally. Type: conv double; Default: 1.0e-5. INCFOCK_FULL_FOCK_EVERY (SCF)¶SCF — Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. INDUCED_CONVERGENCE (PE)¶PE — Threshold for induced moments convergence. Type: conv double; Default: 1e-8. INTCOS_GENERATE_EXIT (OPTKING)¶OPTKING — Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. INTEGRAL_CUTOFF (DFOCC)¶DFOCC — Cutoff value for DF integrals. Type: integer; Default: 9. INTEGRAL_PACKAGE (GLOBALS)¶GLOBALS — Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT1, SIMINT, LIBINT2; Default: L",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:150563,perform,perform,150563,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,3,['perform'],['perform']
Performance," limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 0.50. HESS_UPDATE_USE_LAST (OPTKING)¶OPTKING — Number of previous steps to use in Hessian update, 0 uses all. Type: integer; Default: 4. HESSIAN_WRITE (FINDIF)¶FINDIF — Do write a hessian output file? If so, the filename will end in .hess, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ICORE (DETCI)¶DETCI — Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. INCFOCK (SCF)¶SCF — Do perform incremental Fock build?. Type: boolean; Default: false. INCFOCK_CONVERGENCE (SCF)¶SCF — The density threshold at which to stop building the Fock matrix incrementally. Type: conv double; Default: 1.0e-5. INCFOCK_FULL_FOCK_EVERY (SCF)¶SCF — Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. INDUCED_CONVERGENCE (PE)¶PE — Threshold for induced moments convergence. Type: conv double; Default: 1e-8. INTCOS_GENERATE_EXIT (OPTKING)¶OPTKING — Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. INTEGRAL_CUTOFF (DFOCC)¶DFOCC — Cutoff value for DF integrals. Type: integer; Default: 9. INTEGRAL_PACKAGE (GLOBALS)¶GLOBALS — Integral package to use. If compiled with Simint support, change this option to use them; LibInt2 is used otherwise. Type: string; Possible Values: LIBINT2, SIMINT; Default: LIBINT2. INTERFRAG_CO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:153358,perform,perform,153358,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['perform'],['perform']
Performance," list of geometry variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, arg0: int) → str¶; Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize(self: psi4.core.Molecule, arg0: float) → None¶; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3) → None¶; Translates molecule by arg1. update_geometry(self: psi4.core.Molecule) → None¶; Reevaluates the geometry with current variable values, orientation directives, etc. Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int) → float¶; x position of atom arg1 (0-indexed in Bohr). y(self: psi4.core.Molecule, arg0: int) → float¶; y position of atom arg1 (0-indexed in Bohr). z(self: psi4.core.Molecule, arg0: int) → float¶; z position of atom arg1 (0-indexed in Bohr). BFS(); Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int) → float; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule) → None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int) → None; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:20387,Perform,Perform,20387,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['Perform'],['Perform']
Performance," lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the and integrals are held in core; (=5) and and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC¶. Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if CFOUR_CC_PROGRAM =EXTERNAL has been specified. Type: boolean; Default: true. CFOUR_INTEGRALS¶. This keyword defines what type of integral input will be written by xjoda. VMOL (=1) has to be used with the programs of CFOUR. Using ARGOS (=0), input for Pitzer’s ARGOS integral program will be written. (Default: VMOL). Type: string; Possible Values: VMOL, ARGOS; Default: VMOL. CFOUR_JODA_PRINT¶. Controls amount of debug printing performed by xjoda. The higher the number, the more information is printed. Values of 25 or higher generally do not produce anything of interest to the general user. Do not set JODA_PRINT to 999 as this will cause the core vector to be dumped to disk. Type: integer; Default: 0. CFOUR_LINEQ_CONV¶. Convergence threshold for linear equations controlled by LINEQ_TYPE. Equations are iterated until smallest residual falls below , where is the value associated with this keyword. Type: integer; Default: 7. CFOUR_LINEQ_MAXCY¶. The maximum number of iterations in all linear CC equations. Type: integer; Default: 50. CFOUR_LINEQ_TYPE¶. Determines the algorithm used to solve linear equations ( and derivative and ). POPLE (=0) uses Pople’s method of successively orthogonalized basis vectors, while DIIS (=1) uses Pulay’s DIIS method. The latter offers the practical advantage of requiring much less disk space, although it is not guaranteed to converge. Moreover, POPLE has not been tested for s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:34821,perform,performed,34821,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['perform'],['performed']
Performance," machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶. Overall PSI4 Package¶; The following citation should be used in any publication utilizing the; PSI4 program package:. “Psi4: An open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci. 2, 556 (2012).; (doi: 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:1383,optimiz,optimization,1383,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,4,['optimiz'],['optimization']
Performance," machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; Psi4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of Psi4 input files and how Python can be mixed with; quantum chemistry directives in Psi4. Section Psithon Functions; provides more detail on the Python functions provided by Psi4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using Psi4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendices include a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest Psi4 documentation, check; www.psicode.org. Citing Psi4¶. Overall Psi4 Package¶; The following citation should be used in any publication utilizing the; Psi4 program package:. “Psi4: An open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci. 2, 556 (2012).; (doi: 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:1390,optimiz,optimization,1390,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,2,['optimiz'],['optimization']
Performance," macroiteration is completed by performing the orbital transformation of the; integrals. As in the simultaneous algorithm, the DIIS; extrapolation is used to accelerate convergence. Two-step algorithm is; only available for the DC-06 and DC-12 methods. QCIn the quadratically-convergent algorithm, the; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the cumulant will be solved using a standard Jacobi update.; If requested by the user (set QC_COUPLING to TRUE), the electronic Hessian can include; matrix elements that couple the orbitals and the density cumulant.; The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below \(10^{-7}\). The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensive \({\cal O}(N^5)\) integral transformations, the simultaneous; algorithm benefits from a smaller number of expensive \({\cal O}(N^6)\); cumulant updates. As a result, for small closed-shell systems the two-st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dct.html:9862,perform,perform,9862,psi4manual/master/dct.html,https://psicode.org,https://psicode.org/psi4manual/master/dct.html,9,['perform'],['perform']
Performance," make plots of the molecular geometry; with the atoms colored according to their order-1 F-SAPT contributions. We have; a set of template .pymol scripts to help with this process. These can be; obtained by running:; 1>>> copy_pymol.py. and then in PyMol:; 1>>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; Elst.pymol), which in turn load in the molecule and order-1 analysis; (contained in the .pdb file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Difference F-SAPT Analysis¶; For those interested in taking the differences between two F-SAPT partitions; (e.g., to see how a substituent modulates a noncovalent interaction), we have; the fsapt-diff.py script to help with this. This is invoked as:; 1>>> fsapt-diff.py source-fsapt-dir1 source-fsapt-dir2 target-diff-fsapt-dir. Where the use has already performed fsapt.py analysis using the same; functional group names in source-fsapt-dir-1 and source-fsapt-dir-2. The; difference F-SAPT partition entries are computed as \(E^{\Delta} = E^{1} -; E^{2}\), and the geometries for order-1 .pdb visualization files are taken; from system 1. I-SAPT: A Representative Example¶. Caution; As of April 2018, you can’t specify molecule fragments; with an unphysical multiplicity like the singlet OH fragments in; the molecule below, especially as (again in the example below) the; overall molecule needs to be a singlet, which PSI4 doesn’t at; present let be set independently. For situations like this, use the; temporary input pattern in isapt1 . Below, we show an example of using I-SAPT0/jun-cc-pVDZ to analyze the; interaction between the two phenol groups in a 2,4-pentanediol molecule.; This example is; explicitly included in isapt1. A video; lecture explaining this example is available; I-SAPT#1,; while an additional video describing how to plot ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/fisapt-1.html:8270,perform,performed,8270,psi4manual/1.2.1/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/fisapt-1.html,4,['perform'],['performed']
Performance," make plots of the molecular geometry; with the atoms colored according to their order-1 F-SAPT contributions. We have; a set of template .pymol scripts to help with this process. These can be; obtained by running:; 1>>> copy_pymol.py. and then in PyMol:; 1>>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; Elst.pymol), which in turn load in the molecule and order-1 analysis; (contained in the .pdb file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Difference F-SAPT Analysis¶; For those interested in taking the differences between two F-SAPT partitions; (e.g., to see how a substituent modulates a noncovalent interaction), we have; the fsapt-diff.py script to help with this. This is invoked as:; 1>>> fsapt-diff.py source-fsapt-dir1 source-fsapt-dir2 target-diff-fsapt-dir. Where the use has already performed fsapt.py analysis using the same; functional group names in source-fsapt-dir-1 and source-fsapt-dir-2. The; difference F-SAPT partition entries are computed as \(E^{\Delta} = E^{1} -; E^{2}\), and the geometries for order-1 .pdb visualization files are taken; from system 1. I-SAPT: A Representative Example¶; Below, we show an example of using I-SAPT0/jun-cc-pVDZ to analyze the; interaction between the two phenol groups in a 2,4-pentanediol molecule.; This example is; explicitly included in isapt1. A video; lecture explaining this example is available; I-SAPT#1,; while an additional video describing how to plot the density and ESP fields from; the I-SAPT embedding procedure is available I-SAPT#2:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43memory 1 GB. molecule mol {; 0 1; O 0.39987 2.94222 -0.26535; H 0.05893 2.05436 -0.50962; --; 0 1; O 0.48122 0.30277 -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fisapt-1.html:8268,perform,performed,8268,psi4manual/1.1.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fisapt-1.html,2,['perform'],['performed']
Performance," many-body gradients of different BSSE schemes. numpy-array-interface; Numpy interface testing. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. mints-helper; A general test of the MintsHelper function. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. cbs-parser; mtd/basis syntax examples. dft-reference; MP2 with a PBE0 reference computation. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. ocepa3; OCEPA cc-pV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:21306,Optimiz,Optimization,21306,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['Optimiz'],['Optimization']
Performance," matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:105189,Load,Loads,105189,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['Load'],['Loads']
Performance," matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:10666,Load,Loads,10666,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['Load'],['Loads']
Performance," maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of `w`, computed on the last iteration of the solver; best_R: List[`vector`]; (nroots) The best approximation of the right hand eigenvectors, :math:`X+Y`, computed on the last iteration of the solver.; best_L: List[`vector`]; (nroots) The best approximation of the left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly. References; ----------; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, ""An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules."" J. Chem. Phys.,; 109, 8218 (1998); """""". nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""conv"": True,; ""nvec"": 0,; ""product_count"": 0,; }; print_name = ""HamiltonianSolver""; title_lines = [""Generalized Hamiltonian Solver"", ""By Andrew M. James""]. _diag_print_head",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:26797,perform,performed,26797,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,8,['perform'],['performed']
Performance," may change with; each call to compute integrals. The integral engine provides a; std::vector<const double*> containing the pointers to the start of each; “chunk” of integrals. For first derivatives there are 12 such “chunks”, which; are ordered Px,Py,Pz,Qx,Qy,Qz,Rx,Ry,Rz,Sx,Sy,Sz, where the Px refers to the x; derivative with respect to the basis functions in shell P. Note that all; integral derivatives are provided by the new integral code, unlike the previous; version where only 9 of 12 were provided and the user was responsible for using; translation invariance relationships to fill in the rest. The addresses for; each chunk are updated in the vector after each call to compute integrals, so; the user should keep a const reference to that object, and query that for the; address of interest. Density Screening¶; The old code looked only at the integral to determine whether terms can be; avoided a priori. However, if the integral is to be contracted with a; density or a density-like quantity, the screening can be performed on the; product, which yields more sparsity. To enable this, simply call the integral; object’s update_density member, passing it a SharedMatrix holding the; current density (remember that it changes during each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 sy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_integrals.html:6430,perform,performed,6430,psi4manual/master/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_integrals.html,9,['perform'],['performed']
Performance," memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA)¶CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE)¶CCRESPONSE — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT)¶CCTRANSORT — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCT)¶DCT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC)¶OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY)¶CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:10347,CACHE,CACHELEVEL,10347,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,18,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance," method). is_meta() (psi4.core.Functional method). (psi4.core.SuperFunctional method). is_poisson() (psi4.core.FittingMetric method). is_pure() (psi4.core.GaussianShell method). is_variable() (psi4.core.Molecule method). is_x_hybrid() (psi4.core.SuperFunctional method). is_x_lrc() (psi4.core.SuperFunctional method). ISA. ; MBIS. Isotopes. ISOTROPIC_POL (PE). ISTOP (DETCI). iteration (psi4.driver.ConvergenceError attribute). (psi4.driver.OptimizationConvergenceError attribute). (psi4.driver.SCFConvergenceError attribute). (psi4.driver.TDSCFConvergenceError attribute). iteration_ (psi4.core.HF attribute). iteration_energies (psi4.core.HF attribute). iterations() (psi4.core.HF method). J. J() (psi4.core.JK method). JK (class in psi4.core). jk() (psi4.core.HF method). JOBTYPE (CCLAMBDA). K. K() (psi4.core.JK method). keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. keywords (psi4.driver.AtomicComputer attribute). (psi4.driver.driver_cbs.CompositeComputer attribute). (psi4.driver.driver_nbody.ManyBodyComputer attribute). KIND (ADC). kinetic() (psi4.core.FISAPT method). kinetic_grad() (psi4.core.MintsHelper method). KineticInt (class in psi4.core). kwargs_lower() (in module psi4.driver.p4util). L. L (psi4.core.Localizer attribute). label() (psi4.core.Molecule method). (psi4.core.MOSpace method). lagrangian() (psi4.core.Wavefunction method). LaplaceDenominator (class in psi4.core). LCC2 (+LMP2) TOTAL ENERGY. LCCD CORRELATION ENERGY. LCCD DOUBLES ENERGY. LCCD OPPOSITE-SPIN CORRELATION ENERGY. LCCD SAME-SPIN CORRELATION ENERGY. LCCD SINGLES ENERGY. LCCD TOTAL ENERGY. LCCSD. (+LMP2). LCCSD CORRELATION ENERGY. LCCSD DOUBLES ENERGY. LCCSD OPPOSITE-SPIN CORRELATION ENERGY. LCCSD SAME-SPIN CORRELATION ENERGY. LCCSD SINGLES ENERGY. LCCSD TOTAL ENERGY. LEFT-RIGHT CC2 EIGENVECTOR OVERLAP. LEFT-RIGHT CC3 EIGENVE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:69535,optimiz,optimize,69535,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['optimiz'],['optimize']
Performance," method, [1], [2]. fx() psi4.core.Molecule method, [1], [2]. fy() psi4.core.Molecule method, [1], [2]. fZ() psi4.core.Molecule method, [1], [2]. fz() psi4.core.Molecule method, [1], [2]. fzc() psi4.core.MOSpace method, [1], [2]. fzv() psi4.core.MOSpace method, [1], [2]. G. G_CONVERGENCE (OPTKING). gau2grid. GAUGE (CCDENSITY). (CCRESPONSE). Gaussian Formatted Checkpoint. GaussianShell class in psi4.core, [1]. GaussianType class in psi4.core, [1]. gCP. GDMA. gdma() in module psi4. in module psi4.driver. GDMA_LIMIT (GDMA). GDMA_MULTIPOLE_UNITS (GDMA). GDMA_ORIGIN (GDMA). GDMA_RADIUS (GDMA). GDMA_SWITCH (GDMA). gemm() psi4.core.Matrix method, [1], [2]. genbas() psi4.core.BasisSet method, [1], [2]. general. ; setting keywords. general_invert() psi4.core.Matrix method, [1], [2]. generate_oei() psi4.core.IntegralTransform method, [1], [2]. GEOM_MAXITER (OPTKING). geometry optimization. ; IRC. constrained. convergence criteria. function call. minima. output. transition state. geometry optimization, optimization. geometry() in module psi4.driver. psi4.core.Molecule method, [1], [2]. GeometryUnits class in psi4.core, [1]. get() psi4.core.IntVector method, [1], [2]. psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. get_active_efp() in module psi4.core, [1]. get_active_molecule() in module psi4.core, [1]. get_algorithm() psi4.core.FittingMetric method, [1], [2]. get_AO_core() psi4.core.DFHelper method, [1], [2]. get_AO_size() psi4.core.DFHelper method, [1], [2]. get_array() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. get_array_variable() in module psi4.core, [1]. get_array_variables() in module psi4.core, [1]. get_atomic_point_charges() in module psi4.core, [1]. get_basisset() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:57684,optimiz,optimization,57684,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,4,['optimiz'],['optimization']
Performance," method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SS_SCALE¶. A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SYMMETRIZE¶. Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5, REMP, OREMP; Default: OMP2. Expert¶. SPIN_SCALE_TYPE¶. Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. table of contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DIIS_MAX_VECS; DIIS_MIN_VECS; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; E_CONVERGENCE; IP_POLES; LEVEL_SHIFT; MAX_MOGRAD_CONVERGENCE; MOGRAD_DAMPING; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; NAT_ORBS; OCC_ORBS_PRINT; OEPROP; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; OS_SCALE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; RELAXED; REMP_A; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_TYPE; SS_SCALE; SYMMETRIZE; TPDM_ABCD_TYPE; WFN_TYPE. Expert; SPIN_SCALE_TYPE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; OCC. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__occ.html:8221,CACHE,CACHELEVEL,8221,psi4manual/1.7.x/autodir_options_c/module__occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__occ.html,1,['CACHE'],['CACHELEVEL']
Performance, method. psi4.core.Wavefunction method. to_schema() psi4.core.Molecule method. to_serial() psi4.core.Matrix method. psi4.core.Vector method. to_string() psi4.core.Molecule method. to_tuple() psi4.core.Dimension method. tocclean() psi4.core.IO method. tocentry_exists() psi4.core.IO method. tocprint() psi4.core.IO method. tocscan() psi4.core.IO method. tocwrite() psi4.core.IO method. TPDM (DETCI). tpdm() psi4.core.CIWavefunction method. TPDM_ABCD_TYPE (OCC). trace() psi4.core.Matrix method. psi4.core.SymmetryOperation method. TracelessQuadrupoleInt class in psi4.core. transform() psi4.core.DFHelper method. psi4.core.Matrix method. psi4.core.SymmetryOperation method. transform_ci_integrals() psi4.core.CIWavefunction method. transform_mcscf_integrals() psi4.core.CIWavefunction method. transform_tei() psi4.core.IntegralTransform method. transform_tei_first_half() psi4.core.IntegralTransform method. transform_tei_second_half() psi4.core.IntegralTransform method. transition state. ; geometry optimization. translate() psi4.core.Molecule method. TRANSLATE_PSI4 (CFOUR). transpose() psi4.core.DFHelper method. psi4.core.Matrix method. psi4.core.SymmetryOperation method. transpose_this() psi4.core.Matrix method. TREE_EXPANSION_ORDER (PE). TREE_THETA (PE). TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_IABC_TYPE (DFOCC). TRIPLES_LOW_MEMORY (FNOCC). triplet() in module psi4.core. psi4.core.Matrix static method. true_atomic_number() psi4.core.Molecule method. tstart() in module psi4.core. tstop() in module psi4.core. TURN_ON_ACTV (MCSCF). TWO-ELECTRON ENERGY. TwoBodyAOInt class in psi4.core. twoel_Hx() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. TwoElectronInt class in psi4.core. U. U psi4.core.BoysLocalizer attribute. psi4.core.Localizer attribute. psi4.core.PMLocalizer attribute. UHF class in psi4.core. UHF_NOONS (SCF). UKSFunctions class in psi4.core. UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify(),MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:143682,optimiz,optimization,143682,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,4,['optimiz'],['optimization']
Performance," mints-helper; A general test of the MintsHelper function. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. mp2-h; check that methods can act on single atom. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. casscf-sp; CASSCF/6-31G** energy point. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-func; optimization with method defined via cbs. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. scf-occ; force occupations in scf. cdoremp-energy2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. aediis-2; EDIIS test case from 10.1063/1.1470195. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. nbody-freq; Vibrational a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:34631,optimiz,optimization,34631,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance," mints3; Test individual integral objects for correctness. dft-smoke; DFT Functional Smoke Test. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. linK-1; RHF Linear Exchange Algorithm test for water. mbis-3; MBIS calculation on OH radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. dft2; DFT Functional Test. soscf-large; Second-order SCF convergnece: Benzene. cbs-xtpl-alpha; Extrapolated water energies. cc17; Single point energies of multiple excited states with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. mbis-6; MBIS calculation on H2O. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. cbs-delta-energy; Extrapolated energies with delta correction. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. frac-sym; Fractional occupation with symmetry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:32519,optimiz,optimization,32519,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance," module arg1 or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. psi4.core.has_variable(arg0: str) → bool¶; Returns true if the PSI variable exists/is set. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:232811,optimiz,optimized,232811,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['optimiz'],['optimized']
Performance," module arg1 or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. psi4.core.has_variable(arg0: str) → bool¶; Returns true if the PSI variable exists/is set. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:153578,optimiz,optimized,153578,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['optimiz'],['optimized']
Performance," module calls for; a MP2 calculation. run_mp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 gradient calculation. run_mp2_select(name, **kwargs)¶; Function selecting the algorithm for a MP2 energy call; and directing toward the MP2 or the DFMP2 modules. run_mp2_select_gradient(name, **kwargs)¶; Function selecting the algorithm for a MP2 gradient call; and directing toward the MP2 or the DFMP2 modules. run_mp2c(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a coupled MP2 calculation. run_mrcc(name, **kwargs)[source]¶; Function that prepares environment and input files; for a calculation calling Kallay’s MRCC code. run_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. run_omp2_gradient(name, **kwargs)¶; Function encoding sequence of PSI module calls for; OMP2 gradient calculation. run_omp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP3 computation. run_psimrcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. run_psimrcc_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. run_sapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SAPT calculation of any level. run_sapt_ct(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. run_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. run_scf_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SCF gradient calculation. run_scf_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; SCF calculat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:11132,optimiz,optimized,11132,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance," module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:17429,perform,performance,17429,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance," module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_lccd_gradient', name, 'CC_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:19612,perform,performance,19612,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance," modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». CCENERGY¶; Computes coupled cluster energies. Called as part of any coupled cluster computation. General¶. ABCD¶. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CPHF_CUTOFF¶. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_CUT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html:1073,cache,cache,1073,psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html,2,['cache'],['cache']
Performance," modules    . toc    ; PSI4 [beta5] » ; Module code ». Source code for proc; #; #@BEGIN LICENSE; #; # PSI4: an ab initio quantum chemistry software package; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. from __future__ import print_function; """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. """"""; import shutil; import os; import subprocess; import re; import psi4; import p4const; import p4util; from p4regex import *; #from extend_Molecule import *; from molutil import *; from functional import *; # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://sirius.chem.vt.edu/psi4manual/master/proc_py.html. [docs]def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['DCFT', 'REFERENCE']). psi4.set_local_option('SCF', 'REFERENCE', 'UHF'); psi4.set_local_option('DCFT', 'REFERENCE', 'UHF'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs); psi4.dcft(). optstash.restor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:1110,optimiz,optimize,1110,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['optimiz'],['optimize']
Performance," modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. fci-h2o-2; 6-31G H2O Test FCI Energy Point. fd-gradient; SCF STO-3G finite-difference tests. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. phi-ao; Test computing values of basis functions (puream and non-puream) at points. dfcasscf-sp; CASSCF/6-31G** energy point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/testsuite.html:1058,optimiz,optimization,1058,psi4manual/1.8.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/testsuite.html,1,['optimiz'],['optimization']
Performance," mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. fsapt-ext-abc2; FSAPT with external charge on dimer. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. scf-response3; UHF Dipole Polarizability Test. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc36; CC2(RHF)/cc-pVDZ energy of H2O. opt11; Transition-state optimizations of HOOH to both torsional transition states. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. sapt11; sapt example with orbital freezing with alkali metal and dMP2. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. cc52; CCSD Response for H2O2. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc56; EOM-CCSD/6-31g excited state transition data for water cation. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. ci-property; CI/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:12651,optimiz,optimizations,12651,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimizations']
Performance," mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and dir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:19977,perform,performance,19977,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['perform'],['performance']
Performance," multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequency.html:2805,optimiz,optimize,2805,psi4manual/1.6.x/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequency.html,1,['optimiz'],['optimize']
Performance," must enable the psi4 executable to be found through any of:. prepending to PATH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file; activating the conda environment (p4env above) in shell, ~/.bashrc, or PBS cmd file; supplying full path to executable (shell or PBS cmd file). Similarly, the scratch directory (see Scratch Files and Elementary Restart) must be specified through:. defining PSI_SCRATCH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file. Suitable values for these variables have been printed to screen during installation (see last codeblock in step 6). Useful Commands¶. Initially install PSI4 stable release. # equivalent; >>> conda install psi4 -c psi4; >>> conda install psi4 –channel psi4. Initially install PSI4 stable release with non-current python. 1>>> conda install psi4 python=3.6 -c psi4. Update to latest PSI4 stable release. 1>>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). 1; 2>>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. 1>>> conda install psi4=0.1.12 -c psi4. Uninstall PSI4 from current environment. 1>>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 –channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. 1>>> conda install psi4 python=3.6 -c psi4/label/dev. Update to latest PSI4 nightly build. 1>>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). 1; 2>>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. 1>>> conda install psi4=0.1.12 -c psi4/label/dev. Troubleshooting¶. If the target computer doesn’t have libc >= 2.7 (released c.2007; for referen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/conda-1.html:21053,load,loaded,21053,psi4manual/1.2.1/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/conda-1.html,2,['load'],['loaded']
Performance," n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [E_h] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [E_h] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [E_h] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). CURRENT HESSIAN¶; The total electronic Hessian [E_h/a0/a0] of the most recent stage of a; calculation, (3 * {nat}, 3 * {nat}). CUSTOM SCS-MP2 TOTAL ENERGY¶. CUSTOM SCS-MP2 CORRELATION ENERGY¶; Changeable quantities based on options.; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed by any reweighting of MP2 DOUBLES ENERGY; for opposite-spin and same-spin contributions, with; any singles carried along.; Depending on weights, may equal any of MP2, SCS-MP2, SCS(N)-MP2, etc. quantities.; Contrast with SCS-MP2 TOTAL ENERGY. CUSTOM SCS-MP2.5 TOTAL ENERGY¶. CUSTOM SCS-MP2.5 CORRELATION ENERGY¶. CUSTOM SCS-MP3 TOTAL ENERGY¶. CUSTOM SCS-MP3 CORRELATION ENERGY¶. CUSTOM SCS-REMP2 TOTAL ENERGY¶. CUSTOM SCS-REMP2 CORRELATIO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:24228,optimiz,optimizer,24228,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,4,['optimiz'],['optimizer']
Performance," name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CI_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:24482,perform,performance,24482,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance," name.lower(); kwargs = kwargs_lower(kwargs). Case sensitivity for kwargs dictionary values still needs to be handled. The first line below shows how to convert argument values to lowercase for matching. When not matching a whole value such that regular expressions are needed, the second line below performs a case insensitive match.; if (kwargs['db_mode'].lower() == 'continuous'):; if re.match(r'^sapt', name, flags=re.IGNORECASE):. Match boolean keywords (db_cp in the example below) with expressions like the following, which allow case insensitive yes/true/on/1/no/false/off/0 user input. If your argument’s value is a derivative level, similarly, use input.der0th, input.der1st, and input.der2nd.; if input.yes.match(str(db_cp)):; elif input.no.match(str(db_cp)):. For keywords that might be used in other functions as well as your own, prepend the argument name with a short representation of your function name. For example, there are keywords cp_func, db_func, and opt_func to request what python function, if not energy(), is called by cp(), database(), and optimize(). Upon checking in a new python file, edit the file psi4/doc/userman/source/index.rst and follow the instructions therein that your file may be autodocumented here. Write docstrings! For a major function intended for use in input files, emulate any docstring in psi4/share/python/driver.py. For a behind-the-scenes function or if you don’t want the bother of dealing with reStructuredText, just write an ordinary docstring. It will get slurped into the documentation in plain text. Your python function should follow PEP8 conventions (without the line-length restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case from passing. A test case(s) should be written and checked in f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html:2953,optimiz,optimize,2953,psi4manual/1.0.0/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/bestpractices_py-1.html,2,['optimiz'],['optimize']
Performance," name.lower(); kwargs = kwargs_lower(kwargs). Case sensitivity for kwargs dictionary values still needs to be handled. The first line below shows how to convert argument values to lowercase for matching. When not matching a whole value such that regular expressions are needed, the second line below performs a case insensitive match.; if (kwargs['db_mode'].lower() == 'continuous'):; if re.match(r'^sapt', name, flags=re.IGNORECASE):. Match boolean keywords (db_cp in the example below) with expressions like the following, which allow case insensitive yes/true/on/1/no/false/off/0 user input. If your argument’s value is a derivative level, similarly, use input.der0th, input.der1st, and input.der2nd.; if input.yes.match(str(db_cp)):; elif input.no.match(str(db_cp)):. For keywords that might be used in other functions as well as your own, prepend the argument name with a short representation of your function name. For example, there are keywords cp_func, db_func, and opt_func to request what python function, if not energy(), is called by cp(), database(), and optimize(). Upon checking in a new python file, edit the file psi4/doc/userman/source/index.rst and follow the instructions therein that your file may be autodocumented here. Write docstrings! For a major function intended for use in input files, start with the skeleton docstring in psi4/lib/python/example_docstring and replace anything that looks like <this>. For a behind-the-scenes function or if you don’t want the bother of dealing with reStructuredText, just write an ordinary docstring. It will get slurped into the documentation in plain text. Your python function should follow PEP8 conventions (without the line-length restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/bestpractices_py-1.html:2936,optimiz,optimize,2936,psi4manual/4.0b4/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/bestpractices_py-1.html,8,['optimiz'],['optimize']
Performance," named “intco.dat”. See the Optimizing Minima; section for more detail.; The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 20. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/optking-1.html:2710,optimiz,optimization,2710,psi4manual/4.0b2/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html,4,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance," not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and dou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:3320,Optimiz,Optimizations,3320,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,12,['Optimiz'],['Optimizations']
Performance," not yet implemented. Buy a developer some coffee. - In sow/reap mode, use only global options (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:3534,optimiz,optimize,3534,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,4,['optimiz'],['optimize']
Performance," number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac_nuke(h2o, nmax = 2). Note: this feature is new/powerful enough that we have several papers pending on; it, and are interested in expanding this work. If you would like to publish; results using this code, please contact Rob Parrish to make arrangements for; collaboration. Dispersion Corrections¶; Dispersion corrections are discussed here.; HF-3c and PBEh-3c dispersion and BSSE corrections are discussed here. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). table of contents. DFT: Density Functional The",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:26080,optimiz,optimizing,26080,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,4,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance," number, canonicalizes the name; so that files can be consistently written and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data):; """"""Summary. Parameters; ----------; wfn_data : str or dict; If a str reads a Wavefunction from a disk otherwise, assumes the data; is passed in. Returns; -------; Wavefunction; A deserialized Wavefunction object; """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:4743,load,load,4743,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['load'],['load']
Performance," object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: PK. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 100.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the cc-pVDZ-RI basis set (when available for all elements). Type: string; Possible Values: basis string; Default: FALSE. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html:2286,perform,performed,2286,psi4manual/4.0b3/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html,2,['perform'],['performed']
Performance," occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a SAPT computation at any; level using only the monomer-centered basis. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:17966,perform,performs,17966,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['performs']
Performance," oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_A = moH_A.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_A.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = alpha_mo_idx(il[0][index] + offset); col = alpha_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; PSIF_MO_B_FZC = 'MO-basis Beta Frozen-Core Oper'; moH_B = core.Matrix(PSIF_MO_B_FZC, wfn.nmopi(), wfn.nmopi()); moH_B.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_B = moH_B.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FCIDUMP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html:6828,load,load,6828,psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,2,['load'],['load']
Performance," of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/testsuite-1.html:13019,optimiz,optimization,13019,psi4manual/4.0b3/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/testsuite-1.html,4,['optimiz'],['optimization']
Performance," of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM)¶CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR)¶CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA)¶CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE)¶CCRESPONSE — Caching level for libdpd. Type: integer; Default: 2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:9241,cache,cache,9241,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,18,['cache'],['cache']
Performance," of TREUTLER, BECKE, or NAIVE.; Once the molecular quadrature grid is built, the points are partitioned into; blocks of points which are spatially close to each other. We use an octree; algorithm for this procedure, which produces a good balance between spatial; compactness of each block (which helps achieve linear scaling due to the; exponential decay of the basis functions), and retaining a large number of; points in each block (which helps keep the FLOP rate up by allowing for a; reasonably large amount of BLAS3/BLAS2 work to form the densities and potentials; in each block). For each block, a united set of significant basis functions is; determined by the cutoff radius of each shell of basis functions. The size of; this cutoff radius (and thereby the accuracy of the density/potential; evaluation) can be varied by setting the DFT_BASIS_TOLERANCE, which; defaults to 1E-12. We are still exploring optimizations of the octree algorithm; and the basis cutoffs, but it is likely that significant speed gains may be; realized by relaxing the basis cutoff tolerance, with negligible decrease in; accuracy.; An example of a fully specified grid is as follows:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; dft_spherical_points 590 # Often needed; dft_radial_points 99 # Often needed; dft_radial_scheme treutler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to; those for Hartree–Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn–Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:20767,optimiz,optimizations,20767,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,6,['optimiz'],['optimizations']
Performance," of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:50139,Optimiz,Optimizations,50139,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,3,['Optimiz'],['Optimizations']
Performance," of functions; per shell remains (L + 1)(L + 2)/2, and the ordering remains the same; as above. Note that the individual functions are not normalized for; angular momentum as in most codes: the self-overlap of a PSI4 Cartesian D; or higher function with more than one nonzero Cartesian exponent (e.g., lx; = 1, ly = 1, lz = 0) will be less than one. If Spherical Harmonics are; used, 2L + 1 real combinations of the spherical harmonics are built from; the (L+1)(L+2)/2 Cartesian Gaussians, according to H. Schlegel and M.; Frish, IJQC, 54, 83-87, 1995. Unlike Cartesian functions these functions; are all strictly normalized. Note that in PSI4, the real combinations of; spherical harmonic functions (see the paragraph below Eq. 15 in the; Schlegel paper) are ordered as: 0, 1+, 1-, 2+, 2-, …. USO (Unique Symmetry-Adapted Orbitals): Spatial symmetry-adapted; combinations of SOs, blocked according to irrep. The total number of USOs; is the same as the number of SOs, but the number of USOs within each irrep; is usually much smaller, which can lead to significant performance; improvements. Note that this basis is sometimes unfortunately referred to; as the SO basis, so it’s a bit context specific. OSO (Orthogonal Symmetry-Adapted Orbitals): USOs orthogonalized by; Symmetric or Canonical Orthogonalization. The number of OSOs may be; slightly smaller than the total number of USOs, due to removal of linear; dependencies via Canonical Orthogonalization. The OSOs are rarely; encountered, as usually we go straight from USOs to MOs. MO (Molecular Orbitals): The combination of OSOs that diagonalizes; the Fock Matrix, so each basis function is a Hartree-Fock (or Kohn-Sham); molecular orbital. The number of OSOs and MOs is always the same. MOs are; orthonormal. LO (Localized Orbitals): Localized occupied orbitals, a different; combination of the occupied molecular orbitals which enhances spatial; locality. LOs do not diagonalize the occ-occ block of the Fock Matrix, but; remain orthonormal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html:10726,perform,performance,10726,psi4manual/1.2.1/prog_blas-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/prog_blas-1.html,4,['perform'],['performance']
Performance," of hyperpolarizabilities related to optical rectification, VERDET (=26) the calculation of Verdet constants. Type: string; Possible Values: OFF, FIRST_ORDER, SECOND_ORDER, NMR, HYPERPOL, DYN_HYP, SHG, OPT_REC, VERDET; Default: OFF. CFOUR_PROP_INTEGRAL¶. Allows storage of property integrals computed in xvdint on internal files (e.g., MOINTS and GAMLAM, default choice INTERNAL, =0) or on external files (EXTERNAL, =1). Type: string; Possible Values: INTERNAL, EXTERNAL; Default: INTERNAL. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calcualtion; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. CFOUR_QRHF_GENERAL¶. The presence of this keyword specifies that a QRHF based CC calculation, or alternatively, an SCF calculation that uses the CFOUR_QRHFGUES option, is to be performed. Type: array; Default: No Default. CFOUR_QRHF_ORBITAL¶. By default, in QRHF calculations, electrons are removed from the highest occupied orbital in a symmetry block (symmetry block HOMO), while electrons are added to the lowest unoccupied orbital within a symmetry block (symmetry block LUMO). The purpose of the QRHF_ORBITAL keyword is to allow additional flexibility in choosing which orbitals will have their occupation numbers altered. The value of this keyword gives the offset with respect to the default orbital for the orbital which will be depopulated (or populated)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:48471,perform,performed,48471,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['perform'],['performed']
Performance," of hyperpolarizabilities related to optical rectification, VERDET (=26) the calculation of Verdet constants. Type: string; Possible Values: OFF, FIRST_ORDER, SECOND_ORDER, NMR, HYPERPOL, DYN_HYP, SHG, OPT_REC, VERDET; Default: OFF. CFOUR_PROP_INTEGRAL¶. Allows storage of property integrals computed in xvdint on internal files (e.g., MOINTS and GAMLAM, default choice INTERNAL, =0) or on external files (EXTERNAL, =1). Type: string; Possible Values: INTERNAL, EXTERNAL; Default: INTERNAL. CFOUR_QRHFGUES¶. If this keyword is set to ON (=1), then the QRHF orbitals specified by the CFOUR_QRHF_GENERAL CFOUR_QRHF_ORBITAL and CFOUR_QRHF_SPIN (nyi?) keywords are used as a starting guess for a restarted SCF procedure. This can be an extremely useful way to converge “difficult” SCF solutions, such as those that correspond to states that are not the lowest states of a given symmetry. Note that when this option is used, the calculation that is performed is not a QRHF-CC calculation; it is instead a UHF-based or ROHF-based calculation, depending on what type of reference is specified by the CFOUR_REFERENCE keyword. The QRHF aspect of the calculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. CFOUR_QRHF_GENERAL¶. The presence of this keyword specifies that a QRHF based CC calculation, or alternatively, an SCF calculation that uses the CFOUR_QRHFGUES option, is to be performed. Type: array; Default: No Default. CFOUR_QRHF_ORBITAL¶. By default, in QRHF calculations, electrons are removed from the highest occupied orbital in a symmetry block (symmetry block HOMO), while electrons are added to the lowest unoccupied orbital within a symmetry block (symmetry block LUMO). The purpose of the QRHF_ORBITAL keyword is to allow additional flexibility in choosing which orbitals will have their occupation numbers altered. The value of this keyword gives the offset with respect to the default orbital for the orbital which will be depopulated (or populated)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html:49023,perform,performed,49023,psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,15,['perform'],['performed']
Performance," of integral-direct SCF algorithms, including no disk I/O,; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size; while simultaneously providing a formally-exact computation of the; Exchange term. See Linear Exchange for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation. Additionally, expert users; can manually switch between the in-memory and on-disk options within MEM_DF or DISK_DF using; the SCF_SUBTYPE option. Using SCF_SUBTYPE = AUTO, where PSI4; automatically selects the in-memory or on-disk option for MEM_DF/DISK_DF based on memory and molecule, is the default; and recommended option. However, the in-memory or on-disk algorithms for MEM_DF and DISK_DF can be forced by using; SCF_SUBTYPE = INCOR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:30609,optimiz,optimized,30609,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,4,"['optimiz', 'perform']","['optimized', 'performance']"
Performance," of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type 1¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency 7; 8; 8. SCF of post-HF; energy; 8; 8; PK 3. optimization; 10; 10. frequency 7; 10; 10. CC property 2; 10; 10. Post-SCF convergence criteria defaults by calculation type 4¶. Ab Initio Method; Calculation Type; E_CONVERGENCE 5; R_CONVERGENCE 6. post-HF of post-HF; energy; 6. optimization; 8. frequency 7; 8. CC property 2; 8. Footnotes. 1; Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. 2(1,2); This applies to properties computed through the properties() function. 3; Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. 4; Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. 5; The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. 6; The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defined; according to the quantum chemical me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:40079,optimiz,optimization,40079,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,5,['optimiz'],['optimization']
Performance," of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:9312,cache,cache,9312,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['cache'],['cache']
Performance," of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CPHF); CPHF — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:9187,cache,cache,9187,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,4,['cache'],['cache']
Performance," of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:8741,cache,cache,8741,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,['cache'],['cache']
Performance," of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:9382,cache,cache,9382,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['cache'],['cache']
Performance," of orbital response micro-iterations per macro-iteration for the solution of the response equations (for RESPONSE_ALOGRITHM = TWOSTEP). Type: integer; Default: 50. SCF_MEM_SAFETY_FACTOR (SCF); SCF — Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE (CPHF); CPHF — SCF Type. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: DIRECT. SCF_TYPE (SCF); SCF — What algorithm to use for the SCF computation. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: PK. SCHMIDT_ADD_RESIDUAL_TOLERANCE (CCEOM); CCEOM — Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure. Type: conv double; Default: 1e-3. SCHWARZ_CUTOFF (CPHF); CPHF — The schwarz cutoff value. Type: double; Default: 1.0e-12. SCREEN_INTS (LMP2); LMP2 — Do screen integrals?. Type: boolean; Default: false. SCS (LMP2); LMP2 — Do ?. Type: boolean; Default: false. SCS (MP2); MP2 — Do perform a spin component scaled MP2 computation?. Type: boolean; Default: false. SCS_CCSD (CCENERGY); CCENERGY — Do ?. Type: boolean; Default: false. SCS_MP2 (CCENERGY); CCENERGY — Do ?. Type: boolean; Default: false. SCS_N (LMP2); LMP2 — Do ?. Type: boolean; Default: false. SCS_N (MP2); MP2 — Do perform a spin component scaled (N) MP2 computation?. Type: boolean; Default: false. SCSN_MP2 (CCENERGY); CCENERGY — Do ?. Type: boolean; Default: false. SEKINO (CCLAMBDA); CCLAMBDA — Do ?. Type: boolean; Default: false. SEKINO (CCRESPONSE); CCRESPONSE — Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. SEM_MAXITER (ADC); ADC — Maximum iteration number in simultaneous expansion method. Type: integer; Default: 30. SEMICANONICAL (CCENERGY); CCENERGY — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SEMICANONICAL (CCEOM); CCEOM — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SEMICANONICAL (CCSORT); CCSORT — Convert ROHF MOs to semicanonical",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:90484,perform,perform,90484,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance," of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommend",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sapt-1.html:4348,perform,perform,4348,psi4manual/4.0b2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html,4,"['perform', 'scalab']","['perform', 'scalable']"
Performance," of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT and terms. Re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/sapt-1.html:4375,perform,perform,4375,psi4manual/4.0b3/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/sapt-1.html,12,"['perform', 'scalab']","['perform', 'scalable']"
Performance," of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequencies.html:2860,optimiz,optimize,2860,psi4manual/1.7.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequencies.html,1,['optimiz'],['optimize']
Performance," of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Parameters:. raw_input (str) – Input in a mixture of Python and PSIthon syntax.; print_level (int) – raw_input is printed to the output file unless print_level =0. Return type:; str. psi4.driver.frac.ip_fitting(name, omega_l=0.05, omega_r=2.5, omega_convergence=0.001, maxiter=20, **kwargs)[source]¶; Optimize DFT omega parameter for molecular system. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l (float) – Minimum omega to be considered during fitting.; omega_r (float) – Maximum omega to be considered during fitting.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence (float) – Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter (int) – Maximum number of iterations towards omega convergence. Returns:; Optimal omega parameter. Return type:; float. psi4.driver.frac.frac_traverse(name, **kwargs)[source]¶; Scan electron occupancy from +1 electron to -1. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult (Optional[int]) – Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult (Optional[int]) – Multiplicity of anion, if not neutral multiplicity + 1.; frac_start (Optional[int]) – Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs (Optional[List]) – Occupations to step through ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external_apis.html:3540,tune,tuned,3540,psi4manual/master/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/master/external_apis.html,4,['tune'],['tuned']
Performance," of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import absolute_import. # Gn theory. import re; import os; import math; import warnings; import driver; import psi4; import p4util; import p4const; #from driver import *; # never import aliases into this file. [docs]def run_gaussian_2(name, **kwargs):. # throw an exception for open-shells; if (psi4.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""""""g2 computations require ""reference rhf"".""""""). # stash user options:; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['MP2_TYPE'],; ['SCF','SCF_TYPE']). # override default scf_type; psi4.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; psi4.clean(); psi4.set_global_option('BASIS',""6-31G(D)""); driver.optimize('scf'); psi4.clean(). # scf frequencies for zpe; scf_e, ref = driver.frequency('scf', return_wfn=True). # thermodynamic properties; du = psi4.get_variable('INTERNAL ENERGY CORRECTION'); dh = psi4.get_variable('ENTHALPY CORRECTION'); dg = psi4.get_variable('GIBBS FREE ENERGY CORRECTION'). freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range(0, nfreq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); psi4.set_global_option('MP2_TYPE', 'CONV'); driver.optimize('mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); ref = driver.proc.run_fnocc('qcisd(t)', return_wfn=True, **kwargs). # HLC: high-level correction based on number of valence elect",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:1912,optimiz,optimize,1912,psi4manual/1.0.0/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html,1,['optimiz'],['optimize']
Performance," of the eigenvalues of `w`, computed on the last iteration of the solver; best_R: List[`vector`]; (nroots) The best approximation of the right hand eigenvectors, :math:`X+Y`, computed on the last iteration of the solver.; best_L: List[`vector`]; (nroots) The best approximation of the left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly. References; ----------; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, ""An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules."" J. Chem. Phys.,; 109, 8218 (1998); """""". nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""conv"": True,; ""nvec"": 0,; ""product_count"": 0,; }; print_name = ""HamiltonianSolver""; title_lines = [""Generalized Hamiltonian Solver"", ""By Andrew M. James""]. _diag_print_heading(title_lines, print_name, max_ss_size, nroot, r_convergence, maxiter, verbose). vecs = guess; best_L = []; best_R = []; best_vals = []; stats = []; while iter_info['count'] < maxiter:. # increment iteration/ save old vals; iter_inf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:27050,perform,performed,27050,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,4,['perform'],['performed']
Performance," of the singlet. Uses TCSCF orbitals. fnocc5; Test FNO-DF-CCSD(T) energy. mints-benchmark; run some BLAS benchmarks. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. mbis-1; MBIS calculation on H2O. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. dft-reference; MP2 with a PBE0 reference computation. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. cubeprop-esp; RHF orbitals and density for water. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. linK-2; RKS Linear Exchange Algorithm test for benzene. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. tdscf-1; td-uhf test on triplet states of methylene (rpa). dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. fnocc4; Test FNO-DF-CCSD(T) energy. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:31020,optimiz,optimization,31020,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,4,['optimiz'],"['optimization', 'optimized']"
Performance," of the transitions and can be used to form; spectroscopic observables, such as oscillator and rotatory strengths.; The \(\mathbf{A}\) and \(\mathbf{B}\) matrices appearing on the left-hand side are; the blocks of the molecular electronic; Hessian, [Norman2018-tn]; whose dimensionality is \((OV)^{2}\), with \(O\) and \(V\) the number of occupied and; virtual molecular orbitals, respectively.; This prevents explicit formation of the full Hessian, and subspace iteration; methods need to be used to extract the first few roots.; In such methods, the eigenvectors are expanded in a subspace of trial vectors,; whose dimensionality is greatly lower than that of the full eigenproblem.; The Hessian is projected down to this subspace where conventional full; diagonalization algorithms can be applied. The subspace is augmented with new; trial vectors, until a suitable convergence criterion is met.; The efficiency of the subspace solver is determined by the first half-projection; of the Hessian in the trial subspace, that is, by the efficiency of the routines; performing the matrix-vector products.; It is essential to note that, despite the hermiticity of the molecular; electronic Hessian, the response eigenvalue equation is not an Hermitian; eigenproblem, due to the nonunit metric on the right-hand side. Indeed the Davidson; solver, the standard subspace iteration method in quantum chemistry,; demonstrates very poor convergence, sometimes manifesting as spurious complex; eigenvalues.; The eigenproblem however has Hamiltonian symmetry: the; roots appear in pairs \((\omega_{n}, -\omega_{n})\), as do the eigenvectors.; A robust subspace solver should preserve the Hamiltonian symmetry, by enforcing; the paired structure on the trial vectors themselves.; Since PSI4 employs real orbitals, the response eigenproblem can be brought; to the form:. \[(\mathbf{A} - \mathbf{B})(\mathbf{A} + \mathbf{B})| \mathbf{X}_{n} + \mathbf{Y}_{n}\rangle; =; \omega^{2}_{n} | \mathbf{X}_{n} + \mathbf{Y}_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tdscf.html:5817,perform,performing,5817,psi4manual/master/tdscf.html,https://psicode.org,https://psicode.org/psi4manual/master/tdscf.html,9,['perform'],['performing']
Performance," of vectors to store for DIIS extrapolation. Type: integer; Default: 8. MP2_SCALE_OS¶. Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. MP2_SCALE_SS¶. Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0/3.0. DIPMOM¶. Compute the dipole moment? Note that quadrupole moments will also be computed if PRINT >= 2. Type: boolean; Default: false. CEPA_VABCD_DIRECT¶. Use integral-direct implementation of the (ac|bd) t(ij,cd) contraction? AO integrals will be generated on the fly. The CEPA iterations will be slower, but the AO->MO integral transform will be faster, and the out-of-core sort of the (AC|BD) integrals will be avoided. Type: boolean; Default: false. Advanced Coupled Pair Keywords¶. CEPA_LEVEL¶. Which coupled-pair method is called? This parameter is used internally by the python driver. Changing its value won’t have any effect on the procedure. Type: string; Default: CEPA(0). SCS_CEPA¶. Perform SCS-CEPA? If true, note that the default values for the spin component scaling factors are optimized for the CCSD method. Type: boolean; Default: false. CEPA_SCALE_OS¶. Oppposite-spin scaling factor for SCS-CEPA. Type: double; Default: 1.27. CEPA_SCALE_SS¶. Same-spin scaling factor for SCS-CEPA. Type: double; Default: 1.13. CEPA_NO_SINGLES¶. Flag to exclude singly excited configurations from the computation. Note that this algorithm is not optimized for doubles-only computations. Type: boolean; Default: false. Table Of Contents. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; BASIS; FREEZE_CORE; R_CONVERGENCE; MAXITER; DIIS_MAX_VECS; MP2_SCALE_OS; MP2_SCALE_SS; DIPMOM; CEPA_VABCD_DIRECT. Advanced Coupled Pair Keywords; CEPA_LEVEL; SCS_CEPA; CEPA_SCALE_OS; CEPA_SCALE_SS; CEPA_NO_SINGLES. Previous topic; SAPT: Symmetry-Adapted Perturbation Theory; Next topic; CC: Coupled Cluster Methods; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cepa-1.html:5139,Perform,Perform,5139,psi4manual/4.0b3/cepa-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cepa-1.html,4,"['Perform', 'optimiz']","['Perform', 'optimized']"
Performance," of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCRESPONSE); CCRESPONSE — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCAL_WEAKP (CCSORT); CCSORT — Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique avaliable option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS); GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_ATTEMPTS (SCF); SCF (Expert) — When using STABILITY_ANALYSIS = FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. MAX_CCD_DIISVECS (SAPT); SAPT — Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MAX_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:154922,perform,performed,154922,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance," of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 20. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/optking-1.html:2891,optimiz,optimization,2891,psi4manual/4.0b2/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html,2,['optimiz'],['optimization']
Performance," of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:3423,optimiz,optimization,3423,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,2,['optimiz'],['optimization']
Performance," on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True). The program will do the same optimization as in our p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:6919,OPTIMIZ,OPTIMIZED,6919,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['OPTIMIZ'],['OPTIMIZED']
Performance," on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True, dertype=1). The program will do the same optimization as in our previ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:7557,OPTIMIZ,OPTIMIZED,7557,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,9,['OPTIMIZ'],['OPTIMIZED']
Performance," on the def2 fitting bases.; The same basis “block” syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; set df_basis_mp2 cc-pvdz-ri. or. df_basis_mp2 {; assign cc-pVDZ-RI; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; df_basis_mp2 {; assign C aug-cc-pVDZ-RI; }. Decontracted Basis Sets¶; Decontraction of the basis set can be useful in certain situations. In; order to decontract a given basis set, simply add “-decon” to the name; of the primary basis set (e.g. decontract).; set basis cc-pvdz-decon. Obviously this will add significantly to the computational cost of any given calculation, however it can; be useful when checking the basis set dependence of a particular calculated property or in certain situations; where a large basis set is critical. Currently it is recommended that a decontracted basis is always used when performing relativistic calculations using the X2C Hamiltonian. User-Defined Basis Sets¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. There are three routes by which a basis set in G94 format can be introduced to PSI4‘s notice.; (1) Install new basis set file into PSI4 basis library.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Name the file with the name of the basis set and a .gbs extension,; after app",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/basissets.html:6642,perform,performing,6642,psi4manual/master/basissets.html,https://psicode.org,https://psicode.org/psi4manual/master/basissets.html,9,['perform'],['performing']
Performance," on the output file. If the; deviation is greater than a few hundredths, it is advisable to switch to a; ROHF to avoid this “spin-contamination” problem. Restricted Open-Shell Hartree–Fock (ROHF)Appropriate for open-shell systems where spin-contamination is problem.; Sometimes more difficult to converge, and assumes uniformly positive spin; polarization (the alpha and beta doubly-occupied orbitals are identical). Constrained Unrestricted Hartree–Fock (CUHF)A variant of ROHF that starts from a UHF ansatz and is therefore often; easier to converge. These can be invoked by the REFERENCE keyword, which defaults to RHF.; The charge and multiplicity may either be specified in the molecule definition:; molecule h {; 0 2 # Neutral doublet; H; }. or, dynamically, by setting the relevant attributes in the Python molecule; object:; h.set_molecular_charge(0); h.set_multiplicity(2). Abelian spatial symmetry is fully supported in PSI4 and can be used to; obtain physical interpretation of the molecular orbitals, to assist in difficult; convergence cases, and, in some methods, to obtain significant performance; gains. The point group of the molecule is inferred when reading the molecule; section, and may be overridden by the symmetry flag, as in:; molecule h {; 0 2; H; symmetry c1; }. or by the reset_point_group Python molecule attribute:; h.reset_point_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; \(C_{2v}\) water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3, 0, 1, 1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Broken Symmetry¶; For certain problems, such diradicals, allowing the spin-up and spin-dow",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:9861,perform,performance,9861,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,9,['perform'],['performance']
Performance," one_electron_integrals() psi4.core.MintsHelper method, [1], [2]. OneBodyAOInt class in psi4.core, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). OrbitalSpace class in psi4.core, [1]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt attribute, [1]. psi4.core.OneBodyAOInt attribute, [1], [2]. psi4.core.OverlapInt attribute, [1]. psi4.core.PotentialInt attribute, [1]. psi4.core.PseudospectralInt attribute, [1]. psi4.core.QuadrupoleInt attribute, [1]. psi4.core.TracelessQuadrupoleInt attribute, [1]. original_coef() psi4.core.GaussianShell method, [1], [2]. ORTH_TYPE (DFOCC). (OCC). outfile_name() in module psi4.core, [1]. output. ; SAPT. cbs(). database(). geometry optimization. vibrational analysis. overlap_3c() psi4.core.IntegralFactory method, [1], [2]. OVERLAP_CHECK (CCEOM). OverlapInt class in psi4.core, [1]. P. p psi4.core.AOShellCombinationsIterator attribute, [1],",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:72045,Optimiz,Optimized,72045,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['Optimiz'],['Optimized']
Performance," opt of C2h methane dimer with user-combined reference points. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ao-casscf-sp; CASSCF/6-31G** energy point. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. fnocc6; Test method/basis with disk_df. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cepa1; cc-pvdz H2O Test CEPA(1) Energy. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. ao-dfcasscf-sp; CASSCF/6-31G** energy point. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:39565,perform,performs,39565,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance," optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC)¶OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. OPT_RESTART (OPTKING)¶OPTKING — Restart the optimization from optking’s written history. Type: double; Default: 0. OPT_TYPE (OPTKING)¶OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC)¶DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC)¶OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (DFOCC)¶DFOCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORB_RESP_SOLVER (OCC)¶OCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORBITAL_LEVEL_SHIFT (DCT)¶DCT (Exper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:191300,optimiz,optimize,191300,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,4,['optimiz'],['optimize']
Performance," optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR); CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. CFOUR_GIAO (CFOUR); CFOUR — Specifies whether gauge-including atomic orbitals are used (ON) or not (OFF). Default: ON for CFOUR_PROPS =NMR and =MAGNETIC, otherwise OFF. Type: string; Possible Values: ON, OFF; Default: No Default. CFOUR_GRID (CFOUR); CFOUR — Keyword used to control type of grid calculation (see later section in this manual). Options are OFF (=0), no grid calculation; CARTESIAN (=1), steps are in Cartesian coordinates (which must be run with CFOUR_COORDINATES =CARTESIAN); INTERNAL (=2), steps are in Z-matrix internal coordinates; QUADRATURE (=3) steps are chosen for an integration based on Gauss-Hermite quadrature. (Default: OFF). Type: string; Possible Values: OFF, CARTESIAN, INTERNAL, QUADRATURE; Default: OFF. CFOUR_GUESS (CFOUR); CFOUR — Where the initi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:49165,optimiz,optimization,49165,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,8,['optimiz'],['optimization']
Performance," optimizer, which begins; from a Cartesian representation of the system. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:2897,optimiz,optimization,2897,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,8,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance," optimizer, which begins; from a Cartesian representation of the system. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/optking-1.html:2899,optimiz,optimization,2899,psi4manual/1.2.1/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/optking-1.html,18,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance," optimzation, with Cartesian input. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. mom-h2o-4; MOM excitation from LUMO HOMO+4. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. cdremp-2; Cholesky decomposed REMP/cc-pVDZ energies for the CH3 radical. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. extern4; External potential calculation involving a TIP3P water and a QM water. Gradient on the external charges is compared to gradient on the QM atoms to v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:16217,optimiz,optimization,16217,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,4,"['Perform', 'optimiz']","['Performs', 'optimization']"
Performance," option if the induction energy is not going to be used. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. Expert¶. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. Table Of Contents. SAPT; General; AIO_CPHF; AIO_DF_INTS; BASIS; DENOMINATOR_ALGORITHM; DENOMINATOR_DELTA; DF_BASIS_ELST; DF_BASIS_SAPT; D_CONVERGENCE; E_CONVERGENCE; FREEZE_CORE; INTS_TOLERANCE; MAXITER; NAT_ORBS; NAT_ORBS_T2; NO_RESPONSE; OCC_TOLERANCE; PRINT; SAPT_LEVEL; SAPT_MEM_CHECK; SAPT_MEM_SAFETY; SAPT_OS_SCALE; SAPT_SS_SCALE. Expert; DO_THIRD_ORDER. Previous topic; REFERENCE; Next topic; AIO_CPHF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__sapt-1.html:4185,perform,performed,4185,psi4manual/4.0b2/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__sapt-1.html,2,['perform'],['performed']
Performance," options (scf_type) being set global or local. This input uses local. scf-response2; Compute the dipole polarizability for water with custom basis set. scf-guess-read3; Test if the the guess read in the same basis converges. scf-level-shift-uhf; SCF level shift on a UHF computation. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. freq-masses; check nonphysical masses possible. scf-level-shift-cuhf; SCF level shift on a CUHF computation. dft-freq-analytic1; Analytic SVWN frequencies, compared to finite difference values. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. mbis-2; MBIS calculation on OH- (Expanded Arrays). sapt-sf1; Tests the Psi4 SF-SAPT code. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. cc13d; Tests analytic CC2 gradients. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. fsapt-ext-abc2; FSAPT with external charge on dimer. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:14660,optimiz,optimization,14660,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance," or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:23031,perform,performance,23031,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance," orbital approximations for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? This approximation is promising for accuracy and computational savings, but it has not been rigorously tested. Type: boolean; Default: false. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/sapt-1.html:12812,perform,performs,12812,psi4manual/4.0b3/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/sapt-1.html,6,['perform'],['performs']
Performance," orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP3L_ENERGY¶. Do compute mp3l energy? In order to this option to be valid one should use “TPDM_ABCD_TYPE COMPUTE” option. Type: boolean; Default: false. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OMP3_ORBS_PRINT¶. Do print OMP3 orbital energies?. Type: boolean; Default: false. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_SCALE¶. Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contributi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html:3234,optimiz,optimization,3234,psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,2,['optimiz'],['optimization']
Performance," orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the OMP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp2] and [Bozkaya:2011:omp3]. Methods¶; The orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. omp2; Orbital-Optimized MP2; Y; Y; RHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/UHF/RKS/UKS. scs-mi-omp2; A special version of SCS-OMP2 (from S22 database); Y; N; RHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/UHF/RKS/UKS. The orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. omp3; Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:4257,optimiz,optimized,4257,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,2,['optimiz'],['optimized']
Performance," orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: UHF, RHF, ROHF; Default: RHF. RESPONSE_ALGORITHM¶. Algorithm to use for the solution of DC-06 response equations in computation of analytic gradients and properties. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: TWOSTEP. R_CONVERGENCE¶. Convergence criterion for the RMS of the residual vector in density cumulant updates, as well as the solution of the density cumulant and orbital response equations. In the orbital updates controls the RMS of the SCF error vector. Type: conv double; Default: 1e-10. THREE_PARTICLE¶. Whether to compute three-particle energy correction or not. Type: string; Possible Values: NONE, PERTURBATIVE; Default: NONE. Expert¶. CACHELEVEL¶. Controls how to cache quantities within the DPD library. Type: integer; Default: 2. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the orbital update procedure: 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DCFT_GUESS¶. Whether to read the orbitals from a previous computation, or to compute an MP2 guess. Type: string; Possible Values: CC, BCC, MP2, DCFT; Default: MP2. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 3. ENERGY_LEVEL_SHIFT¶. Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dcft-1.html:4174,CACHE,CACHELEVEL,4174,psi4manual/1.0.0/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dcft-1.html,6,['CACHE'],['CACHELEVEL']
Performance," orbitals. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. phi-ao; Test computing values of basis functions (puream and non-puream) at points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mbis-6; MBIS calculation on H2O. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc13b; Tests RHF CCSD(T)gradients. soscf-large; Second-order SCF convergnece: Benzene. mints-helper; A general test of the MintsHelper function. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. extern3; External potential calculation with one Ghost atom and on",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:26942,Optimiz,Optimize,26942,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['Optimiz'],['Optimize']
Performance," orbitals?. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 0.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html:3189,perform,performing,3189,psi4manual/1.3.2/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html,2,['perform'],['performing']
Performance," other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, crea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:6079,Load,Load,6079,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,2,['Load'],['Load']
Performance," other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import psi4; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; psi4.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/plugins-1.html:6079,Load,Load,6079,psi4manual/4.0b5/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/plugins-1.html,2,['Load'],['Load']
Performance," p4const import *; import p4util; import psi4; import collections; import shelve; import copy; import sys; import inspect; import os; # Relative hack for now; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile(inspect.currentframe()))[0], ""../""))); sys.path.append(path_dir); from . import findif_response_utils. [docs]def run_roa(name, **kwargs):; """"""; Main driver for managing Raman Optical activity computations with; CC response theory. Uses distributed finite differences approach -->; 1. Sets up a database to keep track of running/finished/waiting; computations.; 2. Generates separate input files for displaced geometries.; 3. When all displacements are run, collects the necessary information; from each displaced computation, and computes final result.; """""". # Get list of omega values -> Make sure we only have one wavelength; # Catch this now before any real work gets done; omega = psi4.get_option('CCRESPONSE', 'OMEGA'); if len(omega) > 2:; raise Exception('ROA scattering can only be performed for one wavelength.'); else:; pass. psi4.print_out(; 'Running ROA computation. Subdirectories for each '; 'required displaced geometry have been created.\n\n'). dbno = 0; # Initialize database; db = shelve.open('database', writeback=True); # Check if final result is in here; # ->if we have already computed roa, back up the dict; # ->copy it setting this flag to false and continue; if ('roa_computed' in db) and ( db['roa_computed'] ):; db2 = shelve.open('.database.bak{}'.format(dbno), writeback=True); dbno += 1; for key,value in db.iteritems():; db2[key]=value. db2.close(); db['roa_computed'] = False; else:; db['roa_computed'] = False. if 'inputs_generated' not in db:; findif_response_utils.initialize_database(db,name,""roa"", [""roa_tensor""]). # Generate input files; if not db['inputs_generated']:; findif_response_utils.generate_inputs(db,name); # handled by helper db['inputs_generated'] = True. # Check job status; if db['inputs_generated'] and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/roa.html:2251,perform,performed,2251,psi4manual/1.0.0/_modules/procedures/roa.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/roa.html,1,['perform'],['performed']
Performance," pair energies?. Type: boolean; Default: false. T2_COUPLED¶. Type: boolean; Default: false. T3_WS_INCORE¶. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Expert¶. AO_BASIS¶. The algorithm to use for the \(\left\langle VV||VV\right\rangle\) terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. FORCE_RESTART¶. Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Possible Values: CCSD, CCSD_T, CCSD_AT, EOM_CCSD, LEOM_CCSD, BCCD, BCCD_T, CC2, CC3, EOM_CC2, EOM_CC3, CCSD_MVD; Default: NONE. table of contents. CCENERGY; General; ABCD; ANALYZE; BCCD_MAXITER; BRUECKNER_ORBS_R_CONVERGENCE; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC_OS_SCALE; CC_SS_SCALE; DIIS; E_CONVERGENCE; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; MP2_AMPS_PRINT; MP2_OS_SCALE; MP2_SS_SCALE; NEW_TRIPLES; NUM_AMPS_PRINT; PAIR_ENERGIES_PRINT; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SCSN_MP2; SCS_CCSD; SCS_MP2; SEMICANONICAL; SPINADAPT_ENERGIES; T2_COUPLED; T3_WS_INCORE. Expert; AO_BASIS; FORCE_RESTART; WFN. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__ccenergy-1.html:6864,CACHE,CACHELEVEL,6864,psi4manual/1.1.0/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__ccenergy-1.html,4,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance," pair natural orbital domains (DLPNO) [manual]. scs-dlpno-mp2; spin-component-scaled DLPNO MP2 [manual]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. scs-mp3; spin-component scaled MP3 [manual]. sos-pi-mp2; A special version of SOS-MP2 for pi systems [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual] [details]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order Møller–Plesset (MP) perturbation theory [manual] [details]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. scs-omp2; spin-component scaled OMP2 [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. scs-omp3; spin-component scaled OMP3 [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. omp2.5; orbital-optimized MP2.5 [manual] [details]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual] [details]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual] [details]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual] [details]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual] [details]. fno-aqcc; AQCC with frozen natural orbitals [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual] [details]. fno-qcisd; QCISD with frozen natural orbitals [manual]. remp2; 2nd-order retaining-the-excitation-de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/energy.html:3684,optimiz,optimized,3684,psi4manual/master/energy.html,https://psicode.org,https://psicode.org/psi4manual/master/energy.html,8,['optimiz'],['optimized']
Performance," pairs. Type: string; Default: NONE. LOCAL_WEAKP (CIS); CIS — Desired treatment of “weak pairs” in the local-CIS method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. LOCK_OCC (DCFT); DCFT (Expert) — Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. M_FILE (TRANSQT); TRANSQT — Output integrals file. Type: integer; Default: 0. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS); GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_BUCKETS (TRANSQT); TRANSQT — Maximum buckets. Type: integer; Default: 499. MAX_CCD_DIISVECS (SAPT); SAPT — Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MAX_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING); OPTKING — Conver",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:73536,perform,performed,73536,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance," pairs. Type: string; Default: NONE. LOCAL_WEAKP (CIS); CIS — Desired treatment of “weak pairs” in the local-CIS method. A value of NEGLECT ignores weak pairs entirely. A value of NONE treats weak pairs in the same manner as strong pairs. A value of MP2 uses second-order perturbation theory to correct the local-CIS energy computed with weak pairs ignored. Type: string; Possible Values: MP2, NEGLECT, NONE; Default: MP2. LOCK_OCC (DCFT); DCFT (Expert) — Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. LOCK_SINGLET (PSIMRCC); PSIMRCC — Do lock onto a singlet root?. Type: boolean; Default: false. LSE (DETCI); DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI); DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI); DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. M_FILE (TRANSQT); TRANSQT — Output integrals file. Type: integer; Default: 0. MADMP2_SLEEP (DFMP2); DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS); GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_BUCKETS (TRANSQT); TRANSQT — Maximum buckets. Type: integer; Default: 499. MAX_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:69271,perform,performed,69271,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance," parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mp2(...); mp2() -> float :; Runs the conventional (slow) MP2 code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like notation) to the output file.; ; print_variables(...); print_variables() -> None :; Prints ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:110890,optimiz,optimization,110890,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['optimiz'],['optimization']
Performance," pass. """"""; msg = '\t{0:.<66}PASSED'.format(label); print(msg); sys.stdout.flush(); psi4.print_out(msg + '\n'). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; message = (""\t%s: computed value (%.*f) does not match (%.*f) to %d decimal places."" % (label, digits+1, computed, digits+1, expected, digits)); if (abs(expected - computed) > 10 ** (-digits)):; print(message); raise TestComparisonError(message); if ( math.isnan(computed) ):; print(message); print(""\tprobably because the computed value is nan.""); raise TestComparisonError(message); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; message = (""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); raise TestComparisonError(message); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html:4416,Perform,Performs,4416,psi4manual/1.0.0/_modules/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/p4util/util.html,1,['Perform'],['Performs']
Performance," plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:6486,load,loaded,6486,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,4,['load'],['loaded']
Performance," problems import python dependencies. Prints error message; *msg* to standard output stream and output file.; """"""; def __init__(self, msg):; PsiException.__init__(self,msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging and iterative method. Prints; error message *msg* to standard output stream and output file. """"""; def __init__(self, eqn_description, maxit):; msg = ""Could not converge %s in %d iterations."" % (eqn_description, maxit); PsiException.__init__(self, msg); self.message = msg; core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer."""""". def __init__(self, eqn_description, maxit, wfn):; ConvergenceError.__init__(self, eqn_description, maxit); self.wfn = wfn. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not available{5}"""""".format(*circs); else:; msg = """"""{0}: Method '{1}' with {2} '{3}' and REFERENCE '{4}' not directable to QC_MODULE '{5}'"""""".format(*circs); PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class Dftd3Error(PsiException):; """""". """"""; def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nDftd3Error: %s\n\n' % msg. [docs]class PastureRequiredError(PsiException):; """"""Error called when the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/exceptions.html:2936,Optimiz,OptimizationConvergenceError,2936,psi4manual/1.2.1/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/exceptions.html,2,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimizer']"
Performance," procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0. # Does an analytic procedure exist for the requested method?; if dertype == 2:; psi4.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; psi4.set_variable('CURRENT ENERGY', wfn.energy()). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). elif dertype == 1:; psi4.print_out(""""""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_freq_1(moleculeclone, irrep); moleculeclone.reinterpret_coordentry(False); moleculeclone.fix_orientation(True). # Record undisplaced symmetry for projection of diplaced point groups; psi4.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print("""""" %d displacements needed."""""" % ndisp); gradients = []; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """"""# to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """"""# has produced a number of input files (FREQ-*.in) for individual components\n""""""; instru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:65698,perform,perform,65698,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['perform'],['perform']
Performance," processes geometry like psi4 Molecule class. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. scf6; Tests RHF/ROHF/UHF SCF gradients. casscf-sp; CASSCF/6-31G** energy point. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. scf-auto-cholesky; Cholesky filter a complete basis. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). cubeprop-esp; RHF orbitals and density for water. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and sph",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:43008,optimiz,optimization,43008,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance," products in the; bra- and ket- of the \((ov|ov)\)-type Electron Repulsion Integrals (ERIs); appearing in MP2 are cast onto a linear-scaling auxiliary basis by least-squares; fitting. Substitution of the DF factorization into the MP2 equations results in; a formal scaling and prefactor reduction of MP2, and further speed gains are; possible due to heavy utilization of matrix-multiplication kernels and minimal; storage requirements in a DF approach. The method has been found to be quite; robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; MP2 defaults in PSI4 to the density-fitted code. See; MP2_TYPE for performing a MP2 with conventional integrals.; An example utilization of the code is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted \((Q|ov)\) integrals and then builds the; full \((ov|ov)\) tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19---------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dfmp2-1.html:1769,perform,performing,1769,psi4manual/1.1.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dfmp2-1.html,6,['perform'],['performing']
Performance," products in the; bra- and ket- of the \((ov|ov)\)-type Electron Repulsion Integrals (ERIs); appearing in MP2 are cast onto a linear-scaling auxiliary basis by least-squares; fitting. Substitution of the DF factorization into the MP2 equations results in; a formal scaling and prefactor reduction of MP2, and further speed gains are; possible due to heavy utilization of matrix-multiplication kernels and minimal; storage requirements in a DF approach. The method has been found to be quite; robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; MP2 defaults in PSI4 to the density-fitted code. See; MP2_TYPE for performing a MP2 with conventional integrals.; An example utilization of the code is:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set basis cc-pvdz; set scf_type df; set freeze_core True. energy('mp2'). The energy('mp2') call to energy() executes; the predefined DF-MP2 procedure, first calling; the SCF module with a default RHF reference and DF algorithm for the; two-electron integrals. When the orbitals are converged, the DF-MP2 module is; launched, which forms the density-fitted \((Q|ov)\) integrals and then builds the; full \((ov|ov)\) tensor in blocks, evaluating the contributions to the MP2 energy; as it goes. A RHF-MP2 wavefunction is selected automatically due to the RHF; reference. In this example, we freeze the core, both for efficiency and; because split-valence bases like cc-pVDZ do not contain core correlation; functions. The result looks something like:; -----------------------------------------------------------; ==================> DF-MP2 Energies <====================; ---",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dfmp2-1.html:1838,perform,performing,1838,psi4manual/1.4.0/dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dfmp2-1.html,5,['perform'],['performing']
Performance," program binary (gcp) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.interface_gcp.run_gcp(self, func=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/gcp-1.html:2108,optimiz,optimization,2108,psi4manual/1.3.2/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/gcp-1.html,2,['optimiz'],['optimization']
Performance," program binary (gcp) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; 1energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; 1optimize('pbeh3c'). HF-3c with non-standard basis; 1; 2set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; 1; 2set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.interface_gcp.run_gcp(self, func=None, dertype=None, verbose=False)[source]¶; Function to call Grimme’s dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level dashlvl using parameters for; the functional func. The dictionary dashparam can be used to supply; a full set of dispers",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/gcp-1.html:1949,optimiz,optimization,1949,psi4manual/1.1.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/gcp-1.html,4,['optimiz'],['optimization']
Performance," properties for Potassium nitrate (rocket fuel!). omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. adc2; ADC(2)/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. pubchem2; Superficial test of PubChem interface. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. casscf-fzc-sp; CASSCF/6-31G** energy point. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. fci-h2o-2; 6-31G H2O Test FCI Energy Point. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. mom-h2o-4; MOM excitation from LUMO HOMO+4. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:3768,optimiz,optimization,3768,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,4,['optimiz'],"['optimization', 'optimized']"
Performance," provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). mp2-1; All-electron MP2 6-31G** geometry optimization of water. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. pubchem2; Superficial test of PubChem interface. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. aediis-1; ADIIS test case, from 10.1063/1.3304922. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. sapt11; sapt example with orbital freezing with alkali metal and dMP2. dfmp2-4; conventional and density-fitting mp2 test o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/testsuite.html:1557,Optimiz,Optimize,1557,psi4manual/1.7.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/testsuite.html,1,['Optimiz'],['Optimize']
Performance," psi4 in your PATH, either permanently through rc-files or temporarily in this terminal session. You can keep or undo these changes. For general psi4 use, you must enable the psi4 executable to be found through any of:. prepending to PATH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file; activating the conda environment (p4env above) in shell, ~/.bashrc, or PBS cmd file; supplying full path to executable (shell or PBS cmd file). Similarly, the scratch directory (see Scratch Files and Elementary Restart) must be specified through:. defining PSI_SCRATCH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file. Suitable values for these variables have been printed to screen during installation (see last codeblock in step 6). Useful Commands¶. Update to latest PSI4 version; 1>>> conda update psi4. Install into a conda environment “p4env” instead of “root”. Second command only works on bash; for csh/tsch, setenv PATH /path/to/miniconda/envs/p4env/bin:$PATH instead. This creates a sandbox with just PSI4 and python (loaded as dependency).; 1; 2>>> conda create -y -n p4env psi4; >>> source activate p4env. Install a particular PSI4 version; 1>>> conda install psi4=0.1.12. Uninstall PSI4 from current environment; 1>>> conda remove psi4. Troubleshooting¶. If the target computer doesn’t have libc >= 2.7 (released c.2007; for reference, 2.10 is newer than 2.7; unlike most libraries, libc generally not available in multiple versions on a computer), the PSI4 conda package won’t work.; 1; 2; 3; 4; 5; 6# unsuitable computer; >>> ldd --version; ldd (GNU libc) 2.5; # suitable computer; >>> ldd --version; ldd (GNU libc) 2.17. It is of greatest importance that the PSI4 executable be linked against conda libpython.so not against any system libpython.so. This is arranged by setting RPATH to seek libraries relative to executable (thanks, conda binary relocation routine!). The conda PSI4 executable is not vulnerable to interference from your LD_LIBRARY_PATH settings. Below shows a well-linked executab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/conda-1.html:18484,load,loaded,18484,psi4manual/1.1.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/conda-1.html,2,['load'],['loaded']
Performance," psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.VBase method, [1], [2]. fx() psi4.core.Molecule method, [1], [2]. fy() psi4.core.Molecule method, [1], [2]. fZ() psi4.core.Molecule method, [1], [2]. fz() psi4.core.Molecule method, [1], [2]. G. G_CONVERGENCE (OPTKING). GAUGE (CCDENSITY). (CCRESPONSE). Gaussian Formatted Checkpoint. Gaussian94BasisSetParser class in psi4.core, [1]. GaussianShell class in psi4.core, [1]. GaussianType class in psi4.core, [1]. gCP. GDMA. gdma() in module psi4. in module psi4.driver. GDMA_LIMIT (GDMA). GDMA_MULTIPOLE_UNITS (GDMA). GDMA_ORIGIN (GDMA). GDMA_RADIUS (GDMA). GDMA_SWITCH (GDMA). gemm() psi4.core.Matrix method, [1], [2]. genbas() psi4.core.BasisSet method, [1], [2]. general. ; setting keywords. GEOM_MAXITER (OPTKING). geometry optimization. ; IRC. constrained. convergence criteria. function call. minima. output. transition state. geometry optimization, optimization. geometry() in module psi4.driver. psi4.core.Molecule method, [1], [2]. GeometryUnits class in psi4.core, [1]. get() psi4.core.IntVector method, [1], [2]. psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. get_active_efp() in module psi4.core, [1]. get_active_molecule() in module psi4.core, [1]. get_algorithm() psi4.core.FittingMetric method, [1], [2]. get_array() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. get_array_variable() in module psi4.core, [1]. get_array_variables() in module psi4.core, [1]. get_atomic_point_charges() in module psi4.core, [1]. get_basisset() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. get",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:48744,optimiz,optimization,48744,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,4,['optimiz'],['optimization']
Performance," psi4.core.JK method. psi4.core.MemDFJK method. c_functional() psi4.core.SuperFunctional method. c_functionals() psi4.core.SuperFunctional method. C_left_add() psi4.core.DirectJK method. psi4.core.JK method. psi4.core.MemDFJK method. c_omega() psi4.core.SuperFunctional method. c_os_alpha() psi4.core.SuperFunctional method. C_right_add() psi4.core.DirectJK method. psi4.core.JK method. psi4.core.MemDFJK method. c_ss_alpha() psi4.core.SuperFunctional method. Ca() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.SADGuess method. psi4.core.UHF method. psi4.core.Wavefunction method. Ca_subset() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. CACHELEVEL (ADC). (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (DCT). (OCC). CACHETYPE (CCENERGY). (CCEOM). CALC_S_SQUARED (DETCI). CANONICALIZE_ACTIVE_FAVG (MCSCF). CANONICALIZE_INACTIVE_FAVG (MCSCF). CART_HESS_READ (OPTKING). Cartesian psi4.core.GaussianType attribute. Cb() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.SADGuess method. psi4.core.UHF method. psi4.core.Wavefunction method. Cb_subset() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. CBS CORRELATION ENERGY. CBS REFERENCE ENERGY. CBS TOTAL ENERGY. cbs(). ; extrapolation schemes. output. setting keywords. theory, [1], [2]. cbs() in module psi4.driv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:16685,CACHE,CACHELEVEL,16685,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['CACHE'],['CACHELEVEL']
Performance, psi4.core.Molecule static method. from_file() psi4.core.Wavefunction static method. from_list() psi4.core.Dimension class method. psi4.core.Matrix class method. psi4.core.Vector class method. from_schema() psi4.core.Molecule class method. from_serial() psi4.core.Matrix class method. psi4.core.Vector class method. from_string() psi4.core.Molecule class method. Frozen natural orbital coupled cluster. Frozen Natural Orbitals. FROZEN_BEND (OPTKING). FROZEN_CARTESIAN (OPTKING). FROZEN_DIHEDRAL (OPTKING). FROZEN_DISTANCE (OPTKING). FROZEN_DOCC (GLOBALS). FROZEN_OOFP (OPTKING). FROZEN_UOCC (GLOBALS). frzcpi() psi4.core.Wavefunction method. frzvpi() psi4.core.Wavefunction method. fsymbol() psi4.core.Molecule method. ftrue_atomic_number() psi4.core.Molecule method. Full psi4.core.SaveType attribute. full_geometry() psi4.core.Molecule method. FULL_HESS_EVERY (OPTKING). FULL_MATRIX (CCEOM). full_name() psi4.core.PointGroup method. full_pg_n() psi4.core.Molecule method. function call. ; geometry optimization. gradient. hessian. vibrational analysis. function_index psi4.core.GaussianShell attribute. function_to_center() psi4.core.BasisSet method. function_to_shell() psi4.core.BasisSet method. Functional class in psi4.core. functional() psi4.core.HF method. psi4.core.VBase method. functionals. functions_local_to_global() psi4.core.BlockOPoints method. fx() psi4.core.Molecule method. fy() psi4.core.Molecule method. fZ() psi4.core.Molecule method. fz() psi4.core.Molecule method. fzc() psi4.core.MOSpace static method. fzv() psi4.core.MOSpace static method. G. G_CONVERGENCE (OPTKING). gamma psi4.driver.p4util.Lineshape attribute. gamma() psi4.core.CharacterTable method. gau2grid. GAUGE (ADC). (CCDENSITY). (CCRESPONSE). Gaussian class in psi4.driver.p4util. Gaussian Formatted Checkpoint. GaussianShell class in psi4.core. GaussianType class in psi4.core. gCP. GDMA. gdma() in module psi4.driver. GDMA_LIMIT (GDMA). GDMA_MULTIPOLE_UNITS (GDMA). GDMA_ORIGIN (GDMA). GDMA_RADIUS (GDMA). GDMA,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:54610,optimiz,optimization,54610,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['optimiz'],['optimization']
Performance," psi4.core.SOMCSCF method. compute_shell() psi4.core.OneBodyAOInt method. psi4.core.ThreeCenterOverlapInt method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. compute_spin_contamination() psi4.core.HF method. compute_state_transfer() psi4.core.CIWavefunction method. COMPUTE_TRIPLES (FNOCC). compute_V() psi4.core.VBase method. compute_Vx() psi4.core.VBase method. computed psi4.driver.AtomicComputer attribute. computed_shells_per_iter() psi4.core.JK method. computeExternExternInteraction() psi4.core.ExternalPotential method. computeNuclearEnergy() psi4.core.ExternalPotential method. computePotentialMatrix() psi4.core.ExternalPotential method. computer psi4.driver.driver_findif.FiniteDifferenceComputer attribute. CONDA_PREFIX, [1]. connectivity() psi4.core.Molecule method. CONSECUTIVE_BACKSTEPS (OPTKING). construct_from_pydict() psi4.core.BasisSet static method. contact. continuum solvation, [1]. converged psi4.core.Localizer attribute. convergence criteria. ; geometry optimization. ConvergenceError. copy() psi4.core.CIVector method. psi4.core.IntVector method. psi4.core.Matrix method. psi4.core.Vector method. copy_file_from_scratch() in module psi4.driver. in module psi4.driver.p4util. copy_file_to_scratch() in module psi4.driver. in module psi4.driver.p4util. copy_lower_to_upper() psi4.core.Matrix method. copy_upper_to_lower() psi4.core.Matrix method. core_hamiltonian_grad() psi4.core.MintsHelper method. corl_xtpl_helgaker_2() in module psi4.driver.driver_cbs_helper. CORR_ANSATZ (PSIMRCC). CORR_CCSD_T (PSIMRCC). CORR_CHARGE (PSIMRCC). CORR_MULTP (PSIMRCC). CORR_WFN (PSIMRCC). Correlated psi4.core.DerivCalcType attribute. CorrelationFactor class in psi4.core. CorrelationTable class in psi4.core. COSMO. COSX_BASIS_TOLERANCE (SCF). COSX_DENSITY_TOLERANCE (SCF). COSX_INTS_TOLERANCE (SCF). COSX_OVERLAP_FITTING (SCF). COSX_PRUNING_SCHEME (SCF). COSX_RADIAL_POINTS_FINAL (SCF). COSX_RADIAL_POINTS_INITIAL (SCF). COSX_SPHERICAL_POINTS_FINAL (SCF). COSX_SPHERI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:30208,optimiz,optimization,30208,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['optimiz'],['optimization']
Performance," psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cep",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:227065,Perform,Performs,227065,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['Perform'],['Performs']
Performance, psi4.driver.compare_matrices; psi4.driver.compare_strings; psi4.driver.compare_values; psi4.driver.compare_vectors; psi4.driver.ConvergenceError; psi4.driver.copy_file_from_scratch; psi4.driver.copy_file_to_scratch; psi4.driver.create_plugin; psi4.driver.csx2endict; psi4.driver.CSXError; psi4.driver.cubeprop; psi4.driver.Dftd3Error; psi4.driver.dynamic_variable_bind; psi4.driver.EmpericalDispersion; psi4.driver.energy; psi4.driver.extract_cluster_indexing; psi4.driver.extract_clusters; psi4.driver.fchk; psi4.driver.filter_comments; psi4.driver.find_approximate_string_matches; psi4.driver.freq; psi4.driver.frequencies; psi4.driver.frequency; psi4.driver.gdma; psi4.driver.geometry; psi4.driver.get_memory; psi4.driver.getFromDict; psi4.driver.gradient; psi4.driver.hessian; psi4.driver.join_path; psi4.driver.levenshtein; psi4.driver.ManagedMethodError; psi4.driver.molden; psi4.driver.molecule_get_attr; psi4.driver.molecule_set_attr; psi4.driver.oeprop; psi4.driver.opt; psi4.driver.optimize; psi4.driver.ParsingError; psi4.driver.PastureRequiredError; psi4.driver.pcm_helper; psi4.driver.print_stderr; psi4.driver.print_stdout; psi4.driver.process_input; psi4.driver.process_pubchem_command; psi4.driver.prop; psi4.driver.property; psi4.driver.PsiException; psi4.driver.PsiImportError; psi4.driver.QMMM; psi4.driver.sanitize_name; psi4.driver.scf_helper; psi4.driver.scf_wavefunction_factory; psi4.driver.set_memory; psi4.driver.set_module_options; psi4.driver.set_options; psi4.driver.success; psi4.driver.Table; psi4.driver.TestComparisonError; psi4.driver.ValidationError; psi4.driver.xml2dict. Appendices; Appendices. /autodir_options_c; ; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:339424,optimiz,optimize,339424,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['optimiz'],['optimize']
Performance, psi4.driver.compare_matrices; psi4.driver.compare_strings; psi4.driver.compare_values; psi4.driver.compare_vectors; psi4.driver.ConvergenceError; psi4.driver.copy_file_from_scratch; psi4.driver.copy_file_to_scratch; psi4.driver.create_plugin; psi4.driver.csx2endict; psi4.driver.CSXError; psi4.driver.cubeprop; psi4.driver.Dftd3Error; psi4.driver.dynamic_variable_bind; psi4.driver.EmpericalDispersion; psi4.driver.energy; psi4.driver.extract_cluster_indexing; psi4.driver.extract_clusters; psi4.driver.fchk; psi4.driver.filter_comments; psi4.driver.find_approximate_string_matches; psi4.driver.freq; psi4.driver.frequencies; psi4.driver.frequency; psi4.driver.gdma; psi4.driver.geometry; psi4.driver.get_memory; psi4.driver.getFromDict; psi4.driver.gradient; psi4.driver.hessian; psi4.driver.join_path; psi4.driver.levenshtein; psi4.driver.ManagedMethodError; psi4.driver.molden; psi4.driver.molecule_get_attr; psi4.driver.molecule_set_attr; psi4.driver.oeprop; psi4.driver.opt; psi4.driver.optimize; psi4.driver.ParsingError; psi4.driver.PastureRequiredError; psi4.driver.pcm_helper; psi4.driver.print_stderr; psi4.driver.print_stdout; psi4.driver.process_input; psi4.driver.process_pubchem_command; psi4.driver.prop; psi4.driver.property; psi4.driver.PsiException; psi4.driver.PsiImportError; psi4.driver.QMMM; psi4.driver.sanitize_name; psi4.driver.scf_helper; psi4.driver.scf_wavefunction_factory; psi4.driver.set_memory; psi4.driver.set_module_options; psi4.driver.set_options; psi4.driver.success; psi4.driver.Table; psi4.driver.TestComparisonError; psi4.driver.ValidationError; psi4.driver.xml2dict. Appendices; Appendices. autodir_options_c; ; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>;,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:298000,optimiz,optimize,298000,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['optimiz'],['optimize']
Performance," psi4.driver.opt(name, **kwargs)¶; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float – Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html:1207,optimiz,optimization,1207,psi4manual/1.7.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html,4,['optimiz'],['optimization']
Performance," psi4.driver.optimize(name, **kwargs)[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.optimize-1.html:1214,optimiz,optimization,1214,psi4manual/1.3.2/api/psi4.driver.optimize-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.optimize-1.html,2,['optimiz'],['optimization']
Performance," psi4.driver.optimize(name, **kwargs)[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.optimize-1.html:1214,optimiz,optimization,1214,psi4manual/1.2.1/api/psi4.driver.optimize-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.optimize-1.html,2,['optimiz'],['optimization']
Performance," psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:7479,perform,perform,7479,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['perform'],['perform']
Performance," psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses cbs() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; cbs() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point energy by this comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs-1.html:27014,optimiz,optimization,27014,psi4manual/1.4.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs-1.html,8,['optimiz'],"['optimization', 'optimize']"
Performance," python files for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples :. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric we",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/db-1.html:5609,Optimiz,Optimize,5609,psi4manual/4.0b3/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/db-1.html,4,"['Optimiz', 'optimiz']","['Optimize', 'optimize']"
Performance," pywrap-align; apply linear fragmentation algorithm to a water cluster. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. cc13c; Tests RHF CCSD(T)gradients. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. casscf-fzc-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. fnocc6; Test method/basis with disk_df. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fci-h2o-2; 6-31G H2O Test FCI Energy Point. dct10; The multiple guesses for DCT amplitudes for ODC-12. mints-benchmark; run some BLAS benchmarks. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using var",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:20622,optimiz,optimization,20622,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance," quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [E_h] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [E_h] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [E_h] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [E_h] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). CURRENT HESSIAN¶; The total electronic Hessian [E_h/a0/a0] of the most recent stage of a; calculation, (3 * {nat}, 3 * {nat}). CUSTOM SCS-MP2 TOTAL ENERGY¶. CUSTOM SCS-MP2 CORRELATION ENERGY¶; Changeable quantities based on options.; The total electronic energy [E_h] and correlation energy component [E_h]; for the MP2-like method formed b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:23798,optimiz,optimizer,23798,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,4,['optimiz'],['optimizer']
Performance," quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:10350,CACHE,CACHELEVEL,10350,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['CACHE'],['CACHELEVEL']
Performance," radical. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). omp2_5-1; OMP2 cc-pVDZ energy for the H2O molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:13098,perform,performed,13098,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['perform'],['performed']
Performance," radical. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). omp2_5-1; OMP2 cc-pVDZ energy for the H2O molecule. fci-dipole; 6-31G H2O Test FCI Energy Point. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. fnocc3; Test FNO-QCISD(T) computation. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:13096,perform,performed,13096,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['perform'],['performed']
Performance," recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with PSI4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user should not specify the entire; physical memory of the system, or swapping is likely. However, for especially large; calculations, it is better to set the memory keyword to a value less than 16 GB.; Set the CACHELEVEL keyword to 0.; This will turn off cacheing, which, for very large calculations, can; lead to heap fragmentation and memory faults, even when sufficient; physical memory exists.; Set the PRINT keyword to 2. This; will help narrow where memory bottlenecks or other errors exist in the; event of a crash. Excited State Coupled Cluster Calculations¶; A complete list of keywords related to; coupled cluster linear response is provided in Appendix CCEOM.; The most important keywords associated with EOM-CC calculations are:. ROOTS_PER_IRREP¶. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. SINGLES_PRINT¶. Do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cc-1.html:6578,CACHE,CACHELEVEL,6578,psi4manual/4.0b5/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cc-1.html,2,['CACHE'],['CACHELEVEL']
Performance," recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with PSI4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user should not specify the entire; physical memory of the system, or swapping is likely. However, for especially large; calculations, it is better to set the memory keyword to a value less than 16 GB.; Set the CACHELEVEL keyword to 0.; This will turn off cacheing, which, for very large calculations, can; lead to heap fragmentation and memory faults, even when sufficient; physical memory exists.; Set the PRINT keyword to 2. This; will help narrow where memory bottlenecks or other errors exist in the; event of a crash. Excited State Coupled Cluster Calculations¶; A complete list of keywords related to; coupled cluster linear response is provided in Appendix CCEOM.; The most important keywords associated with EOM-CC calculations are:. ROOTS_PER_IRREP¶. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. SINGLES_PRINT¶. Do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cc-1.html:6591,CACHE,CACHELEVEL,6591,psi4manual/4.0b4/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cc-1.html,2,['CACHE'],['CACHELEVEL']
Performance," recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with PSI4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user should not specify the entire; physical memory of the system, or swapping is likely. However, for especially large; calculations, it is better to set the memory keyword to a value less than 16 GB.; Set the CACHELEVEL keyword to 0.; This will turn off cacheing, which, for very large calculations, can; lead to heap fragmentation and memory faults, even when sufficient; physical memory exists.; Set the PRINT keyword to 2. This; will help narrow where memory bottlenecks or other errors exist in the; event of a crash. Excited State Coupled Cluster Calculations¶; A complete list of keywords related to; coupled cluster linear response is provided in Appendix CCEOM.; The most important keywords associated with EOM-CC calculations are:. ROOTS_PER_IRREP¶. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-8. SINGLES_PRINT¶. Do print information on the iterative solution to the single-excitation EOM-CC problem used as a gu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cc-1.html:6543,CACHE,CACHELEVEL,6543,psi4manual/4.0b2/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cc-1.html,4,['CACHE'],['CACHELEVEL']
Performance," recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with Psi4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user should not specify the entire; physical memory of the system, or swapping is likely. However, for especially large; calculations, it is better to set the memory keyword to a value less than 16 GB.; Set the CACHELEVEL keyword to 0.; This will turn off cacheing, which, for very large calculations, can; lead to heap fragmentation and memory faults, even when sufficient; physical memory exists.; Set the PRINT keyword to 2. This; will help narrow where memory bottlenecks or other errors exist in the; event of a crash. Excited State Coupled Cluster Calculations¶; A complete list of keywords related to; coupled cluster linear response is provided in Appendix CCEOM.; The most important keywords associated with EOM-CC calculations are:. ROOTS_PER_IRREP¶. Number of excited states per irreducible representation for EOM-CC and CC-LR calculations. Irreps denote the final state symmetry, not the symmetry of the transition. Type: array; Default: No Default. E_CONVERGENCE¶. Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. SINGLES_PRINT¶. Do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cc-1.html:6642,CACHE,CACHELEVEL,6642,psi4manual/1.0.0/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cc-1.html,2,['CACHE'],['CACHELEVEL']
Performance," recognizes that the local DFA is potentially exact at short range in the; exchange hole, and that the hybrid-exchange energy of the noninteracting; quasiparticles is also exact for true electrons at long range in the exchange; hole. Therefore LRC switches from DFA at short range to hybrid exchange at long; range, typically using the function as a; partition function.; Tying all these pieces together, a full LRC-hybrid GKS functional has the; generic form,. For LRC functionals, the choice of range-separtion parameter has; been the subject of considerable activity since the inception of LRC; functionals. Some authors advocate a static range-separation parameter; determined by optimization over a test set of chemical systems. However, a more; physically-motivated and often more accurate approach is the idea of “gap; fitting” or “optimal tuning” or simply “tuning.” The most popular tuned-LRC; approach is IP-fitting, in which the is varied until the; Koopman’s IP (the opposite of the HOMO energy) matches the true IP (the; difference between -electron and -electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. Note that LRC functionals with default only capture the; dependence,. hybrid functionals only capture part of the dependence,. and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. IP-tuned LRC functionals effectively pin the chemical potential at ; electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empiric",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dft-1.html:7162,tune,tuned-LRC,7162,psi4manual/4.0b3/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dft-1.html,10,['tune'],['tuned-LRC']
Performance," redundant ERI computations into the calculation. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting SCF_TYPE to J_alg+K_alg,; where J_alg and K_alg are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively. Alternatively, if one is using; DFT with non-hybrid functionals, a composite Coulomb construction algorithm can be; specified solo by setting SCF_TYPE to J_alg, without the need to set; an associated K_alg.; Specialized algorithms available to construct the Coulomb term within a composite framework; are as follows:. DFDIRJAn integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays; strong performance with large system size through a combination of; effective parallelization and utilization of density-fitting to minimize; ERI computational cost. See the Integral-Direct Density-Fitted Coulomb Construction section for more information. Specialized algorithms available to construct the Exchange term within a composite framework; are as follows:. COSXAn algorithm based on the semi-numerical “chain of spheres exchange” (COSX); approach described in [Neese:2009:98]. The COSX algorithm uses no I/O, scales; well with system size, and requires minimal memory, making it ideal for; large systems and multi-core CPUs. See COSX Exchange for more information. LINKAn implementation of the linear-scaling “Linear Exchange” (LinK); algorithm described in [Ochsenfeld:1998:1663]. The LINK algorithm provides; many of the benefits of integral-direct SCF algorithms, including no disk I/O,; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size; while simultaneously providing a formal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:29198,perform,performance,29198,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,1,['perform'],['performance']
Performance," redundant ERI computations into the calculation. Therefore, composite Fock build; algorithms tend to perform better for larger systems, but worse for smaller systems. Arbitrary; composite algorithms can be accessed by setting SCF_TYPE to J_alg+K_alg,; where J_alg and K_alg are the names of the separate Coulomb; and Exchange construction algorithms to use, respectively. Alternatively, if one is using; DFT with non-hybrid functionals, a composite Coulomb construction algorithm can be; specified solo by setting SCF_TYPE to J_alg, without the need to set; an associated K_alg.; Specialized algorithms available to construct the Coulomb term within a composite framework; are as follows:. DFDIRJAn integral-direct algorithm constructing the Coulomb term based on [Weigend:2002:4285]; The DFDIRJ algorithm combines the benefits of integral-direct SCF approaches; with that of density-fitting. Specifically, DFJ utilizes no I/O and displays; strong performance with large system size through a combination of; effective parallelization and utilization of density-fitting to minimize; ERI computational cost. See the Integral-Direct Density-Fitted Coulomb Construction section for more information. Specialized algorithms available to construct the Exchange term within a composite framework; are as follows:. COSXAn algorithm based on the semi-numerical “chain of spheres exchange” (COSX); approach described in [Neese:2009:98]. The coulomb term is computed with a; direct density-fitting algorithm. The COSX algorithm uses no I/O, scales; well with system size, and requires minimal memory, making it ideal for; large systems and multi-core CPUs. See COSX Exchange for more information. LINKAn implementation of the linear-scaling “Linear Exchange” (LinK); algorithm described in [Ochsenfeld:1998:1663]. The LINK algorithm provides; many of the benefits of integral-direct SCF algorithms, including no disk I/O,; low memory usage, and effective parallelization. Additionally, the; LINK implementatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/scf.html:29191,perform,performance,29191,psi4manual/1.9.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/scf.html,1,['perform'],['performance']
Performance," reference functions?. Type: boolean; Default: false. MP2_CCSD_METHOD (PSIMRCC); PSIMRCC — How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS (PSIMRCC); PSIMRCC — Do start from a MP2 guess?. Type: boolean; Default: true. MP2_OS_SCALE (CCENERGY); CCENERGY — MP2 opposite-spin scaling value. Type: double; Default: 1.20. MP2_OS_SCALE (DFMP2); DFMP2 — OS Scale. Type: double; Default: 6.0/5.0. MP2_OS_SCALE (LMP2); LMP2 — The scale factor used for opposite-spin pairs in SCS computations. Type: double; Default: 6.0/5.0. MP2_OS_SCALE (OCC); OCC — MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SCALE_OS (FNOCC); FNOCC — Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. MP2_SCALE_SS (FNOCC); FNOCC — Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0/3.0. MP2_SOS_SCALE (OCC); OCC — MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2 (OCC); OCC — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE (CCENERGY); CCENERGY — MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (DFMP2); DFMP2 — SS Scale. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (LMP2); LMP2 — The scale factor used for same-spin pairs in SCS computations. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (OCC); OCC — MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_TYPE (DFMP2); DFMP2 — Algorithm to use for the MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_TYPE (OCC); OCC — Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2R12A (TRANSQT); TRANSQT — Transformations for explicitly-correlated MP2 methods. Type: string; Possible Values: MP2R12AERI, MP2R12AR12, MP2R12AR12T1; Default: MP2R12AERI. MPN (DETCI); DETCI — Do compute the MPn series out to kth order where k is determined by MAX_NUM_VECS ? For open-shell systems (RE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:80754,optimiz,optimized-,80754,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized-']
Performance," reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only dfmp2 for now. func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_mp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:5635,perform,performance,5635,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance," removal/redistribution. Type: double; Default: 2.2. BORDER_RMIN_UNIT (PE)¶PE — unit of BORDER_RMIN, default is atomic units (AU). Type: string; Possible Values: AU, AA; Default: AU. BORDER_TYPE (PE)¶PE — border type, either remove or redistribute moments/polarizabilities. Type: string; Possible Values: REMOVE, REDIST; Default: REMOVE. BRIANQC_ENABLE (GLOBALS)¶GLOBALS — Whether to enable using the BrianQC GPU module. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC)¶FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (CCDENSITY)¶CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY)¶CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM)¶CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:7959,CACHE,CACHELEVEL,7959,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,4,['CACHE'],['CACHELEVEL']
Performance, resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the MP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the CEPA0 code should cite the following publication(s):; [Bozkaya:2011:omp2]. Methods¶; The conventional and orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A spec,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:5391,Optimiz,Optimized,5391,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,2,['Optimiz'],['Optimized']
Performance," return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:1817,optimiz,optimization,1817,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,2,['optimiz'],['optimization']
Performance," return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:1817,optimiz,optimization,1817,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,2,['optimiz'],['optimization']
Performance," rotate (need not be normalized); @param phi double : magnitude of rotation in rad; @param Sn bool : if true, then also reflect in plane through origin and perpendicular to rotation; @returns SharedMatrix with rotated points (rows). matrix_3d_rotation_Cn(coord, axis, reflect, tol=1e-08, max_Cn_to_check=-1)[source]¶; Find maximum n in Cn around given axis, i.e., the highest-order rotation axis.; @param coord Matrix : points to rotate - column dim is 3; @param axis Vector3 : axis around which to rotate, does not need to be normalized; @param bool reflect : if true, really look for Sn not Cn; @returns n. Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. all_casings(input_string)[source]¶; Function to return a generator of all lettercase permutations; of input_string. compare_integers(expected, computed, label)[source]¶; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_strings(expected, computed, label)[source]¶; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. compare_values(expected, computed, digits, label, exitonfail=True)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits; (or to digits itself when digits > 1 e.g. digits=0.04). Performs; a system exit on failure unless exitonfail False, in which case; returns error message. Used in inpu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:95907,Perform,Performs,95907,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Perform'],['Performs']
Performance," run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to get a Psi4 logo file; How to use a local Add-On repository in the Psi4 build; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Installing from Binary; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Install",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external.html:2935,queue,queue,2935,psi4manual/master/external.html,https://psicode.org,https://psicode.org/psi4manual/master/external.html,5,['queue'],['queue']
Performance," same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__ccresponse.html:3781,CACHE,CACHELEVEL,3781,psi4manual/1.7.x/autodir_options_c/module__ccresponse.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__ccresponse.html,1,['CACHE'],['CACHELEVEL']
Performance," scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(uuid.uuid4())[:8]; if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html:5600,Load,Load,5600,psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,5,['Load'],['Load']
Performance," second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.417 0.538 1.007825; H 0.000 -0.417 0.538 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for; each atom along the normal mode coordinate. (This information could be used; to animate the vibrational frequency using visualization sof",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:7868,optimiz,optimization,7868,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['optimiz'],['optimization']
Performance," see it in the output file, set print > 2. Variants of S. Grimme’s -D correction. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [, , , ]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, have nothing to do with this table. [2][Grimme:2004:1463]. [3](1, 2) [Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dftd3.html:5417,optimiz,optimize,5417,psi4manual/4.0b3/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dftd3.html,5,['optimiz'],['optimize']
Performance," selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:20990,perform,performance,20990,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,6,['perform'],['performance']
Performance," series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; freq. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.freq.html:2832,optimiz,optimize,2832,psi4manual/1.7.x/api/psi4.driver.freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.freq.html,1,['optimiz'],['optimize']
Performance," set as usual, then translates; the basis set format and writes out a GENBAS file with an entry for; each atom. The P4C4 interface sets keyword CFOUR_BASIS=SPECIAL; and CFOUR_SPHERICAL as appropriate, then writes the basis section; necessary for SPECIAL below the *CFOUR(...) block. (I’m sorry that the; name of the basis doesn’t appear in ZMAT, but the combination of the; ~14 character basis name limit and the absence of a comment line marker; rather precludes that helpful label.); The input below employs a PSI4 library basis set and also introduces; the final stage of conversion toward PSI4 format. Instead of the; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call PSI4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:11641,optimiz,optimize,11641,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['optimiz'],['optimize']
Performance," set as usual, then translates; the basis set format and writes out a GENBAS file with an entry for; each atom. The P4C4 interface sets keyword CFOUR_BASIS=SPECIAL; and CFOUR_SPHERICAL as appropriate, then writes the basis section; necessary for SPECIAL below the *CFOUR(...) block. (I’m sorry that the; name of the basis doesn’t appear in ZMAT, but the combination of the; ~14 character basis name limit and the absence of a comment line marker; rather precludes that helpful label.); The input below employs a PSI4 library basis set and also introduces; the final stage of conversion toward PSI4 format. Instead of the; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call PSI4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:11412,optimiz,optimize,11412,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,9,['optimiz'],['optimize']
Performance," set as usual, then translates; the basis set format and writes out a GENBAS file with an entry for; each atom. The P4C4 interface sets keyword CFOUR_BASIS=SPECIAL; and CFOUR_SPHERICAL as appropriate, then writes the basis section; necessary for SPECIAL below the *CFOUR(...) block. (I’m sorry that the; name of the basis doesn’t appear in ZMAT, but the combination of the; ~14 character basis name limit and the absence of a comment line marker; rather precludes that helpful label.); The input below employs a Psi4 library basis set and also introduces; the final stage of conversion toward Psi4 format. Instead of the; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call Psi4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:11416,optimiz,optimize,11416,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['optimiz'],['optimize']
Performance," set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the hydrogens with the DZ; basis set. On the third line, the hydrogen atoms which have been specifically; labelled as H1 are given the STO-3G basis set, leaving the unlabelled hydrogen; atoms with the DZ basis set. Likewise, the fourth line assigns the STO-3G; basis set to just the carbon atoms labelled C1. This bizzare example was; constructed to demonstrate the syntax, but the flexibility of the basis set; specification is advantageous, for example, when selectivily omitting diffuse; functions to make computations more tractable.; In the above example the basis sets have been assigned asymmetrically, reducing; the effective symmetry from to ; PSI4 will detect this; automatically and run in the appropriate point group. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:17548,perform,performs,17548,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,8,['perform'],['performs']
Performance," set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The various orbital-optimized methods supported by the OCC/DFOCC; modules in PSI4 are summarized in Table OCC OO; Methods and detailed in Table OCC; OO Capabilities. Note that while two; separate libraries OCC (conventional integrals CONV) and DFOCC; (density-fitted DF and Cholesky-decomposed CD) together provide; the methods described on this page, they are controlled through one; QC_MODULE value OCC. Without set qc_module occ,; these methods may default to implementations in other modules based on efficiency considerations. Orbital-optimized theoretical methods accessible through OCC/DFOCC¶. name; calls method; OO. omp2; orbital-optimized second-order MP perturbation theory; E/G. omp2.5; orbital-optimized average of MP2 and MP3; E/G. omp3; orbital-optimized third-order MP perturbation theory; E/G. oremp2; orbital-optimized second-order REMP hybrid PT; E/G. olccd; orbital-optimized linear coupled cluster doubles; E/G. Detailed orbital-optimized capabilities of the OCC module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[1] ↓ →; FREEZE_CORE[2]→. QC_MODULE=OCC Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. omp2[4]; MP2_TYPE; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. omp2.5[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. omp3[4]; MP_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:10553,optimiz,optimized,10553,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['optimiz'],['optimized']
Performance," set. Type: string; Default: FALSE. BCCD_MAXITER (CCENERGY); CCENERGY — Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. BENCH (GLOBALS); GLOBALS — Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC); FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:6756,CACHE,CACHELEVEL,6756,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance," should cite the following publication(s):; [Bozkaya:2011:omp2]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals generally provide much better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals we can simply use “reference rohf” option. For DFT orbitals one should use “reference uks” and “dft_functional b3lyp” options. Of; course users can use any DFT functional available in Psi4. Methods¶; The conventional and orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RK",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:6153,Optimiz,Optimized,6153,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['Optimiz'],['Optimized']
Performance," similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DF; A DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used.; DISK_DF; A DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4’s internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation.; For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications).; We have added the automatic capability to use the extremely fast DF; code for intermediate convergence of the orbitals, for SCF_TYPE; DIRECT. At the moment, the code defaults to cc-pVDZ-JKFIT as the; auxiliary basis, unless the user specifies DF_BASIS_SCF manually. For; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/scf-1.html:23321,perform,performance,23321,psi4manual/1.2.1/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/scf-1.html,4,['perform'],['performance']
Performance," singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.energy.html:22309,perform,perform,22309,psi4manual/1.6.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.energy.html,2,['perform'],['perform']
Performance," sites which are not in the border region. Type: integer; Default: -1. BORDER_REDIST_ORDER (PE)¶PE — order from which moments are removed, e.g., if set to 1 (default), only charges are redistributed and all higher order moments are removed. Type: integer; Default: 1. BORDER_REDIST_POL (PE)¶PE — redistribute polarizabilities? If false, polarizabilities are removed (default). Type: boolean; Default: false. BORDER_RMIN (PE)¶PE — minimum radius from QM atoms to MM sites to be taken into account for removal/redistribution. Type: double; Default: 2.2. BORDER_RMIN_UNIT (PE)¶PE — unit of BORDER_RMIN, default is atomic units (AU). Type: string; Possible Values: AU, AA; Default: AU. BORDER_TYPE (PE)¶PE — border type, either remove or redistribute moments/polarizabilities. Type: string; Possible Values: REMOVE, REDIST; Default: REMOVE. BRIANQC_ENABLE (GLOBALS)¶GLOBALS — Whether to enable using the BrianQC GPU module. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC)¶FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC)¶ADC — How to cache quantities within the DPD library. This option is only available for the built-in ADC backend. Type: integer; Default: 2. CACHELEVEL (CCDENSITY)¶CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY)¶CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities wit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:7719,optimiz,optimization,7719,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['optimiz'],['optimization']
Performance," sites which are not in the border region. Type: integer; Default: -1. BORDER_REDIST_ORDER (PE)¶PE — order from which moments are removed, e.g., if set to 1 (default), only charges are redistributed and all higher order moments are removed. Type: integer; Default: 1. BORDER_REDIST_POL (PE)¶PE — redistribute polarizabilities? If false, polarizabilities are removed (default). Type: boolean; Default: false. BORDER_RMIN (PE)¶PE — minimum radius from QM atoms to MM sites to be taken into account for removal/redistribution. Type: double; Default: 2.2. BORDER_RMIN_UNIT (PE)¶PE — unit of BORDER_RMIN, default is atomic units (AU). Type: string; Possible Values: AU, AA; Default: AU. BORDER_TYPE (PE)¶PE — border type, either remove or redistribute moments/polarizabilities. Type: string; Possible Values: REMOVE, REDIST; Default: REMOVE. BRIANQC_ENABLE (GLOBALS)¶GLOBALS — Whether to enable using the BrianQC GPU module. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC)¶FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (CCDENSITY)¶CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY)¶CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM)¶CCEO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:7568,optimiz,optimization,7568,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,4,['optimiz'],['optimization']
Performance," snLinK grids. Type: conv double; Default: 1.0e-10. SNLINK_DENSITY_TOLERANCE (SCF)¶SCF (Expert) — Screening criteria for shell-pair densities in snLinK. Type: conv double; Default: 1.0e-10. SNLINK_FORCE_CARTESIAN (SCF)¶SCF (Expert) — Force snLinK to use cartesian coordinates. Type: boolean; Default: false. SNLINK_GPU_MEM (SCF)¶SCF (Expert) — Proportion (in %) of available GPU memory to allocate to snLinK. Type: boolean; Default: 90. SNLINK_GRID_BATCH_SIZE (SCF)¶SCF (Expert) — Maximum number of grid points per grid block for GauXC. Type: integer; Default: 2048. SNLINK_INTEGRATOR_KERNEL (SCF)¶SCF (Expert) — Integrator execution kernel for snLinK GauXC also has SHELLBATCHED, but it is incompatible with Psi4 due to not being yet implemented with sn-LinK. Type: string; Possible Values: DEFAULT, INCORE; Default: DEFAULT. SNLINK_INTS_TOLERANCE (SCF)¶SCF — Screening criteria for integrals and intermediates in snLinK. Type: conv double; Default: 1.0e-11. SNLINK_LOAD_BALANCER_KERNEL (SCF)¶SCF (Expert) — Load Balancer kernel for snLinK. Type: string; Possible Values: DEFAULT, REPLICATED, REPLICATED-PETITE, REPLICATED-FILLIN; Default: DEFAULT. SNLINK_LWD_KERNEL (SCF)¶SCF (Expert) — Integrator local work driver kernel for snLinK GauXC also has SCHEME1-CUTLASS, but it is disabled in Psi4 for now due to compile-time issues and requiring very modern CUDA CCs (>=80). Type: string; Possible Values: DEFAULT, REFERENCE, SCHEME1, SCHEME1-MAGMA; Default: DEFAULT. SNLINK_MOL_WEIGHTS_KERNEL (SCF)¶SCF (Expert) — Molecular Weights kernel for snLinK. Type: string; Possible Values: DEFAULT; Default: DEFAULT. SNLINK_PRUNING_SCHEME (SCF)¶SCF (Expert) — Pruning scheme for snLinK grids. Type: string; Possible Values: ROBUST, TREUTLER, NONE; Default: ROBUST. SNLINK_RADIAL_POINTS (SCF)¶SCF — Number of radial points in snLinK grid. Type: integer; Default: 70. SNLINK_RADIAL_SCHEME (SCF)¶SCF — Radial Scheme for snLinK grid. MURA is default here as it matches the GauXC default option. Type: string; Poss",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:227948,Load,Load,227948,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['Load'],['Load']
Performance," some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Python layer is a good idea, as it allows the many; Python tools for farming out embarrassingly parallel workloads to be used,; while the C++ layer can be used to implement the energy function to be; differentiated.; In SCF, we have a number of sources of external embeddi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_ways_to_add.html:4934,perform,performs,4934,psi4manual/master/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_ways_to_add.html,9,['perform'],['performs']
Performance," some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell SAPT0 keywords¶. SAPT_MEM_SA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sapt-1.html:17309,perform,performs,17309,psi4manual/1.2.1/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sapt-1.html,2,['perform'],['performs']
Performance," some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:21671,perform,performs,21671,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,11,['perform'],['performs']
Performance," specified module arg1 or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. psi4.core.has_scalar_variable(arg0: str) → bool¶; Is the double QC variable (case-insensitive) set?. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:284099,optimiz,optimizer,284099,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['optimiz'],['optimizer']
Performance," specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE').",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:6336,perform,performance,6336,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance," sset='default', failoninc=True, verbose=False, returnindiv=False)[source]¶; For full database or subset sset, computes many error; statistics between single modelchem and benchmark model; chemistries. Returns error if model chemistries are missing; for any reaction in subset unless failoninc set to False,; whereupon returns partial statistics. Returns dictionary of; statistics labels and values. dbse = None¶; internal name of database; >>> print asdf.dbse; 'NBC1'. get_pec_weightinfo()[source]¶. hrgt = None¶; dict of reagents/geometries; >>> print asdf.hrgt.keys(); ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']. hrxn = None¶; OrderedDict of reactions/members; >>> print asdf.hrxn.keys(); ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']. integer_reactions()[source]¶; Returns boolean of whether reaction names need to be cast to integer. static load_pickled(dbname, path=None)[source]¶. load_qcdata(modname, funcname, pythonpath=None, failoninc=True)[source]¶; Loads qcdb.ReactionDatums from module modname function; funcname. Module search path can be prepended with pythonpath. load_qcdata_byproject(project, pythonpath=None)[source]¶; Loads qcdb.ReactionDatums from standard location for project; :module dbse_project and function load_project. Module search path; can be prepended with pythonpath. load_qcdata_hdf5_trusted(project, path=None)[source]¶; Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. load_qcdata_hrxn_byproject(project, path=None)[source]¶. load_subsets(modname='subsetgenerator', pythonpath=None)[source]¶; Loads subsets from all functions in module modname. oss = None¶; object of defined reaction subsets. sset = None¶; dict of defined reaction subsets.; Note that self.sset[‘default’] contains all the nonredundant information.; >>> print asdf.sset.keys(); ['meme', 'mxddpp', '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:48430,Load,Loads,48430,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Load'],['Loads']
Performance," starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 1.20. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. NEW_TRIPLES¶. Do use new triples?. Type: boolean; Default: true. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. PAIR_ENERGIES_PRINT¶. Do print MP2 and CCSD pair energies for RHF references?. Type: boolean; Default: false. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, MAGNETIZABILITY, ROA, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. SCSN_MP2¶. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SCS_CCSD¶. Do spin-component-scaled CCSD. Type: boolean; Default: false. SCS_MP2¶. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SEMICANONICAL¶. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SPINADAPT_ENERGIES¶. Do print spin-adapted pair energies?. Type: boolean; Default: false. T2_COUPLED¶. Type: boolean; Default: false. T3_WS_INCORE¶. Do build W intermediate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__ccenergy-1.html:4660,optimiz,optimizations,4660,psi4manual/1.0.0/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__ccenergy-1.html,6,['optimiz'],['optimizations']
Performance," starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = physconst.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in ; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = PsiMod.get_active_molecule(). dashlvl = dashlvl.lower(); dashlvl = dash_alias['-' + dashlvl][1:] if ('-' + dashlvl) in dash_alias.keys() else dashlvl; if dashlvl not in dashcoeff.keys():; raise ValidationError(""""""-D c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:6175,Queue,Queue,6175,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,2,['Queue'],['Queue']
Performance," step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tupl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59275,optimiz,optimized,59275,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,3,['optimiz'],['optimized']
Performance," step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:61026,optimiz,optimized,61026,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,1,['optimiz'],['optimized']
Performance," structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:1947,perform,performed,1947,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,2,['perform'],['performed']
Performance," structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:1947,perform,performed,1947,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,2,['perform'],['performed']
Performance," superfunctional. get_block(self, arg0); Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args, **kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self, arg0); Sets the internal density. set_debug(self, arg0); Sets the debug level of the object. set_print(self, arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; Returns internal AO density. basis(self: psi4.core.VBase) → psi4.core.BasisSet¶; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str) → psi4.core.VBase¶. build_collocation_cache(self: psi4.core.VBase, arg0: int) → None¶; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase) → None¶; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; doctsring. compute_Vx(self: psi4.core.VBase, arg0: List[psi4.core.Matrix], arg1: List[psi4.core.Matrix]) → None¶; doctsring. compute_gradient(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs)¶; Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase) → psi4.core.SuperFunctional¶; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int) → psi4.core.BlockOPoints¶; Returns the requested BlockOPoints. get_np_xyzw()¶; Returns the x, y, z, and weights of a grid as a tuple of NumPy array ob",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.vbase.html:1803,cache,cache,1803,psi4manual/1.4.0/api/psi4.core.vbase.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.vbase.html,6,['cache'],['cache']
Performance," superfunctional. get_block(self, arg0); Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args, **kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self, arg0); Sets the internal density. set_debug(self, arg0); Sets the debug level of the object. set_print(self, arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: list[psi4.core.Matrix]) → None¶; Returns internal AO density. basis(self: psi4.core.VBase) → psi4.core.BasisSet¶; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str) → psi4.core.VBase¶. build_collocation_cache(self: psi4.core.VBase, arg0: int) → None¶; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase) → None¶; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: list[psi4.core.Matrix]) → None¶; doctsring. compute_Vx(self: psi4.core.VBase, arg0: list[psi4.core.Matrix], arg1: list[psi4.core.Matrix]) → None¶; doctsring. compute_gradient(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs)¶; Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase) → psi4.core.SuperFunctional¶; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int) → psi4.core.BlockOPoints¶; Returns the requested BlockOPoints. get_np_xyzw()¶; Returns the x, y, z, and weights of a grid as a tuple of NumPy array ob",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.VBase.html:1794,cache,cache,1794,psi4manual/master/api/psi4.core.VBase.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.VBase.html,1,['cache'],['cache']
Performance," surface without the RANGED_DIHEDRAL keyword, a zmatrix; can be used. Warning; Rotating dihedrals in large increments without allowing the molecule to relax; in between increments can lead to unphysical geometries with overlapping functional groups in larger molecules,; which may prevent successful constrained optimzations. Furthermore, such a relaxed scan of the PES does; not always procude a result close to an IRC, or even a reaction path along which the energy changes in a; continuous way. molecule hooh {; 0 1; H; O 1 0.95; O 2 1.39 1 103; H 3 0.95 2 103 1 D. D = 99. units ang; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; frozen_dihedral ("" 1 2 3 4 ""); }. dihedrals = [100, 110, 120, 130, 140, 150]; PES = []. for phi in dihedrals:; hooh.D = phi; E = optimize('scf'); PES.append((phi, E)). print(""\n\tcc-pVDZ SCF energy as a function of phi\n""); for point in PES:; print(""\t%5.1f%20.10f"" % (point[0], point[1])). Multi-Fragment Optimizations¶; In previous versions of optking, the metric for connecting atoms was increased until all atoms; were connected. This is the current behavior for FRAG_MODE single.; Setting FRAG_MODE to multi will now add a special; set of intermolecular coordinates between fragments - internally referred to as DimerFrag; coordinates (see here <DimerIntro_> for the brief description).; For each pair of molecular fragments, a set of up to 3 reference points; are chosen on each fragment. Each reference point will be either an atom or a linear combination; of positions of atoms within that fragment. Stretches, bends, and dihedral angles between the two; fragments will be created using these reference points. See; Dimer coordinate table for how reference points are created.; For a set of three dimers A, B, and C, sets of coordinates are created between each pair:; AB, AC, and BC. Each DimerFrag may use different reference points.; Creation of the intermolecular coordinates can be controlled through FRAG_REF_ATOMS; and INTERFRAG_COORDS. FRAG_REF_A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:9049,Optimiz,Optimizations,9049,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,4,['Optimiz'],['Optimizations']
Performance," sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # stash user options; optst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:111993,Load,Load,111993,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,5,['Load'],['Load']
Performance," sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; core.set_variable(m + ' TOTAL ENERGY', ene); core.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; core.set_variable('CURRENT ENERGY', ene); core.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs). # stash user options; optstash = p4uti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:159880,Load,Load,159880,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['Load'],['Load']
Performance," system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n -----------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:58371,optimiz,optimizer,58371,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimizer']
Performance," tasks by; modifying some of the example input files supplied with PSI4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. Most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; Let’s also suppose you want to do counterpoise (CP) correction to compute interaction energies.; Counterpoise correction involves computing the dimer energy and then; subtracting out the energies of the two monomers, each evaluated in the; dimer basis. Again, each of these computations could be run in a separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, PSI4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue of specifying the monomers separately was already dealt; with in the previous SAPT example, where we saw that two dashes in the; molecule block can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne2 at; a series of different interatomic distances. And let’s print out a table; of the interatomic distances we’ve considered, and the CP-corrected CCSD(T); interaction energies (in kcal mol-1) at each geometry. Doing all this; in a single input is surprisingly easy in PSI4. Here’s the input; (available as tu6-cp-ne2).; #! Example potential energy surface scan and CP-correction for Ne2. molecule dimer {; Ne; --; Ne 1 R; }. Rvals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:17099,perform,perform,17099,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,15,['perform'],['perform']
Performance," that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important \(t_1\) and \(t_2\) amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with PSI4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user should not specify the entire; physical memory of the system, or swapping is likely. However, for especially large; calculations, it is better to set the memory keyword to a value less than 16 GB.; Set the CACHELEVEL keyword to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cc.html:8357,cache,cache,8357,psi4manual/master/cc.html,https://psicode.org,https://psicode.org/psi4manual/master/cc.html,15,['cache'],['cache']
Performance," that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; Psi4 code is not necessary.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection.; pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of Psi4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main Psi4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; addit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/plugins-1.html:6099,load,loaded,6099,psi4manual/1.0.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/plugins-1.html,2,['load'],['loaded']
Performance," that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geomet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:70432,Optimiz,Optimize,70432,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['Optimiz'],['Optimize']
Performance," that this option might be not available for all type of calculations. Type: string; Possible Values: DISK, DIRECT; Default: DISK. CFOUR_GENBAS_1 (CFOUR)¶CFOUR — This keyword applies only to Hydrogen and Helium atoms and specifies the number of contracted Gaussian functions per shell. There is usually no need to use this keyword, but it can be useful for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR)¶CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR)¶CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR)¶CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR)¶CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR)¶CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in san",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:47078,perform,performs,47078,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['perform'],['performs']
Performance," the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:23323,Optimiz,Optimization,23323,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,2,['Optimiz'],['Optimization']
Performance," the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. A PSI4 Tutorial; Psithon Tutorial: Using PSI4 as an Executable. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/tutorial-1.html:23323,Optimiz,Optimization,23323,psi4manual/1.5.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/tutorial-1.html,2,['Optimiz'],['Optimization']
Performance," the ERI and ERF integrals. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cc17; Single point energies of multiple excited states with EOM-CCSD. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. casscf-sp; CASSCF/6-31G** energy point. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. dft-reference; MP2 with a PBE0 reference computation. options1; check all variety of options parsing. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc5; Test FNO-DF-CCSD(T) energy. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. df",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:32088,optimiz,optimization,32088,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance," the Kohn–Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:24859,perform,performs,24859,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,5,['perform'],['performs']
Performance," the OCC (conv MP2) or the DFMP2 modules. run_mp2_select_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 gradient call; and directing toward the OCC (conv MP2) or the DFMP2 modules. run_mp2c(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a coupled MP2 calculation. run_mp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 calculation. run_mp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 gradient calculation. run_mrcc(name, **kwargs)[source]¶; Function that prepares environment and input files; for a calculation calling Kallay’s MRCC code. run_ocepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized CEPA computation. run_ocepa_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OCEPA gradient calculation. run_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. run_omp2_5(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2.5 computation. run_omp2_5_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2.5 gradient calculation. run_omp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2 gradient calculation. run_omp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP3 computation. run_omp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP3 gradient calculation. run_psimrcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. run_psimrcc_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. ru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:12591,optimiz,optimized,12591,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance," the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Conver",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:58223,optimiz,optimizer,58223,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimizer']
Performance," the Ubuntu shell). If using the PSI4 binary, dkh has already been installed alongside. If using PSI4 built from source, and anaconda or miniconda has; already been installed (instructions at Quick Installation),; dkh can be obtained through conda install dkh.; Then enable it as a feature with ENABLE_dkh,; hint its location with CMAKE_PREFIX_PATH,; and rebuild PSI4 to detect dkh and activate dependent code. To remove a conda installation, conda remove dkh. Source. If using PSI4 built from source and you want dkh built from; from source also,; enable it as a feature with ENABLE_dkh,; and let the build system fetch and build it and activate dependent code. Input¶; For all electron calculations one can use the Douglas-Kroll-Hess (DKH); Hamiltonian to take into account scalar relativistic effects.; Minimal input for DKH single-point computation looks like this:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; Mg; }. set basis aug-cc-pvdz-dk; set relativistic dkh. energy('scf'). By default a 2nd-order DKH calculation is performed. To change the default; order use the DKH_ORDER option. The version of the code found in; PSI4 is capable of up to 4th-order DKH calculations. Keywords¶. RELATIVISTIC¶. Relativistic Hamiltonian type. Type: string; Possible Values: NO, X2C; Default: NO. DKH_ORDER¶. Order of Douglas-Kroll-Hess. Type: integer; Default: 2. Reference¶; When using this code please make reference to the appropriate following paper:. “The Generalized Douglas-Kroll Transformation,” A. Wolf,; M. Reiher, and B. A. Hess, J. Chem. Phys. 117, 9215 (2002).; (doi: 10.1063/1.1515314). How to configure dkh for building Psi4¶; Role and Dependencies. Role — In PSI4, DKH is a library that provides additional; quantum chemical capabilities (relativistic effects).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) dkh; Upstream Dependencies — dkh \(\Leftarrow\) Fortran. CMake Variables. ENABLE_dkh — CMake variable toggling whether Psi4 builds with dkh; CMAKE_PREFIX_PATH — CMake list variable ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dkh-1.html:1434,perform,performed,1434,psi4manual/1.1.0/dkh-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dkh-1.html,2,['perform'],['performed']
Performance," the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. opt-multi-dimer-c2h; Multi-fragment opt of C2h metha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:18187,perform,performed,18187,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance," the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:13623,perform,performance,13623,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance," the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Spin Multiplicities of Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; CI: Configuration Interaction. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/detci.html:15174,perform,perform,15174,psi4manual/1.7.x/detci.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/detci.html,1,['perform'],['perform']
Performance," the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis function, uses zero disk, and can obtain significant; speedups with negligible error loss if the INTS_TOLERANCE value; is set to 1.0E-8 or so.; DF [Default]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for all Dunning bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [CCSD(T)] or a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/scf-1.html:18940,bottleneck,bottleneck,18940,psi4manual/4.0b5/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/scf-1.html,2,['bottleneck'],['bottleneck']
Performance," the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; Psi4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis function, uses zero disk, and can obtain significant; speedups with negligible error loss if the INTS_TOLERANCE value; is set to 1.0E-8 or so.; DF [Default]; A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for all Dunning bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [CCSD(T)] or a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf.html:18871,bottleneck,bottleneck,18871,psi4manual/1.0.0/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf.html,2,['bottleneck'],['bottleneck']
Performance," the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treatments is controlled through ‘type select’ values;; see rightmost column in Table Conventional OCC/DFOCC Methods.; Depending on efficiency considerations, the OCC & DFOCC modules may; or may not be the default in PSI4 for available methods. (See; Cross-module Redundancies for gory; details.) To call the OCC/DFOCC implementation of any method below in; preference to the default module, issue set qc_module occ.; Starting in v1.4, MP2.5 and MP3 default to the density-fit algorithm. Set MP_TYPE to CONV to get previous behavior. Conventional (non-OO) CC and MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. mp2; MP2; RHF/UHF/ROHF; RHF/UHF; MP2_TYPE CONV. Density-Fitted",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/occ-1.html:16581,optimiz,optimized,16581,psi4manual/1.4.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/occ-1.html,5,['optimiz'],['optimized']
Performance," the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis, This can be done by placing a cast_up =; 'SMALL_BASIS' modifier in the energy() procedure call. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:14257,perform,performing,14257,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['perform'],['performing']
Performance," the different R values and the CP-corrected CCSD(T) energies, converted from; atomic units (Hartree) to kcal mol-1 by multiplying by the; automatically-defined conversion factor psi_hartree2kcalmol. PSI4; provides several built-in physical constants and conversion factors, as; described in section Physical Constants.; Notice the loop over \(R\) to create; the table looks just like the loop over R to run the different; computations, and the CP-corrected energies ecp[R] are accessed the same; way they were stored. The print line at the end just specifies some; formatting for the printed table (first element is a floating point number 3; spaces wide with one digit after the decimal, and the second element is a; floating point number 10 spaces wide with 6 digits after the decimal); the; format strings are the same as in the C programming language. For tables more; complicated than the simple one used here, Psithon has built-in support for; tables (see the next section).; Our table is printed at the very end of the output file, and looks like; this; 1; 2; 3; 4; 5; 6; 7CP-corrected CCSD(T)/aug-cc-pVDZ interaction energies. R (Ang) E_int (kcal/mol); -----------------------------------------------------; 2.5 0.757718; 3.0 0.015687; 4.0 -0.016264. The following section goes over Psithon in much more detail, but; hopefully this example already makes it clear that many complex tasks; can be done very easily in PSI4. table of contents. Psithon Tutorial: Using PSI4 as an Executable; Basic Input File Structure; Sample Input Files; Running a Basic Hartree–Fock Calculation; Geometry Optimization and Vibrational Frequency Analysis; Analysis of Intermolecular Interactions; Potential Surface Scans and Counterpoise Correction Made Easy with Psithon. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. A PSI4 Tutorial. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/tutorial-1.html:23508,Optimiz,Optimization,23508,psi4manual/1.2.1/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/tutorial-1.html,2,['Optimiz'],['Optimization']
Performance," the frequency is required), NMR (=5) requests the calculation of NMR chemical shifts/chemical shielding tensors (by default using GIAOs), J_FC requests the calculation of the Fermi-Contact contribution to indirect spin-spin coupling constants, J_SD the calculation of the corresponding spin-dipole contribution, and J_SO the calculation of the corresponding spin-orbit contribution to J; HYPERPOL (=22) invokes a calculation of static hyperpolarizabilities, DYN_HYP (=23) requests the calculation of frequency-dependent hyperpolarizabilities, SHG (=24) the calculation of hyperpolarizabilities related to the second-harmonic generation, OPT_REC (=25) the computation of hyperpolarizabilities related to optical rectification, VERDET (=26) the calculation of Verdet constants. Type: string; Possible Values: OFF, FIRST_ORDER, SECOND_ORDER, NMR, HYPERPOL, DYN_HYP, SHG, OPT_REC, VERDET; Default: OFF. CFOUR_QRHF_GENERAL (CFOUR); CFOUR — The presence of this keyword specifies that a QRHF based CC calculation, or alternatively, an SCF calculation that uses the CFOUR_QRHFGUES option, is to be performed. Type: array; Default: No Default. CFOUR_QRHF_ORBITAL (CFOUR); CFOUR — By default, in QRHF calculations, electrons are removed from the highest occupied orbital in a symmetry block (symmetry block HOMO), while electrons are added to the lowest unoccupied orbital within a symmetry block (symmetry block LUMO). The purpose of the QRHF_ORBITAL keyword is to allow additional flexibility in choosing which orbitals will have their occupation numbers altered. The value of this keyword gives the offset with respect to the default orbital for the orbital which will be depopulated (or populated) in QRHF-CC calculations. For calculations involving more than one removal or addition of electrons, values are separated by commas and correspond to the CFOUR_QRHF_GENERAL input on a one-to-one basis. For example, specifying CFOUR_QRHF_GENERAL =2/-4, QRHF_ORBITAL=3/2 means that an electron will be added to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:67170,perform,performed,67170,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,8,['perform'],['performed']
Performance," the frequency is required), NMR (=5) requests the calculation of NMR chemical shifts/chemical shielding tensors (by default using GIAOs), J_FC requests the calculation of the Fermi-Contact contribution to indirect spin-spin coupling constants, J_SD the calculation of the corresponding spin-dipole contribution, and J_SO the calculation of the corresponding spin-orbit contribution to J; HYPERPOL (=22) invokes a calculation of static hyperpolarizabilities, DYN_HYP (=23) requests the calculation of frequency-dependent hyperpolarizabilities, SHG (=24) the calculation of hyperpolarizabilities related to the second-harmonic generation, OPT_REC (=25) the computation of hyperpolarizabilities related to optical rectification, VERDET (=26) the calculation of Verdet constants. Type: string; Possible Values: OFF, FIRST_ORDER, SECOND_ORDER, NMR, HYPERPOL, DYN_HYP, SHG, OPT_REC, VERDET; Default: OFF. CFOUR_QRHF_GENERAL (CFOUR)¶CFOUR — The presence of this keyword specifies that a QRHF based CC calculation, or alternatively, an SCF calculation that uses the CFOUR_QRHFGUES option, is to be performed. Type: array; Default: No Default. CFOUR_QRHF_ORBITAL (CFOUR)¶CFOUR — By default, in QRHF calculations, electrons are removed from the highest occupied orbital in a symmetry block (symmetry block HOMO), while electrons are added to the lowest unoccupied orbital within a symmetry block (symmetry block LUMO). The purpose of the QRHF_ORBITAL keyword is to allow additional flexibility in choosing which orbitals will have their occupation numbers altered. The value of this keyword gives the offset with respect to the default orbital for the orbital which will be depopulated (or populated) in QRHF-CC calculations. For calculations involving more than one removal or addition of electrons, values are separated by commas and correspond to the CFOUR_QRHF_GENERAL input on a one-to-one basis. For example, specifying CFOUR_QRHF_GENERAL =2/-4, QRHF_ORBITAL=3/2 means that an electron will be added to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:67315,perform,performed,67315,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['perform'],['performed']
Performance," the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; 1; 2; 3; 4; 5; 6; 7molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; 1optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; 1; 2set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; 1optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; 1; 2set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; 1; 2; 3; 4; 5; 6; 7set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; 1; 2set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:4557,Optimiz,Optimize,4557,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['Optimiz'],['Optimize']
Performance," the given excitation level EX_LEVEL. Type: boolean; Default: true. MIXED4 (DETCI)¶DETCI (Expert) — Do allow “mixed” excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MO_DIIS_NUM_VECS (DFOCC)¶DFOCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER (DFOCC)¶DFOCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_MAXITER (OCC)¶OCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF)¶MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OCC)¶OCC — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX (DFOCC)¶DFOCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_STEP_MAX (OCC)¶OCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OCC)¶OCC — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODULE (CPHF)¶CPHF — What app to test?. Type: string; Possible Values: RCPHF; Default: RCPHF. MOGRAD_DAMPING (OCC)¶OCC — Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MOLDEN_WITH_VIRTUAL (GLOBALS)¶GLOBALS — Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MOLDEN_WRITE (DFOCC)¶DFOCC — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MOLDEN_WRITE (SCF)¶SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:169797,optimiz,optimization,169797,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['optimiz'],['optimization']
Performance," the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate \(E_{ind}^{(20)}\) and \(E_{exch-ind}^{(20)}\) instead of their response-including counterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell SAPT0 keywords¶. SAPT_MEM_SA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:16899,perform,performs,16899,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['perform'],['performs']
Performance," the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local intern",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:8016,optimiz,optimizer,8016,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimizer']
Performance," the one-particle density matrix?. Type: boolean; Default: true. OPT_COORDINATES (OPTKING)¶OPTKING — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. CUSTOM is not fully implemented yet - expected optking 0.3.1. Type: string; Possible Values: REDUNDANT, INTERNAL, CARTESIAN, BOTH, CUSTOM; Default: INTERNAL. OPT_METHOD (DFOCC)¶DFOCC — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC)¶OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. OPT_RESTART (OPTKING)¶OPTKING — Restart the optimization from optking’s written history. Type: double; Default: 0. OPT_TYPE (OPTKING)¶OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC)¶DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC)¶OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (DFOCC)¶DFOCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:190822,perform,performed,190822,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['perform'],['performed']
Performance," the output from the dftd3; program is suppressed; to see it in the output file, set print > 2. Variants of S. Grimme’s -D correction. Extension [1]; Variant and Computing Program; DFT_DISPERSION_PARAMETERS. -D; alias to -D2P4;  . -D1; -D1 [2] within PSI4;  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within PSI4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [, , , ]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, have nothing to do with this table. [2][Grimme:2004:1463]. [3](1, 2) [Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dftd3.html:5340,optimiz,optimization,5340,psi4manual/4.0b3/dftd3.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dftd3.html,5,['optimiz'],['optimization']
Performance," the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""anharmonicity"",; ""least_squares_fit_polynomial"",; ]. from typing import Any, Dict, List. import numpy as np. from psi4 import core; from psi4.driver import constants; from psi4.driver.p4util.exceptions import *. def least_squares_fit_polynomial(; xvals: List[float],; fvals: List[float],; localization_point: float,; no_factorials: bool = True,; weighted: bool = True,; polynomial_order: int = 4,; ):; """"""Performs an unweighted least squares fit of a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]; def anharmonicity(rvals: List[float], energies: List[float], plot_fit: str = '', mol = None) -> Dict[str, Any]:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html:1516,Perform,Performs,1516,psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/diatomic.html,1,['Perform'],['Performs']
Performance," the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""anharmonicity"",; ""least_squares_fit_polynomial"",; ]. from typing import Any, Dict, List. import numpy as np. from psi4 import core; from psi4.driver import constants; from psi4.driver.p4util.exceptions import *. def least_squares_fit_polynomial(; xvals: List[float],; fvals: List[float],; localization_point: float,; no_factorials: bool = True,; weighted: bool = True,; polynomial_order: int = 4,; ):; """"""Performs an unweighted least squares fit of a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See https://doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]def anharmonicity(rvals: List[float], energies: List[float], plot_fit: str = '', mol = None) -> Dict[str, Any]:; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. https://doi.org/10.1063/1.4862157, p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/diatomic.html:1514,Perform,Performs,1514,psi4manual/1.7.x/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/diatomic.html,1,['Perform'],['Performs']
Performance," the threshold value (given as an integer) for the treatment of CPHF coefficients in second derivative calculations using perturbed canonical orbitals. If a CPHF coefficient is above the threshold, the corresponding orbital rotation is treated (at the expense of additional CPU cost) using the standard non-canonical procedures, while orbital pairs corresponding to CPHF coefficients below the threshold are treated using perturbed canonical representation. Default: 25 (Default: 1 in the developer version). Type: integer; Default: 25. CFOUR_UNITS (CFOUR); CFOUR — Specifies the units used for molecular geometry input. ANGSTROM (= 0) uses Angstrom units, BOHR (= 1) specifies atomic units. Psi4 Interface: Keyword set from active molecule, always ANGSTROM. Type: string; Possible Values: ANGSTROM, BOHR; Default: ANGSTROM. CFOUR_UPDATE_HESSIAN (CFOUR); CFOUR — Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION (CFOUR); CFOUR — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF, EXACT; Default: NO. CFOUR_VT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:82802,optimiz,optimization,82802,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimization']
Performance," the threshold value (given as an integer) for the treatment of CPHF coefficients in second derivative calculations using perturbed canonical orbitals. If a CPHF coefficient is above the threshold, the corresponding orbital rotation is treated (at the expense of additional CPU cost) using the standard non-canonical procedures, while orbital pairs corresponding to CPHF coefficients below the threshold are treated using perturbed canonical representation. Default: 25 (Default: 1 in the developer version). Type: integer; Default: 25. CFOUR_UNITS (CFOUR); CFOUR — Specifies the units used for molecular geometry input. ANGSTROM (= 0) uses Angstrom units, BOHR (= 1) specifies atomic units. Psi4 Interface: Keyword set from active molecule, always ANGSTROM. Type: string; Possible Values: ANGSTROM, BOHR; Default: ANGSTROM. CFOUR_UPDATE_HESSIAN (CFOUR); CFOUR — Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION (CFOUR); CFOUR — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF; Default: NO. CFOUR_VTRAN (CF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:82583,optimiz,optimization,82583,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimization']
Performance," the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are not available. Frequencies will proceed through; finite differences according to availability of gradients or energies. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). hessian(name[, molecule, return_wfn, func, dertype, irrep])[source]¶; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. Returns:Matrix – Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. Returns:(Matrix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, psi4.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). Previous topic; Geometry Optimization, optimize() and gradient(); Next topic; Database, database(). This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/freq-1.html:4266,Optimiz,Optimization,4266,psi4manual/1.0.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/freq-1.html,4,"['Optimiz', 'optimiz']","['Optimization', 'optimize']"
Performance," the variable arg2 in the list of geometry variables, then calls update_geometry(). symbol((self: psi4.core.Molecule, ...); Gets the cleaned up label of atom arg1 (C2 => C, H4 = H) (0-indexed). symmetrize((self: psi4.core.Molecule, ...); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. translate((self: psi4.core.Molecule, ...); Translates molecule by arg1. update_geometry(...); Reevaluates the geometry with current variable values, orientation directives, etc. x((self: psi4.core.Molecule, arg0: int) -> float); x position of atom arg1 (0-indexed in Bohr). y((self: psi4.core.Molecule, arg0: int) -> float); y position of atom arg1 (0-indexed in Bohr). z((self: psi4.core.Molecule, arg0: int) -> float); z position of atom arg1 (0-indexed in Bohr). Attributes Documentation. units¶; Units (Angstrom or Bohr) used to define the geometry. Methods Documentation. BFS()¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. Z(self: psi4.core.Molecule, arg0: int) → float¶; Nuclear charge of atom arg1 (0-indexed). activate_all_fragments(self: psi4.core.Molecule) → None¶; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, arg0: int, arg1: float, arg2: float, arg3: float, arg4: str, arg5: float, arg6: float, arg7: int) → None¶; Adds to Molecule arg0 an atom with atomic number arg1, Cartesian coordinates in Bohr (arg2, arg3, arg4), atomic symbol arg5, mass arg6, charge arg7 (optional), and lineno arg8 (optional). atom_at_position(self: psi4.core.Molecule, arg0: float, arg1: float) → int¶; Tests to see if an atom is at the position arg2 with a given tolerance arg3. center_of_mass(self: psi4.core.Molecule) → psi4.core.Vector3¶; Computes center of mass of molecule (does not translate mol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html:8124,Perform,Perform,8124,psi4manual/1.1.0/api/psi4.core.molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.molecule.html,1,['Perform'],['Perform']
Performance," the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:6896,optimiz,optimizations,6896,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,4,['optimiz'],['optimizations']
Performance," the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computations of small systems (less than 150 basis; functions and high symmetry) the use of the default parameters is recommended,; including the choice of the two-step algorithm.; For large systems (more than 150 basis functions) the simultaneous algorithm; is preferred and can be significantly faster than two-step, as the result of; smaller number of the expensive steps. In addition,; significant savings can be achieved if one sets AO_BASIS option to; DISK together with simultaneous algorithm. It should be noted, however, that; the analytic gradients of the DC-06 method are currently not implemented for; AOBASIS DISK option.; In the ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:10769,optimiz,optimize,10769,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance," the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computations of small systems (less than 150 basis; functions and high symmetry) the use of the default parameters is recommended,; including the choice of the two-step algorithm.; For large systems (more than 150 basis functions) the simultaneous algorithm; is preferred and can be significantly faster than two-step, as the result of; smaller number of the expensive steps. In addition,; significant savings can be achieved if one sets AO_BASIS option to; DISK together with simultaneous algorithm.; In the case when insufficient memory is available, set AO_BASIS option; to DISK. This will significantly reduce the memory requirements. Howeve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/dcft-1.html:10708,optimiz,optimize,10708,psi4manual/4.0b5/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/dcft-1.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance," the; complete-active-space self-consistent-field (CASSCF) approach [Roos:1980],; which includes all possible determinants (with the proper symmetry) that can be; formed by distributing a set of active electrons among a set of active; orbitals. The MCSCF module performs CASSCF optimization of molecular orbitals; via a two-step procedure in which the CI coefficients and orbitals are; optimized in an alternating manner. The program uses a fairly simple; approximate orbital Hessian [Chaban:1997:88] and a Newton-Raphson update,; accelerated by Pulay’s DIIS procedure [Pulay:1980]. We have also implemented; the RASSCF method [Malmqvist:1990:RASSCF], which is another kind of MCSCF; which is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations faster and is helpful in some circumstances where; unphysical mixing of inactive and active occupied orbitals might occur.; Presently, it is not possible to mix the use of restricted and frozen orbitals; in PSI4.; An illustrative CASSCF example is as follows:; molecule {; O; H 1 1.00; H 1 1.00 2 103.1; }. set {; basis 6-31G**; restricted_docc [1, 0, 0, 0]; active [3, 0, 1, 2]; }; energy('casscf'). This input will compute the CASSCF energy of water where the 1s Oxygen orbital; and several virtual orbitals are not included in the CI expansion, but are; still optimized. The following is a full list of spaces within the various MCSCF; types. Orbital spaces for MCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/mcscf.html:1821,optimiz,optimized,1821,psi4manual/master/mcscf.html,https://psicode.org,https://psicode.org/psi4manual/master/mcscf.html,9,['optimiz'],['optimized']
Performance," the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option.; 1) Simultaneous algorithm (ALGORITHM = SIMULTANEOUS, currently the default).; In this algorithm the DCFT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. The macroiterations are repeated until the simultaneous; convergence of the cumulant and orbitals is achieved.; Convergence of the simultaneous algorithm is accelerated using the; DIIS extrapolation technique.; 2) Two-step algorithm (can be invoked by setting the ALGORITHM option to; TWOSTEP). In the two-step algorithm each macroiteration consists of two sets of; microiterations. In the first set, the density cumulant equations are solved; iteratively, while the orbitals are kept fixed. After the density cumulant is; converged, the second set of microiterations is performed for the; self-consistent update of the orbitals with the fixed density cumulant. Each; macroiteration is completed by performing the orbital transformation of the; integrals. As in the simultaneous algorithm, the DIIS; extrapolation is used to accelerate convergence. Two-step algorithm is; only available for the DC-06 and DC-12 methods.; 3) Quadratically-convergent algorithm (set ALGORITHM to QC). The; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:8403,perform,performed,8403,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['perform'],['performed']
Performance," them.; Currently only used for the WebMO implementation of SAPT. :returns: :ref:`Molecule<sec:psimod_Molecule>`) |w--w| fragmented molecule. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. """"""; # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molname = molecule.name(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = list(range(numatoms)); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(numatoms):; A = F[f + 1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < _autofragment_convert(u, symbol) + _autofragment_convert(i, symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (addi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html:3002,Queue,Queue,3002,psi4manual/1.0.0/_modules/wrapper_autofrag.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html,1,['Queue'],['Queue']
Performance," theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (CPHF). (DETCI). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (CPHF). (DFMP2). opt(); . see optimize(); . OPT_METHOD (OCC). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in p4util.optproc. OptionState class in p4util.optproc. ORB_OPT (OCC). ORB_RESP_SOLVER (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OCEPA. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OCC). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). p4const module. p4const.__init__ module. p4const.physconst module. p4const.psifiles module. p4regex module. p4util module. p4util.__init__ module. p4util.basislist module. p4util.basislistdunning module. p4util.basislistother module. p4util.optproc module. p4util.procutil module. p4util.text module. p4util.util module. PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_error() in module pcmgetkw. parse_multiline_array() in module inputparser. parseFile() GetkwParser method. parseString() GetkwParser method. PATH, [1], [2], [3], [4]. PCG_BETA_TYPE (OCC). PCG_CONVERGENCE (OCC). PCG_MAXITER (OCC). pcmgetkw module. pcmpreprocess module. PEP1. perp_unit() in module qcdb.vecutil. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:33868,Optimiz,Optimized,33868,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['Optimiz'],['Optimized']
Performance," theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRONENERGY. one_electron_integrals() psi4.core.MintsHelper method, [1], [2]. OneBodyAOInt class in psi4.core, [1]. onel_Hx() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. option_exists_in_module() in module psi4.core, [1]. Options class in psi4.core, [1]. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orbital_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. OrbitalSpace class in psi4.core, [1]. order() psi4.core.CharacterTable method, [1], [2]. psi4.core.PointGroup method, [1], [2]. ordered_params psi4.driver.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. orientation_fixed() psi4.core.Molecule method, [1], [2]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:102269,optimiz,optimize,102269,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['optimiz'],['optimize']
Performance," theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRONENERGY. one_electron_integrals() psi4.core.MintsHelper method, [1], [2]. OneBodyAOInt class in psi4.core, [1]. onel_Hx() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. option_exists_in_module() in module psi4.core, [1]. Options class in psi4.core, [1]. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orbital_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. OrbitalSpace class in psi4.core, [1]. orientation() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. orientation_fixed() psi4.core.Molecule method, [1], [2]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:87819,Optimiz,OptimizationConvergenceError,87819,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['Optimiz'],['OptimizationConvergenceError']
Performance," to Hydrogen and Helium atoms and specifies the number of contracted Gaussian functions per shell. There is usually no need to use this keyword, but it can be useful for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR)¶CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR)¶CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR)¶CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR)¶CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR)¶CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR)¶CFOUR — S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:47255,perform,performs,47255,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['perform'],['performs']
Performance," to be used in diagonalizing the Hamiltonian. The valid options are: RSP, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); OLSEN, to use Olsen’s preconditioned inverse subspace method (1990); MITRUSHENKOV, to use a 2x2 Olsen/Davidson method; and DAVIDSON (or SEM) to use Liu’s Simultaneous Expansion Method, which is identical to the Davidson method if only one root is to be found. There also exists a SEM debugging mode, SEMTEST. The SEM method is the most robust, but it also requires CI vectors on disk, where is the maximum number of iterations and is the number of roots. Type: string; Possible Values: RSP, OLSEN, MITRUSHENKOV, DAVIDSON, SEM, SEMTEST; Default: SEM. LSE¶. Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE¶. Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE¶. Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. PRECONDITIONER¶. This specifies the type of preconditioner to use in the selected diagonalization method. The valid options are: DAVIDSON which approximates the Hamiltonian matrix by the diagonal elements; H0BLOCK_INV which uses an exact Hamiltonian of H0_BLOCKSIZE and explicitly inverts it; GEN_DAVIDSON which does a spectral decomposition of H0BLOCK; ITER_INV using an iterative approach to obtain the correction vector of H0BLOCK. The H0BLOCK_INV, GEN_DAVIDSON, and ITER_INV approaches are all formally equivalent but the ITER_INV is less computationally expensive. Default is DAVIDSON. Type: string; Possible Values: LANCZOS, DAVIDSON, GEN_DAVIDSON, H0BLOCK, H0BLOCK_INV, ITER_INV, H0BLOCK_COUPLING, EVANGELISTI; Default: DAVIDSON. UPDATE¶. The update or correction vector formula, either DAVIDSON (default) or OLSEN. Type: string; Possible Values: DAVIDSON, OLSEN; Default: DAVIDSON. Density Matrices¶. DIPMOM¶. Do compute th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__detci-1.html:4929,perform,performed,4929,psi4manual/1.0.0/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__detci-1.html,10,['perform'],['performed']
Performance," to check frozen core. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. nbody-he-4b; MP2/aug-cc-pvDZ many body energies of an arbitrary Helium complex, addressing 4-body formulas. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. scf-guess-read3; Test if the the guess read in the same basis converges. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. cbs-xtpl-func; optimization with method defined via cbs. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doub",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:16764,optimiz,optimization,16764,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance," to make plots of the molecular geometry; with the atoms colored according to their order-1 F-SAPT contributions. We have; a set of template .pymol scripts to help with this process. These can be; obtained by running:; >>> copy_pymol.py. and then in PyMol:; >>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; Elst.pymol), which in turn load in the molecule and order-1 analysis; (contained in the .pdb file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Difference F-SAPT Analysis¶; For those interested in taking the differences between two F-SAPT partitions; (e.g., to see how a substituent modulates a noncovalent interaction), we have; the fsapt-diff.py script to help with this. This is invoked as:; >>> fsapt-diff.py source-fsapt-dir1 source-fsapt-dir2 target-diff-fsapt-dir. Where the use has already performed fsapt.py analysis using the same; functional group names in source-fsapt-dir-1 and source-fsapt-dir-2. The; difference F-SAPT partition entries are computed as \(E^{\Delta} = E^{1} -; E^{2}\), and the geometries for order-1 .pdb visualization files are taken; from system 1. I-SAPT: A Representative Example¶. Caution; As of April 2018, you can’t specify molecule fragments; with an unphysical multiplicity like the singlet OH fragments in; the molecule below, especially as (again in the example below) the; overall molecule needs to be a singlet, which PSI4 doesn’t at; present let be set independently. For situations like this, use the; temporary input pattern in isapt1 . Below, we show an example of using I-SAPT0/jun-cc-pVDZ to analyze the; interaction between the two phenol groups in a 2,4-pentanediol molecule.; This example is; explicitly included in isapt1. A video; lecture explaining this example is available; I-SAPT#1,; while an additional video describing how to plot ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/fisapt.html:8288,perform,performed,8288,psi4manual/master/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/master/fisapt.html,9,['perform'],['performed']
Performance," to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_ever",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:4816,optimiz,optimize,4816,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimize']
Performance," to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); else:; instructionsM += """"""# psi4 -a -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in', 'OPT-master.out'); instructionsM += """"""# After each optimization iteration",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:25045,optimiz,optimization,25045,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,3,['optimiz'],['optimization']
Performance," to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Depen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:6528,load,load,6528,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,6,['load'],['load']
Performance," to the specified module arg1 or globally, by either user or code. has_variable((arg0: str) -> bool); Returns true if the PSI variable exists/is set. initialize(() -> bool). legacy_wavefunction(() -> psi::Wavefunction); Returns the current legacy_wavefunction object from the most recent computation. libfock(...); Runs a CPHF calculation, using libfock. mcscf(...); Runs the MCSCF code, (N.B. mrcc_generate_input(...); Generates an input for Kallay’s MRCC code. mrcc_load_densities(...); Reads in the density matrices from Kallay’s MRCC code. occ(...); Runs the orbital optimized CC codes. opt_clean(() -> None); Cleans up the optimizer’s scratch files. optking(() -> int); Runs the geometry optimization / frequency analysis code. outfile_name(() -> str); Returns the name of the output file. plugin((arg0: str, ...); Call the plugin of name arg0. plugin_close((arg0: str) -> None); Close the plugin of name arg0. plugin_close_all(() -> None); Close all open plugins. plugin_load((arg0: str) -> int); Load the plugin of name arg0. prepare_options_for_module((arg0: str) -> None); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(() -> None); Prints the currently set global (all modules) options to the output file. print_options(() -> None); Prints the currently set options (to the output file) for the current module. print_out((arg0: str) -> None); Prints a string (using sprintf-like notation) to the output file. print_variables(() -> None); Prints all PSI variables that have been set internally. psi_top_srcdir(() -> str); Returns the location of the source code. psimrcc((arg0: psi::Wavefunction) -> float); Runs the multireference coupled cluster code. reopen_outfile(() -> None); Reopens the output file. revoke_global_option_changed((arg0: str) -> None); Given a string of a keyword name arg1, sets the has_changed attribute in the global options scope to false. revoke_local_option_changed((arg0: str, ...); Given a string of a ke",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:168703,Load,Load,168703,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['Load'],['Load']
Performance," to understand the specifics of SAPT0 before beginning; with F/I-SAPT0.; F-SAPT is detailed over two papers: [Parrish:2014:044115] on our much-earlier; “atomic” SAPT (A-SAPT) and [Parrish:2014:4417] on the finished “functional; group” SAPT (F-SAPT). An additional paper describes how to use F-SAPT to analyze; differences under functional group substitutions [Parrish:2014:17386]. I-SAPT; is explained in [Parrish:2015:051103]. There is also a reasonably-detailed; review of the aims of A/F/I-SAPT and the existing state-of-the-art in the field; in the introduction chapter on partitioned SAPT methods in Parrish’s thesis.; A video tutorial series for the use of the FISAPT module is available here.; Specific videos in the series include:. F-SAPT#1.; Describes the use of F-SAPT to analyze the; distribution of the intermolecular interaction energy components between the; various hydroxyl and phenyl moieties of the phenol dimer.; F-SAPT#2.; Discusses how to plot the order-1 F-SAPT analysis with PyMol and perform a; “difference F-SAPT” analysis; I-SAPT#1.; Describes the use of I-SAPT to analyze the interaction between the two phenol; groups in a 2,4-pentanediol molecule.; I-SAPT#2.; Discusses how to plot the density fields and ESPs of the various moieties of; the I-SAPT embedding scheme with PyMol; F/I-SAPT Options.; Details all of the more-advanced options in the F/I-SAPT code (rarely needed). The scripts discussed below are located in psi4/psi4/share/psi4/fsapt. F-SAPT: A Representative Example¶; Below, we show an example of using F-SAPT0/jun-cc-pVDZ to analyze the; distribution of the intermolecular interaction energy components between the; various hydroxyl and phenyl moieties of the phenol dimer. This example is; explicitly included in fsapt1. A video; lecture explaining this example is available F-SAPT#1,; while an additional video describing how to plot the order-1 F-SAPT analysis; with PyMol and perform a “difference F-SAPT”; analysis is available F-SAPT#2:; 1; 2; 3; 4; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fisapt-1.html:2124,perform,perform,2124,psi4manual/1.1.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fisapt-1.html,6,['perform'],['perform']
Performance," to understand the specifics of SAPT0 before beginning; with F/I-SAPT0.; F-SAPT is detailed over two papers: [Parrish:2014:044115] on our much-earlier; “atomic” SAPT (A-SAPT) and [Parrish:2014:4417] on the finished “functional; group” SAPT (F-SAPT). An additional paper describes how to use F-SAPT to analyze; differences under functional group substitutions [Parrish:2014:17386]. I-SAPT; is explained in [Parrish:2015:051103]. There is also a reasonably-detailed; review of the aims of A/F/I-SAPT and the existing state-of-the-art in the field; in the introduction chapter on partitioned SAPT methods in Parrish’s thesis.; A video tutorial series for the use of the FISAPT module is available here.; Specific videos in the series include:. F-SAPT#1.; Describes the use of F-SAPT to analyze the; distribution of the intermolecular interaction energy components between the; various hydroxyl and phenyl moieties of the phenol dimer.; F-SAPT#2.; Discusses how to plot the order-1 F-SAPT analysis with PyMol and perform a; “difference F-SAPT” analysis; I-SAPT#1.; Describes the use of I-SAPT to analyze the interaction between the two phenol; groups in a 2,4-pentanediol molecule.; I-SAPT#2.; Discusses how to plot the density fields and ESPs of the various moieties of; the I-SAPT embedding scheme with PyMol; F/I-SAPT Options.; Details all of the more-advanced options in the F/I-SAPT code (rarely needed). The scripts discussed below are located in psi4/psi4/share/psi4/fsapt. F-SAPT: A Representative Example¶; Below, we show an example of using F-SAPT0/jun-cc-pVDZ to analyze the; distribution of the intermolecular interaction energy components between the; various hydroxyl and phenyl moieties of the phenol dimer. This example is; explicitly included in fsapt1. A video; lecture explaining this example is available F-SAPT#1,; while an additional video describing how to plot the order-1 F-SAPT analysis; with PyMol and perform a “difference F-SAPT”; analysis is available F-SAPT#2:; memory 1 GB.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:2179,perform,perform,2179,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,6,['perform'],['perform']
Performance," to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set' : [{'type' : 'distance',; 'indices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in; place:; molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:22569,Optimiz,Optimize,22569,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,9,['Optimiz'],['Optimize']
Performance," totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). psi4.hessian(name[, molecule, return_wfn, func, dertype, irrep])[source]; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. Returns; Matrix – Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. Returns; (Matrix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). It’s handy to collect the wavefunction after a frequency; calculation through e, wfn = psi4.frequency(...,; return_wfn=True) as the frequencies can be accessed through; psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/freq-1.html:3486,optimiz,optimize,3486,psi4manual/1.4.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/freq-1.html,5,['optimiz'],['optimize']
Performance," touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); tensor[1][1] += self.mass(i) * (self.x(i) * self.x(i) + self.z(i) * self.z(i)); tensor[2][2] += self.mass(i) * (self.x(i) * self.x(i) + self.y(i) * self.y(i)). # I(alpha, beta); tensor[0][1] -= self.mass(i) * self.x(i) * self.y(i); tensor[0][2] -= self.mass(i) * self.x(i) * self.z(i); tensor[1][2] -= self.mass(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12732,Queue,Queue,12732,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,2,['Queue'],['Queue']
Performance," touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True, zero=ZERO):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt, zero). [docs] def inertia_tensor_partial(self, part, masswt=True, zero=ZERO):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); tensor[1][1] += self.mass(i) * (self.x(i) * self.x(i) + self.z(i) * self.z(i)); tensor[2][2] += self.mass(i) * (self.x(i) * self.x(i) + self.y(i) * self.y(i)). # I(alpha, beta); tensor[0][1] -= self.mass(i) * self.x(i) * self.y(i); tensor[0][2] -= self.mass(i) * self.x(i) * self.z(i)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:30120,Queue,Queue,30120,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,2,['Queue'],['Queue']
Performance," toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the dynamic level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals.; Optking does support the specification of ghost atoms. Certain internal coordinates such; as torsions become poorly defined when they contain near-linear bends.; An internal error AlgError may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; however, they may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting OPT_COORDINATES to cartesian will avoid any internal; coordinate difficulties altogether. These coordinate changes can be automatically; performed by turning DYNAMIC_LEVEL to 1. Warning; In some cases, such as the coordinate issues described above, optking will reset to maintain; a consistent history. If an error occurs in Psi4 due to GEOM_MAXITER being exceeded but; the final step report indicates that optking has not taken GEOM_MAXITER steps, such a; reset has occured. Inspection will show that the step counter was reset to 1 somewhere in the; optimization. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:17921,optimiz,optimization,17921,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,4,['optimiz'],['optimization']
Performance," triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:17846,optimiz,optimization,17846,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,2,['optimiz'],['optimization']
Performance," triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/opt.html:17197,optimiz,optimization,17197,psi4manual/1.7.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/opt.html,2,['optimiz'],['optimization']
Performance," triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/opt.html:17403,optimiz,optimization,17403,psi4manual/1.8.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/opt.html,2,['optimiz'],['optimization']
Performance," triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/opt.html:17839,optimiz,optimization,17839,psi4manual/1.9.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/opt.html,2,['optimiz'],['optimization']
Performance," triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/mrcc-1.html:3920,optimiz,optimize,3920,psi4manual/1.4.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/mrcc-1.html,4,['optimiz'],['optimize']
Performance," triples with iterative quadruples (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/mrcc-1.html:3920,optimiz,optimize,3920,psi4manual/1.5.0/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/mrcc-1.html,4,['optimiz'],['optimize']
Performance," true. MO_MAXITER (OMP2); OMP2 — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_MAXITER (OMP3); OMP3 — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF); MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OMP2); OMP2 — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_READ (OMP3); OMP3 — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_RELAX (DCFT); DCFT (Expert) — Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. MO_STEP_MAX (OMP2); OMP2 — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_STEP_MAX (OMP3); OMP3 — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OMP2); OMP2 — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MO_WRITE (OMP3); OMP3 — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODE (TRANSQT); TRANSQT — The way of transformation, from ao basis to mo basis or vice versa. Type: string; Possible Values: TO_MO, TO_AO; Default: TO_MO. MODULE (CPHF); CPHF — What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. MOLDEN_FILE (SCF); SCF — The name of a molden-style output file which is only generated if the user specifies one. Type: string; Default: No Default. MOM_OCC (SCF); SCF — The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START (SCF); SCF — The iteration to start MOM on (or 0 for no MOM)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:74111,optimiz,optimization,74111,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance," tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. cbs-xtpl-dict; Extrapolated water energies. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cbs-delta-energy; Extrapolated energies with delta correction. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc51; EOM-CC3/cc-pVTZ on H2O. opt7; Various constrained energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:8865,perform,performed,8865,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance," two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:16203,perform,perform,16203,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,2,['perform'],['perform']
Performance," two-electron integrals file. Type: integer; Default: PSIF_MO_BB_TEI. BENCH (GLOBALS); GLOBALS — Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Cache",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:6390,CACHE,CACHELEVEL,6390,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,"['CACHE', 'Cache']","['CACHELEVEL', 'Cacheing']"
Performance," uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; ---",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:5014,perform,perform,5014,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,12,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance," uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; ------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:5667,perform,perform,5667,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,18,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance," uhf; energy ('scf'). This sample input can be found in; tu2-ch2-energy and as; before it can be run through the command psi4 input.dat output.dat; (actually, because psi4 by default looks for an input file named; input.dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92534160932308. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt.; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After about 4 cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; -----------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:4196,perform,perform,4196,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,8,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance," unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.SymmetryOperation.html:2617,Perform,Performs,2617,psi4manual/1.6.x/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.SymmetryOperation.html,2,['Perform'],['Performs']
Performance," unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. FROZEN_UOCC (PSIMRCC); PSIMRCC — The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING); OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM); CCEOM — Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. FZC_A_FILE (TRANSQT); TRANSQT — Alpha-spin frozen-core file. Type: integer; Default: PSIF_OEI. FZC_B_FILE (TRANSQT); TRANSQT — Beta-spin frozen-core file. Type: integer; Default: PSIF_OEI. FZC_FILE (TRANSQT); TRANSQT — Frozen-core file. Type: integer; Default: PSIF_OEI. G_CONVERGENCE (OPTKING); OPTKING — Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. GAUGE (CCDENSITY); CCDENSITY — The type of gauge to use for properties. Type: string; Default: LENGTH. GAUGE (CCRESPONSE); CCRESPONSE — Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; De",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:47508,optimiz,optimization,47508,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance," upon activating through ``set integral_package erd``, known failures will be caught and halted, but perhaps other types not tested and identified will give *wrong* answers. Consider this your warning.""); endif(). ############################ Options: Build How? #############################; include(psi4OptionsTools); option_with_print(BUILD_SHARED_LIBS ""Build internally built Psi4 add-on libraries as shared, not static"" OFF); option_with_print(ENABLE_OPENMP ""Enables OpenMP parallelization"" ON); option_with_print(ENABLE_AUTO_BLAS ""Enables CMake to auto-detect BLAS"" ON); option_with_print(ENABLE_AUTO_LAPACK ""Enables CMake to auto-detect LAPACK"" ON); option_with_print(ENABLE_PLUGIN_TESTING ""Test the plugin templates build and run"" OFF); option_with_flags(ENABLE_XHOST ""Enables processor-specific optimization"" ON; ""-xHost"" ""-march=native""); option_with_flags(ENABLE_CODE_COVERAGE ""Enables details on code coverage"" OFF; ""-ftest-coverage""); option_with_flags(ENABLE_BOUNDS_CHECK ""Enables bounds check in Fortran"" OFF; ""-ftrapuv -check all -fpstkchk"" ""-fcheck=all"" ""-fbounds-check -fcheck-array-temporaries""); option_with_flags(ENABLE_ASAN ""Enables address sanitizer"" OFF; ""-fsanitize=address"" ""-fno-omit-frame-pointer""); option_with_flags(ENABLE_TSAN ""Enables thread sanitizer"" OFF; ""-fsanitize=thread"" ""-fno-omit-frame-pointer -pie""); option_with_flags(ENABLE_UBSAN ""Enables undefined behavior sanitizer"" OFF; ""-fsanitize=undefined"" ""-fno-omit-frame-pointer""); option_with_default(MAX_AM_ERI ""Maximum angular momentum for integrals"" 5); option_with_default(CMAKE_BUILD_TYPE ""Build type (Release or Debug)"" Release); option_with_default(FC_SYMBOL ""The type of Fortran name mangling"" 2); option_with_default(BUILD_FPIC ""Compile static libraries with position independent code"" ON). Note that external projects will have their own sets of build; configuration options. Only the most-common user knobs of those are; mentioned above. How to install elsewhere than /usr/local/psi4¶; The installatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:13447,optimiz,optimization,13447,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['optimiz'],['optimization']
Performance," uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. scf-upcast-custom-basis; test scf castup with custom basis sets. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. fnocc5; Test FNO-DF-CCSD(T) energy. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:39128,perform,performed,39128,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance," values. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). mbis-4; MBIS calculation on NaCl. numpy-array-interface; Numpy interface testing. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fci-dipole; 6-31G H2O Test FCI Energy Point. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. mints-helper; A general test of the MintsHelper function. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cisd-h2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:17201,optimiz,optimization,17201,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance," variables:\n'); PsiMod.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (PsiMod.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False):; PsiMod.opt_clean(); PsiMod.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(). optstash.restore(); return thisenergy; PsiMod.print_out('\n Structure for next step:\n'); PsiMod.get_active_molecule().print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = get_psifile(1); kwargs['mode'] = 'sow'. n += 1. PsiMod.print_out('\tOptimizer: Did not converge!'). optstash.restore(); return 0.0. ## Aliases ##; opt = optimize. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """"""; namelower = name.lower(). # matches 'mrccsdt(q)'; if namelower.startswith('mrcc'):; # grabs 'sdt(q)'; ccfullname = namelower[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method' : 1, 'order' : 2, 'fullname' : 'CCSD' },; 'sdt' : { 'method' : 1, 'order' : 3, 'fullname' : 'CCSDT' },; 'sdtq' : { 'method' : 1, 'order' : 4, 'fullname' : 'CCSDTQ' },; 'sdtqp' : { 'method' : 1, 'order' : 5, 'fullname' : 'CCSDTQP' },; 'sdtqph' : { 'method' : 1, 'order' : 6, 'fullname' : 'CCSDTQPH' },; 'sd(t)' : { 'method' : 3, 'order' : -3, 'fullname' : 'CCSD(T)' },; 'sdt(q)' : { 'method' : 3, 'order' : -4, 'fullname' : 'CCSDT(Q)' },; 'sdtq(p)' : { 'method' : 3, 'order' : -5, 'fullname' : 'CCSDTQ(P)' },; 'sdtqp(h)' : { 'method' : 3, 'order' : -6, 'fullname' : 'CCSDTQP(H)' },; 'sd(t)_l' : ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:54356,optimiz,optimize,54356,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['optimiz'],['optimize']
Performance," various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/testsuite-1.html:12172,optimiz,optimized,12172,psi4manual/4.0b3/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/testsuite-1.html,4,['optimiz'],['optimized']
Performance," we do the QQR integral sieve of Maurer et al. When false, just uses * the Schwarz sieve. Type: boolean; Default: false. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING); OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:112605,perform,perform,112605,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,12,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance," weak pairs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__ccresponse-1.html:3771,CACHE,CACHELEVEL,3771,psi4manual/1.3.2/autodir_options_c/module__ccresponse-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__ccresponse-1.html,2,['CACHE'],['CACHELEVEL']
Performance," when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_strings(expected, computed, label)[source]¶; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. compare_values(expected, computed, digits, label, exitonfail=True)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits; (or to digits itself when digits > 1 e.g. digits=0.04). Performs; a system exit on failure unless exitonfail False, in which case; returns error message. Used in input files in the test suite. drop_duplicates(seq)[source]¶; Function that given an array seq, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. findfile_ignorecase(fil, pre='', post='')[source]¶; Function to locate a file pre + fil + post in any possible ; lettercase permutation of fil. Returns pre + fil + post if ; available, None if not. getattr_ignorecase(module, attr)[source]¶; Function to extract attribute attr from module if attr; is available in any possible lettercase permutation. Returns; attribute if available, None if not. import_ignorecase(module)[source]¶; Function to import module in any possible lettercase; permutation. Returns module object if available, None if not. query_yes_no(question, default=True)[source]¶; Ask a yes/no question via raw_input() and return their answer.; question is a string that is presented to the user.; default is the presumed an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:96813,Perform,Performs,96813,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Perform'],['Performs']
Performance," whether just the excitation energies (OFF, =0) or in addition transition moments (EXPECTATION, =1) are calculated. Note that this keyword should not be used in excited-state calculations involving analytic gradients and that transition moments are essentially only available for EOM-CCSD/CCSD-LR. Type: string; Possible Values: OFF, EXPECTATION; Default: OFF. CFOUR_EVAL_HESS (CFOUR)¶CFOUR — Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. CFOUR_EXCITATION (CFOUR)¶CFOUR — Specifies in CC calculations using mrcc the excitation level if the calculation level has been chosen as CC(n), CI(n), or CCn(n). Type: integer; Default: 0. CFOUR_EXCITE (CFOUR)¶CFOUR — Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. CFOUR_FC_FIELD (CFOUR)¶CFOUR — Specifies the strength of a Fermi-Contact perturbation as required for finite-field calculations of spin densities and the FC contributions to indirect spin-spin coupling constants. The value must be specified as an integer and the FC strength used by the program will be the value of the keyword \(\times 10^{-6}\). The atom for which the FC perturbation is switched on is specified in the ZMAT file after the CFOUR command line and potential basis set input, as follows %spin density N with N as the number of atom (in (X5,I3) format) in the order they are written by JODA to the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:39318,perform,performed,39318,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['perform'],['performed']
Performance," which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 12. NUM_ROOTS¶. number of CI roots to find. Type: integer; Default: 1. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. DIAG_METHOD¶. This specifies which method is to be used in diagonalizing the Hamiltonian. The valid options are: RSP, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); OLSEN, to use Olsen’s preconditioned inverse subspace method (19",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/detci-1.html:5981,optimiz,optimized,5981,psi4manual/4.0b3/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/detci-1.html,4,['optimiz'],['optimized']
Performance," will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard setting (freezes more orbitals). More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. NUM_FROZEN_DOCC¶. The number of core orbitals to freeze in later correlated computations. FROZEN_DOCC trumps this option. Type: integer; Default: 0. NUM_FROZEN_UOCC¶. The number of virtual orbitals to freeze in later correlated computations. FROZEN_UOCC trumps this option. Type: integer; Default: 0. PRINT¶. The amount of information to print to the output file. 1 prints basic information, and higher levels print more information. A value of 5 will print very large amounts of debugging information. Type: integer; Default: 1. PROPERTIES¶. List of properties to compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates, or a string (see manual) describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default come",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__globals-1.html:1564,optimiz,optimized,1564,psi4manual/4.0b3/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__globals-1.html,2,['optimiz'],['optimized']
Performance," will default to freezing the standard default number of core orbitals. For heavier elements, there can be some ambiguity in how many core orbitals to freeze; in such cases, SMALL picks the most conservative standard setting (freezes fewer orbitals), and LARGE picks the least conservative standard setting (freezes more orbitals). More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. NUM_FROZEN_DOCC¶. The number of core orbitals to freeze in later correlated computations. FROZEN_DOCC trumps this option. Type: integer; Default: 0. NUM_FROZEN_UOCC¶. The number of virtual orbitals to freeze in later correlated computations. FROZEN_UOCC trumps this option. Type: integer; Default: 0. PRINT¶. The amount of information to print to the output file. 1 prints basic information, and higher levels print more information. A value of 5 will print very large amounts of debugging information. Type: integer; Default: 1. PROPERTIES¶. List of properties to compute. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Type: boolean; Default: true. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__globals-1.html:1549,optimiz,optimized,1549,psi4manual/4.0b2/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__globals-1.html,2,['optimiz'],['optimized']
Performance," will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; psi4.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(moleculeclone); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print("""""" %d displacements needed ..."""""" % (ndisp), end=''); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if opt_mode == 'sow':; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:37649,optimiz,optimization,37649,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimization']
Performance," with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: false. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. HESS_TYPE¶. Type Hessian matrix will be used in orbital optimization procedure. Type: string; Possible Values: NONE; Default: NONE. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html:1467,perform,perform,1467,psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance," with different Cartesian coordinates like Cartesian-distance-matrix; cost matrix does. So, form a bipartite graph from all essentially-zero connections between; ref and concern and run Uno algorithm to enumerate them. """"""; if verbose >= 1:; print(""""""Space: {} <--> {}"""""".format(rgp, cgp)). # formulate cost matrix from internal (not Cartesian) layouts of R & C; npcgp = np.array(cgp); submatCC = ccnremat[np.ix_(cgp, cgp)]; submatRR = rrnremat[np.ix_(rgp, rgp)]; sumCC = 100.0 * np.sum(submatCC, axis=0) # cost mat small if not scaled, this way like Z=Neon; sumRR = 100.0 * np.sum(submatRR, axis=0); cost = np.zeros((len(cgp), len(rgp))); for j in range(cost.shape[1]):; for i in range(cost.shape[0]):; cost[i, j] = (sumCC[i] - sumRR[j]) ** 2; if verbose >= 2:; print(""Cost:\n"", cost); costcopy = np.copy(cost) # other one gets manipulated by hungarian call. # find _a_ best match btwn R & C atoms through Kuhn-Munkres (Hungarian) algorithm; # * linear_sum_assigment call is exactly like `scipy.optimize.linear_sum_assignment(cost)` only with extra return; t00 = time.time(); (row_ind, col_ind), reducedcost = linear_sum_assignment(cost, return_cost=True); ptsCR = list(zip(row_ind, col_ind)); ptsCR = sorted(ptsCR, key=lambda tup: tup[1]); sumCR = costcopy[row_ind, col_ind].sum(); t01 = time.time(); if verbose >= 2:; print(""Reduced cost:\n"", cost); if verbose >= 1:; print(""Hungarian time [s] for space: {:.3}"".format(t01 - t00)). # find _all_ best matches btwn R & C atoms through Uno algorithm, seeded from Hungarian sol'n; edges = np.argwhere(reducedcost < uno_cutoff); gooduns = uno(edges, ptsCR); t02 = time.time(); if verbose >= 1:; print(""Uno time [s] for space: {:.3}"".format(t02 - t01)). for gu in gooduns:; gu2 = gu[:]; gu2.sort(key=lambda x: x[1]) # resorts match into (r, c) = (info, range); subans = [p[0] for p in gu2] # compacted to subans/lap format. ans = tuple(npcgp[np.array(subans)]); if verbose >= 3:; print(""Best Candidate ({:6.3}):"".format(sumCR), rgp, ""<--"", ans, "" from"", ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html:12533,optimiz,optimize,12533,psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/qcelemental/molutil/align.html,3,['optimiz'],['optimize']
Performance," with other scientific software projects).; PSI4 1.3 supports Python 3.6 and 3.7.; PSI4 1.4 supports Python 3.6, 3.7, 3.8, and 3.9.; PSI4 1.5 supports Python 3.7, 3.8, and 3.9.; PSI4 1.6 supports Python 3.8, 3.9, and 3.10.; PSI4 1.7 supports Python 3.8, 3.9, 3.10, and 3.11 (no binary packages for 3.11).; PSI4 1.8 supports Python 3.8, 3.9, 3.10, and 3.11.; PSI4 1.9 supports Python 3.8, 3.9, 3.10, 3.11, and 3.12.; The future plan is to (1) be compatible with 3.8 and above until there is a good reason to drop; older versions but (2) only build and test for versions conda-forge supports.; The current master supports 3.8, 3.9, 3.10, 3.11, and 3.12. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; General GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties.; For more tables with capabilities details:. Full Capabilities (first below) lists all methods; Capabilities Breakdown (second below) lists selected methods by reference, etc.; Module Capabilities lists selected methods by implementation; Energy, Energy (DFT), Energy (MRCC), Energy (CFOUR) fully list energy target methods; Gradient, Gradient (CFOUR) fully list gradient target methods; Frequency fully lists",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/introduction.html:23805,perform,perform,23805,psi4manual/1.9.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/introduction.html,1,['perform'],['perform']
Performance," with the DF phase reaching convergence in eight true; iterations. When used together, SAD and DIIS are usually sufficient to converge; the SCF for all but the most difficult systems. Additional convergence; techniques are available for more difficult cases, and are detailed below. At; this point, the code switches on the requested Direct integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in Psi4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf.html:3968,optimiz,optimized,3968,psi4manual/1.0.0/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf.html,2,['optimiz'],['optimized']
Performance," {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:56046,optimiz,optimizer,56046,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,5,['optimiz'],['optimizer']
Performance," {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). """"""; import psi4; if not psi4.addons(""mrcc""):; raise ImportError(""Install MRCC (executable 'dmrcc') to use the allen_focal_point function.""). # Note: HF and MP2 steps (which do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:4828,perform,performed,4828,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html,3,['perform'],['performed']
Performance," {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]; def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; ## First half of this fn -- entry means user wants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:41747,optimiz,optimize,41747,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['optimiz'],['optimize']
Performance," | C++ signature :; | void writeNO(N3psi12MoldenWriterE {lvalue},Ss,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class Molecule(Boost.Python.instance); | Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; | ; | Method resolution order:; | Molecule; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | BFS(self); | Perform a breadth-first search (BFS) on the real atoms; | in molecule, returning an array of atom indices of fragments.; | Relies upon van der Waals radii and so faulty for close; | (esp. hydrogen-bonded) fragments. Original code from; | Michael S. Marshall.; | ; | Z(...); | Z( (Molecule)arg1, (int)arg2) -> float :; | Nuclear charge of atom; | ; | C++ signature :; | d Z(N3psi8MoleculeE {lvalue},i); | ; | __getattr__ = new_get_attr(self, name); | Function to redefine __getattr__ method of molecule class.; | ; | __init__(...); | __init__( (object)arg1) -> None :; | ; | C++ signature :; | void __init__(P7_object); | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | __setattr__ = new_set_attr(self, name, value); | Function to redefine __setattr__ method of molecule class.; | ; | activate_all_fragments(...); | activate_all_fragments( (Molecule)arg1) -> None :; | Sets all fragments in the molecule to be active; | ; | C++ signature :; | void activate_all_fragments(N3psi8MoleculeE {lvalue}); | ; | add_atom(...); |",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:542789,Perform,Perform,542789,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['Perform'],['Perform']
Performance," || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:1702,optimiz,optimization,1702,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,12,['optimiz'],['optimization']
Performance," }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True). monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True). psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'). aux_basis = psi4.core.BasisSet.build(wfn_dimer.molecule(), ""DF_BASIS_SAPT"",; psi4.core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", psi4.core.get_global_option(""BASIS"")); wfn_dimer.set_basisset(""DF_BASIS_SAPT"", aux_basis); wfn_dimer.set_basisset(""DF_BASIS_ELST"", aux_basis). psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be tweaked for individual fragments.; For optimal efficiency, the example uses set df_ints_io save to keep file 97,; which contains the three-index integrals for density fitting. set df_ints_io load; then instructs the program to read these integrals from disk instead of recomputing; them. For each SCF computation, we use psi4.IO.set_default_namespace to uniquely; name scratch files. In the following SCF step, only file 97 is renamed using; psi4.IO.change_file_namespace so that integrals can be read from it.; For more information on stability analysis, see the stability; documentation. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT; truncations, using different basis sets, is reported in; [Parker:2014:094106]. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been inclu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:17549,load,load,17549,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,13,['load'],['load']
Performance,"    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; prop. prop¶. psi4.driver.prop(*args, **kwargs)¶; Function to compute various properties. Aliases:; prop(). Returns:; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.prop.html:998,optimiz,optimized,998,psi4manual/1.8.x/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.prop.html,1,['optimiz'],['optimized']
Performance,"    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; prop. prop¶. psi4.driver.prop(*args, **kwargs)¶; Function to compute various properties. Aliases:; prop(). Returns:; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.prop.html:998,optimiz,optimized,998,psi4manual/1.9.x/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.prop.html,1,['optimiz'],['optimized']
Performance,"    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → Annotated[list[Annotated[list[float], FixedSize(3)]], FixedSize(3)]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.SymmetryOperation.html:1049,Perform,Performs,1049,psi4manual/master/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,"    .    .  · ; 1.3.2;  · . PSI4. Appendices. Test Suite and Sample Inputs¶; PSI4 is distributed with an extensive test suite, which can; be found in psi4/tests. After building the source code, these; can automatically be run by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. CFOUR; CHEMPS2; COOKBOOK; DFTD3; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/testsuite-1.html:1053,optimiz,optimizations,1053,psi4manual/1.3.2/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/testsuite-1.html,2,['optimiz'],['optimizations']
Performance,"  . -D2; alias to -D2P4;  . -D2P4; -D2 [3] within Psi4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [, , , ]. -D3M; alias to -D3MZERO;  . -D3MZERO; -D3 [6] w/ reparameterized and more flexible original zero-damping through dftd3; [, , , ]. -D3MBJ; -D3 [6] w/ reparameterized newer Becke-Johnson rational damping through dftd3; [, , , ]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, have nothing to do with this table. [2][Grimme:2004:1463]. [3](1, 2) [Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. [6](1, 2) [Smith:2016:2197]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same Psi4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dftd3-1.html:6311,optimiz,optimization,6311,psi4manual/1.0.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dftd3-1.html,2,['optimiz'],['optimization']
Performance,"  . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module ». CCENERGY¶; Performs local MP2 computations for RHF reference functions. General¶. ABCD¶. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DF_BASIS_MP2¶. Auxiliary basis set for MP2 density fitting calculations. Type: string; Possible Values: basis string; Default: No Default. DF_LMP2¶. Do use density fitting? Turned on with specification of fitting basis. Type: boolean; Default: true. DIAG_METHOD¶. Diagonalization method for the CI mat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html:1092,cache,cache,1092,psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,2,['cache'],['cache']
Performance,"  .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module. DFMP2¶; Performs density-fitted MP2 computations for RHF/UHF/ROHF reference wavefunctions. General¶. BASIS¶. Primary basis set. Type: string; Possible Values: basis string; Default: NONE. DFMP2_MEM_FACTOR¶. % of memory for DF-MP2 three-index buffers. Type: double; Default: 0.9. DFMP2_P2_TOLERANCE¶. Minimum error in the 2-norm of the P(2) matrix for corrections to Lia and P. Type: conv double; Default: 0.0. DFMP2_P_TOLERANCE¶. Minimum error in the 2-norm of the P matrix for skeleton-core Fock matrix derivatives. Type: conv double; Default: 0.0. DF_BASIS_MP2¶. Auxiliary basis set for MP2 density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_INTS_NUM_THREADS¶. Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. INTS_TOLERANCE¶. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 0.0. MP2_OS_SCALE¶. OS Scale. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. SS Scale. Type: double; Default: 1.0/3.0. ONEPDM¶. Do compute one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: true. Expert¶. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. MADMP2_SLEEP¶. A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. table of contents. DFMP2; General; BASIS; DFMP2_MEM_FACTOR; DFMP2_P2_TOLERANCE; DFMP2_P_TOLERANCE; DF_BASIS_MP2; DF_INTS_NUM_THREADS; INTS_TOLERANCE; MP2_OS_SCALE; MP2_SS_SCALE; ONEPDM; OPDM_RELAX. Expert; DF_INTS_IO; MADMP2_SLEEP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__dfmp2-1.html:1427,LOAD,LOAD,1427,psi4manual/1.2.1/autodir_options_c/module__dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__dfmp2-1.html,2,['LOAD'],['LOAD']
Performance,"  .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_builtins.pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.symmetryoperation.html:1041,Perform,Performs,1041,psi4manual/1.3.2/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.symmetryoperation.html,1,['Perform'],['Performs']
Performance,"  .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; prop. prop¶. psi4.driver.prop(*args, **kwargs)¶; Function to compute various properties. Aliases:; prop(). Returns:; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.prop.html:1005,optimiz,optimized,1005,psi4manual/master/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.prop.html,1,['optimiz'],['optimized']
Performance," ». CCENERGY¶; Computes coupled cluster energies. Called as part of any coupled cluster computation. General¶. ABCD¶. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html:1151,CACHE,CACHETYPE,1151,psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html,2,['CACHE'],['CACHETYPE']
Performance," – file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request – ask the forum; Why do you? – ask the forum; When will you? – ask the forum; I have an experience that can improve the build documentation – inform the forum or add to the documentation itself; Anything you want to share privately – crawdad@vt.edu or sherrill@gatech.edu. Footnotes. 1; Frozen natural orbital variant available. In particular, RHF available as CONV. 2(1,2); Frozen natural orbital variant available. In particular, RHF available as CONV/DF. 3(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21); threading through BLAS routines only. 4; DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. DH-DFT gradients not implemented. 5; Both EFP/EFP and QM/EFP energies are available. 6; Adapted from here. 7; DH-DFT only available with DF-MP2. 8(1,2,3,4); Not all combinations of reference and algorithm available. In particular, non-RHF references only available as CONV. For CCSD(T), gradients are not available with frozen core. 9; Orbital-optimized variant available. In particular, all references available as CONV/DF. 10(1,2,3,4,5,6,7,8,9,10); Capabilities breakdown in great detail can be found here. table of contents. Introduction; Overview; Citing PSI4; Overall PSI4 Package; Density Cumulant Theory (DCT); Configuration Interaction (CI); Coupled Cluster (CC); Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC); Symmetry-Adapted Perturbation Theory (SAPT); Orbital-Optimized Post-Hartree–Fock Methods; Algebraic-Diagrammatic Construction methods (ADC); Density Matrix Renormalization Group (DMRG); Scalar Relativistic Corrections. Supported Systems; License; Capabilities; Technical Support. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Introduction. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/introduction.html:28215,optimiz,optimized,28215,psi4manual/1.6.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/introduction.html,2,"['Optimiz', 'optimiz']","['Optimized', 'optimized']"
Performance," — Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS); GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. QMEFP_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation?. Type: boolean; Default: true. QMEFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. R4S (DETCI); DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:187826,perform,perform,187826,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance," — Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS); GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. QMEFP_ELST (EFP); EFP — Do include electrostatics energy term in QM/EFP computation?. Type: boolean; Default: true. QMEFP_POL (EFP); EFP — Do include polarization energy term in EFP computation?. Type: boolean; Default: true. R4S (DETCI); DETCI (Expert) — Do restrict strings with in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:188151,perform,perform,188151,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance," — Controls whether to include the coupling terms in the DCFT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS); GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. QC_TYPE (DCFT); DCFT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC); DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF); SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP); EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. R4S (DETCI); DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (CCLAMBDA); CCLAMBDA — Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:190569,perform,perform,190569,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['perform'],['perform']
Performance," — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MAX_VECS (PSIMRCC)¶PSIMRCC — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (SCF)¶SCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS (DCT)¶DCT (Expert) — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 3. DIIS_MIN_VECS (DETCI)¶DETCI — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_MIN_VECS (OCC)¶OCC — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_MIN_VECS (SCF)¶SCF — Minimum number of error vectors stored for DIIS extrapolation. Will be removed in v1.7. Type: integer; Default: 2. DIIS_RMS_ERROR (SCF)¶SCF — Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. DIIS_START (PSIMRCC)¶PSIMRCC — The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. DIIS_START (SCF)¶SCF — The minimum iteration to start storing DIIS vectors and performing ADIIS/EDIIS. Type: integer; Default: 1. DIIS_START_CONVERGENCE (DCT)¶DCT — Value of RMS of the density cumulant residual and SCF error vector below which DIIS extrapolation starts. Same keyword controls the DIIS extrapolation for the solution of the response equations. Type: conv double; Default: 1e-3. DIIS_START_ITER (DETCI)¶DETCI — Iteration at which to start using DIIS. Type: integer; Default: 1. DIPMOM (DETCI)¶DETCI — Do compute the dipole moment?. Type: boolean; Default: false. DIPMOM (FNOCC)¶FNOCC — Compute the dipole moment? Note that dipole moments are only available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods. Type: boolean; Default: false. DISP_SIZE (FINDIF)¶FINDIF — Displacement size in au for finite-differences. Type: double; Default: 0.005. DISTRIBUTED_MATRIX (SCF)¶SCF (Expert) — The di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:114300,perform,performed,114300,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,5,['perform'],['performed']
Performance, — PSI4 [beta3] documentation; DO_SCS — PSI4 [beta3] documentation; DO_SOS — PSI4 [beta3] documentation; E_CONVERGENCE — PSI4 [beta3] documentation; HESS_TYPE — PSI4 [beta3] documentation; LEVEL_SHIFT — PSI4 [beta3] documentation; LINEQ_SOLVER — PSI4 [beta3] documentation; MAX_MOGRAD_CONVERGENCE — PSI4 [beta3] documentation; MO_MAXITER — PSI4 [beta3] documentation; MO_READ — PSI4 [beta3] documentation; MO_STEP_MAX — PSI4 [beta3] documentation; MO_WRITE — PSI4 [beta3] documentation; MP2_OS_SCALE — PSI4 [beta3] documentation; MP2_SS_SCALE — PSI4 [beta3] documentation; NAT_ORBS — PSI4 [beta3] documentation; OMP2_ORBS_PRINT — PSI4 [beta3] documentation; OPT_METHOD — PSI4 [beta3] documentation; ORTH_TYPE — PSI4 [beta3] documentation; R_CONVERGENCE — PSI4 [beta3] documentation; RMS_MOGRAD_CONVERGENCE — PSI4 [beta3] documentation; SCS_TYPE — PSI4 [beta3] documentation; SOS_SCALE — PSI4 [beta3] documentation; SOS_SCALE2 — PSI4 [beta3] documentation; SOS_TYPE — PSI4 [beta3] documentation; CACHELEVEL — PSI4 [beta3] documentation; CC_MAXITER — PSI4 [beta3] documentation; CUTOFF — PSI4 [beta3] documentation; DIIS_MAX_VECS — PSI4 [beta3] documentation; DO_LEVEL_SHIFT — PSI4 [beta3] documentation; DO_SCS — PSI4 [beta3] documentation; DO_SOS — PSI4 [beta3] documentation; E_CONVERGENCE — PSI4 [beta3] documentation; E3_SCALE — PSI4 [beta3] documentation; HESS_TYPE — PSI4 [beta3] documentation; LEVEL_SHIFT — PSI4 [beta3] documentation; LINEQ_SOLVER — PSI4 [beta3] documentation; MAX_MOGRAD_CONVERGENCE — PSI4 [beta3] documentation; MO_MAXITER — PSI4 [beta3] documentation; MO_READ — PSI4 [beta3] documentation; MO_STEP_MAX — PSI4 [beta3] documentation; MO_WRITE — PSI4 [beta3] documentation; MP2_OS_SCALE — PSI4 [beta3] documentation; MP2_SS_SCALE — PSI4 [beta3] documentation; MP3L_ENERGY — PSI4 [beta3] documentation; NAT_ORBS — PSI4 [beta3] documentation; OMP3_ORBS_PRINT — PSI4 [beta3] documentation; OPT_METHOD — PSI4 [beta3] documentation; ORTH_TYPE — PSI4 [beta3] documentation; R_CONVERG,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1135266,CACHE,CACHELEVEL,1135266,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance," — Psi4 [1.0.0 6a9a71b] Docs; Introduction — Psi4 [1.0.0 6a9a71b] Docs; Introduction — Psi4 [1.0.0 6a9a71b] Docs; Interface to LIBEFP by I. Kaliman — Psi4 [1.0.0 6a9a71b] Docs; Interface to LIBEFP by I. Kaliman — Psi4 [1.0.0 6a9a71b] Docs; Theoretical Methods: SCF to FCI — Psi4 [1.0.0 6a9a71b] Docs; Theoretical Methods: SCF to FCI — Psi4 [1.0.0 6a9a71b] Docs; Interface to Molden, molden() — Psi4 [1.0.0 6a9a71b] Docs; Interface to Molden, molden() — Psi4 [1.0.0 6a9a71b] Docs; Interface to MRCC by M. Kállay — Psi4 [1.0.0 6a9a71b] Docs; Interface to MRCC by M. Kállay — Psi4 [1.0.0 6a9a71b] Docs; <no title> — Psi4 [1.0.0 6a9a71b] Docs; <no title> — Psi4 [1.0.0 6a9a71b] Docs; Counterpoise Correct — Psi4 [1.0.0 6a9a71b] Docs; Counterpoise Correct — Psi4 [1.0.0 6a9a71b] Docs; Notes on Options — Psi4 [1.0.0 6a9a71b] Docs; Notes on Options — Psi4 [1.0.0 6a9a71b] Docs; Notes on Options — Psi4 [1.0.0 6a9a71b] Docs; Notes on Options — Psi4 [1.0.0 6a9a71b] Docs; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories — Psi4 [1.0.0 6a9a71b] Docs; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories — Psi4 [1.0.0 6a9a71b] Docs; oeprop() Evaluation of One-Electron Properties — Psi4 [1.0.0 6a9a71b] Docs; oeprop() Evaluation of One-Electron Properties — Psi4 [1.0.0 6a9a71b] Docs; Geometry Optimization, optimize() and gradient() — Psi4 [1.0.0 6a9a71b] Docs; Geometry Optimization, optimize() and gradient() — Psi4 [1.0.0 6a9a71b] Docs; LibOptions: globals, locals, has_changed and all that — Psi4 [1.0.0 6a9a71b] Docs; LibOptions: globals, locals, has_changed and all that — Psi4 [1.0.0 6a9a71b] Docs; Geometry Optimization — Psi4 [1.0.0 6a9a71b] Docs; Geometry Optimization — Psi4 [1.0.0 6a9a71b] Docs; Interface to PCMSolver — Psi4 [1.0.0 6a9a71b] Docs; Interface to PCMSolver — Psi4 [1.0.0 6a9a71b] Docs; PEP1: Proposing PsiPEP for Psi4 — Psi4 [1.0.0 6a9a71b] Docs; PEP1: Proposing PsiPEP for Psi4 — Psi4 [1.0.0 6a9a71b] Docs; Plugins: Adding N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:143447,Optimiz,Optimized,143447,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['Optimiz'],['Optimized']
Performance, —; Y. MN12-SX-D3BJATM; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; Y. MN12-SX-D3ZERO2B; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; Y. MN12-SX-D3ZEROATM; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; Y. N12-SX; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; —; —. N12-SX-D3BJ2B; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; Y. N12-SX-D3BJATM; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; Y. N12-SX-D3ZERO2B; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; Y. N12-SX-D3ZEROATM; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; Y. TUNED-CAM-B3LYP; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; 0.150000; 0.079900; —; —; —; —; —. WB97; wB97 GGA Exchange-Correlation Functional; Y; —; 0.400000; —; —; —; —; —; —. WB97M-D3BJ; wB97M-V with D3(BJ) instead of VV10 dispersion; Y; Y; 0.300000; 0.150000; —; —; —; Y. WB97M-V; wB97M-V Hyb-GGA Exchange-Correlation Functional; Y; Y; 0.300000; 0.150000; —; —; —; —; —. WB97X; wB97X Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; —; —. WB97X-D; wB97X-D Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.222036; —; —; —; Y. WB97X-D3; wB97X-D3 Hyb-GGA Exchange-Correlation Functional; Y; —; 0.250000; 0.195728; —; —; —; Y. WB97X-D3BJ; wB97X-V with D3(BJ) instead of VV10 dispersion; Y; —; 0.300000; 0.167000; —; —; —; Y. WB97X-D3BJATM; wB97X-d3bjatm Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; Y. WB97X-D3ZERO2B; wB97X-d3zero2b Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; Y. WB97X-D3ZEROATM; wB97X-d3zeroatm Hyb-GGA E,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_dft_lrc.html:4380,TUNE,TUNED-CAM-,4380,psi4manual/1.8.x/autodoc_dft_lrc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_dft_lrc.html,4,['TUNE'],['TUNED-CAM-']
Performance, —; Y. MN12-SX-D3BJATM; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; Y. MN12-SX-D3ZERO2B; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; Y. MN12-SX-D3ZEROATM; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; Y. N12-SX; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; —; —. N12-SX-D3BJ2B; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; Y. N12-SX-D3BJATM; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; Y. N12-SX-D3ZERO2B; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; Y. N12-SX-D3ZEROATM; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; Y. TUNED-CAM-B3LYP; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; 0.150000; 0.079900; —; —; —; —; —. WB97; wB97 GGA Exchange-Correlation Functional; Y; —; 0.400000; —; —; —; —; —; —. WB97M-D3BJ; wB97M-V with D3(BJ) instead of VV10 dispersion; Y; Y; 0.300000; 0.150000; —; —; —; Y. WB97M-V; wB97M-V Hyb-GGA Exchange-Correlation Functional; Y; Y; 0.300000; 0.150000; —; —; —; —; —. WB97X; wB97X Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; —; —. WB97X-D; wB97X-D Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.222036; —; —; —; Y. WB97X-D3; wB97X-D3 Hyb-GGA Exchange-Correlation Functional; Y; —; 0.250000; 0.195728; —; —; —; Y. WB97X-D3BJ; wB97X-V with D3(BJ) instead of VV10 dispersion; Y; —; 0.300000; 0.167000; —; —; —; Y. WB97X-D3ZERO2B; wB97X-d3zero2b Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; Y. WB97X-D3ZEROATM; wB97X-d3zeroatm Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; Y. WB97X-V; wB97X-V Hyb-GGA Exchange-Corr,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_dft_lrc.html:4487,TUNE,TUNED-CAM-,4487,psi4manual/master/autodoc_dft_lrc.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_dft_lrc.html,12,['TUNE'],['TUNED-CAM-']
Performance," —; threaded (pthreads);  ;  . ACPF/AQCC; RHF; CONV; —; —; threaded [3];  ; E. CISD; RHF/ROHF; CONV; —; —; partially threaded;  ; E. QCISD; RHF; CONV; —; —; threaded [3];  ; E. QCISD(T); RHF; CONV; —; —; threaded [3];  ; E. CI(n); RHF/ROHF; CONV; —; —; partially threaded;  ;  . FCI; RHF/ROHF; CONV; —; —; partially threaded;  ;  . Mk-MRPT2; RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . Mk-MRCCSD; RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . Mk-MRCCSD(T); RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . RAS-CI; RHF/ROHF; CONV; —; —; partially threaded;  ;  . CASSCF, RASSCF; RHF/ROHF; CONV/DF; —; —; partially threaded;  ;  . SAPT; RHF; CONV; —; —; threaded;  ;  . ADC(2); RHF; CONV; —; —; threaded [3];  ;  . EOM-CC2; RHF; CONV; —; —; threaded [3];  ;  . EOM-CCSD; RHF/UHF/ROHF; CONV; RHF/UHF/ROHF; CONV; threaded [3];  ;  . EOM-CC3; RHF/UHF/ROHF; CONV; —; —; threaded [3];  ;  . DMRG-CI; Y; CONV; —; —;  ;  ;  . DMRG-SCF; Y; CONV; —; —;  ;  ;  . Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; Psi4 can also compute an extensive list of one-electron properties. Technical Support¶; The Psi4 package is distributed for free and without any guarantee of; reliability, accuracy, or suitability for any particular purpose. No; obligation to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries on the forum or GitHub. For bug reports,; specific and detailed information, with example inputs, would be; appreciated.; Where-to-post summary:[6]. How do I? – ask the forum; I got this error, why? – ask the forum; I got this error and I’m sure it’s a bug – file a GitHub issue; Can I open a discussion on this bit of code? – file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:19401,optimiz,optimization,19401,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,4,"['optimiz', 'perform']","['optimization', 'performed']"
Performance, —; —; —; —; Y. TPSS-D3BJATM; TPSS Meta-GGA XC Functional; Y; Y; —; —; —; —; —; Y. TPSS-D3ZERO2B; TPSS Meta-GGA XC Functional; Y; Y; —; —; —; —; —; Y. TPSS-D3ZEROATM; TPSS Meta-GGA XC Functional; Y; Y; —; —; —; —; —; Y. TPSS-NL; TPSS Meta-GGA XC Functional; Y; Y; —; —; —; —; —; —; —. TPSSH; TPSSh Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TPSSH-D3BJ2B; TPSSh-d3bj2b Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y. TPSSH-D3BJATM; TPSSh-d3bjatm Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y. TPSSH-D3ZERO2B; TPSSh-d3zero2b Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y. TPSSH-D3ZEROATM; TPSSh-d3zeroatm Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y. TPSSH-NL; TPSSh-nl Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TPSSLYP1W; TPSSLYP1W GGA Exchange-Correlation Functional; Y; Y; —; —; —; —; —; —; —. TUNED-CAM-B3LYP; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; 0.150000; 0.079900; —; —; —; —; —. VSXC; VSXC Meta-GGA XC Functional; Y; Y; —; —; —; —; —; —; —. VV10; VV10 GGA Exchange-Correlation Functional; Y; —; —; —; —; —; —; —; —. WB97; wB97 GGA Exchange-Correlation Functional; Y; —; 0.400000; —; —; —; —; —; —. WB97M-D3BJ; wB97M-V with D3(BJ) instead of VV10 dispersion; Y; Y; 0.300000; 0.150000; —; —; —; Y. WB97M-V; wB97M-V Hyb-GGA Exchange-Correlation Functional; Y; Y; 0.300000; 0.150000; —; —; —; —; —. WB97X; wB97X Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; —; —. WB97X-D; wB97X-D Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.222036; —; —; —; Y. WB97X-D3; wB97X-D3 Hyb-GGA Exchange-Correlation Functional; Y; —; 0.250000; 0.195728; —; —; —; Y. WB97X-D3BJ; wB97X-V with D3(BJ) instead of VV10 dispersion; Y; —; 0.300000; 0.167000; —; —; —; Y. WB97X-D3ZERO2B; wB97X-d3zero2b Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; Y. WB97X-D3ZEROA,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_dft_all.html:42114,TUNE,TUNED-CAM-,42114,psi4manual/master/autodoc_dft_all.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_dft_all.html,12,['TUNE'],['TUNED-CAM-']
Performance," ‘’, 32, True):; -mv /tmp/temp /scratch/parrish/psi.12345.32. get_memory()[source]¶; Function to return the total memory allocation. get_num_threads()[source]¶; Function to return the number of threads to parallelize across. set_memory(bytes)[source]¶; Function to reset the total memory allocation. set_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. run_mp2_5(name, **kwargs)[source]¶; Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. Psi variables:. MP2.5 TOTAL ENERGY; MP2.5 CORRELATION ENERGY. >>> energy('mp2.5'). run_plugin_omega(name, **kwargs)[source]¶; Function encoding sequence of PSI module and plugin calls, as well; as typical options, to access Rob Parrish’s omega plugin.; >>> energy('plugin_omega'). sherrillgroup_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). Table Of Contents. Python Driver; input; pubchem; psiexceptions; frac; molutil; proc; procutil; driver; physconst; wrappers; qmmm; functional; text; util; aliases. Previous topic; PRINT; Next topic; PsiMod: Linking C++ and Python; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » . © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:23492,perform,performed,23492,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['perform'],['performed']
Performance," “mixed” excitations involving RAS IV into the CI space. Useful to specify a split-virtual CISD[TQ] computation. If FALSE, then if there are any electrons in RAS IV, then the number of holes in RAS I cannot exceed the given excitation level EX_LEVEL. Type: boolean; Default: true. MO_DIIS_NUM_VECS (DFOCC)¶DFOCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER (DFOCC)¶DFOCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 100. MO_MAXITER (OCC)¶OCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF)¶MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OCC)¶OCC — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX (DFOCC)¶DFOCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_STEP_MAX (OCC)¶OCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OCC)¶OCC — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODULE (CPHF)¶CPHF — What app to test?. Type: string; Possible Values: RCPHF; Default: RCPHF. MOGRAD_DAMPING (OCC)¶OCC — Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MOLDEN_WITH_VIRTUAL (GLOBALS)¶GLOBALS — Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MOLDEN_WRITE (DFOCC)¶DFOCC — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MOLDEN_WRITE (SCF)¶SCF — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:176068,optimiz,optimization,176068,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,4,['optimiz'],['optimization']
Performance," ✓̲. ✓̳. ✓̲. ✓̳. ✓̲. ✓̲. ✓̳. b3lyp, Hybrid DFT; SCF_TYPE; ✓̲. ✓̳. ✓̲. ✓̲. ✓̳. ✓̲. ✓̳. ✓̲. ✓̲. ✓̳. wb97x, LRC DFT; SCF_TYPE; ✓̲. ✓̳. ✓̲. ✓̳. ✓̲. ✓̳. ✓̲. ✓̳. b2plyp, DH DFT[5]; SCF_TYPE; ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲. [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-core F. [3]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [4]; (1,2,3); Finite difference Hessians are not marked explicitly by “∷”, but the capability can be gleaned from the gradient or energy availability. [5]; DH-DFT only available with DF-MP2. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dft.html:26560,perform,perform,26560,psi4manual/master/dft.html,https://psicode.org,https://psicode.org/psi4manual/master/dft.html,4,['perform'],['perform']
Performance," ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. omp3[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. oremp2[4]; CC_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. olccd[4]; CC_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-core F. [3]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [4]; (1,2,3,4,5); Also available for DFT references RKS/UKS. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:12462,Optimiz,Optimized,12462,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['Optimiz'],['Optimized']
Performance,"!= computed.dim(irrep)):; message = (""\tThe reference has %d entries in irrep %d, but the computed vector has %d\n."" %; (expected.dim(irrep), irrep, computed.dim(irrep))); raise TestComparisonError(message); dim = expected.dim(irrep); failed = 0; for entry in range(dim):; if (abs(expected.get(irrep, entry) - computed.get(irrep, entry)) > 10**(-digits)):; failed = 1; break. if (failed):; core.print_out(""The computed vector\n""); computed.print_out(); core.print_out(""The reference vector\n""); expected.print_out(); message = (""\t%s: computed value (%s) does not match (%s)."" % (label, computed.get(irrep, entry),; expected.get(irrep, entry))); raise TestComparisonError(message); success(label); return True. [docs]def compare_arrays(expected, computed, digits, label, rtol=1.e-16):; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. Sets rtol to zero to match expected Psi4 behaviour, otherwise measured as:; absolute(computed - expected) <= (atol + rtol * absolute(expected)); """""". try:; expected = np.asarray(expected); computed = np.asarray(computed); shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2:; TestComparisonError(""Input shapes do not match.""). tol = 10**(-digits); if not np.allclose(expected, computed, atol=tol, rtol=rtol):; message = ""\tArray difference norm is %12.6e."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label); return True. [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html:12050,Perform,Performs,12050,psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/util.html,1,['Perform'],['Performs']
Performance,""" % (tmp); else:; fmcs[mc] = """"""%20s / %-20s, %s"""""" % \; (methods[mtd].fullname, bases[bas].fullname, mod); return fmcs. # def fancy_mcs_nested(self):; # """""". # """"""; # fmcs = defaultdict(lambda: defaultdict(dict)); # for mc in self.mcs.keys():; # try:; # mtd, mod, bas = mc.split('-'); # except ValueError:; # fmcs['All']['All'][mc] = mc; # fmcs['Method']['Others'][mc] = mc; # fmcs['Options']['Others'][mc] = mc; # fmcs['Basis Treatment']['Others'][mc] = mc; # else:; # fancyrepr = """"""%20s / %-20s %s"""""" % (methods[mtd].latex, bases[bas].latex, mod); # fmcs['All']['All'][mc] = fancyrepr; # fmcs['Method'][methods[mtd].latex][mc] = fancyrepr; # fmcs['Options'][mod][mc] = fancyrepr; # fmcs['Basis Treatment'][bases[bas].latex][mc] = fancyrepr; # return fmcs. [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; return {db: odb.integer_reactions() for db, odb in self.dbdict.items()}. [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""For each component database, loads qcdb.ReactionDatums from; standard location for *project* :module dbse_project and function; load_project. Module search path can be prepended with *pythonpath*. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_byproject(project, pythonpath=pythonpath); self._intersect_modelchems(). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_hdf5_trusted(project, path=path); self._intersect_modelchems(). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; for db, odb in self.dbdict.items():; odb.load_qcdata_hrxn_byproject(project, path=path); self._intersect_modelchems(). [docs] def available_projects(self, path=None):; """"""""""""; import glob. if path ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:51090,load,loads,51090,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loads']
Performance,""" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CI_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_cisd', name, 'CI_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp4', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_adc2(name, **kwargs):; """"""Function selecting the algorithm for ADC(2) excited ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:28659,perform,performance,28659,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,""""" % (self.fullname); # text += """""" LaTeX representation: %s\n"""""" % (self.latex); # text += """""" DOI: %s\n"""""" % (self.doi); # text += """""" Literature citations:\n""""""; # for rol, cit in self.citations.iteritems():; # text += """""" %17s: %s\n"""""" (rol, cit.doi); # text += """""" Comment: %s\n"""""" % (self.comment); # text += """"""\n""""""; # return text. _tlist = [; Publication('dhdft', doi='', dsdbid='', owner='CAC',; fullname=""""),; Publication('dft', doi='10.1063/1.3545971', dsdbid='Burns:2011:084107', owner='LAB',; fullname=""""""Density-Functional Approaches to Noncovalent Interactions: A Comparison of Dispersion Corrections (DFT-D), Exchange-Hole Dipole Moment (XDM) Theory, and Specialized Functions. L. A. Burns, A. Vazquez-Mayagoitia, B. G. Sumpter, and C. D. Sherrill, J. Chem. Phys. 134(8), 084107/1-25 (2011)""""""),; Publication('saptone', doi='10.1063/1.4867135', dsdbid='Parker:2014:094106', owner='LAB',; fullname=""""""Levels of Symmetry Adapted Perturbation Theory (SAPT). I. Efficiency and Performance for Interaction Energies. T. M. Parker, L. A. Burns, R. M. Parrish, A. G. Ryno, and C. D. Sherrill, J. Chem. Phys. 140(9), 094106/1-16 (2014)""""""),; Publication('pt2', doi='10.1063/1.4903765', dsdbid='Burns:2014:234111', owner='LAB',; fullname=""""""Appointing Silver and Bronze Standards for Noncovalent Interactions: A Comparison of Spin-Component-Scaled (SCS), Explicitly Correlated (F12), and Specialized Wavefunction Approaches. L. A. Burns, M. S. Marshall, and C. D. Sherrill, J. Chem. Phys. 141(23), 234111/1-21 (2014)""""""),; Publication('s22b', doi='10.1063/1.3659142', dsdbid='Marshall:2011:194102', owner='LAB',; fullname=""""""Basis Set Convergence of the Coupled-Cluster Correction, delta_MP2^CCSD(T): Best Practices for Benchmarking Noncovalent Interactions and the Attendant Revision of the S22, NBC10, HBC6, and HSG Databases. M. S. Marshall, L. A. Burns, and C. D. Sherrill, J. Chem. Phys. 135(19), 194102/1-10 (2011)""""""),; Publication('dilabio', doi='10.1021/ct400149j', dsdbid='Burns:2014:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/modelchems.html:7369,Perform,Performance,7369,psi4manual/1.0.0/_modules/qcdb/modelchems.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/modelchems.html,1,['Perform'],['Performance']
Performance,"""""""; basisChanged = PsiMod.has_option_changed(""BASIS""); ribasisChanged = PsiMod.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = PsiMod.reference_wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diff",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html:1870,perform,perform,1870,psi4manual/4.0b2/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/qmmm.html,2,['perform'],['perform']
Performance,"""""""; basisChanged = PsiMod.has_option_changed(""BASIS""); ribasisChanged = PsiMod.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = PsiMod.has_option_changed(""SCF_TYPE""). basis = PsiMod.get_option(""BASIS""); ribasis = PsiMod.get_option(""DF_BASIS_SCF""); scftype = PsiMod.get_option(""SCF_TYPE""). PsiMod.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). PsiMod.set_global_option(""BASIS"", self.basisname); PsiMod.set_global_option(""DF_BASIS_SCF"", self.ribasisname); PsiMod.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); PsiMod.print_out(""\n""). self.fitGeneral(). PsiMod.clean(). PsiMod.set_global_option(""BASIS"", basis); PsiMod.set_global_option(""DF_BASIS_SCF"", ribasis); PsiMod.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; PsiMod.revoke_option_changed(""BASIS""); if not ribasisChanged:; PsiMod.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; PsiMod.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; PsiMod.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = PsiMod.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = PsiMod.Gaussian94BasisSetParser(); self.ribasis = PsiMod.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = PsiMod.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = PsiMod.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/qmmm.html:1867,perform,perform,1867,psi4manual/4.0b4/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qmmm.html,1,['perform'],['perform']
Performance,"""""""g2 computations require ""reference rhf"".""""""). # stash user options:; optstash = p4util.OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['SCF','SCF_TYPE']). # override default scf_type; psi4.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; psi4.clean(); psi4.set_global_option('BASIS',""6-31G(D)""); optimize('scf'); psi4.clean(). # scf frequencies for zpe; frequency('scf'). # thermodynamic properties; du = psi4.get_variable('INTERNAL ENERGY CORRECTION'); dh = psi4.get_variable('ENTHALPY CORRECTION'); dg = psi4.get_variable('GIBBS FREE ENERGY CORRECTION'). ref = psi4.wavefunction(); freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range (0,nfreq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); optimize('conv-mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); run_fnocc('qcisd(t)',**kwargs). # HLC: high-level correction based on number of valence electrons; ref = psi4.wavefunction(); nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G(D_P)""); energy('mp4'); emp4_6311pg_dp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html:2376,optimiz,optimize,2376,psi4manual/4.0b5/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/gaussian_n.html,1,['optimiz'],['optimize']
Performance,"""""""{; ""Natoms per frag"": [12, 16],; ""A Frag"": 1,; ""A Ref Atoms"": [[1, 3, 4, 6, 8], [8], [11]],; ""A Label"": ""methylthiophene"",; ""B Frag"": 2,; ""B Ref Atoms"": [[13, 14, 15, 16, 17, 18], [13], [15]],; ""B Label"": ""tyrosine"",; ""Frozen"": [""theta_A"", ""theta_B"", ""tau"", ""phi_A"", ""phi_B""],; }"""""". set {; basis 6-31+G; frag_mode MULTI; interfrag_coords $MTdimer; }. optimize(""mp2""). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the dynamic level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals.; Optking does support the specification of ghost atoms. Certain internal coordinates such; as torsions become poorly defined when they contain near-linear bends.; An internal error AlgError may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:16851,optimiz,optimization,16851,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,4,['optimiz'],['optimization']
Performance,"""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:31942,perform,performance,31942,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"""""; basisChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/qmmm.html:2773,perform,perform,2773,psi4manual/1.1.0/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/qmmm.html,1,['perform'],['perform']
Performance,"""); else:; return self.np.__array_interface__. def _np_write(self, filename=None, prefix=""""):. ret = {}; ret[prefix + ""Irreps""] = self.nirrep(); ret[prefix + ""Name""] = self.name; for h, v in enumerate(self.nph):; ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def _np_read(self, filename, prefix=""""):. if isinstance(filename, np.lib.npyio.NpzFile):; data = filename; elif (sys.version_info[0] == 2) and isinstance(filename, (str, unicode)):; if not filename.endswith('.npz'):; filename = filename + '.npz'; data = np.load(filename); elif (sys.version_info[0] > 2) and isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(data):; """"""; Converts an object with a .nph accessor to a serialized dictionary; """""". json_data = {}; json_data[""shape""] = []; json_data[""data""] = []. for view in data.nph:; json_data[""shape""].append(view.shape); json_data[""data",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html:10252,load,load,10252,psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/p4util/numpy_helper.html,1,['load'],['load']
Performance,"""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = core.get_datadir(); #nolongerpredictable psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; driver_loc = os.path.dirname(os.path.abspath(__file__)); dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath + \; ':' + driver_loc # so the databases can ""import qcdb"". sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html:9724,load,load,9724,psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,1,['load'],['load']
Performance,"""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" %; (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (opt_mode == 'continuous') and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.get_variable('CURRENT ENERGY'). # Compute the gradient; G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.get_variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone()). # S/R: Quit after getting new displacements or if forming gradient fails; if opt_mode == 'sow':; return (0.0, None); elif opt_mode == 'reap' and thisenergy == 0.0:; return (0.0, None). core.set_gradient(G). # S/R: Move opt data file from last pass into namespace for this pass; if opt_mode == 'reap' and n != 0:; core.IOManager.shared_object().set_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:61471,optimiz,optimization,61471,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimization']
Performance,"""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" %; (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (opt_mode == 'continuous') and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.get_variable('CURRENT ENERGY'). # Compute the gradient; G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.get_variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # S/R: Quit after getting new displacements or if forming gradient fails; if opt_mode == 'sow':; return (0.0, None); elif opt_mode == 'reap' and thisenergy == 0.0:; return (0.0, None). core.set_gradient(G). # S/R: Move opt data file from last pass into namespace for this pass; if opt_mode == 'reap' and n != 0:; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); if 'opt_datafile' in kwargs:; restartfile = kwargs.pop('opt_datafile'); #if core.me() == 0: TODO ask Ryan; s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:59248,optimiz,optimization,59248,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['optimiz'],['optimization']
Performance,"""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= psi4.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" %; (current_sym, initial_sym)); kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (opt_mode == 'continuous') and (not psi4.get_option('SCF', 'GUESS_PERSIST')):; psi4.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (psi4.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = psi4.get_variable('CURRENT ENERGY'). # Compute the gradient; G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = psi4.get_variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # S/R: Quit after getting new displacements or if forming gradient fails; if opt_mode == 'sow':; return (0.0, None); elif opt_mode == 'reap' and thisenergy == 0.0:; return (0.0, None). psi4.set_gradient(G). # S/R: Move opt data file from last pass into namespace for this pass; if opt_mode == 'reap' and n != 0:; psi4.IOManager.shared_object().set_specific_retention(1, True); psi4.IOManager.shared_object().set_specific_path(1, './'); if 'opt_datafile' in kwargs:; restartfile = kwargs.pop('opt_datafile'); #if psi4.me() == 0: TODO ask Ryan; s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:57406,optimiz,optimization,57406,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimization']
Performance,"""mdi_run"",; ""MDIEngine"",; ]. import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html:2273,optimiz,optimization,2273,psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/mdi_engine.html,1,['optimiz'],['optimization']
Performance,"""mdi_run"",; ""MDIEngine"",; ]. import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html:2271,optimiz,optimization,2271,psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/mdi_engine.html,1,['optimiz'],['optimization']
Performance,"# Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html:5876,load,loaded,5876,psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/interface_cfour.html,5,['load'],['loaded']
Performance,"# Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(); kwargs['molecule'] = molecule. # Allow specification of methods to arbitrary order; lowername = args[0].lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. if ""/"" in lowername:; return driver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:47199,optimiz,optimize,47199,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,3,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"# Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""frac_nuke"",; ""frac_traverse"",; ""ip_fitting"",; ]. from typing import Callable, Dict, Union. from psi4 import core. from . import driver, p4util; from .p4util.exceptions import *. [docs]; def frac_traverse(name: Union[str, Callable], **kwargs) -> Dict[float, float]:; """"""Scan electron occupancy from +1 electron to -1. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult : Optional[int]; Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult : Optional[int]; Multiplicity of anion, if not neutral multiplicity + 1.; frac_start : Optional[int]; Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs : Optional[List]; Occupations to step through for cation, by default `[1 - 0.1 * x for x in range(11)]`.; LUMO_occs : Optional[List]; Occupations to step through for anion, by default `[1 - 0.1 * x for x in range(11)]`.; HOMO : Optional[int]; Index of HOMO.; LUMO : Optional[int]; Index of LUMO.; frac_diis : Optional[bool]; Do use DIIS for non-1.0-occupied points?; neutral_guess : Optional[bool]; Do use neutral orbitals as guess for the anion?; hf_guess: Optional[bool]; Do use UHF guess before UKS?; continuous_guess : Optional[bool]; Do carry along guess rather than reguessing at each occupation?; filename : Optional[str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/frac.html:1645,tune,tuned,1645,psi4manual/1.9.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/frac.html,2,['tune'],['tuned']
Performance,"%6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter; Maximum number of iterations towards omega convergence. Returns; -------; float; Optimal omega parameter. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'DFT_OMEGA'],; ['DOCC'],; ['SOCC']). kwargs = p4util.kwargs_lower(kwargs). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. if core.get_option('SCF', 'REFERENCE') != 'UKS':; core.print_out("""""" Requested procedure `ip_fitting` runs further calculations with UKS referenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:14747,optimiz,optimized,14747,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,1,['optimiz'],['optimized']
Performance,"%s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:24013,optimiz,optimize,24013,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['optimiz'],['optimize']
Performance,"' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # call thermo module; PsiMod.thermo(). optstash.restore(); # TODO: add return statement. else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print(info). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); if not PsiMod.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 11); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 11). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:64755,perform,perform,64755,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,"['Perform', 'perform']","['Performing', 'perform']"
Performance,"' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = psi4.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; psi4.clean(). psi4.fd_freq_1(gradients, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; psi4.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; psi4.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; psi4.get_active_molecule().reinterpret_coordentry(True). optstash.restore(); # TODO: add return statement of hessian matrix; # TODO: set current energy to un-displaced energy. else:; # If not, perform finite difference of energies; print('Performing finite difference calculations by energies'). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 11); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 11). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 10). # Obtain l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:64470,perform,perform,64470,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,"['Perform', 'perform']","['Performing', 'perform']"
Performance,"' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.freq-1.html:2770,optimiz,optimize,2770,psi4manual/1.3.2/api/psi4.driver.freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.freq-1.html,6,['optimiz'],['optimize']
Performance,"'). else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:36412,optimiz,optimize,36412,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['optimiz'],['optimize']
Performance,"'); # Considering only [df]occ/ccenergy/detci/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:20214,perform,performance,20214,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"'); if 'opt_datafile' in kwargs:; restartfile = kwargs.pop('opt_datafile'); if(PsiMod.me() == 0):; shutil.copy(restartfile, get_psifile(1)). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = PsiMod.get_gradient(); PsiMod.IOManager.shared_object().set_specific_retention(1, True); PsiMod.IOManager.shared_object().set_specific_path(1, './'); frequencies(name, **kwargs); steps_since_last_hessian = 0; PsiMod.set_gradient(G); PsiMod.set_global_option('CART_HESS_READ', True); elif ((full_hess_every == -1) and (PsiMod.get_global_option('CART_HESS_READ')) and (n == 1)):; pass; # Do nothing; user said to read existing hessian once; else:; PsiMod.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # print 'cart_hess_read', PsiMod.get_global_option('CART_HESS_READ'); # Take step; if PsiMod.optking() == PsiMod.PsiReturnType.EndLoop:; print('Optimizer: Optimization complete!'); PsiMod.print_out('\n Final optimized geometry and variables:\n'); PsiMod.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (PsiMod.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False):; PsiMod.opt_clean(); PsiMod.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(). optstash.restore(); return thisenergy; PsiMod.print_out('\n Structure for next step:\n'); PsiMod.get_active_molecule().print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = get_psifile(1); kwargs['mode'] = 'sow'. n += 1. PsiMod.print_out('\tOptimi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:53263,Optimiz,Optimizer,53263,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['Optimiz'],"['Optimization', 'Optimizer']"
Performance,"'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Dimer DFMP2'); PsiMod.print_out('\n'); e_dimer_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer A DFMP2'); PsiMod.print_out('\n'); e_monomerA_mp2 = PsiMod.dfmp2(). activate(monomerB); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer B DFMP2'); PsiMod.print_out('\n'); e_monomerB_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); PsiMod.IO.chan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:44404,LOAD,LOAD,44404,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['LOAD'],['LOAD']
Performance,"', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:7883,perform,performance,7883,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; # print(""about to generate displacements""); displacements = core.fd_geoms_1_0(moleculeclone); # print(displacements); ndisp = len(displacements); # print(""generated displacments""). # This version is pretty dependent on the reference geometry being last (as it is now); print("""""" %d displacements needed ..."""""" % (ndisp), end=''); energies = []. # S/R: Wr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:37853,perform,perform,37853,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,"', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; psi4.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; psi4.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(moleculeclone); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print("""""" %d displacements needed ..."""""" % (ndisp), end=''); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if opt_mode == 'sow':; inst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:36622,perform,perform,36622,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['perform'],['perform']
Performance,"', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); fmaster.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, dertype=dertype, **kwargs); fmaster.write((""""""retE, retwfn = optimize('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1). # Build string of title banner; banners = ''; banners += """"""core.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""core.print_out('\\n')\n\n"""""". if opt_mode == 'continuous':. # print progress to file and screen; core.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(core.get_variable('CURRENT ENERGY')). # S/R: Write each displaced geometry to an input file; elif opt_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); freagent.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); freagent.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write((""""""electronic_energy = energy('%s', **kwargs)\n\n"""""" % (lowername)).enc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:42247,Load,Loading,42247,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['Load'],['Loading']
Performance,"', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); fmaster.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, dertype=dertype, **kwargs); fmaster.write((""""""retE, retwfn = optimize('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if opt_mode == 'continuous':. # print progress to file and screen; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(psi4.get_variable('CURRENT ENERGY')). # S/R: Write each displaced geometry to an input file; elif opt_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); freagent.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); freagent.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write((""""""electronic_energy = energy('%s', **kwargs)\n\n"""""" % (lowername)).enc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:40913,Load,Loading,40913,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Load'],['Loading']
Performance,"', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = core.get_datadir(); #nolongerpredictable psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; driver_loc = os.path.dirname(os.path.abspath(__file__)); dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath + \; ':' + driver_loc # so the databases can ""import qcdb"". sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html:10045,load,loading,10045,psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,1,['load'],['loading']
Performance,"', corl_basis='cc-pv[dt]z'); energy(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z"", ""scheme"": ""corl_xtpl_helgaker_2""}]). Caution; In PSI4 previous to Spring 2022 and v1.6, calling certain; cbs-related functions like the above looked like; energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z'). energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z"", ""scheme"": corl_xtpl_helgaker_2}]). The difference is that the main function; psi4.driver.cbs() and extrapolation schemes like; psi4.driver.driver_cbs_helper.xtpl_highest_1() and; psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2() and composite; aliases like psi4.driver.aliases.sherrill_gold_standard(); and psi4.driver.aliases.allen_focal_point() in the old way; passed the Python function directly, whereas the new way uses the; string of the function name. A CCSD(T) DT coupled-cluster correction atop a TQ MP2 extrapolation; geometry optimization can also be accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(""cbs"", corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases:; complete_basis_set(). Returns:; (float) – Total ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cbs.html:1710,optimiz,optimization,1710,psi4manual/master/cbs.html,https://psicode.org,https://psicode.org/psi4manual/master/cbs.html,4,['optimiz'],['optimization']
Performance,"', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:11764,perform,performance,11764,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:13286,perform,performance,13286,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:10880,perform,performance,10880,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"'-', 1); if intrxn:; rxn = int(rxn); self.hrxn[rxn].data[mc] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]). [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; return False; else:; return True. @staticmethod; [docs] def load_pickled(dbname, path=None):; """""". """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; picklefile = psiutil.findfile_ignorecase(dbname,; pre=os.path.abspath(path) + os.sep, post='_WDb.pickle'); if not picklefile:; raise ValidationError(""Pickle file for loading database data from file %s does not exist"" % (; os.path.abspath(path) + os.sep + dbname + '.pickle')); # with open('/var/www/html/bfdb_devel/bfdb/scratch/ASDFlogfile.txt', 'a') as handle:; # handle.write('<!-- PICKLE %s\n' % (picklefile)); with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:41508,load,load,41508,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['load']
Performance,"'.encode('utf-8')); fmaster.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); fmaster.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, dertype=dertype, **kwargs); fmaster.write((""""""retE, retwfn = optimize('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1). # Build string of title banner; banners = ''; banners += """"""core.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""core.print_out('\\n')\n\n"""""". if opt_mode == 'continuous':. # print progress to file and screen; core.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(core.get_variable('CURRENT ENERGY')). # S/R: Write each displaced geometry to an input file; elif opt_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); freagent.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); freagent.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write((""""""electronic_energy = energy('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); freagent.write((""""""core.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:42387,Load,Load,42387,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['Load'],['Load']
Performance,"'.encode('utf-8')); fmaster.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); fmaster.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, dertype=dertype, **kwargs); fmaster.write((""""""retE, retwfn = optimize('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if opt_mode == 'continuous':. # print progress to file and screen; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(psi4.get_variable('CURRENT ENERGY')). # S/R: Write each displaced geometry to an input file; elif opt_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); freagent.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); freagent.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write((""""""electronic_energy = energy('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); freagent.write((""""""psi4.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:41053,Load,Load,41053,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Load'],['Load']
Performance,"': 'DB4'}],; ['l', r""""""Error Distribution\footnotemark[1]"""""",; r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'),; textables.graphics, {}],; ['d', 'NBC10', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'NBC1'}],; ['d', 'HBC6', r""""""TT\footnotemark[2] """""", textables.val, {'sset': 'tt-5min', 'dbse': 'HBC1'}],; ['d', 'Avg', r""""""TT\footnotemark[2]"""""", textables.val, {'sset': 'tt-5min', 'dbse': 'DB4'}]]. footnotes = [fnreservoir['blankslat'], fnreservoir['5min']]; landscape = True; theme = 'lgmerge'; title = r""""""Interaction energy [kcal/mol] {{err}} subset statistics with computed with {{opt}}{0}."""""".format(; '' if subjoin else r"""""" and {bas}""""""); return rowplan, columnplan, landscape, footnotes, title, theme. [docs]class DB4(Database):; def __init__(self, pythonpath=None, loadfrompickle=False, path=None):; """"""Initialize FourDatabases object from SuperDatabase""""""; Database.__init__(self, ['s22', 'nbc10', 'hbc6', 'hsg'], dbse='DB4',; pythonpath=pythonpath, loadfrompickle=loadfrompickle, path=path). # # load up data and definitions; # self.load_qcdata_byproject('dft'); # self.load_qcdata_byproject('pt2'); # #self.load_qcdata_byproject('dhdft'); # self.load_subsets(); self.define_supersubsets(); self.define_supermodelchems(). [docs] def define_supersubsets(self):; """""". """"""; self.sset['tt'] = ['default', 'default', 'default', 'default']; self.sset['hb'] = ['hb', None, 'default', 'hb']; self.sset['mx'] = ['mx', 'mx', None, 'mx']; self.sset['dd'] = ['dd', 'dd', None, 'dd']; self.sset['mxdd'] = ['mxdd', 'default', None, 'mxdd']; self.sset['pp'] = ['mxddpp', 'mxddpp', None, None]; self.sset['np'] = ['mxddnp', 'mxddnp', None, 'mxdd']; self.sset['tt-5min'] = ['default', '5min', '5min', 'default']; self.sset['hb-5min'] = ['hb', None, '5min', 'hb']; self.sset['mx-5min'] = ['mx', 'mx-5min', None, 'mx']; self.sset['dd-5min'] = ['dd', 'dd-5min', None, 'dd']; self.sset['mxdd-5min'] = ['mxdd', '5min', None, 'mxdd']; self.sset['pp-5m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:106276,load,loadfrompickle,106276,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,2,['load'],['loadfrompickle']
Performance,"': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = physconst.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be ind",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:5852,Queue,Queue,5852,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Queue'],['Queue']
Performance,"'EFP'); if efp_enabled:; # EFP: Set QM system, options, and callback. Display efp geom in [A]; efpobj = self.molecule().EFP; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). efpptc, efpcoords, efpopts = get_qm_atoms_opts(self.molecule()); efpobj.set_point_charges(efpptc, efpcoords); efpobj.set_opts(efpopts, label='psi', append='psi'). efpobj.set_electron_density_field_fn(field_fn). # Initilize all integratals and perform the first guess; if self.attempt_number_ == 1:; mints = core.MintsHelper(self.basisset()); if core.get_global_option('RELATIVISTIC') in ['X2C', 'DKH']:; mints.set_rel_basisset(self.get_basisset('BASIS_RELATIVISTIC')). mints.one_electron_integrals(); self.initialize_jk(self.memory_jk_, jk=jk); if self.V_potential():; self.V_potential().build_collocation_cache(self.memory_collocation_). core.timer_on(""HF: Form core H""); self.form_H(); core.timer_off(""HF: Form core H""). if efp_enabled:; # EFP: Add in permanent moment contribution and cache; core.timer_on(""HF: Form Vefp""); verbose = core.get_option('SCF', ""PRINT""); Vefp = modify_Fock_permanent(self.molecule(), mints, verbose=verbose-1); Vefp = core.Matrix.from_array(Vefp); self.H().add(Vefp); Horig = self.H().clone(); self.Horig = Horig; core.print_out("" QM/EFP: iterating Total Energy including QM/EFP Induction\n""); core.timer_off(""HF: Form Vefp""). core.timer_on(""HF: Form S/X""); self.form_Shalf(); core.timer_off(""HF: Form S/X""). core.timer_on(""HF: Guess""); self.guess(); core.timer_off(""HF: Guess""). else:; # We're reading the orbitals from the previous set of iterations.; self.form_D(); self.set_energies(""Total Energy"", self.compute_initial_E()). # turn off VV10 for iterations; if core.get_option('SCF', ""DFT_VV10_POSTSCF"") and self.functional().vv10_b() > 0.0:; core.print_out("" VV10: post-SCF option active \n \n""); self.functional().set_lock(False); self.functional().set_do_vv10(False); self.functional().set_lock(True). def scf_iterate(self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html:6572,cache,cache,6572,psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/scf_proc/scf_iterator.html,1,['cache'],['cache']
Performance,"'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Consideri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:11010,perform,performance,11010,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; try:; if PsiMod.outfile_name() == 'stdout':; retcode = subprocess.call('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + PsiMod.outfile_name(), shell=True). if retcode < 0:; print >>sys.stderr, 'MRCC was terminated by signal', -retcode; exit(1); elif retcode > 0:; print >>sys.stderr, 'MRCC errored', retcode; exit(1). except OSError, e:; print >>sys.stderr, 'Execution failed:', e; exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; if fullname in line:; fields = line.split(); e = float(fields[5]). PsiMod.set_variable('CURRENT ENERGY', e); PsiMod.set_variable(fullname + ' ENERGY', e). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSerror, e:; print >>sys.stderr, 'Unable to remove MRCC temporary directory', e; exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiMod.print_out('\n'); PsiMod.print_out(iface_contents). return e. # General wrapper for property computations; [docs]def run_property(name, **kwargs):. junk = 1; return junk. Quick search. Enter search terms or a module, class or function name.; . N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:35902,Load,Load,35902,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['Load'],['Load']
Performance,"'NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], PsiMod.get_variable('NUCLEAR REPULSION ENERGY'), ; 4, '%s %.4f' % (rgt, PsiMod.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:44240,load,loads,44240,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['load'],['loads']
Performance,"'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while White or Queue: # Iterates to the next fragment; Fragment.append([]). while Queue: # BFS within a fragment; for u in Queue: # find all white neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt(; (self.x(i) - self.x(u)) ** 2 +; (self.y(i) - self.y(u)) ** 2 +; (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + \; vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # & remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if White: # can't move White -> Queue if empty; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the psi4.Molecule class. """"""; cls.__setattr__ = new_set_attr; cls.__getattr__ = new_get_attr; cls.BFS = BFS. dynamic_variable_bind(psi4.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name*; from the geometry in string *geom*. Permitted for user use but d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html:6568,Queue,Queue,6568,psi4manual/1.0.0/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html,1,['Queue'],['Queue']
Performance,"'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:11163,perform,performance,11163,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"'\n'. if shortlong:; for at in range(nat):; text += """"""{:{presp}}{:5d} {:{width}}"""""".format('',; at + 1,; atom_lbl[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. [docs]def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html:30802,Perform,Perform,30802,psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/qcdb/vib.html,4,['Perform'],['Perform']
Performance,"'\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/util.html:2061,Perform,Performs,2061,psi4manual/4.0b4/_modules/util.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/util.html,2,['Perform'],['Performs']
Performance,"']) and not \; (mc['f_wfn'] == job['f_wfn']):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Expand listings to all that will be obtained; JOBS_EXT = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; JOBS_EXT.append(dict(zip(f_fields, [wfn, job['f_basis'], job['f_zeta'],; 0.0,; psi4.Matrix(natom, 3),; psi4.Matrix(3 * natom, 3 * natom)]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in JOBS_EXT:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]); psi4.print_out(instructions). psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(p4const.PSIF_SCF_MOS, True); # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # needs to be communicated to optimize() so reset by that optstash; psi4.set_local_option('SCF', 'GUESS_PERSIST', True). Njobs = 0; # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""psi4.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s%s ')\n"""""" % \; (mc['f_wfn'].upper(), mc['f_basis'].upper(), addlremark[ptype]); cbsbanners += """"""psi4.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\npsi4.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""psi4.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); exec(commands). # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if pt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:46312,optimiz,optimize,46312,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['optimiz'],['optimize']
Performance,"']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'S22', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'S22', 'MX', textables.val, {'sset': 'mx'}],; # ['d', r'S22', 'DD', textables.val, {'sset': 'dd'}],; # ['d', r'S22', 'TT', textables.val, {'sset': 'default'}],; # # ['l', r""""""Error Distribution\footnotemark[1]"""""", r""""""\includegraphics[width=6.67cm,height=3.5mm]{%s%s.pdf}"""""" % (plotpath, 'blank'), textables.graphics, {}],; # ['l', r""""""Error Distribution\footnotemark[1]"""""", r"""""""""""", textables.graphics, {}],; # ]. [docs]class Database(object):; """"""Collection for handling single or multiple qcdb.WrappedDatabase objects.; Particularly, unifying modelchem and subset names that when inconsistent; across component databases. Also, defining statistics across databases. >>> asdf = qcdb.Database(['s22', 'Nbc10', 'hbc6', 'HSG'], 'DB4'); >>> qwer = qcdb.Database('s22'); """""". def __init__(self, dbnamelist, dbse=None, pythonpath=None, loadfrompickle=False, path=None):; #: internal name of database collection; #:; #: >>> print asdf.dbse; #: 'DB4'; self.dbse = None. #: ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [od",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:46848,load,loadfrompickle,46848,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loadfrompickle']
Performance,"'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). optstash.restore(); return returnvalue. ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory :ref:`[manual] <sec:dcft>` |; +-------------------------+----------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:45232,optimiz,optimize,45232,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,3,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. # are we in sow/reap mode?; isSowReap = False; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; isSowReap = True; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; isSowReap = True; optstash = OptionsState(; ['SCF', 'GUESS']). n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. while n <= PsiMod.get_global_option('GEOM_MAXITER'):; kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; if (n > 1) and (not isSowReap):; PsiMod.set_local_option('SCF', 'GUESS', 'READ'). # Compute the gradient; thisenergy = gradient(name, **kwargs). # S/R: Quit after getting new displacements or if forming gradient fai",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:38373,optimiz,optimization,38373,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. while n <= PsiMod.get_option('GEOM_MAXITER'):; kwargs['opt_iter'] = n. # Compute the gradient; thisenergy = gradient(name, **kwargs). # S/R: Quit after getting new displacements or if forming gradient fails; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; return 0.0; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (thisenergy == 0.0):; return 0.0. # S/R: Move opt data file from last pass into namespace for this pass; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (n != 0):; PsiMod.IOManager.shared_object().set_specific_retention(1, True); Psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:36013,optimiz,optimization,36013,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. # are we in sow/reap mode?; isSowReap = False; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; isSowReap = True; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; isSowReap = True; optstash = OptionsState(; ['SCF', 'GUESS']). n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. PsiMod.get_active_molecule().update_geometry(); mol = PsiMod.get_active_molecule(); mol.update_geometry(); initial_sym = mol.schoenflies_symbol(); while n <= PsiMod.get_global_option('GEOM_MAXITER'):; mol = PsiMod.get_active_molecule(); mol.update_geometry(); current_sym = mol.schoenflies_symbol(); if initial_sym != current_sym:; raise Except",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:50325,optimiz,optimization,50325,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). full_hess_every = psi4.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. # are we in sow/reap mode?; isSowReap = False; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; isSowReap = True; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; isSowReap = True; optstash = p4util.OptionsState(; ['SCF', 'GUESS']). n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. psi4.get_active_molecule().update_geometry(); mol = psi4.get_active_molecule(); mol.update_geometry(); initial_sym = mol.schoenflies_symbol(); while n <= psi4.get_global_option('GEOM_MAXITER'):; mol = psi4.get_active_molecule(); mol.update_geometry(); current_sym = mol.schoenflies_symbol(); if initial_sym != current_sym:; raise Ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:50568,optimiz,optimization,50568,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"'ccsd_no.molden', density_a=wfn.Da()). >>> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = property('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = property. Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. Module code. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:92291,optimiz,optimize,92291,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"'continuous':; pass; elif freq_mode == 'sow':; if dertype == 2:; raise ValidationError(""""""Frequency execution mode 'sow' not valid for analytic Hessian calculation.""""""); elif freq_mode == 'reap':; freq_linkage = kwargs.get('linkage', None); if freq_linkage is None:; raise ValidationError(""""""Frequency execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Select certain irreps; irrep = kwargs.get('irrep', -1); if irrep == -1:; pass # do all irreps; else:; irrep = driver_util.parse_cotton_irreps(irrep, molecule.schoenflies_symbol()); irrep -= 1 # A1 irrep is externally 1, internally 0. # Does an analytic procedure exist for the requested method?; if dertype == 2:; psi4.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; psi4.set_variable('CURRENT ENERGY', wfn.energy()). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). elif dertype == 1:; psi4.print_out(""""""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_freq_1(moleculeclone, irrep); moleculeclone.reinterpret_coordentry(False); moleculeclone.fix_orientation(True). # Record undisplaced symmetry for projection of diplaced point groups; psi4.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print("""""" %d ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:65211,perform,perform,65211,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['perform'],['perform']
Performance,"'monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if psi4.get_global_option('DF_BASIS_MP2') == '':; ribasis = p4util.corresponding_rifit(psi4.get_global_option('BASIS')); if ribasis:; psi4.set_global_option('DF_BASIS_MP2', ribasis); psi4.print_out(' No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Dimer DFMP2'); psi4.print_out('\n'); e_dimer_mp2 = psi4.dfmp2(); psi4.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_A'); psi4.print_out('\n'); p4util.banner('Monomer A HF'); psi4.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Monomer A DFMP2'); psi4.print_out('\n'); e_monomerA_mp2 = psi4.dfmp2(). activate(monomerB); if (ri == 'DF'):; psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_B'); psi4.print_out('\n'); p4util.banner('Monomer B HF'); psi4.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); psi4.print_out('\n'); p4util.banner('Monomer B DFMP2'); psi4.print_out('\n'); e_monomerB_mp2 = psi4.dfmp2(); psi4.set_global_option('DF_INTS_IO', df_ints_io). psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); psi4.IO.change",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:46667,LOAD,LOAD,46667,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['LOAD'],['LOAD']
Performance,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.freq-1.html:1521,perform,performed,1521,psi4manual/1.4.0/api/psi4.driver.freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.freq-1.html,20,['perform'],['performed']
Performance,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/freq.html:2243,perform,performed,2243,psi4manual/master/freq.html,https://psicode.org,https://psicode.org/psi4manual/master/freq.html,16,['perform'],['performed']
Performance,"'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.freq-1.html:1518,perform,performed,1518,psi4manual/1.3.2/api/psi4.driver.freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.freq-1.html,8,['perform'],['performed']
Performance,"("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # CC_LAMBDA keyword was being set TRUE sporadically, but that's covered c-side. director = {; ""mp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:66211,optimiz,optimized,66211,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['optimiz'],['optimized']
Performance,"(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57586,optimiz,optimize,57586,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['optimiz'],['optimize']
Performance,"('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Call executable xcfour, directing cfour output to the psi4 output file; try:; retcode = subprocess.Popen([xmod], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); #p4out.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message) . c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; #if psi4.outfile_name() == 'stdout':; # sys.stdout.write(data); #else:; # p4out.write(data); # p4out.flush(); c4out += data; #internal_p4c4_info['output'] = c4out; return c4out. [docs]def vpt2(name, **kwargs):; """"""Perform vibrational second-order perturbation computation through; Cfour to get anharmonic frequencies. This version uses c4 for the disp; and pt2 but gets gradients from p4. :type c4full: :ref:`boolean <op_py_boolean>`; :param c4full: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether when *name* indicates a Cfour method and *mode*; indicates a sow/reap approach, sown files are direct ZMAT files; and FJOBARC files are expected to reap, so that Cfour only, not; Cfour-through-Psi4, is needed for distributed jobs. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Presently uses all gradients. Could mix in analytic 2nd-derivs. - Collect resutls. - Manage scratch / subdir better. - Untangle CCSD(T) vs CCSD[T] and FJOBARC issue. - Allow CFOUR_BASIS. - Consider forcing some tighter convcrit, c4 and p4. - sow/reap. - mixed ang/bohr signals. - error by converting to ang in psi?. - Expand CURRENT DIPOLE XYZ beyond SCF. - Remember additional FJOBARC record TOTENER2 if EXCITE .ne. NONE. - S/R P4grad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html:3329,Perform,Perform,3329,psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/wrappers_cfour.html,1,['Perform'],['Perform']
Performance,"('Wrapper counterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option(""BASIS"", psi4.get_global_option(""BASIS"")). df_ints_io = psi4.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; psi4.set_global_option('DF_INTS_IO', 'SAVE'); psioh = psi4.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). psi4.print_out(""\n""); p4util.banner(""CP Computation: Complex.\nFull Basis Set.""); psi4.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). psi4.clean(); psi4.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); p4util.banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; psi4.clean(). psi4.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); psi4.print_out(""\n""); #cluster.print_to_output(); p4util.banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); psi4.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. psi4.set_globa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:20465,LOAD,LOAD,20465,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['LOAD'],['LOAD']
Performance,"('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if abs(expected - computed) > 10 ** (-digits):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if math.isnan(computed):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); _success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; rows = len(expected); cols = len(expected[0]); failed = 0; for row in range(rows):; for col in range(cols):; if abs(expected[row][col] - computed[row][col]) > 10 ** (-digits):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, expected[row][col], computed[row][col])); failed = 1; break. if failed:; print(""The Failed Test Matrices\n""); show(computed); print('\n'); show(expected); sys.exit(1); _success(label). [docs]def query_yes_no(question, default=True):; """"""Ask a yes/no question via raw_input() and return their answer. *question* is a string that is presented to the user.; *default* is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user). The return value is one of True or False. """""". yes = re.compile(r'^(y|yes|true|on|1)', re.IGNORECASE); no = re.compile(r'^(n|no|false|off|0)', re.IGNORECASE). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/psiutil.html:1432,Perform,Performs,1432,psi4manual/4.0b3/_modules/qcdb/psiutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/psiutil.html,3,['Perform'],['Performs']
Performance,"('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n ------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:56003,optimiz,optimizer,56003,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,5,['optimiz'],['optimizer']
Performance,"('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well tested - Experimental; opt_object = optking.opt_helper.CustomHelper(molecule); with open(f""{core.get_writer_file_prefix(molecule.name())}.1.dat"", 'r') as f:; stashed_opt = json.load(f); opt_object.from_dict(stashed_opt); else:; # create an OptHelper to run an optimization through; # Optking will ignore any keywords it doesn't recognize.; params = p4util.prepare_options_for_modules(); optimizer_params = {k: v.get('value') for k, v in params.pop(""OPTKING"").items() if v.get('has_changed')}; optimizer_params.update(kwargs.get(""optimizer_keywords"", {})); opt_object = optking.opt_helper.CustomHelper(molecule, params=optimizer_params). initial_sym = molecule.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = molecule.schoenflies_symbol(); if initial_sym != current_sym:. if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; raise ValidationError(""Symmet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:71531,optimiz,optimization,71531,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimization']
Performance,"('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sherrill Group Gold Standard'; return driver_cbs.cbs(func, label, **kwargs). [docs]def allen_focal_point(func, label, **kwargs):; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; :py:func:`~driver_cbs.complete_basis_set` to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~driver_cbs.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~driver_cbs.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] = kwargs.get('c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/aliases.html:4944,perform,performed,4944,psi4manual/1.0.0/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/aliases.html,4,['perform'],['performed']
Performance,"((mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs] def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta * 2 + 1; qcvars[f""CBS {self.cbsrec[dc]['d_stage'].upper()} TOTAL ENERGY""] = self.cbsrec[dc][""d_energy""] - self.cbsrec[dc + 1][""d_energy""]. G0 = assembled_results[""gradient""]; if G0 is not None:; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessian""]; if H0 is not None:; qcvars[""CURRENT HESSIAN""] = H0; qcvars[""CB",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:58668,load,load,58668,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['load'],['load']
Performance,"((self: psi4.core.Matrix, ...); docstring. array_interface((self: psi4.core.Matrix) -> list). axpy((self: psi4.core.Matrix, arg0: float, ...); docstring. back_transform((self: psi4.core.Matrix, ...); docstring. cholesky_factorize(...); docstring. clone(...); docstring. coldim(...); docstring. cols((self: psi4.core.Matrix, arg0: int) -> int); docstring. copy((self: psi4.core.Matrix, ...); docstring. copy_lower_to_upper(...); docstring. copy_upper_to_lower(...); docstring. diagonalize((self: psi4.core.Matrix, ...); docstring. doublet((self: psi4.core.Matrix, ...); docstring. from_array(arr[, name, dim1, dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_serial(json_data); Converts serialized data to the correct Psi4 data type. gemm((self: psi4.core.Matrix, arg0: bool, ...); docstring. get(*args, **kwargs); Overloaded function. identity((self: psi4.core.Matrix) -> None); docstring. invert((self: psi4.core.Matrix) -> None); docstring. load((self: psi4.core.Matrix, arg0: str) -> None); docstring. load_mpqc((self: psi4.core.Matrix, ...); docstring. nirrep((self: psi4.core.Matrix) -> int); docstring. np_read(filename[, prefix]). np_write([filename, prefix]). partial_cholesky_factorize(...); docstring. power((self: psi4.core.Matrix, arg0: float, ...); docstring. print_out((self: psi4.core.Matrix) -> None); docstring. project_out((self: psi4.core.Matrix, ...); docstring. remove_symmetry((self: psi4.core.Matrix, ...); docstring. rms((self: psi4.core.Matrix) -> float); docstring. rotate_columns((self: psi4.core.Matrix, ...); docstring. rowdim(...); docstring. rows((self: psi4.core.Matrix, arg0: int) -> int); docstring. save((self: psi4.core.Matrix, arg0: str, ...); docstring. scale((self: psi4.core.Matrix, ...); docstring. scale_column((self: psi4.core.Matrix, ...); docstring. scale_row((self: psi4.core.Matrix, ...); docstring. schmidt((self: psi4.core.Matrix) -> None). set(*args, **kwargs); Overloaded function. subtract((self: ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html:1523,load,load,1523,psi4manual/1.1.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"() # 2. psi4.driver.inputparser.process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python.; :rtype: str; Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Parameters:. raw_input (str) – Input in a mixture of Python and PSIthon syntax.; print_level (int) – raw_input is printed to the output file unless print_level =0. Return type:; str. psi4.driver.frac.ip_fitting(name, omega_l=0.05, omega_r=2.5, omega_convergence=0.001, maxiter=20, **kwargs)[source]¶; Optimize DFT omega parameter for molecular system. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l (float) – Minimum omega to be considered during fitting.; omega_r (float) – Maximum omega to be considered during fitting.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence (float) – Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter (int) – Maximum number of iterations towards omega convergence. Returns:; Optimal omega parameter. Return type:; float. psi4.driver.frac.frac_traverse(name, **kwargs)[source]¶; Scan electron occupancy from +1 electron to -1. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult (Optional[int]) – Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult (Optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/external_apis.html:3319,optimiz,optimized,3319,psi4manual/1.9.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/external_apis.html,1,['optimiz'],['optimized']
Performance,() LibmintsMolecule method. set_coordinates() CartesianEntry method. ZMatrixEntry method. set_fixed() CoordValue method. set_full_geometry() LibmintsMolecule method. set_full_point_group() LibmintsMolecule method. set_geometry() LibmintsMolecule method. set_ghost_fragment() LibmintsMolecule method. set_ghost_fragments() LibmintsMolecule method. set_ghosted() CoordEntry method. set_has_zmatrix() LibmintsMolecule method. set_memory() in module p4util.util. set_molecular_charge() LibmintsMolecule method. set_multiplicity() LibmintsMolecule method. set_name() LibmintsMolecule method. set_num_threads() in module p4util.util. set_point_group() LibmintsMolecule method. set_status() Keyword method. Section method. set_units() LibmintsMolecule method. set_variable() LibmintsMolecule method. setkw() Getkw method. Keyword method. Section method. setting; . keywords C-side. keywords anharmonicity(). keywords cbs(). keywords cp(). keywords database(). keywords energy(). keywords molecule. keywords optimize(). keywords property(). setup_keywords() in module pcmpreprocess. SF_RESTRICT (DETCI). sherrill_gold_standard() in module aliases. show() in module qcdb.vecutil. SIGMA_OVERLAP (DETCI). single-point. SINGLES_PRINT (CCEOM). SMALL_CUTOFF (PSIMRCC). SO_S_FILE (TRANSQT). SO_T_FILE (TRANSQT). SO_TEI_FILE (TRANSQT). SO_V_FILE (TRANSQT). SOCC (GLOBALS). (MCSCF). SOLVER_CONVERGENCE (CPHF). SOLVER_EXACT_DIAGONAL (CPHF). SOLVER_MAX_SUBSPACE (CPHF). SOLVER_MAXITER (CPHF). SOLVER_MIN_SUBSPACE (CPHF). SOLVER_N_GUESS (CPHF). SOLVER_N_ROOT (CPHF). SOLVER_NORM (CPHF). SOLVER_PRECONDITION (CPHF). SOLVER_PRECONDITION_MAXITER (CPHF). SOLVER_PRECONDITION_STEPS (CPHF). SOLVER_QUANTITY (CPHF). SOLVER_TYPE (CPHF). SORTED_TEI_FILE (TRANSQT). SOS_TYPE (OCC). SPINADAPT_ENERGIES (CCENERGY). split_menial() in module wrappers. SS_E_CONVERGENCE (CCEOM). SS_R_CONVERGENCE (CCEOM). SS_SKIP_DIAG (CCEOM). SS_VECS_PER_ROOT (CCEOM). STABILITY_ADD_VECTORS (DCFT). STABILITY_ANALYSIS (SCF). STABILITY_AUGMENT_SPACE_TOL,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:45643,optimiz,optimize,45643,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['optimiz'],['optimize']
Performance,"() family when functions pass. basislistdunning¶; Module (auto-generated from make_dunning.pl script); with commands building BasisFamily objects that; encode the Dunning basis set orbital definitions in; psi4/lib/basis/NOTES and fitting bases designed for those; orbital bases. load_basfam_dunning()[source]¶. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. run_mp2_5(name, **kwargs)[source]¶; Function that computes MP2.5 energy from results of a DETCI; MP3 calculation. Psi variables:. MP2.5 TOTAL ENERGY; MP2.5 CORRELATION ENERGY. >>> energy('mp2.5'). sherrillgroup_gold_standard(name='conv-mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:34545,perform,performed,34545,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['perform'],['performed']
Performance,"() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. psi4.frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/freq-1.html:1730,perform,performed,1730,psi4manual/1.4.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/freq-1.html,5,['perform'],['performed']
Performance,"() psi4.core.IO method, [1], [2]. tocentry_exists() psi4.core.IO method, [1], [2]. tocprint() psi4.core.IO method, [1], [2]. tocscan() psi4.core.IO method, [1], [2]. tocwrite() psi4.core.IO method, [1], [2]. TPDM (DETCI). tpdm() psi4.core.CIWavefunction method, [1], [2]. TPDM_ABCD_TYPE (OCC). trace() psi4.core.Matrix method, [1], [2]. psi4.core.SymmetryOperation method, [1], [2]. TracelessQuadrupoleInt class in psi4.core, [1]. transform() psi4.core.DFHelper method, [1], [2]. psi4.core.Matrix method, [1], [2]. psi4.core.SymmetryOperation method, [1], [2]. transform_ci_integrals() psi4.core.CIWavefunction method, [1], [2]. transform_mcscf_integrals() psi4.core.CIWavefunction method, [1], [2]. transform_oei() psi4.core.IntegralTransform method, [1], [2]. transform_tei() psi4.core.IntegralTransform method, [1], [2]. transform_tei_first_half() psi4.core.IntegralTransform method, [1], [2]. transform_tei_second_half() psi4.core.IntegralTransform method, [1], [2]. transition state. ; geometry optimization. translate() psi4.core.Molecule method, [1], [2]. TRANSLATE_PSI4 (CFOUR). transpose() psi4.core.DFHelper method, [1], [2]. psi4.core.Matrix method, [1], [2]. psi4.core.SymmetryOperation method, [1], [2]. transpose_this() psi4.core.Matrix method, [1], [2]. TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_IABC_TYPE (DFOCC). TRIPLES_LOW_MEMORY (FNOCC). triplet() in module psi4.core, [1]. psi4.core.Matrix static method, [1], [2]. true_atomic_number() psi4.core.Molecule method, [1], [2]. tstart() in module psi4.core, [1]. tstop() in module psi4.core, [1]. TURN_ON_ACTV (MCSCF). TWO-ELECTRONENERGY. TwoBodyAOInt class in psi4.core, [1]. twoel_Hx() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. TwoElectronInt class in psi4.core, [1]. U. U psi4.core.BoysLocalizer attribute, [1]. psi4.core.Localizer attribute, [1], [2]. psi4.core.PMLocalizer attribute, [1]. UHF class in psi4.core,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:144597,optimiz,optimization,144597,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['optimiz'],['optimization']
Performance,"() psi4.driver.p4util.SolverEngine method. vector_dot() psi4.core.Matrix method. psi4.core.Vector method. psi4.driver.p4util.SolverEngine static method. vector_multiply() psi4.core.CIVector method. vector_scale() psi4.driver.p4util.SolverEngine method. vectors() psi4.core.FISAPT method. verbose psi4.driver.driver_cbs.CompositeComputer attribute. version() in module psi4.core. vibanal_wfn() in module psi4.driver. vibrational analysis. ; function call. output. vir() psi4.core.MOSpace static method. visualization, [1]. VMDPATH. vmfc. ; setting keywords. vmfc psi4.driver.driver_nbody.BsseEnum attribute. vv10_b() psi4.core.SuperFunctional method. vv10_c() psi4.core.SuperFunctional method. Vvals() psi4.core.OEProp method. W. w() psi4.core.BlockOPoints method. WABEI_LOWDISK (CCHBAR). Wavefunction class in psi4.core. WCOMBINE (SCF). WebMO. WFN (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (CCTRIPLES). (DETCI). (GLOBALS). wfn psi4.driver.OptimizationConvergenceError attribute. psi4.driver.SCFConvergenceError attribute. psi4.driver.TDSCFConvergenceError attribute. WFN (SCF). WFN_SYM (MCSCF). (PSIMRCC). WFN_TYPE (DFOCC). (OCC). what psi4.driver.TDSCFConvergenceError attribute. WIBERG LOWDIN INDICES. width psi4.driver.p4util.InPsight attribute. wK() psi4.core.JK method. write() psi4.core.CIVector method. psi4.core.FCHKWriter method. psi4.core.MoldenWriter method. psi4.core.MOWriter method. psi4.core.NBOWriter method. write_molden() psi4.core.Wavefunction method. write_nbo() psi4.core.Wavefunction method. WRITE_NOS (CCDENSITY). WRITE_OPT_HISTORY (OPTKING). WRITE_OPT_RESULT (OPTKING). write_scratch_file() psi4.core.IOManager method. WRITE_TRAJECTORY (OPTKING). WRITER_FILE_LABEL (GLOBALS). X. x() psi4.core.BlockOPoints method. psi4.core.Molecule method. x_alpha() psi4.core.SuperFunctional method. x_beta() psi4.core.SuperFunctional method. x_functional() psi4.core.SuperFunctional method. x_functionals() psi4.core.SuperFunctional method. x_omega(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:126567,Optimiz,OptimizationConvergenceError,126567,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,1,['Optimiz'],['OptimizationConvergenceError']
Performance,"() psi4.driver.p4util.SolverEngine method. vector_dot() psi4.core.Matrix method. psi4.core.Vector method. psi4.driver.p4util.SolverEngine static method. vector_multiply() psi4.core.CIVector method. vector_scale() psi4.driver.p4util.SolverEngine method. vectors() psi4.core.FISAPT method. verbose psi4.driver.driver_cbs.CompositeComputer attribute. version() in module psi4.core. vibanal_wfn() in module psi4.driver. vibrational analysis. ; function call. output. vir() psi4.core.MOSpace static method. visualization, [1]. VMDPATH. vmfc. ; setting keywords. vmfc psi4.driver.driver_nbody.BsseEnum attribute. vv10_b() psi4.core.SuperFunctional method. vv10_c() psi4.core.SuperFunctional method. Vvals() psi4.core.OEProp method. W. w() psi4.core.BlockOPoints method. WABEI_LOWDISK (CCHBAR). Wavefunction class in psi4.core. WCOMBINE (SCF). WebMO. WFN (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (CCTRIPLES). (DETCI). (GLOBALS). wfn psi4.driver.OptimizationConvergenceError attribute. psi4.driver.SCFConvergenceError attribute. psi4.driver.TDSCFConvergenceError attribute. WFN (SCF). WFN_SYM (MCSCF). (PSIMRCC). WFN_TYPE (DFOCC). (OCC). what psi4.driver.TDSCFConvergenceError attribute. WIBERG LOWDIN INDICES. width psi4.driver.p4util.InPsight attribute. wK() psi4.core.JK method. write() psi4.core.CIVector method. psi4.core.FCHKWriter method. psi4.core.MoldenWriter method. psi4.core.MOWriter method. write_molden() psi4.core.Wavefunction method. write_nbo() psi4.core.Wavefunction method. WRITE_NOS (CCDENSITY). WRITE_OPT_HISTORY (OPTKING). WRITE_OPT_RESULT (OPTKING). write_scratch_file() psi4.core.IOManager method. WRITE_TRAJECTORY (OPTKING). WRITER_FILE_LABEL (GLOBALS). X. x() psi4.core.BlockOPoints method. psi4.core.Molecule method. x_alpha() psi4.core.SuperFunctional method. x_beta() psi4.core.SuperFunctional method. x_functional() psi4.core.SuperFunctional method. x_functionals() psi4.core.SuperFunctional method. x_omega() psi4.core.SuperFunctional ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/genindex.html:127249,Optimiz,OptimizationConvergenceError,127249,psi4manual/1.8.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/genindex.html,1,['Optimiz'],['OptimizationConvergenceError']
Performance,"()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; if name in ['mp2', 'omp2', 'mp2.5', 'mp3', 'lccd',]:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). if name == ""a-ccsd(t)"":; # temporary until dfocc can be edited and qcvar name changed; core.set_variable(""A-CCSD(T) TOTAL ENERGY"", core.variables()[""CCSD(AT) TOTAL ENERGY""]); core.set_variable(""A-(T) CORRECTION ENERGY"", core.variables()[""(AT) CORRECTION ENERGY""]); core.del_variable(""CCSD(AT) TOTAL ENERGY""); core.del_variable(""(AT) CORRECTION ENERGY""). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if core.get_global_option('SCF_TYPE') != 'DISK_DF':; raise ValidationError('DFOCC gradients need DF-SCF reference.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); corl_type = core.get_global_option('MP2_TYPE'); elif name in ['mp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; elif name in [""omp2.5""]:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); corl_type = core.get_global_option('MP_TYPE'); elif name in ['mp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); corl_type = core.get_global_option('MP_TYPE') if core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:58765,optimiz,optimized,58765,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['optimiz'],['optimized']
Performance,"(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). # power user returns; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:10559,optimiz,optimize,10559,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['optimiz'],['optimize']
Performance,"(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access arra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:10496,optimiz,optimize,10496,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['optimiz'],['optimize']
Performance,"(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; 1; 2>>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). 1; 2>>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). 1; 2>>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; 1; 2>>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). 1; 2>>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). table of contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:20084,optimiz,optimization,20084,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"(). corl_xtpl_helgaker_2(**largs)[source]¶; Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by complete_basis_set(). Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/lib/python/aliases.py; (source location) or psi4/share/psi/python/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. sherrill_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). allen_focal_point(name='mp2', **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). Table Of Contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Previous topic; BAK",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:15089,optimiz,optimization,15089,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an input dictionary. tdscf(wfn, **kwargs). temp_circular_import_blocker(). vibanal_wfn(wfn[, hess, irrep, molecule, ...]); Function to perform analysis of a hessian or hessian block, specifically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. AtomicComputer(**data); Computer for analytic single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:21558,perform,perform,21558,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,1,['perform'],['perform']
Performance,"(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, sets relevant auxiliary basis sets on it, and prepares any empirical dispersion. set_memory(inputval[, execute, quiet]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an input dictionary. tdscf(wfn, **kwargs). temp_circular_import_blocker(). vibanal_wfn(wfn[, hess, irrep, molecule, ...]); Function to perform analysis of a hessian or hessian block, specifically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). SCFConvergenceError(eqn_desc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:21439,perform,perform,21439,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,2,['perform'],['perform']
Performance,"(...); libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mp2(...); mp2() -> float :; Runs the conventional (slow) MP2 code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:110662,optimiz,optimized,110662,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['optimiz'],['optimized']
Performance,"(0.000001 * psi4.get_memory()); if mem == 256:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; molecule = psi4.get_active_molecule(); if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; psi4.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if psi4.get_global_option('BASIS') == '':; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1') # need basis printed for *every* atom; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(psi4.BasisSet.pyconstruct_orbital(molecule, ""BASIS"", psi4.get_global_option('BASIS')).genbas()); psi4.print_out(' GENBAS loaded from Psi4 LibMints for basis %s\n' % (psi4.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(psi4.MintsHelper().basisset().has_puream()). # Handle psi4 keywords implying cfour keyword values; if psi4.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psik",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html:14985,load,loaded,14985,psi4manual/1.0.0/_modules/procedures/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/interface_cfour.html,1,['load'],['loaded']
Performance,"(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['MP2_TYPE'],; ['SCF','SCF_TYPE']). # override default scf_type; psi4.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; psi4.clean(); psi4.set_global_option('BASIS',""6-31G(D)""); driver.optimize('scf'); psi4.clean(). # scf frequencies for zpe; scf_e, ref = driver.frequency('scf', return_wfn=True). # thermodynamic properties; du = psi4.get_variable('INTERNAL ENERGY CORRECTION'); dh = psi4.get_variable('ENTHALPY CORRECTION'); dg = psi4.get_variable('GIBBS FREE ENERGY CORRECTION'). freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range(0, nfreq):; freqsum += freqs.get(i); zpe = freqsum / p4const.psi_hartree2wavenumbers * 0.8929 * 0.5; psi4.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; psi4.set_global_option('FREEZE_CORE',""FALSE""); psi4.set_global_option('MP2_TYPE', 'CONV'); driver.optimize('mp2'); psi4.clean(). # qcisd(t); psi4.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); psi4.set_global_option('FREEZE_CORE',""TRUE""); psi4.set_global_option('BASIS',""6-311G(D_P)""); ref = driver.proc.run_fnocc('qcisd(t)', return_wfn=True, **kwargs). # HLC: high-level correction based on number of valence electrons; nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = psi4.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(). # correction for diffuse functions; psi4.set_global_option('BASIS',""6-311+G(D_P)""); driver.energy('mp4'); emp4_6311pg_dp = psi4.get_variable(""MP4 TOTAL ENERGY""); emp2_6311pg_dp = psi4.get_variable(""MP2 TOTAL ENERGY""); psi4.clean(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html:2597,optimiz,optimize,2597,psi4manual/1.0.0/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/gaussian_n.html,1,['optimiz'],['optimize']
Performance,"(CCRESPONSE). (CCSORT). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (CPHF). (DETCI). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (CPHF). (DFMP2). opt(); . see optimize(); . OPT_METHOD (OCC). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in p4util.optproc. OptionState class in p4util.optproc. ORB_OPT (OCC). ORB_RESP_SOLVER (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OCEPA. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OCC). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). p4const module. p4const.__init__ module. p4const.physconst module. p4const.psifiles module. p4regex module. p4util module. p4util.__init__ module. p4util.basislist module. p4util.basislistdunning module. p4util.basislistother module. p4util.optproc module. p4util.procutil module. p4util.text module. p4util.util module. PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_error() in module pcmgetkw. parse_multiline_array() in module inputparser. parseFile() GetkwParser method. parseString() GetkwParser method. PATH, [1], [2], [3], [4]. PCG_BETA_TYPE (OCC). PCG_CONVERGENCE (OCC). PCG_MAXITER (OCC). pcmgetkw module. pcmpreprocess module. PEP1. perp_unit() in module qcdb.v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:33800,Optimiz,Optimized,33800,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['Optimiz'],['Optimized']
Performance,"(CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRONENERGY. one_electron_integrals() psi4.core.MintsHelper method, [1], [2]. OneBodyAOInt class in psi4.core, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). OrbitalSpace class in psi4.core, [1]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt attribute, [1]. psi4.core.OneBodyAOInt attribute, [1], [2]. psi4.core.OverlapInt attribute, [1]. psi4.core.PotentialInt attribute, [1]. psi4.core.PseudospectralInt attribute, [1]. psi4.core.QuadrupoleInt attribute, [1]. psi4.core.TracelessQuadrupoleInt attribute, [1]. original_coef() psi4.core.GaussianShell method, [1], [2]. ORTH_TYPE (DFOCC). (OCC). outfile_name() in module psi4.core, [1]. output. ; SAPT. cbs(). database(). geometry optimization. vibrational analysis. overlap_3c() psi4.core.IntegralFactory method, [1], [2]. OVERLAP_CHECK (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:71943,Optimiz,Optimized,71943,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,"(CPHF); CPHF — Solver precondition type. Type: string; Possible Values: SUBSPACE, JACOBI, NONE; Default: JACOBI. SOLVER_PRECONDITION_MAXITER (CPHF); CPHF — Solver precondtion max steps. Type: integer; Default: 1. SOLVER_PRECONDITION_STEPS (CPHF); CPHF — Solver precondition step type. Type: string; Possible Values: CONSTANT, TRIANGULAR; Default: TRIANGULAR. SOLVER_QUANTITY (CPHF); CPHF — Solver residue or eigenvector delta. Type: string; Possible Values: EIGENVECTOR, RESIDUAL; Default: RESIDUAL. SOLVER_TYPE (CPHF); CPHF — Solver type (for interchangeable solvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SORTED_TEI_FILE (TRANSQT); TRANSQT — MO-basis sorted two-electron integrals file. Type: integer; Default: PSIF_MO_TEI. SOS_SCALE (OMP2); OMP2 — Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE (OMP3); OMP3 — Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2 (OMP2); OMP2 — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_SCALE2 (OMP3); OMP3 — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_TYPE (OMP2); OMP2 — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OMP3); OMP3 — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM —",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:117296,optimiz,optimized-,117296,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized-']
Performance,"(DETCI)¶DETCI (Expert) — Array specifying the absolute alpha string number and beta string number for the second determinant in the filter procedure. (See FILTER_GUESS). Type: array; Default: No Default. FILTER_GUESS_SIGN (DETCI)¶DETCI (Expert) — The required phase (1 or -1) between the two determinants specified by FILTER_GUESS_DET1 and FILTER_GUESS_DET2. Type: integer; Default: 1. FILTER_ZERO_DET (DETCI)¶DETCI (Expert) — If present, the code will try to filter out a particular determinant by setting its CI coefficient to zero. FILTER_ZERO_DET = [alphastr, betastr] specifies the absolute alpha and beta string numbers of the target determinant. This could be useful for trying to exclude states that have a nonzero CI coefficient for the given determinant. However, this option was experimental and may not be effective. Type: array; Default: No Default. FINAL_GEOM_WRITE (OPTKING)¶OPTKING — Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. FISAPT_CHARGE_COMPLETENESS (FISAPT)¶FISAPT — Amount of fragment charge completeness to distinguish link bonds. Type: double; Default: 0.8. FISAPT_DO_FSAPT (FISAPT)¶FISAPT — Do an F-SAPT analysis?. Type: boolean; Default: true. FISAPT_DO_FSAPT_DISP (FISAPT)¶FISAPT — Do F-SAPT Dispersion?. Type: boolean; Default: true. FISAPT_DO_PLOT (FISAPT)¶FISAPT — Plot a scalar-field analysis. Type: boolean; Default: false. FISAPT_FSAPT_EXCH_SCALE (FISAPT)¶FISAPT — Do F-SAPT exchange scaling? (ratio of S^infty to S^2). Type: boolean; Default: true. FISAPT_FSAPT_FILEPATH (FISAPT)¶FISAPT — Filepath to drop F-SAPT data within input file directory. Type: string; Default: fsapt/. FISAPT_FSAPT_IND_RESPONSE (FISAPT)¶FISAPT — Do F-SAPT coupled response? (not recommended). Type: boolean; Default: false. FISAPT_FSAPT_IND_SCALE (FISAPT)¶FISAPT ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:127388,optimiz,optimization,127388,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['optimiz'],['optimization']
Performance,"(PSIMRCC). OLCCD; . setting keywords. theory. OMEGA (CCRESPONSE). (CCSORT). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). OPDM_AVG (DETCI). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (DFMP2). operate() SymmetryOperation method. SymRep method. opt(); . see optimize(); . OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). optimize(); . setting keywords. optimize() in module driver. OptionsState class in p4util.optproc. OptionState class in p4util.optproc. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orca_gradient_list() in module qcdb.orca. orca_list() in module qcdb.orca. order() CharacterTable method. IrreducibleRepresentation method. OrderedDict class in qcdb.oldpymodules. orientation_fixed() LibmintsMolecule method. OrientMols class in qcdb.orient. origin() PointGroup method. original_coef() ShellInfo method. original_coefs() ShellInfo method. ORTH_TYPE (DFOCC). (OCC). oss WrappedDatabase attribute. output; . SAPT. cbs(). database(). geometry optimization. vibrational analysis. OVERLAP_CHECK (CCEOM). oxcom() in module qcdb.dbwrap. P. P (THERMO). p() IrreducibleRepresentation method. p4const module. p4const.__init__ module. p4const.physconst module. p4const.psifiles module. p4util module. p4util.__init__ module. p4util.basislist module. p4util.basislistdunning module. p4util.basislistother modul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:54871,Optimiz,Optimized,54871,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['Optimiz'],['Optimized']
Performance,"(PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError('SAPT requires requires \""reference rhf\"".'). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF (Dimer Basis)'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerB); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF (Dimer Basis)'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). activate(monomerAm); PsiMod.IO.set_default_namespace('monomerAm'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF (Monomer Basis)'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerBm); Psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:59144,LOAD,LOAD,59144,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['LOAD'],['LOAD']
Performance,"(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. scf-auto-cholesky; Cholesky filter a complete basis. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. nbody-nocp-gradient; Computation of NoCP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mints3; Test individual integral objects for correctness. phi-ao; Test computing values of basis functions (puream and non-puream) at points. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:36721,optimiz,optimization,36721,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"(STABILITY). NUM_VECS_WRITE (DETCI). O. OCC_TOLERANCE (SAPT). OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). (RESPONSE). OMEGA_BRACKET_ALPHA (PLUGIN_OMEGA), [1]. OMEGA_CONVERGE (PLUGIN_OMEGA), [1]. OMEGA_GUESS (PLUGIN_OMEGA), [1]. OMEGA_GUESS_A (PLUGIN_OMEGA), [1]. OMEGA_GUESS_B (PLUGIN_OMEGA), [1]. OMEGA_GUESS_INTERPOLATE (PLUGIN_OMEGA), [1]. OMEGA_MAXITER (PLUGIN_OMEGA), [1]. OMEGA_PROCEDURE (PLUGIN_OMEGA), [1]. OMEGA_ROOT_ALGORITHM (PLUGIN_OMEGA), [1]. OMP2_ORBS_PRINT (OMP2). OMP_N_THREAD (CPHF). (JK), [1]. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). OPDM (DETCI). (MP2). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (MP2). opt(); . see optimize(); . OPT_METHOD (OMP2). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() (in module driver). ORTH_TYPE (OMP2). output; . SAPT. cbs(). database(). geometry optimization. P. PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() (in module driver). parse_cotton_irreps() (in module driver). PATH, [1]. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). physconst (module). physical constants. PITZER (TRANSQT). plugin; . plugin_aointegrals. plugin_backtrans. plugin_ccsd_serial. plugin_ccsort. plugin_cepa. plugin_dfadc. plugin_libfock. plugin_mointegrals. plugin_mp2. plugin_omega. plugin_rqchf. plugin_sointegrals. plugin_test_matrix. plugin_testparse. plugin_testparse.__init__ (module). plugins; . available. POINTS (FINDIF). POLE_MAX (PLUGIN_DFADC), [1]. POLE_MAXITER (ADC). populateExtern() (Diffuse method). (QMMM method). PR (ADC). PRECONDITIONER (DETCI). PRESORT_FILE (TRANSQT). PRINT (CPHF). (GLOBALS). (JK), [1]. (PLUGIN_AOINTEGRALS), [1]. (PLUGIN_BACKTRAN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/genindex.html:20246,optimiz,optimize,20246,psi4manual/4.0b2/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/genindex.html,1,['optimiz'],['optimize']
Performance,"(T)/qz2p on NH2. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao; single-point C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html:3039,perform,performed,3039,psi4manual/1.7.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html,1,['perform'],['performed']
Performance,"(\left\langle VV||VV\right \rangle\) terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. CACHELEVEL¶. The amount of caching of data to perform. Type: integer; Default: 2. DEBUG¶. Reproducing energies from densities ?. Type: integer; Default: 0. GAUGE¶. The type of gauge to use for properties. Type: string; Default: LENGTH. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 1e-14. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: false. PROP_ALL¶. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. WRITE_NOS¶. Do write natural orbitals (molden). Type: boolean; Default: false. XI¶. Do compute Xi?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. OPDM_ONLY¶. For internal use only! Compute the one-particle density matrix, but not the two-particle density matrix. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: SCF. XI_CONNECT¶. Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. table of contents. CCDENSITY; General; AO_BASIS; CACHELEVEL; DEBUG; GAUGE; INTS_TOLERANCE; OPDM_RELAX; PROP_ALL; PROP_ROOT; PROP_SYM; REFERENCE; ROOTS_PER_IRREP; WRITE_NOS; XI; ZETA. Expert; OPDM_ONLY; WFN; XI_CONNECT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CCDENSITY. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__ccdensity.html:1855,CACHE,CACHELEVEL,1855,psi4manual/1.8.x/autodir_options_c/module__ccdensity.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__ccdensity.html,1,['CACHE'],['CACHELEVEL']
Performance,"(\left\langle VV||VV\right \rangle\) terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. CACHELEVEL¶. The amount of caching of data to perform. Type: integer; Default: 2. DEBUG¶. Reproducing energies from densities ?. Type: integer; Default: 0. GAUGE¶. The type of gauge to use for properties. Type: string; Default: LENGTH. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 1e-14. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: false. PROP_ALL¶. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. WRITE_NOS¶. Do write natural orbitals (molden). Type: boolean; Default: false. XI¶. Do compute Xi?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. OPDM_ONLY¶. For internal use only! Compute the one-particle density matrix, but not the two-particle density matrix. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: SCF. XI_CONNECT¶. Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. table of contents. CCDENSITY; General; AO_BASIS; CACHELEVEL; DEBUG; GAUGE; INTS_TOLERANCE; OPDM_RELAX; PROP_ALL; PROP_ROOT; PROP_SYM; REFERENCE; ROOTS_PER_IRREP; WRITE_NOS; XI; ZETA. Expert; OPDM_ONLY; WFN; XI_CONNECT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CCDENSITY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__ccdensity.html:1855,CACHE,CACHELEVEL,1855,psi4manual/1.9.x/autodir_options_c/module__ccdensity.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__ccdensity.html,1,['CACHE'],['CACHELEVEL']
Performance,"(a_1\), \(a_2\)]; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\beta\)]; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]; [\(b\), \(c\)] via NL_DISPERSION_PARAMETERS; [\(s_6\)]; [\(s_6\)]; [\(s_6\)]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. [2][Grimme:2004:1463]. [3][Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. [6](1, 2) [Smith:2016:2197]. [7][Hujo:2011:3866]. [8][Chai:2010:6615]. [9][Pernal:2009:263201]. [10][Podeszwa:2010:550]. [11]Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); 1energy('bp86-d'). DFT-D3BJ optimization with default parameters; 1optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; 1; 2set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); 1; 2set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4’s libdisp; 1energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; 1; 2; 3; 4; 5; 6molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14>>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dftd3-1.html:7508,optimiz,optimize,7508,psi4manual/1.3.2/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dftd3-1.html,2,['optimiz'],['optimize']
Performance,"(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time, nthread); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:2508,Perform,Perform,2508,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['Perform'],['Perform']
Performance,"(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time, nthread); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat entries. clean_variables(); Empties all double and Matrix QCVariables that have been ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:2848,Perform,Perform,2848,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['Perform'],['Perform']
Performance,"(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data laid out like; :meth:`~psi4.core.Wavefunction.to_file`. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to; :py:func:`numpy.load` to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:8552,load,load,8552,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['load'],['load']
Performance,"(default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ALL; Default: POLARIZABILITY. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. GAUGE¶. Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; Default: LENGTH. Table Of Contents. CC: Coupled Cluster Methods; Basic Keywords; REFERENCE; R_CONVERGENCE; MAXITER; BRUECKNER_ORBS_R_CONVERGENCE; RESTART; CACHELEVEL; CACHETYPE; NUM_AMPS_PRINT; MP2_AMPS_PRINT. Larger Calculations; Excited State Coupled Cluster Calculations; ROOTS_PER_IRREP; E_CONVERGENCE; SINGLES_PRINT; SCHMIDT_ADD_RESIDUAL_TOLERANCE; EOM_GUESS. Linear Response (CCLR) Calculations; PROPERTY; OMEGA; GAUGE. Previous topic; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Next topic; FNOCC: Frozen natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cc-1.html:10105,CACHE,CACHELEVEL,10105,psi4manual/4.0b4/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cc-1.html,6,"['CACHE', 'Optimiz']","['CACHELEVEL', 'CACHETYPE', 'Optimized']"
Performance,"(fname); Load FCHK file into a string. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, …); Find list of approximate (within max_distance) matches to string seq1 among options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:18874,optimiz,optimize,18874,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['optimiz'],['optimize']
Performance,(for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. ORBITAL_LEVEL_SHIFT¶. The shift applied to the denominator in the orbital update iterations. Type: double; Default: 0.0. RELAX_GUESS_ORBITALS¶. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. RELAX_TAU¶. Controls whether to relax tau during the cumulant updates or not. Type: boolean; Default: true. STABILITY_ADD_VECTORS¶. The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES¶. The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS¶. The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. TIKHONOW_OMEGA¶. The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. Table Of Contents. DCFT; General; ALGORITHM; AO_BASIS; DCFT_FUNCTIONAL; DCFT_TYPE; DF_BASIS_DCFT; DIIS_START_CONVERGENCE; E_CONVERGENCE; GUESS_R_CONVERGENCE; MAXITER; MOLDEN_WRITE; ODC_,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dcft-1.html:6614,Perform,Performs,6614,psi4manual/1.0.0/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dcft-1.html,2,['Perform'],['Performs']
Performance,(for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. ORBITAL_LEVEL_SHIFT¶. The shift applied to the denominator in the orbital update iterations. Type: double; Default: 0.0. RELAX_GUESS_ORBITALS¶. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. RELAX_TAU¶. Controls whether to relax tau during the cumulant updates or not. Type: boolean; Default: true. STABILITY_ADD_VECTORS¶. The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES¶. The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS¶. The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. TIKHONOW_OMEGA¶. The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. table of contents. DCFT; General; ALGORITHM; AO_BASIS; DCFT_FUNCTIONAL; DCFT_TYPE; DF_BASIS_DCFT; DIIS_START_CONVERGENCE; E_CONVERGENCE; GUESS_R_CONVERGENCE; MAXITER; MOLDEN_WRITE; ODC_,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__dcft-1.html:6579,Perform,Performs,6579,psi4manual/1.1.0/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__dcft-1.html,6,['Perform'],['Performs']
Performance,"(mc['f_wfn'] == mce['f_wfn']) and (mc['f_basis'] == mce['f_basis']); and (mc['f_options'] == mce['f_options'])):; mce['f_energy'] = mc['f_energy']; mce['f_gradient'] = mc['f_gradient']; mce['f_hessian'] = mc['f_hessian']; mce['f_dipole'] = mc['f_dipole']; mce['f_dipder'] = mc['f_dipder']. # logger.debug(""MC\n"" + pp.pformat(mc)). cbs_results, self.cbsrec = _assemble_cbs_components(self.metameta, self.trove, self.cbsrec). instructions = _summary_table(self.metadata, self.trove, self.cbsrec); core.print_out(instructions); logger.info(instructions). # logger.debug('CBS_RESULTS\n' + pp.pformat(cbs_results)); # logger.debug('GRAND_NEED\n' + pp.pformat(self.cbsrec)). cbs_results[""module""] = modules; return cbs_results. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as Composite-flavored QCSchema."""""". assembled_results = self._prepare_results(client=client); E0 = assembled_results[""energy""]. # load QCVariables & properties; qcvars = {; 'CBS NUMBER': len(self.compute_list),; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. for qcv in ['CBS', 'CURRENT']:; qcvars[qcv + ' REFERENCE ENERGY'] = self.cbsrec[0]['d_energy']; qcvars[qcv + ' CORRELATION ENERGY'] = E0 - self.cbsrec[0]['d_energy']; qcvars[qcv + ('' if qcv == 'CURRENT' else ' TOTAL') + ' ENERGY'] = E0. for idelta in range(int(len(self.cbsrec) / 2)):; if idelta == 0:; continue; dc = idelta * 2 + 1; qcvars[f""CBS {self.cbsrec[dc]['d_stage'].upper()} TOTAL ENERGY""] = self.cbsrec[dc][""d_energy""] - self.cbsrec[dc + 1][""d_energy""]. G0 = assembled_results[""gradient""]; if G0 is not None:; qcvars[""CURRENT GRADIENT""] = G0; qcvars[""CBS TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = assembled_results[""hessian""]; if H0 is not None:; qcvars[""CURRENT HESSIAN""] = H0; qcvars[""CB",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:58830,load,load,58830,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['load'],['load']
Performance,"(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:7282,Load,Load,7282,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,1,['Load'],['Load']
Performance,"(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(key); Clear the touched status for keyword key at global (all-module) scope. revoke_local_option_changed(module, key); Clear the touched status for keyword key at module scope. run_gdma(ref_wfn, datfilename); Runs the GDMA interface code. sapt(dimer_wfn, monoa_wfn, monob_wfn); Runs the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:7280,Load,Load,7280,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['Load'],['Load']
Performance,"(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'); }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'); }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'); }. return [scf, corl, delta]. [docs]def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/aliases.html:3379,optimiz,optimization,3379,psi4manual/1.7.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/aliases.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'); }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'); }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'); }. return [scf, corl, delta]. [docs]def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; the composite wrapper to evaluate the following; expression. SCF emplo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html:3385,optimiz,optimization,3385,psi4manual/1.6.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. sapt-sf1; Tests the Psi4 SF-SAPT code. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. scf-guess-read2; Test if the the guess read in the same basis converges. cc13d; Tests analytic CC2 gradients. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. mp2-h; check that methods can act on single atom. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. fnocc3; Test FNO-QCISD(T) computation. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:4595,optimiz,optimization,4595,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); fmaster.write(p4util.format_options_for_input(moleculeclone, **kwargs)); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, freq_dertype=0, **kwargs); fmaster.write((""""""retE, retwfn = %s('%s', **kwargs)\n\n"""""" % (frequency.__name__, lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')); core.print_out(instructionsM). for n, displacement in enumerate(displacements):; rfile = 'FREQ-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""core.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Hessian Computation: Energy Displacement %d ')\n"""""" % (n + 1); banners += """"""core.print_out('\\n')\n\n"""""". if freq_mode == 'continuous':. # print progress to file and screen; core.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(core.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; core.clean(). # S/R: Write each displaced geometry to an input file; elif freq_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, kwargs, function call and energy save; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(moleculeclone, forcexyz=True).encode('utf-8')); freagent.write(p4util.format_options_for_input(moleculeclone, **kwargs).encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs); freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (energy.__name__, lowername)); freagent.write(""""""co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:78343,Load,Load,78343,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['Load'],['Load']
Performance,"(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); fmaster.write(p4util.format_options_for_input(moleculeclone, **kwargs)); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, freq_dertype=0, **kwargs); fmaster.write((""""""retE, retwfn = %s('%s', **kwargs)\n\n"""""" % (frequency.__name__, lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')); psi4.print_out(instructionsM). for n, displacement in enumerate(displacements):; rfile = 'FREQ-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Hessian Computation: Energy Displacement %d ')\n"""""" % (n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if freq_mode == 'continuous':. # print progress to file and screen; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(psi4.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; psi4.clean(). # S/R: Write each displaced geometry to an input file; elif freq_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, kwargs, function call and energy save; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(moleculeclone, forcexyz=True).encode('utf-8')); freagent.write(p4util.format_options_for_input(moleculeclone, **kwargs).encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs); freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (energy.__name__, lowername)); freagent.write(""""""ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:76361,Load,Load,76361,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Load'],['Load']
Performance,(psi4.core.Matrix method). (psi4.core.Vector method). to_string() (psi4.core.Molecule method). to_tuple() (psi4.core.Dimension method). tocclean() (psi4.core.IO method). tocentry_exists() (psi4.core.IO method). tocprint() (psi4.core.IO method). tocscan() (psi4.core.IO method). tocwrite() (psi4.core.IO method). total_index() (psi4.core.CCWavefunction method). TPDM (DETCI). tpdm() (psi4.core.CIWavefunction method). TPDM_ABCD_TYPE (OCC). trace() (psi4.core.Matrix method). (psi4.core.SymmetryOperation method). TracelessQuadrupoleInt (class in psi4.core). transform() (psi4.core.DFHelper method). (psi4.core.Matrix method). (psi4.core.SymmetryOperation method). transform_ci_integrals() (psi4.core.CIWavefunction method). transform_mcscf_integrals() (psi4.core.CIWavefunction method). transform_tei() (psi4.core.IntegralTransform method). transform_tei_first_half() (psi4.core.IntegralTransform method). transform_tei_second_half() (psi4.core.IntegralTransform method). transition state. ; geometry optimization. translate() (psi4.core.Molecule method). TRANSLATE_PSI4 (CFOUR). transpose() (psi4.core.DFHelper method). (psi4.core.Matrix method). (psi4.core.SymmetryOperation method). transpose_this() (psi4.core.Matrix method). TREE_EXPANSION_ORDER (PE). TREE_THETA (PE). TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_IABC_TYPE (DFOCC). TRIPLES_LOW_MEMORY (FNOCC). triplet() (in module psi4.core). (psi4.core.Matrix static method). trove (psi4.driver.driver_cbs.CompositeComputer attribute). true_atomic_number() (psi4.core.Molecule method). tstart() (in module psi4.core). tstop() (in module psi4.core). TURN_ON_ACTV (MCSCF). TWO-ELECTRON ENERGY. TwoBodyAOInt (class in psi4.core). twoel_Hx() (psi4.core.HF method). twoel_Hx_full() (psi4.core.RHF method). TwoElectronInt (class in psi4.core). U. U (psi4.core.Localizer attribute). UHF (class in psi4.core). UHF_NOONS (SCF). UKSFunctions (class in psi4.core). UNCP-CORRECTED 2-BODY INTERACTION ENERGY. UNFREEZE_DIHEDRALS (OPTKING). uni,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:128817,optimiz,optimization,128817,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,1,['optimiz'],['optimization']
Performance,(psi4.core.Matrix method). (psi4.core.Vector method). to_string() (psi4.core.Molecule method). to_tuple() (psi4.core.Dimension method). tocclean() (psi4.core.IO method). tocentry_exists() (psi4.core.IO method). tocprint() (psi4.core.IO method). tocscan() (psi4.core.IO method). tocwrite() (psi4.core.IO method). total_index() (psi4.core.CCWavefunction method). TPDM (DETCI). tpdm() (psi4.core.CIWavefunction method). TPDM_ABCD_TYPE (OCC). trace() (psi4.core.Matrix method). (psi4.core.SymmetryOperation method). TracelessQuadrupoleInt (class in psi4.core). transform() (psi4.core.DFHelper method). (psi4.core.Matrix method). (psi4.core.SymmetryOperation method). transform_ci_integrals() (psi4.core.CIWavefunction method). transform_mcscf_integrals() (psi4.core.CIWavefunction method). transform_tei() (psi4.core.IntegralTransform method). transform_tei_first_half() (psi4.core.IntegralTransform method). transform_tei_second_half() (psi4.core.IntegralTransform method). transition state. ; geometry optimization. translate() (psi4.core.Molecule method). TRANSLATE_PSI4 (CFOUR). transpose() (psi4.core.DFHelper method). (psi4.core.Matrix method). (psi4.core.SymmetryOperation method). transpose_this() (psi4.core.Matrix method). TREE_EXPANSION_ORDER (PE). TREE_THETA (PE). TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_IABC_TYPE (DFOCC). TRIPLES_LOW_MEMORY (FNOCC). triplet() (in module psi4.core). (psi4.core.Matrix static method). trove (psi4.driver.driver_cbs.CompositeComputer attribute). true_atomic_number() (psi4.core.Molecule method). tstart() (in module psi4.core). tstop() (in module psi4.core). TURN_ON_ACTV (MCSCF). TWO-ELECTRON ENERGY. TwoBodyAOInt (class in psi4.core). twoel_Hx() (psi4.core.HF method). twoel_Hx_full() (psi4.core.RHF method). TwoElectronInt (class in psi4.core). U. U (psi4.core.Localizer attribute). UHF (class in psi4.core). UHF_NOONS (SCF). UKSFunctions (class in psi4.core). UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify() (psi4.core.FISAPT method),MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:127390,optimiz,optimization,127390,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,1,['optimiz'],['optimization']
Performance,"(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → Annotated[List[Annotated[List[float], FixedSize(3)]], FixedSize(3)]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html:1914,Perform,Performs,1914,psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,"(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → Annotated[list[Annotated[list[float], FixedSize(3)]], FixedSize(3)]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.SymmetryOperation.html:1921,Perform,Performs,1921,psi4manual/master/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,"(self: psi4.core.HF, shift: float = 0.0) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → None¶; Forms the F matrix. form_G(self: psi4.core.HF) → None¶; Forms the G matrix. form_H(self: psi4.core.HF) → None¶; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF) → None¶; Forms the S^1/2 matrix. form_V(self: psi4.core.HF) → None¶; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF) → None¶; Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self: psi4.core.HF) → None¶; Forms the initial F matrix. frac_renormalize(self: psi4.core.HF) → None¶; docstring. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. functional(self: psi4.core.HF) → psi4.core.SuperFunctional¶; Returns the internal DFT Superfunctional. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_energies(self: psi4.core.HF, arg0: str) → float¶; docstring. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html:22407,load,load,22407,psi4manual/1.4.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.cuhf.html,5,['load'],['load']
Performance,"(t_1\) and \(t_2\) amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. RESTART (CCLAMBDA); CCLAMBDA — Do restart the coupled-cluster iterations from old \(\lambda_1\) and \(\lambda_2\) amplitudes?. Type: boolean; Default: false. RESTART (CCRESPONSE); CCRESPONSE — Do restart from on-disk amplitudes?. Type: boolean; Default: true. RESTART (DETCI); DETCI — Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk. Type: boolean; Default: false. RESTART_EOM_CC3 (CCEOM); CCEOM — Do restart from on-disk?. Type: boolean; Default: false. RESTRICTED_DOCC (GLOBALS); GLOBALS — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (GLOBALS); GLOBALS — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RFO_FOLLOW_ROOT (OPTKING); OPTKING — Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX (OPTKING); OPTKING — Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT (OPTKING); OPTKING — Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RHF_TRIPLETS (CCEOM); CCEOM — Do form a triplet state from RHF reference?. Type: boolean; Default: false. RMS_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units). Type: conv d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:195514,optimiz,optimized,195514,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimized']
Performance,") -> str:; """"""Return canonical path to scratch file `filenumber` based on molecule on `self`. Parameters; ----------; self; Wavefunction instance.; filenumber; Scratch file number from :source:`psi4/include/psi4/psifiles.h`. """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data laid out like; :meth:`~psi4.core.Wavefunction.to_file`. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to; :py:func:`numpy.load` to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_pu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html:8246,load,load,8246,psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/python_helpers.html,4,['load'],['load']
Performance,") CH2 geometry optimization via analytic gradients. mbis-3; MBIS calculation on OH radical. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cisd-sp; 6-31G** H2O Test CISD Energy Point. cbs-xtpl-alpha; Extrapolated water energies. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cc13b; Tests RHF CCSD(T)gradients. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). mbis-4; MBIS calculation on NaCl. numpy-array-interface; Numpy interface testing. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fci-dipole; 6-31G H2O Test FCI Energy Point. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. omp3-grad1; OMP3 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:16261,optimiz,optimization,16261,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,") a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE 4. \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE 6. \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \times 10^{-3}\). TURBOMOLE 4; \(1.0 \times 10^{-6}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\); \(1.0 \times 10^{-3}\); \(5.0 \times 10^{-4}\). GAU 3 6. \(4.5 \times 10^{-4}\); \(3.0 \times 10^{-4}\); \(1.8 \times 10^{-3}\); \(1.2 \times 10^{-3}\). CFOUR 4. \(1.0 \times 10^{-4}\). QCHEM 1 5; \(1.0 \times 10^{-6}\); \(3.0 \times 10^{-4}\). \(1.2 \times 10^{-3}\). MOLPRO 2 5; \(1.0 \times 10^{-6}\); \(3.0 \times 10^{-4}\). \(3.0 \times 10^{-4}\). INTERFRAG_TIGHT 7; \(1.0 \times 10^{-6}\); \(1.5 \times 10^{-5}\); \(1.0 \times 10^{-5}\); \(6.0 \times 10^{-4}\); \(4.0 \times 10^{-4}\). GAU_TIGHT 3 6. \(1.5 \times 10^{-5}\); \(1.0 \times 10^{-5}\); \(6.0 \times 10^{-5}\); \(4.0 \tim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:11525,optimiz,optimization,11525,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimization']
Performance,") a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in Psi4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. GAU [3] [6];  . CFOUR [4];  ;  .  ;  . QCHEM [1] [5].  .  . MOLPRO [2] [5].  .  . GAU_TIGHT [3] [6];  . GAU_VERYTIGHT [6];  . Footnotes. [1]Default. [2]Baker convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:11538,optimiz,optimization,11538,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['optimiz'],['optimization']
Performance,") and [A-B]*v (H2x); H1x, H2x, nprod = engine.compute_products(vecs); iter_info['product_count'] += nprod. # form x*H1x (H1_ss) and x*H2x (H2_ss); H1_ss = np.zeros((l, l)); H2_ss = np.zeros((l, l)); for i in range(l):; for j in range(l):; H1_ss[i, j] = engine.vector_dot(vecs[i], H1x[j]); H2_ss[i, j] = engine.vector_dot(vecs[i], H2x[j]). _print_array(""Subspace Transformed (A+B)"", H1_ss, verbose); _print_array(""Subspace Transformed (A-B)"", H2_ss, verbose). # Diagonalize H2 in the subspace (eigen-decomposition to compute H2^(1/2)); H2_ss_val, H2_ss_vec = np.linalg.eigh(H2_ss); _print_array(""eigenvalues H2_ss"", H2_ss_val, verbose); _print_array(""eigenvectors H2_ss"", H2_ss_vec, verbose). # Check H2 is PD; # NOTE: If this triggers failure the SCF solution is not stable. A few ways to handle this; # 1. Use davidson solver where product function evaluates (H2 * (H1 * X)); # - Poor convergence; # 2. Switch to CIS/TDA; # - User would probably not expect this; # 3. Perform Stability update and restart with new reference; if np.any(H2_ss_val < 0.0):; msg = (""The H2 matrix is not Positive Definite. "" ""This means the reference state is not stable.""); raise RuntimeError(msg). # Build H2^(1/2); H2_ss_half = np.einsum(""ik,k,jk->ij"", H2_ss_vec, np.sqrt(H2_ss_val), H2_ss_vec, optimize=True); _print_array(""SS Transformed (A-B)^(1/2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)"", Tss, verbose). # pick positive roots; Tss = Tss[:, w2 > 1.0e-10]; w2 = w2[w2 > 1.0e-10]. # check for invalid eigvals; with np.errstate(invalid='raise'):; w = np.sqrt(w2). # sort roots; idx = w.argsort()[:nk]; Tss = Tss[:, idx]; w = w[idx]. # Extract Rss = H2^{1/2}T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:29316,Perform,Perform,29316,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,4,['Perform'],['Perform']
Performance,") and not \; (mc['f_wfn'] == job['f_wfn']):; del JOBS[indx_job]. instructions += """"""\n Enlightened listing of computations required.\n""""""; for mc in JOBS:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]). # Expand listings to all that will be obtained; JOBS_EXT = []; for job in JOBS:; for wfn in VARH[job['f_wfn']]:; JOBS_EXT.append(dict(zip(f_fields, [wfn, job['f_basis'], job['f_zeta'],; 0.0,; core.Matrix(natom, 3),; core.Matrix(3 * natom, 3 * natom)]))). instructions += """"""\n Full listing of computations to be obtained (required and bonus).\n""""""; for mc in JOBS_EXT:; instructions += """""" %12s / %-24s for %s%s\n"""""" % \; (mc['f_wfn'], mc['f_basis'], VARH[mc['f_wfn']][mc['f_wfn']], addlremark[ptype]); core.print_out(instructions). psioh = core.IOManager.shared_object(); psioh.set_specific_retention(constants.PSIF_SCF_MOS, True); # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # needs to be communicated to optimize() so reset by that optstash; core.set_local_option('SCF', 'GUESS_PERSIST', True). Njobs = 0; # Run necessary computations; for mc in JOBS:; kwargs['name'] = mc['f_wfn']. # Build string of title banner; cbsbanners = ''; cbsbanners += """"""core.print_out('\\n')\n""""""; cbsbanners += """"""p4util.banner(' CBS Computation: %s / %s%s ')\n"""""" % \; (mc['f_wfn'].upper(), mc['f_basis'].upper(), addlremark[ptype]); cbsbanners += """"""core.print_out('\\n')\n\n""""""; exec(cbsbanners). # Build string of molecule and commands that are dependent on the database; commands = '\n'; commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); exec(commands). # Make energy(), etc. call; response = func(molecule=molecule, **kwargs); if pt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:46667,optimiz,optimize,46667,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,2,['optimiz'],['optimize']
Performance,") energy call; and directing to specified or best-performance default modules. select_ccsd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. select_ccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. select_ccsd_t__gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. select_cisd(name, **kwargs)[source]¶; Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. select_fnoccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. select_fnoccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. select_lccd(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. select_lccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. select_mp2(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. select_mp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. select_mp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. select_mp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 energy ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:167588,perform,performance,167588,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,") or by the option POLICY in combination with appropriate inputs to FREEZE_CORE_POLICY At present, POLICY is an experimental option and is subject to change. Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3, POLICY; Default: FALSE. FREEZE_CORE_POLICY¶. NOTE: This is an experimental feature and subject to change! Specifies a custom frozen-core policy on a per-element basis. Input should be a list of integers representing the number of orbitals to freeze for each atomic number MINUS one (so H is 0, He is 1, etc). For example, to specify that elements H-Be should have 0 frozen orbitals, B-Mg should have 1, and Al should have 2, you would provide the input [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2]. Please make sure to fill in the list up to the highest atomic number included in any calculations. This option is only used if FREEZE_CORE is set to POLICY. Type: array; Default: No Default. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. INTEGRAL_PACKAGE¶. Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT1, SIMINT, LIBINT2; Default: LIBINT2. LITERAL_CFOUR¶. Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. MAX_RADIAL_MOMENT¶. Maximum Radial Moment to Calculate. Type: integer; Default: 4. MBIS_D_CONVERGENCE¶. MBIS Convergence Criteria. Type: conv double; Default: 1.0e-8. MBIS_MAXITER¶. Maximum",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__globals.html:4564,optimiz,optimized,4564,psi4manual/1.7.x/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__globals.html,3,['optimiz'],['optimized']
Performance,") or by the option POLICY in combination with appropriate inputs to FREEZE_CORE_POLICY At present, POLICY is an experimental option and is subject to change. Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3, POLICY; Default: FALSE. FREEZE_CORE_POLICY¶. NOTE: This is an experimental feature and subject to change! Specifies a custom frozen-core policy on a per-element basis. Input should be a list of integers representing the number of orbitals to freeze for each atomic number MINUS one (so H is 0, He is 1, etc). For example, to specify that elements H-Be should have 0 frozen orbitals, B-Mg should have 1, and Al should have 2, you would provide the input [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2]. Please make sure to fill in the list up to the highest atomic number included in any calculations. This option is only used if FREEZE_CORE is set to POLICY. Type: array; Default: No Default. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. INTEGRAL_PACKAGE¶. Integral package to use. If compiled with Simint support, change this option to use them; LibInt2 is used otherwise. Type: string; Possible Values: LIBINT2, SIMINT; Default: LIBINT2. LITERAL_CFOUR¶. Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. LS_THC_DF¶. Use DF approximation when computing LS-THC factorization?. Type: boolean; Default: true. LS_THC_RADIAL_POINTS¶. Number of radial points in LS-THC grid. Type: integer; Default: 10. LS_THC_SPHERICAL_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__globals.html:4573,optimiz,optimized,4573,psi4manual/master/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__globals.html,1,['optimiz'],['optimized']
Performance,")) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix – Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:4669,optimiz,optimize,4669,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,6,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimize']"
Performance,")). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; #molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SCF', 'SAPT', '2-dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'); if (sapt_basis == 'dimer'):; psi4.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); if (sapt_basis == 'dimer'):; psi4.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF' and sapt_basis == 'dimer'):; psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_A'); psi4.print_out('\n'); p4util.banner('Monomer A HF'); psi4.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerB); if (ri == 'DF' and sapt_basis == 'dimer'):; psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); psi4.set_local_option('SCF', 'SAPT', '2-monomer_B'); psi4.print_out('\n'); p4util.banner('Monomer B HF'); psi4.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); psi4.set_global_option('DF_INTS_IO', df_ints_io). psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); psi4.IO.change_file_namespace(p4const.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). activate(molecule); psi4.IO.set_default_namespace('dimer'); psi4.set_local_option('SAPT', 'E_CONVERG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:50224,LOAD,LOAD,50224,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['LOAD'],['LOAD']
Performance,")):; scf_helper(name, **kwargs). PsiMod.set_local_option('OCC', 'DO_SCS', 'TRUE'); PsiMod.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); PsiMod.occ(). optstash.restore(). [docs]def run_sos_omp3(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a spin-opposite scaled OMP3 computation. """"""; lowername = name.lower(). optstash = OptionsState(; ['OCC', 'SOS_TYPE'],; ['OCC', 'DO_SOS'],; ['OCC', 'WFN_TYPE']). # what type of sos?; if (lowername == 'sos-omp3'):; PsiMod.set_local_option('OCC', 'SOS_TYPE', 'SOS'); elif (lowername == 'sos-pi-omp3'):; PsiMod.set_local_option('OCC', 'SOS_TYPE', 'SOSPI'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs) . PsiMod.set_local_option('OCC', 'DO_SOS', 'TRUE'); PsiMod.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); PsiMod.occ(). optstash.restore(). [docs]def run_ocepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an orbital-optimized CEPA computation. """"""; optstash = OptionsState(; ['OCC', 'WFN_TYPE']). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs) . PsiMod.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); PsiMod.occ(). optstash.restore(). [docs]def run_ocepa_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; OCEPA gradient calculation. """"""; optstash = OptionsState(; ['GLOBALS', 'DERTYPE']). PsiMod.set_global_option('DERTYPE', 'FIRST'); run_ocepa(name, **kwargs); PsiMod.deriv(). optstash.restore(). [docs]def run_cepa0(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CEPA (LCCD) computation. """"""; optstash = OptionsState(; ['OCC', 'WFN_TYPE'],; ['OCC', 'ORB_OPT']). PsiMod.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); PsiMod.set_local_option('OCC', 'ORB_OPT', 'FALSE'); run_ocepa(name, **k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:7751,optimiz,optimized,7751,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['optimiz'],['optimized']
Performance,"), MP4, and CEPA; Quadratic configuration interaction and coupled cluster; Many-body perturbation theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; Advanced OCC Keywords; Basic DFOCC Keywords; Advanced DFOCC Keywords; Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Interpreting SAPT Results. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Output. oeprop() Evaluation of One-Electron Properties; Basic Keywords; Properties evaluated on a grid. Vibrational and Thermochemical Analysis; Keywords; Examples; Output. Previous topic; Basis Sets; Next topic; Notes on Options. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » . © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/methods-1.html:2866,Optimiz,Optimization,2866,psi4manual/1.0.0/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/methods-1.html,8,"['Optimiz', 'optimiz']","['Optimization', 'Optimizations', 'Optimizing', 'optimizations']"
Performance,"), \(s_8\), \(s_{r,6}\), \(\alpha_6\)]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]. -D3M; alias to -D3MZERO;  . -D3MZERO; -D3 [6] w/ reparameterized and more flexible original zero-damping through dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\beta\)]. -D3MBJ; -D3 [6] w/ reparameterized newer Becke-Johnson rational damping through dftd3; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, have nothing to do with this table. [2][Grimme:2004:1463]. [3](1, 2) [Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. [6](1, 2) [Smith:2016:2197]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); 1energy('bp86-d'). DFT-D3BJ optimization with default parameters; 1optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; 1; 2set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); 1; 2set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; 1; 2; 3; 4; 5; 6molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14>>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dftd3-1.html:6750,optimiz,optimize,6750,psi4manual/1.1.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dftd3-1.html,4,['optimiz'],['optimize']
Performance,"),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. frequencies; frequencies(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.frequencies.html:2869,optimiz,optimize,2869,psi4manual/master/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.frequencies.html,1,['optimiz'],['optimize']
Performance,"). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter; Maximum number of iterations towards omega convergence. Returns; -------; float; Optimal omega parameter. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'DFT_OMEGA'],; ['DOCC'],; ['SOCC']). kwargs = p4util.kwargs_lower(kwargs). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. if core.get_option('SCF', 'REFERENCE') != 'UKS':; core.print_out("""""" Requested procedure `ip_fitting` runs further calculations with UKS reference.\n""""""); core.set_local_option('SCF', 'REFERENCE', 'UKS'). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:14987,tune,tuned,14987,psi4manual/1.8.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html,3,['tune'],['tuned']
Performance,"). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() psi4.core.CIWavefunction method. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. orientation_fixed() psi4.core.Molecule method. origin psi4.core.AngularMomentumInt attribute. psi4.core.DipoleInt attribute. psi4.core.ElectricFieldInt attribute. psi4.core.ElectrostaticInt attribute. psi4.core.KineticInt attribute. psi4.core.MultipoleInt attribute. psi4.core.NablaInt attribute. psi4.core.OneBodyAOInt attribute. psi4.core.OverlapInt attribute. psi4.core.PotentialInt attribute. psi4.core.PseudospectralInt attribute. psi4.core.QuadrupoleInt attribute. psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:100453,Optimiz,Optimized,100453,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,"). IRC_STEP_SIZE (OPTKING). IRC_STOP (OPTKING). IrreducibleRepresentation class in qcdb.libmintspointgrp. irrep_labels() LibmintsMolecule method. is_axis() LibmintsMolecule method. is_cartesian() ShellInfo method. is_computed() CoordEntry method. is_equivalent_to() CoordEntry method. is_ghosted() CoordEntry method. is_linear_planar() LibmintsMolecule method. is_plane() LibmintsMolecule method. is_pure() ShellInfo method. is_variable() LibmintsMolecule method. Isotopes. ISTOP (DETCI). items() OrderedDict method. iteritems() in module qcdb.textables. OrderedDict method. iterkeys() OrderedDict method. itervalues() in module qcdb.textables. OrderedDict method. J. jajo2mol() in module qcdb.cfour. JOBTYPE (CCLAMBDA). JSCH module, [1]. K. KEEP_INTCOS (OPTKING). KEEP_OEIFILE (CCSORT). KEEP_TEIFILE (CCSORT). keys() OrderedDict method. keywords; . anharmonicity(), setting. cbs(), setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. property(), setting. kwargs_lower() in module p4util.procutil. L. l BasisSet attribute. label() CoordEntry method. LibmintsMolecule method. in module qcdb.textables. label2() in module qcdb.textables. LCC2(+LMP2)TOTALENERGY. LCCSD. LCCSD(+LMP2)TOTALENERGY. LEVEL_SHIFT (DFOCC). (MCSCF). (OCC). levenshtein() in module p4util.text. LIBEFP. LIBINT_MAX_AM BasisSet attribute. LibmintsMolecule class in qcdb.libmintsmolecule. library_modelchem() qcdb.dbwrap.ReactionDatum class method. light InPsight attribute. light_color InPsight attribute. like_world_axis() LibmintsMolecule static method. liliowa() in module qcdb.mpl. in module qcdb.textables. LINEAR (CCRESPONSE). LINEQ_SOLVER (DFOCC). (OCC). LINESEARCH_STATIC_MAX (OPTKING). LINESEARCH_STATIC_MIN (OPTKING). LINESEARCH_STATIC_N (OPTKING). LITERAL_CFOUR (GLOBALS). lmtdbas() in module qcdb.textables. load_basfam_dunning() in module p4util.basislistdunning. in module qcdb.basislistdunning. load_basfam_other() in module p4util.basislis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:45011,optimiz,optimize,45011,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['optimiz'],['optimize']
Performance,"). NUM_VECS_WRITE (DETCI). NumberValue class in qcdb.libmintscoordentry. nunique() LibmintsMolecule method. O. OCC_TOLERANCE (SAPT). OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OEProp. theory. oeprop() in module util. OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). (RESPONSE). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2_ORBS_PRINT (OMP2). OMP3; . setting keywords. theory. OMP3_ORBS_PRINT (OMP3). OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (DETCI). (MP2). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (MP2). opt(); . see optimize(); . OPT_METHOD (OMP2). (OMP3). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in optproc. OptionState class in optproc. optproc module. Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OMP2). (OMP3). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_multiline_array() in module input. PATH, [1], [2], [3]. PEP1. perp_unit() in module qcdb.vecutil. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). PHI_POINTS (SCF). physconst module. physical constants. PITZER (TRANSQT). point_group() LibmintsMolecule method. POINTS (FINDIF). POLE_MAXITER (ADC). populateExtern() Diffuse method. QMMM method. PR (ADC). PRECONDITIONER (DETCI). prerequisites. PRESORT_FILE (TRANSQT). PRINT (CPHF)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/genindex.html:30079,optimiz,optimize,30079,psi4manual/4.0b3/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/genindex.html,1,['optimiz'],['optimize']
Performance,"). OCC_TOLERANCE (FNOCC). (SAPT). OCEPA; . setting keywords. theory. OCEPA(0)CORRELATIONENERGY. OCEPA(0)TOTALENERGY. OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OEProp. theory. oeprop() in module util. OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). (RESPONSE). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (DETCI). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (DFMP2). opt(); . see optimize(); . OPT_METHOD (OCC). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in optproc. OptionState class in optproc. optproc module. ORB_OPT (OCC). ORB_RESP_SOLVER (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OCEPA. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OCC). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_multiline_array() in module input. PATH, [1], [2], [3], [4]. PB_LAMBDA (DFTSAPT). PCG_BETA_TYPE (OCC). PCG_CONVERGENCE (OCC). PCG_MAXITER (OCC). PEP1. perp_unit() in module qcdb.vecutil. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). PHI_POINTS (SCF). physconst module. physical constants",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:31336,optimiz,optimize,31336,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['optimiz'],['optimize']
Performance,"). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). OPDM_AVG (DETCI). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (DFMP2). operate() SymmetryOperation method. SymRep method. opt(); . see optimize(); . OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). optimize(); . setting keywords. optimize() in module driver. OptionsState class in p4util.optproc. OptionState class in p4util.optproc. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orca_gradient_list() in module qcdb.orca. orca_list() in module qcdb.orca. order() CharacterTable method. IrreducibleRepresentation method. OrderedDict class in qcdb.oldpymodules. orientation_fixed() LibmintsMolecule method. OrientMols class in qcdb.orient. origin() PointGroup method. original_coef() ShellInfo method. original_coefs() ShellInfo method. ORTH_TYPE (DFOCC). (OCC). oss WrappedDatabase attribute. output; . SAPT. cbs(). database(). geometry optimization. vibrational analysis. OVERLAP_CHECK (CCEOM). oxcom() in module qcdb.dbwrap. P. P (THERMO). p() IrreducibleRepresentation method. p4const module. p4const.__init__ module. p4const.physconst module. p4const.psifiles module. p4util module. p4util.__init__ module. p4util.basislist module. p4util.basislistdunning module. p4util.basislistother module. p4util.exceptions module. p4util.inpsight module. p4util.numpy_helper ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:54942,Optimiz,Optimized,54942,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['Optimiz'],['Optimized']
Performance,"). OPDM (DCT). (DETCI). opdm() psi4.core.CIWavefunction method. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. orientation_fixed() psi4.core.Molecule method. origin psi4.core.AngularMomentumInt attribute. psi4.core.DipoleInt attribute. psi4.core.ElectricFieldInt attribute. psi4.core.ElectrostaticInt attribute. psi4.core.KineticInt attribute. psi4.core.MultipoleInt attribute. psi4.core.NablaInt attribute. psi4.core.OneBodyAOInt attribute. psi4.core.OverlapInt attribute. psi4.cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:101638,Optimiz,Optimized,101638,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,"). Type: boolean; Default: true. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_IND_EXCH_SINF (SAPT); SAPT (Expert) — For SAPT(DFT) computes the S^inf Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_QQR_SIEVE (CPHF); CPHF — Do we do the QQR integral sieve of Maurer et al. When false, just uses * the Schwarz sieve. Type: boolean; Default: false. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:113254,perform,perform,113254,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"). [docs]def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:6274,Queue,Queue,6274,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Queue'],['Queue']
Performance,"). [docs]def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = physconst.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:5434,Queue,Queue,5434,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Queue'],['Queue']
Performance,). from_file() (psi4.core.Wavefunction static method). from_list() (psi4.core.Dimension class method). (psi4.core.Matrix class method). (psi4.core.Vector class method). from_schema() (psi4.core.Molecule class method). from_serial() (psi4.core.Matrix class method). (psi4.core.Vector class method). from_string() (psi4.core.Molecule class method). Frozen natural orbital coupled cluster. Frozen Natural Orbitals. FROZEN_BEND (OPTKING). FROZEN_CARTESIAN (OPTKING). FROZEN_DIHEDRAL (OPTKING). FROZEN_DISTANCE (OPTKING). FROZEN_DOCC (GLOBALS). FROZEN_OOFP (OPTKING). FROZEN_UOCC (GLOBALS). frzcpi() (psi4.core.Wavefunction method). frzvpi() (psi4.core.Wavefunction method). fsymbol() (psi4.core.Molecule method). ftrue_atomic_number() (psi4.core.Molecule method). Full (psi4.core.SaveType attribute). full_geometry() (psi4.core.Molecule method). FULL_HESS_EVERY (OPTKING). FULL_MATRIX (CCEOM). full_name() (psi4.core.PointGroup method). full_pg_n() (psi4.core.Molecule method). function call. ; geometry optimization. gradient. hessian. vibrational analysis. function_index (psi4.core.GaussianShell attribute). function_to_center() (psi4.core.BasisSet method). function_to_shell() (psi4.core.BasisSet method). Functional (class in psi4.core). functional() (psi4.core.HF method). (psi4.core.VBase method). functionals. functions_local_to_global() (psi4.core.BlockOPoints method). fx() (psi4.core.Molecule method). fy() (psi4.core.Molecule method). fZ() (psi4.core.Molecule method). fz() (psi4.core.Molecule method). fzc() (psi4.core.MOSpace static method). fzv() (psi4.core.MOSpace static method). G. G_CONVERGENCE (OPTKING). gamma (psi4.driver.p4util.Lineshape attribute). gamma() (psi4.core.CharacterTable method). gau2grid. GAUGE (ADC). (CCDENSITY). (CCRESPONSE). Gaussian (class in psi4.driver.p4util). Gaussian Formatted Checkpoint. GaussianShell (class in psi4.core). GaussianType (class in psi4.core). gCP. GDMA. gdma() (in module psi4.driver). GDMA_LIMIT (GDMA). GDMA_MULTIPOLE_UNITS (GDMA). GDMA_O,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:56700,optimiz,optimization,56700,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['optimiz'],['optimization']
Performance,"). gamma() CharacterTable method. GAUGE (CCDENSITY). (CCRESPONSE). Gaussian Formatted Checkpoint. Gaussian94BasisSetParser class in qcdb.libmintsbasissetparser. gaussian_n module. GaussianShell class in qcdb.libmintsgshell. GDMA. gdma() in module driver. GDMA_LIMIT (GDMA). GDMA_MULTIPOLE_UNITS (GDMA). GDMA_ORIGIN (GDMA). GDMA_RADIUS (GDMA). GDMA_SWITCH (GDMA). general; . setting keywords. genset_allneutral() in module qcdb.subsetgenerator. genset_anyanion() in module qcdb.subsetgenerator. genset_anycation() in module qcdb.subsetgenerator. genset_DDn5min() in module qcdb.subsetgenerator. genset_HBn5min() in module qcdb.subsetgenerator. genset_MXDDNPn5min() in module qcdb.subsetgenerator. genset_MXDDPPn5min() in module qcdb.subsetgenerator. genset_MXn5min() in module qcdb.subsetgenerator. genset_MXuDD() in module qcdb.subsetgenerator. GEOM_MAXITER (OPTKING). geometry optimization; . IRC. constrained. convergence criteria. function call. minima. output. transition state. geometry optimization, optimization. geometry() in module molutil. LibmintsMolecule method. get_anchor_atom() LibmintsMolecule method. get_ao_sorted_list() BasisSet method. get_ao_sorted_shell() BasisSet method. get_coord_value() LibmintsMolecule method. get_full_point_group() LibmintsMolecule method. get_hrgt() Database method. get_hrxn() Database method. get_memory() in module p4util.util. get_missing_reactions() Database method. get_num_threads() in module p4util.util. get_pec_weightinfo() WrappedDatabase method. get_psifile() in module p4util.procutil. get_reactions() Database method. get_variable() LibmintsMolecule method. getattr_ignorecase() in module p4util.procutil. in module qcdb.psiutil. getCartesian() PubChemObj method. getFromDict() in module p4util.util. getMoleculeString() PubChemObj method. getPubChemResults() in module pubchem. getrec() in module qcdb.jajo. getSDF() PubChemObj method. getXYZFile() PubChemObj method. Ghost Atoms. gradient; . function call. gradient() in module driver. GR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:39138,optimiz,optimization,39138,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,2,['optimiz'],['optimization']
Performance,"): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.driver.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; ## First half of this fn -- entry means user wants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:41741,optimiz,optimize,41741,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:2644,Queue,Queue,2644,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,6,['Queue'],['Queue']
Performance,"); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self, h, i, j, theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[, h]); Returns the rows in irrep h. save(*ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:2993,load,load,2993,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,4,['load'],['load']
Performance,"); OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CALC_S_SQUARED (DETCI); DETCI — Do calculate the value of \(\langle S^2\rangle\) for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CC (DETCI); DETCI — Do coupled-cluster computation?. Type: boolean; Default: false. CC3_FOLLOW_ROOT (CCEOM); CCEOM — Do turn on root following for CC3. Type: boolean; Default: false. CC_A_RAS3_MAX (DETCI); DETCI — maximum number of alpha electrons in RAS III, for CC. Ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:10504,CACHE,CACHETYPE,10504,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,12,"['CACHE', 'cache']","['CACHETYPE', 'cached']"
Performance,"); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self, arg0, arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self, arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self, x_vec, conv_tol, max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self, arg0); docstring. diis(self, arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[, shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self, arg0, arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. functional(self); Returns the internal DFT Superfunctional. get_energies(self, arg0); docstring. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self, arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self, arg0); Sets the guess Beta Orbital Matrix. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:1809,Perform,Performs,1809,psi4manual/1.7.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html,4,['Perform'],['Performs']
Performance,"); Runs the code to generate the similarity transformed Hamiltonian. cclambda(arg0); Runs the coupled cluster lambda equations code. ccresponse(arg0); Runs the coupled cluster response theory code. cctransort(arg0); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples(arg0); Runs the coupled cluster (T) energy code. clean(); Function to remove scratch files. clean_options(); Function to reset options to clean state. clean_variables(); Empties all PSI scalar and array variables that have been set internally. close_outfile(); Closes the output file. dcft(arg0); Runs the density cumulant functional theory code. del_array_variable(arg0); Removes the requested (case-insensitive) Matrix QC variable. del_scalar_variable(arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key). detci(arg0); Runs the determinant-based configuration interaction code. dfmp2(arg0); Runs the DF-MP2 code. dfocc(arg0); Runs the density-fitted orbital optimized CC codes. dmrg(arg0); Runs the DMRG code. doublet(A, B, transA, transB); Returns the multiplication of two matrices A and B, with options to transpose each beforehand. fcidump_tei_helper(nirrep, restricted, …); Write integrals to file in FCIDUMP format. finalize(). flush_outfile(); Flushes the output file. fnocc(arg0); Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. get_active_molecule(); Returns the currently active molecule object. get_array_variable(key). get_array_variables(). get_atomic_point_charges(); Returns the most recently computed atomic point charges, as a double * object. get_datadir(); Sets the path to shared text resources, PSIDATADIR. get_global_option(arg0); Given a string of a keyword name arg1, returns the value associated with the keyword from the global options. get_global_option_list(); Returns a list of all global options. get_gradient(). get_legacy_gradient(); Returns the global gradient as a (nat, 3) Matrix object. get_legacy_molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:294306,optimiz,optimized,294306,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['optimiz'],['optimized']
Performance,"); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60086,optimiz,optimizer,60086,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['optimiz'],['optimizer']
Performance,"); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58312,optimiz,optimizer,58312,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['optimiz'],['optimizer']
Performance,"); docstring. set_external_cpscf_perturbation(self, name, ...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self, arg0); Sets the internal JK object !expert. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []¶. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) →",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:4863,perform,performed,4863,psi4manual/1.9.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html,2,['perform'],['performed']
Performance,"); docstring. set_external_cpscf_perturbation(self, name, ...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self, arg0); Sets the internal JK object !expert. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF) → None¶; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:4841,perform,performed,4841,psi4manual/1.7.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html,2,['perform'],['performed']
Performance,"); gradients.append(p4mat); energies.append(p4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if freq_mode == 'sow':; optstash.restore(); optstash_conv.restore(); if return_wfn:; return (None, None); else:; return None; elif freq_mode == 'reap':; wfn = psi4.new_wavefunction(molecule, psi4.get_global_option('BASIS')). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = psi4.fd_freq_1(molecule, gradients, irrep) # TODO or moleculeclone?; wfn.set_hessian(H); wfn.set_frequencies(psi4.get_frequencies()). # The last item in the list is the reference energy, return it; psi4.set_variable('CURRENT ENERGY', energies[-1]). psi4.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). else:; psi4.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_freq_0(moleculeclone, irrep); moleculeclone.fix_orientation(True); moleculeclone.reinterpret_coordentry(False). # Record undisplaced symmetry for projection of diplaced point groups; psi4.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:72363,perform,perform,72363,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['perform'],['perform']
Performance,"); if not self.PYmove_to_com:; new_geom += "" no_com\n""; if self.orientation_fixed():; new_geom += "" no_reorient\n"". subset = Molecule(new_geom); subset.update_geometry(); return subset. [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Qu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:6905,Queue,Queue,6905,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,2,['Queue'],['Queue']
Performance,")}\) are not very similar to; each other. Hence, in 2016 universal scaling of all \(S^{2}\) approximated terms; was turned off by default.; Finally, in 2014 Parker et al. [Parker:2014:094106] empirically discovered that; SAPT0 energies for van der Waals dimers with close contacts benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (9)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis aug-cc-pvdz. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT and SAPT(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:11990,perform,perform,11990,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,2,['perform'],['perform']
Performance,")¶DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_LINK (SCF)¶SCF — Perform the linear scaling exchange (LinK) algorithm, as described in [Ochsenfeld:1998:1663]. Only applies to Direct SCF. Type: boolean; Default: false. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:117211,perform,perform,117211,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['perform'],['perform']
Performance,"* Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * hf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html:20371,perform,performed,20371,psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver_cbs.html,2,['perform'],['performed']
Performance,"** H2O CCSD optimization by energies, with Z-Matrix input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. fci-h2o-2; 6-31G H2O Test FCI Energy Point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fnocc7; Test fnocc with linear dependencies. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. freq-masses; che",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:11176,perform,performed,11176,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"**kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:105428,load,load,105428,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['load'],['load']
Performance,"**kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:10905,load,load,10905,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"*\ th-order CI |; +-------------------------+---------------------------------------------------------------------------------------+; | fci | full configuration interaction (FCI) |; +-------------------------+---------------------------------------------------------------------------------------+; | detci | **expert** full control over detci module |; +-------------------------+---------------------------------------------------------------------------------------+; | adc | 2nd-order algebraic diagrammatic construction (ADC) |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-cc2 | EOM-CC2 |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-cc3 | EOM-CC3 |; +-------------------------+---------------------------------------------------------------------------------------+; | cepa(n) | coupled electron pair approximation, variants 0, 1, and 3 |; +-------------------------+---------------------------------------------------------------------------------------+; | acpf | averaged coupled-pair functional |; +-------------------------+---------------------------------------------------------------------------------------+; | aqcc | averaged quadratic coupled cluster |; +-------------------------+---------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second order Moller--Plesset perturbation theory |; +-------------------------+---------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third order Moller--Plesset perturbation theory |; +-------------------------+---------------------------------------------------------------------------------------+.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:12639,optimiz,optimized,12639,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['optimiz'],['optimized']
Performance,"*kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['mp2.5', 'omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['mp3', 'omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); elif name in ['ccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); elif name in ['ccsd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); elif name in ['ccsd(t)']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:47597,optimiz,optimized,47597,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['optimiz'],['optimized']
Performance,"*kwargs). [docs]def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = ps",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:10204,perform,performance,10204,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"*kwargs)[source]¶; Function encoding sequence of PSI module calls for; a coupled MP2 calculation. run_mp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 calculation. run_mp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 gradient calculation. run_mrcc(name, **kwargs)[source]¶; Function that prepares environment and input files; for a calculation calling Kallay’s MRCC code. run_ocepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized CEPA computation. run_ocepa_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OCEPA gradient calculation. run_oldmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 calculation. run_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. run_omp2_5(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2.5 computation. run_omp2_5_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2.5 gradient calculation. run_omp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2 gradient calculation. run_omp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP3 computation. run_omp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP3 gradient calculation. run_psimrcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. run_psimrcc_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. run_sapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SAPT calculation of any level. ru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:10525,optimiz,optimized,10525,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance,"*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__)); try:; ssmod = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). for func in dir(ssmod):; if callable(getattr(ssmod, func)):; self.add_Subset(getattr(ssmod, func).__doc__, getattr(ssmod, func)). print(""""""WrappedDatabase %s: Defined subsets loaded"""""" % (self.dbse)). [docs] def get_pec_weightinfo(self):; """""". """"""; def closest(u, options):; return max(options, key=lambda v: len(os.path.commonprefix([u, v]))). dbdat = {}; oss = self.oss['default']; eqrxns = [rxn for rxn, rr in zip(oss.hrxn, oss.axis['Rrat']) if rr == 1.0]; for rxnix, rxn in enumerate(oss.hrxn):; dbdat[rxn] = {'eq': closest(rxn, eqrxns),; 'Rrat': oss.axis['Rrat'][rxnix]}; return dbdat. # def table_simple1(self, mtd, bas, opt=['CP'], err=['mae'], benchmark='default', failoninc=True,; # plotpath='analysis/flats/flat_', theme='smmerge'):; # rowplan = ['bas', 'mtd']; # columnplan = [; # ['l', r""""""Method \& Basis Set"""""", '', textables.label, {}],; # ['d', r'S22', 'HB', textables.val, {'sset': 'hb'}],; # ['d', r'S22', 'MX', textables.val,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:42893,load,loading,42893,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loading']
Performance,"+(CCD)DMP2 EXCH ENERGY¶. SAPT2+(CCD)DMP2 IND ENERGY¶. SAPT2+(3)(CCD)DMP2 DISP ENERGY¶. SAPT2+(3)(CCD)DMP2 ELST ENERGY¶. SAPT2+(3)(CCD)DMP2 EXCH ENERGY¶. SAPT2+(3)(CCD)DMP2 IND ENERGY¶. SAPT2+3(CCD)DMP2 DISP ENERGY¶. SAPT2+3(CCD)DMP2 ELST ENERGY¶. SAPT2+3(CCD)DMP2 EXCH ENERGY¶. SAPT2+3(CCD)DMP2 IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [E_h] for the; given SAPT level of theory that incorporates MP2 induction correction.; The sum of these four components yields the SAPT Level TOTAL ENERGY. SAPT2+DMP2 TOTAL ENERGY¶. SAPT2+(3)DMP2 TOTAL ENERGY¶. SAPT2+3DMP2 TOTAL ENERGY¶. SAPT2+(CCD)DMP2 TOTAL ENERGY¶. SAPT2+(3)(CCD)DMP2 TOTAL ENERGY¶. SAPT2+3(CCD)DMP2 TOTAL ENERGY¶; The total electronic interaction energy [E_h] for the labeled SAPT level; of theory that incorporates MP2 induction correction. SCF ITERATIONS¶. ADC ITERATIONS¶. CCSD ITERATIONS¶. OPTIMIZATION ITERATIONS¶; Number of iterations [] in the named iterative method or optimization procedure. SCF DIPOLE¶; Dipole array [e a0] for the SCF stage, (3,). SCF QUADRUPOLE¶; Redundant quadrupole array [e a0^2] for the SCF stage, (3, 3). SCF TOTAL ENERGY¶; The total electronic energy [E_h] of the SCF stage of the calculation.; The method CORRELATION ENERGY variables from subsequent stages of a; calculation are often the corresponding method TOTAL ENERGY; variables less this quantity. Constructed from Eq. (4),; where this quantity is \(E_{\text{SCF}}\). \begin{align*}; E_{\text{SCF}} & = E_{NN} + E_{1e^-} + E_{2e^-} + E_{xc} + E_{\text{-D}} \\; & = E_{\text{FCTL/HF}} + E_{\text{-D}}; \end{align*}Unless the method includes a dispersion correction, this quantity is; equal to HF TOTAL ENERGY (for HF) or; DFT FUNCTIONAL TOTAL ENERGY (for; DFT). Unless the method is a DFT double-hybrid, this quantity is equal; to DFT TOTAL ENERGY. SCF TOTAL GRADIENT¶; The total electronic gradient [E_h/a0] of the SCF stage of the calculation, ({nat}, 3)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:52907,OPTIMIZ,OPTIMIZATION,52907,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,8,"['OPTIMIZ', 'optimiz']","['OPTIMIZATION', 'optimization']"
Performance,"+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66821,optimiz,optimization,66821,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['optimiz'],['optimization']
Performance,"+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:69395,optimiz,optimization,69395,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimization']
Performance,"+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:62030,optimiz,optimization,62030,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['optimiz'],['optimization']
Performance,"+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. cbs-xtpl-dict; Extrapolated water energies. soscf-large; Second-order SCF convergnece: Benzene. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc12; Single point energies of multiple excited states with EOM-CCSD. dft2; DFT Functional Test. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:32701,perform,performs,32701,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Moller-Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Moller-Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix – Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, psi4.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). Previous topic; Counterpoise Correct; Next topic; Harmonic Vibrational Analysis, frequency() and hessian(). This Page. Show Source. Quick search. Enter search terms or a modul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:12112,optimiz,optimization,12112,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['optimiz'],['optimization']
Performance,", 'E_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). optstash.restore(); return returnvalue. ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory :ref:`[manual] <sec:dcft>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:45372,optimiz,optimized,45372,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['optimiz'],['optimized']
Performance,", 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:10533,perform,performance,10533,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,", (Vector)arg5, (Vector)arg6, (Vector)arg7, (Vector)arg8) -> None :. docstring; C++ signature :. void write(N3psi12MoldenWriterE {lvalue},Ss,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE). psi4.MoldenWriter.writeNO()¶; Python Library Documentation: method writeNO; writeNO(...) unbound psi4.MoldenWriter method. writeNO( (MoldenWriter)arg1, (str)arg2, (Matrix)arg3, (Matrix)arg4, (Vector)arg5, (Vector)arg6) -> None :. docstring; C++ signature :. void writeNO(N3psi12MoldenWriterE {lvalue},Ss,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6VectorEEE,N5boost10shared_ptrIN3psi6VectorEEE). Molecule¶. psi4.Molecule.BFS()¶; Python Library Documentation: method BFS in module molutil; BFS(self) unbound psi4.Molecule method. Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. psi4.Molecule.Z()¶; Python Library Documentation: method Z; Z(...) unbound psi4.Molecule method. Z( (Molecule)arg1, (int)arg2) -> float :. Nuclear charge of atom; C++ signature :. d Z(N3psi8MoleculeE {lvalue},i). psi4.Molecule.activate_all_fragments()¶; Python Library Documentation: method activate_all_fragments; activate_all_fragments(...) unbound psi4.Molecule method. activate_all_fragments( (Molecule)arg1) -> None :. Sets all fragments in the molecule to be active; C++ signature :. void activate_all_fragments(N3psi8MoleculeE {lvalue}). psi4.Molecule.add_atom()¶; Python Library Documentation: method add_atom; add_atom(...) unbound psi4.Molecule method. add_atom( (Molecule)arg1, (int)arg2, (float)arg3, (float)arg4, (float)arg5, (str)arg6, (float)arg7, (float)arg8, (int)arg9) -> None :. Adds to M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:235954,Perform,Perform,235954,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['Perform'],['Perform']
Performance,", (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :. docstring; C++ signature :. void gemm(N3psi6MatrixE {lvalue},b,b,d,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,d). psi4.Matrix.get()¶; Python Library Documentation: method get; get(...) unbound psi4.Matrix method. get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :. docstring; C++ signature :. d get(N3psi6MatrixE {lvalue},i,i [,i]). psi4.Matrix.identity()¶; Python Library Documentation: method identity; identity(...) unbound psi4.Matrix method. identity( (Matrix)arg1) -> None :. docstring; C++ signature :. void identity(N3psi6MatrixE {lvalue}). psi4.Matrix.invert()¶; Python Library Documentation: method invert; invert(...) unbound psi4.Matrix method. invert( (Matrix)arg1) -> None :. docstring; C++ signature :. void invert(N3psi6MatrixE {lvalue}). psi4.Matrix.load()¶; Python Library Documentation: method load; load(...) unbound psi4.Matrix method. load( (Matrix)arg1, (str)arg2) -> None :. docstring; C++ signature :. void load(N3psi6MatrixE {lvalue},Ss). psi4.Matrix.load_mpqc()¶; Python Library Documentation: method load_mpqc; load_mpqc(...) unbound psi4.Matrix method. load_mpqc( (Matrix)arg1, (str)arg2) -> None :. docstring; C++ signature :. void load_mpqc(N3psi6MatrixE {lvalue},Ss). psi4.Matrix.name()¶; Python Library Documentation: method name; name(...) unbound psi4.Matrix method. name( (Matrix)arg1) -> str :. docstring; C++ signature :. Ss name(N3psi6MatrixE {lvalue}). psi4.Matrix.nirrep()¶; Python Library Documentation: method nirrep; nirrep(...) unbound psi4.Matrix method. nirrep( (Matrix)arg1) -> int :. docstring; C++ signature :. i nirrep(N3psi6MatrixE {lvalue}). psi4.Matrix.np()¶; Python Library Documentation: property. psi4.Matrix.partial_cholesky_factorize()¶; Python Library Documentation: method partial_cholesky_factorize; partial_cholesky_factorize(...) unbound psi4.Matrix method. partial_cholesky_factorize( (Matrix)arg1, (float)arg2, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:208900,load,load,208900,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['load'],['load']
Performance,", **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['OCC']: # SOON """",; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a a-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)"", ""ccsd(t)_l""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:27938,perform,performance,27938,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,1,['perform'],['performance']
Performance,", *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. Added in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction); filename (str); debug (bool); strict_label (bool). >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/fchk.html:2582,optimiz,optimized,2582,psi4manual/master/fchk.html,https://psicode.org,https://psicode.org/psi4manual/master/fchk.html,1,['optimiz'],['optimized']
Performance,", *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/fchk.html:2571,optimiz,optimized,2571,psi4manual/1.7.x/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/fchk.html,1,['optimiz'],['optimized']
Performance,", *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples. Parameters. wfn (psi4.core.Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fchk-1.html:2569,optimiz,optimized,2569,psi4manual/1.4.0/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fchk-1.html,2,['optimiz'],['optimized']
Performance,", *, debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples. Parameters. wfn (psi4.core.Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/fchk-1.html:2569,optimiz,optimized,2569,psi4manual/1.5.0/fchk-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/fchk-1.html,2,['optimiz'],['optimized']
Performance,", 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 22. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark; '<benchmark_name>' <Reference>.; '<default_benchmark_name>' <Reference>. subset; 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. RSE42¶. Database of radical stabilization energies.; Geometries from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; Reference radical stabilization energies from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)] at CCSD(T)/cc-pCVTZ level. benchmark; 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)]. subset; 'small' <members_description>; 'large' <members_description>; 'RSE30' smaller systems in RSE42; '<subset>' <members_description>. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. HTR40¶. Database of Hydrogen transfer reactions.; Geometries from Bozkaya and Sherrill.; Reference energies from Bozkaya and Sherrill. benchmark; '<benchmark_name>' <Reference>.; '<default_benchmark_name>' <Reference>. subset; 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. RGC10¶. Database (Sherrill) of interaction energies for dissociation curves of rare-gas biatomic complexes.; Geometries and reference interaction energies from Tang et al. JCP 118 4976 (2003). cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'equilibrium'; 'HeHe' 18-point dissociation curve for helium dimer; 'HeNe' 18-point dissociation curve for helium-neon complex; 'HeAr' 18-point dissociation cur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_available_databases-1.html:4241,optimiz,optimize,4241,psi4manual/4.0b5/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_available_databases-1.html,4,['optimiz'],['optimize']
Performance,", 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 22. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark; '<benchmark_name>' <Reference>.; '<default_benchmark_name>' <Reference>. subset; 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. RSE42¶. Database of radical stabilization energies.; Geometries from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; Reference radical stabilization energies from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)] at CCSD(T)/cc-pCVTZ level. benchmark; 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)]. subset; 'small' <members_description>; 'large' <members_description>; 'RSE30' smaller systems in RSE42; '<subset>' <members_description>. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. RGC10¶. Database (Sherrill) of interaction energies for dissociation curves of rare-gas biatomic complexes.; Geometries and reference interaction energies from Tang et al. JCP 118 4976 (2003). cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'equilibrium'; 'HeHe' 18-point dissociation curve for helium dimer; 'HeNe' 18-point dissociation curve for helium-neon complex; 'HeAr' 18-point dissociation curve for helium-argon complex; 'HeKr' 18-point dissociation curve for helium-krypton complex; 'NeNe' 18-point dissociation curve for neon dimer; 'NeAr' 18-point dissociation curve for neon-argon complex; 'NeKr' 18-point dissociation curve for neon-krypton complex; 'ArAr' 18-point dissociation curve for argon dimer; 'ArKr' 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_available_databases-1.html:3724,optimiz,optimize,3724,psi4manual/4.0b4/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_available_databases-1.html,4,['optimiz'],['optimize']
Performance,", CVals = geometric.optimize.ParseConstraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:55848,optimiz,optimize,55848,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,3,['optimiz'],['optimize']
Performance,", CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:57599,optimiz,optimize,57599,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimize']
Performance,", DOI: 10.1063/1.4740249. Type: double; Default: 1.0e-1. SOLVER_CONVERGENCE¶. Convergence threshold (max 2-norm) for numerical solvers (instability analysis and CPHF/CPKS). Type: conv double; Default: 1.0e-6. SOLVER_MAXITER¶. Maximum iterations for numerical solvers (instability analysis and CPHF/CPKS). Type: integer; Default: 100. SOLVER_N_GUESS¶. Number of guess vectors per root for instability analysis. Type: integer; Default: 1. SOLVER_N_ROOT¶. Number of roots to converge for all irreps during instability analysis. (Overridden by SOLVER_ROOTS_PER_IRREP.). Type: integer; Default: 1. SOLVER_ROOTS_PER_IRREP¶. Number of roots to converge, per irrep, during instability analysis. (Overrides SOLVER_N_ROOT.). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html:8906,perform,perform,8906,psi4manual/1.7.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html,4,['perform'],['perform']
Performance,", None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath; sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'); user_reference = psi4.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:9713,load,load,9713,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['load'],['load']
Performance,", RTDHF, RTDA, and RTDDFT. run_mcscf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. run_mp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 calculation. run_mp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 gradient calculation. run_mp2_select(name, **kwargs)¶; Function selecting the algorithm for a MP2 energy call; and directing toward the MP2 or the DFMP2 modules. run_mp2_select_gradient(name, **kwargs)¶; Function selecting the algorithm for a MP2 gradient call; and directing toward the MP2 or the DFMP2 modules. run_mp2c(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a coupled MP2 calculation. run_mrcc(name, **kwargs)[source]¶; Function that prepares environment and input files; for a calculation calling Kallay’s MRCC code. run_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. run_omp2_gradient(name, **kwargs)¶; Function encoding sequence of PSI module calls for; OMP2 gradient calculation. run_omp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP3 computation. run_psimrcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. run_psimrcc_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. run_sapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SAPT calculation of any level. run_sapt_ct(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. run_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:10892,optimiz,optimized,10892,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance,", SF-DPT6, SFREE, X2C1E, DPT; Default: OFF. CFOUR_RELAX_DENS (CFOUR)¶CFOUR — Specifies whether the relaxed density matrix is computed for correlated wave functions. OFF (= 0) The relaxed density will not be computed, ON (= 1) it will be computed. Type: boolean; Default: false. CFOUR_RES_RAMAN (CFOUR)¶CFOUR — This option can be used to convert an analytically calculated gradient vector to a particular normal coordinate representation. A useful application is to calculate the gradient of an electronically excited state in the normal coordinate representation of the ground electronic state, as this provides a first approximation to resonance Raman intensities (hence the name of the keyword). Calculations that use the this option require the externally supplied force constant matrix FCMFINAL, which is written to disk during the course of both analytic and finite-difference vibrational frequency calculations. No such transformation is performed if OFF (=0); while ON (=1) directs the program to evaluate the gradient and transform it to the chosen set of normal coordinates. A warning message is printed if the force constant matrix is unavailable. Type: boolean; Default: false. CFOUR_RESTART_CC (CFOUR)¶CFOUR — Offers the possibility to restart a CC calculation which stopped for various reasons, e.g. time limit, in the correlation part. However, note that a restart which is specified by ON (= 1) needs the following files of the previous unfinished calculation: JOBARC, JAINDX, MOINTS, and MOABCD. Type: boolean; Default: false. CFOUR_ROT_EVEC (CFOUR)¶CFOUR — Specifies which eigenvector of the orbital rotation Hessian is to be used to rotate the original SCF orbitals. By default, it will use that associated with the lowest eigenvalue of the totally symmetric part of the block-factored Hessian, as this choice often leads to the lowest energy SCF solution. For RHF stability checks, only those instabilities which correspond to RHF solutions will be considered. It is important to u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:72428,perform,performed,72428,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['perform'],['performed']
Performance,", Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL¶. Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead. Type: string; Possible Values: ABORT, SWITCH, RFA; Default: ABORT. CFOUR_NEWNORM¶. All components of spherical AO’s are normalized to 1. This feature can help with numerical convergence issues if AO integrals are involved. Currently only working for single-point energy calculations. Type: boolean; Default: false. CFOUR_NONHF¶. Specifies whether the reference function used in the correlation energy calculation satisfies the (spin-orbital) HF equations or not. Usually there is no need to set this parameter (OFF = 0 and ON =1), since standard non-HF reference functions (QRHF and ROHF) set this flag automatically. Type: boolean; Default: false. CFOUR_NTOP_TAMP¶. Specifies how many t amplitudes will be printed for each spin case and excitation level. For =N, The largest N amplitudes for each spin case and excitation level will be printed. Type: integer; Default: 15. CFOUR_OCCUPATION¶. Specifie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:39502,optimiz,optimizations,39502,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,34,['optimiz'],"['optimizations', 'optimizer']"
Performance,", Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:9436,optimiz,optimization,9436,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,6,['optimiz'],"['optimization', 'optimized']"
Performance,", [1]. THREE_PARTICLE (DCFT). ThreeCenterOverlapInt class in psi4.core, [1]. TIKHONOW_MAX (PSIMRCC). TIKHONOW_OMEGA (DCFT). (PSIMRCC). TIKHONOW_TRIPLES (PSIMRCC). TILE_SZ (SCF). to_array() psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. to_serial() psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. to_tuple() psi4.core.Dimension method, [1], [2]. tocclean() psi4.core.IO method, [1], [2]. tocprint() psi4.core.IO method, [1], [2]. tocwrite() psi4.core.IO method, [1], [2]. TPDM (DETCI). tpdm() psi4.core.CIWavefunction method, [1], [2]. TPDM_ABCD_TYPE (OCC). trace() psi4.core.Matrix method, [1], [2]. psi4.core.SymmetryOperation method, [1], [2]. TracelessQuadrupoleInt class in psi4.core, [1]. transform() psi4.core.Matrix method, [1], [2]. psi4.core.SymmetryOperation method, [1], [2]. transform_ci_integrals() psi4.core.CIWavefunction method, [1], [2]. transform_mcscf_integrals() psi4.core.CIWavefunction method, [1], [2]. transition state. ; geometry optimization. translate() psi4.core.Molecule method, [1], [2]. TRANSLATE_PSI4 (CFOUR). transpose() psi4.core.SymmetryOperation method, [1], [2]. TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_IABC_TYPE (DFOCC). TRIPLES_LOW_MEMORY (FNOCC). triplet() psi4.core.Matrix method, [1], [2]. tstart() in module psi4.core, [1]. tstop() in module psi4.core, [1]. TURN_ON_ACTV (MCSCF). TWO-ELECTRONENERGY. TwoBodyAOInt class in psi4.core, [1]. TwoElectronInt class in psi4.core, [1]. U. U psi4.core.BoysLocalizer attribute, [1]. psi4.core.Localizer attribute, [1], [2]. psi4.core.PMLocalizer attribute, [1]. UHF class in psi4.core, [1]. UHF_NOONS (SCF). UNCP-CORRECTED2-BODYINTERACTIONENERGY. unit() psi4.core.SymmetryOperation method, [1], [2]. units. ; molecule. UNITS (GLOBALS). units psi4.core.Molecule attribute, [1], [2]. Unnormalized psi4.core.PrimitiveType attribute, [1], [2]. UPDATE (DETCI). update() psi4.core.DFSOMCSCF method, [1]. psi4.core.DiskSOMCSCF method, [1]. psi4.core.SOMCSCF m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:99535,optimiz,optimization,99535,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['optimiz'],['optimization']
Performance,", [2]. functionals. functions_local_to_global() psi4.core.BlockOPoints method, [1], [2]. fx() psi4.core.Molecule method, [1], [2]. fy() psi4.core.Molecule method, [1], [2]. fZ() psi4.core.Molecule method, [1], [2]. fz() psi4.core.Molecule method, [1], [2]. fzc() psi4.core.MOSpace method, [1], [2]. fzv() psi4.core.MOSpace method, [1], [2]. G. G_CONVERGENCE (OPTKING). gamma() psi4.core.CharacterTable method, [1], [2]. gau2grid. GAUGE (CCDENSITY). (CCRESPONSE). Gaussian Formatted Checkpoint. GaussianShell class in psi4.core, [1]. GaussianType class in psi4.core, [1]. gCP. GDMA. gdma() in module psi4. in module psi4.driver. GDMA_LIMIT (GDMA). GDMA_MULTIPOLE_UNITS (GDMA). GDMA_ORIGIN (GDMA). GDMA_RADIUS (GDMA). GDMA_SWITCH (GDMA). gemm() psi4.core.Matrix method, [1], [2]. genbas() psi4.core.BasisSet method, [1], [2]. general. ; setting keywords. general_invert() psi4.core.Matrix method, [1], [2]. generate_oei() psi4.core.IntegralTransform method, [1], [2]. GEOM_MAXITER (OPTKING). geometry optimization. ; IRC. constrained. convergence criteria. function call. minima. output. transition state. geometry optimization, optimization. geometry() in module psi4.driver. psi4.core.Molecule method, [1], [2]. GeometryUnits class in psi4.core, [1]. get() psi4.core.IntVector method, [1], [2]. psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. get_active_molecule() in module psi4.core, [1]. get_algorithm() psi4.core.FittingMetric method, [1], [2]. get_amplitudes() psi4.core.CCWavefunction method, [1], [2]. get_AO_core() psi4.core.DFHelper method, [1], [2]. get_AO_size() psi4.core.DFHelper method, [1], [2]. get_array() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. get_atomic_point_charges() in module psi4.core, [1]. get_basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:67688,optimiz,optimization,67688,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['optimiz'],['optimization']
Performance,", and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). """""". ## Aliases ##; complete_basis_set = cbs. # LAB: below is a piece of pre-class cbs() that didn't make the transition. it has details, so preserving for future revival; #; # #psioh = core.IOManager.shared_object(); # #psioh.set_specific_retention(psif.PSIF_SCF_MOS, True); # # projection across point groups not allowed and cbs() usually a mix of symm-enabled and symm-tol calls; # # needs to be communicated to optimize() so reset by that optstash; # core.set_local_option('SCF', 'GUESS_PERSIST', True); #; # # Run necessary computations; # for mc in JOBS:; # kwargs['name'] = mc['f_wfn']; #; # # Build string of molecule and commands that are dependent on the database; # commands = '\n'; # commands += """"""\ncore.set_global_option('BASIS', '%s')\n"""""" % (mc['f_basis']); # commands += """"""core.set_global_option('WRITER_FILE_LABEL', '%s')\n"""""" % \; # (user_writer_file_label + ('' if user_writer_file_label == '' else '-') + mc['f_wfn'].lower() + '-' + mc['f_basis'].lower()); # exec(commands); #; # psioh.set_specific_retention(psif.PSIF_SCF_MOS, False). def _expand_scheme_orders(scheme: str, basisname: List[str], basiszeta: List[int], wfnname: str, options: Dict) -> Dict[str, Dict[str, Any]]:; """"""Check that the length of *basiszeta* array matches the implied degree of; extrapolation in *scheme* name. Return a dictionary of same length as; basiszet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html:36031,optimiz,optimize,36031,psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver_cbs.html,2,['optimiz'],['optimize']
Performance,", and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF);",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:10316,cache,cache,10316,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,", and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/opt-1.html:14343,optimiz,optimize,14343,psi4manual/1.4.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/opt-1.html,2,['optimiz'],['optimize']
Performance,", and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/opt-1.html:14343,optimiz,optimize,14343,psi4manual/1.5.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/opt-1.html,2,['optimiz'],['optimize']
Performance,", and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Crea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/opt.html:14343,optimiz,optimize,14343,psi4manual/1.6.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/opt.html,1,['optimiz'],['optimize']
Performance,", debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/fchk.html:2573,optimiz,optimized,2573,psi4manual/1.8.x/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/fchk.html,1,['optimiz'],['optimized']
Performance,", debug=False, strict_label=True)[source]; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to programs through FCHK files — fchk(). © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/fchk.html:2573,optimiz,optimized,2573,psi4manual/1.9.x/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/fchk.html,1,['optimiz'],['optimized']
Performance,", dertype, hessian_with])[source]; Function to perform a geometry optimization. Aliases:; opt(). Returns:; float – Total electronic energy of optimized structure in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:; psi4.driver.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.driver.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:1898,optimiz,optimization,1898,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,4,['optimiz'],['optimization']
Performance,", dertype='energy', mode='sow'). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; psi4.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = psi4.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and psi4.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()). # If we are feezing cartesian, do not orient or COM; if psi4.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= psi4.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:55869,Optimiz,Optimize,55869,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,", do up to twenty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')):; maxiter = kwargs['maxiter']. # By default, do not read previous 180 orbitals file; read = False;; read180 = ''; if (kwargs.has_key('read')):; read = True;; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity(). # How many electrons are there?; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). # Work in the ot namespace for this procedure; psi4.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if (read):; psi4.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); old_guess = psi4.get_global_option(""GUESS""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""); psi4.print_out('\n\t==> IP Fitting SCF: Burn-in <==\n'); energy('scf'); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; HOMO = Na; else:; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if (HOMO > 0):; Na1 = Na1-1;; else:; Nb1 = Nb1-1;. charge1 = charge0 + 1;; mult1 = Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];. # Right endpoint; psi4.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; psi4.set_global_option(""GUESS"", ""READ""); p4util.copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); psi4.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(Na - 1)]; E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:12732,LOAD,LOAD,12732,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,1,['LOAD'],['LOAD']
Performance,", either permanently through rc-files or temporarily in this terminal session. You can keep or undo these changes. For general psi4 use, you must enable the psi4 executable to be found through any of:. prepending to PATH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file; activating the conda environment (p4env above) in shell, ~/.bashrc, or PBS cmd file; supplying full path to executable (shell or PBS cmd file). Similarly, the scratch directory (see Scratch Files) must be specified through:. defining PSI_SCRATCH in shell, ~/.bashrc, ~/.tcshrc, or PBS cmd file. Useful Commands¶. Initially install PSI4 stable release. # equivalent; >>> conda install psi4 -c psi4; >>> conda install psi4 --channel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.8 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4. Uninstall PSI4 from current environment. >>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 --channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. >>> conda install psi4 python=3.8 -c psi4/label/dev. Update to latest PSI4 nightly build. >>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4/label/dev. table of contents. Conda Binary Distribution; How to install a Psi4 binary with the Psi4conda installer, download",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/conda.html:17562,load,loaded,17562,psi4manual/master/conda.html,https://psicode.org,https://psicode.org/psi4manual/master/conda.html,9,['load'],['loaded']
Performance,", first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. tdscf-1; td-uhf test on triplet states of methylene (rpa). mbis-4; MBIS calculation on NaCl. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. mom-h2o-4; MOM excitation from LUMO HOMO+4. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. cdremp-2; Cholesky decomposed REMP/cc-pVDZ energies for the CH3 radical. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. nbody-vmfc-he",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:15716,perform,performed,15716,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,", in which case the given equilibrium value may or may not be reached by the optimization. Type: double; Default: 2.0. KEEP_INTCOS¶. Keep internal coordinate definition file. Type: boolean; Default: false. LINESEARCH_STATIC_MAX¶. If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.100. LINESEARCH_STATIC_MIN¶. If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.001. LINESEARCH_STATIC_N¶. If doing a static line search, scan this many points. Type: integer; Default: 8. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. Table Of Contents. OPTKING; Optimization Algorithm; CONSECUTIVE_BACKSTEPS; FROZEN_BEND; FROZEN_DIHEDRAL; FROZEN_DISTANCE; GEOM_MAXITER; INTERFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT_MAX; INTRAFRAG_STEP_LIMIT_MIN; IRC_DIRECTION; IRC_STEP_SIZE; IRC_STOP; OPT_TYPE; RFO_FOLLOW_ROOT; RFO_ROOT; STEP_TYPE. Convergence Control; FLEXIBLE_G_CONVERGENCE; G_CONVERGENCE; MAX_DISP_G_CONVERGENCE; MAX_ENERGY_G_CONVERGENCE; MAX_FORCE_G_CONVERGENCE; RMS_DISP_G_CONVERGENCE; RMS_FORCE_G_CONVERGENCE. Hessian Update; CART_HESS_READ; FULL_HESS_EVERY; HESS_UPDATE; HESS_UPDATE_LIMIT; HESS_UPDATE_LIMIT_MAX; HESS_UPDATE_LIMIT_SCALE; HESS_UPDATE_USE_LAST; INTRAFRAG_HESS. Fragment/Internal Coordinate Control; ADD_AUXILIARY_BONDS; COVALENT_CONNECT; FRAG_MODE; FREEZE_INTERFRAG; FREEZE_INTRAFRAG; H_BOND_CONNECT; INTCOS_GENERATE_EXIT; INTERFRAGMENT_CONNECT; INTERFRAG_DIST_INV; INTERFRAG_HESS; INTERFRAG_MODE. Misc.; FINAL_GEOM_WRITE; INTCO_FIXED_EQ_FORCE_CONSTANT; KEEP_INTCOS; LINESEARCH_STATIC_MAX; LINESEARCH_STATIC_MIN; LINESEARCH_STATIC_N; TEST_B; TEST_DERIVATIVE_B. Previous topic; WFN_TYPE; Next topic; ADD_AUXILIARY_BONDS; This Page. Show Source. Quick search. E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__optking-1.html:8137,Optimiz,Optimization,8137,psi4manual/4.0b4/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__optking-1.html,2,['Optimiz'],['Optimization']
Performance,", light_color)[source]¶. set_color(Z, color)[source]¶. set_define(key, value)[source]¶. set_radius(Z, radius)[source]¶. set_size(width, height)[source]¶. set_view(azimuth, elevation, zoom=0.7)[source]¶. sky = [0.0, -1.0, 0.0]¶. up = [0.0, 0.75, 0.0]¶. update_geometry()[source]¶. width = 1200¶. zoom = 0.5¶. Module with utility functions for use in input files. compare_arrays(expected, computed, digits, label)[source]¶; Function to compare two numpy arrays. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. compare_csx()[source]¶; Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. compare_cubes(expected, computed, label)[source]¶; Function to compare two cube files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_integers(expected, computed, label)[source]¶; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_strings(expected, computed, label)[source]¶; Function to compare two strings. Prints util.success(); when string computed exactly matches string expected.; Performs a system exit on failure. Used in input files in the test suite. compare_values(expected, computed, digits, label)[source]¶; Function to compare two values. Prints util.success(); when value comput",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:132243,Perform,Performs,132243,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Perform'],['Performs']
Performance,", mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:20415,perform,performance,20415,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,", numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:4138,Queue,Queue,4138,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['Queue'],['Queue']
Performance,", quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2). MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html:13367,optimiz,optimized,13367,psi4manual/4.0b4/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html,6,['optimiz'],['optimized']
Performance,", return_wfn, func, mode, dertype, irrep])[source]; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/freq-1.html:1824,perform,performs,1824,psi4manual/1.4.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/freq-1.html,5,['perform'],['performs']
Performance,", see below),; which introduces partial orbital relaxation, or by fully relaxing the orbitals and minimizing the entire energy expression; (as in the ODC-06 and ODC-12 methods).; The energy must be stationary with respect to the variation of the density; cumulant \(\boldsymbol{\lambda_2}\), constrained to N-representability conditions. Making the energy stationary requires solution of two sets of coupled; equations for orbitals and density cumulant, respectively (also known as; residual equations). At the present moment, three different algorithms for the; solution of the system of coupled equations are available (see; Iterative Algorithms for details).; Publications resulting from the use of the DCFT code should cite contributions; listed here. Methods¶; Currently five DCFT methods (functionals) are available: DC-06, DC-12, ODC-06, ODC-12, and ODC-13. The first four; methods use approximate N-representability conditions derived from; second-order perturbation theory and differ in the description of the; correlated (non-idempotent) part \(\boldsymbol{\tau}\) of the one-particle density; matrix and orbital optimization. While in the DC-06 and ODC-06 methods \(\boldsymbol{\tau}\) is derived from the density cumulant; in an approximate way (labelled by ‘06’), the DC-12 and ODC-12 methods derive this contribution exactly, and; take full advantage of the N-representability conditions (which is denoted by ‘12’). The corresponding DC and ODC methods; have similar description of the \(\boldsymbol{\gamma_1}\) N-representability, but differ in describing the orbital relaxation:; the former methods account for the relaxation only partially, while the latter fully relax the orbitals.; Both DC-06 and DC-12 methods have similar computational cost, same is true when comparing ODC-06 and ODC-12.; Meanwhile, the DC methods are generally more efficient than their ODC analogs, due to a more expensive orbital update step; needed for the full orbital optimization. In the ODC-13 method, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dcft-1.html:4997,optimiz,optimization,4997,psi4manual/1.1.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dcft-1.html,6,['optimiz'],['optimization']
Performance,", y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args, **kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self, arg0); Sets the internal density. set_debug(self, arg0); Sets the debug level of the object. set_print(self, arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; Returns internal AO density. basis(self: psi4.core.VBase) → psi4.core.BasisSet¶; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str) → psi4.core.VBase¶. build_collocation_cache(self: psi4.core.VBase, arg0: int) → None¶; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase) → None¶; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; doctsring. compute_Vx(self: psi4.core.VBase, arg0: List[psi4.core.Matrix], arg1: List[psi4.core.Matrix]) → None¶; doctsring. compute_gradient(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs)¶; Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase) → psi4.core.SuperFunctional¶; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int) → psi4.core.BlockOPoints¶; Returns the requested BlockOPoints. get_np_xyzw()¶; Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. Parameters:; self (VBase) – VBase instance. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.VBase.html:1896,cache,cache,1896,psi4manual/1.7.x/api/psi4.core.VBase.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.VBase.html,2,['cache'],['cache']
Performance,", y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args, **kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self, arg0); Sets the internal density. set_debug(self, arg0); Sets the debug level of the object. set_print(self, arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; Returns internal AO density. basis(self: psi4.core.VBase) → psi4.core.BasisSet¶; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str) → psi4.core.VBase¶. build_collocation_cache(self: psi4.core.VBase, arg0: int) → None¶; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase) → None¶; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; doctsring. compute_Vx(self: psi4.core.VBase, arg0: List[psi4.core.Matrix], arg1: List[psi4.core.Matrix]) → None¶; doctsring. compute_gradient(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs)¶; Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase) → psi4.core.SuperFunctional¶; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int) → psi4.core.BlockOPoints¶; Returns the requested BlockOPoints. get_np_xyzw()¶; Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self: psi4.core.VBase) → psi4.core.DFTGrid¶; Returns the grid object. initialize(*args, **kwa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.vbase.html:1914,cache,cache,1914,psi4manual/1.4.0/api/psi4.core.vbase.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.vbase.html,3,['cache'],['cache']
Performance,", y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args, **kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self, arg0); Sets the internal density. set_debug(self, arg0); Sets the debug level of the object. set_print(self, arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; Returns internal AO density. basis(self: psi4.core.VBase) → psi4.core.BasisSet¶; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str) → psi4.core.VBase¶. build_collocation_cache(self: psi4.core.VBase, arg0: int) → None¶; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase) → None¶; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; doctsring. compute_Vx(self: psi4.core.VBase, arg0: List[psi4.core.Matrix], arg1: List[psi4.core.Matrix]) → None¶; doctsring. compute_gradient(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs)¶; Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase) → psi4.core.SuperFunctional¶; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int) → psi4.core.BlockOPoints¶; Returns the requested BlockOPoints. get_np_xyzw()¶; Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects.; :rtype: Tuple[ndarray, ndarray, ndarray, ndarray]. Parameters:; self (VBase) – VBase instance. Re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html:1898,cache,cache,1898,psi4manual/1.9.x/api/psi4.core.VBase.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html,1,['cache'],['cache']
Performance,", y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args, **kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self, arg0); Sets the internal density. set_debug(self, arg0); Sets the debug level of the object. set_print(self, arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: list[psi4.core.Matrix]) → None¶; Returns internal AO density. basis(self: psi4.core.VBase) → psi4.core.BasisSet¶; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str) → psi4.core.VBase¶. build_collocation_cache(self: psi4.core.VBase, arg0: int) → None¶; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase) → None¶; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: list[psi4.core.Matrix]) → None¶; doctsring. compute_Vx(self: psi4.core.VBase, arg0: list[psi4.core.Matrix], arg1: list[psi4.core.Matrix]) → None¶; doctsring. compute_gradient(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs)¶; Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase) → psi4.core.SuperFunctional¶; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int) → psi4.core.BlockOPoints¶; Returns the requested BlockOPoints. get_np_xyzw()¶; Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. Parameters:; self (VBase) – VBase instance. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.VBase.html:1905,cache,cache,1905,psi4manual/master/api/psi4.core.VBase.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.VBase.html,1,['cache'],['cache']
Performance,",6}\), \(\alpha_6\), \(s_{r,8}\)]; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\beta\)]; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]; [\(b\), \(c\)] via NL_DISPERSION_PARAMETERS; [\(s_6\)]; [\(s_6\)]; [\(s_6\)]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. [2][Grimme:2004:1463]. [3][Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. [6](1, 2) [Smith:2016:2197]. [7][Hujo:2011:3866]. [8][Chai:2010:6615]. [9][Pernal:2009:263201]. [10][Podeszwa:2010:550]. [11]Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); 1energy('bp86-d'). DFT-D3BJ optimization with default parameters; 1optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; 1; 2set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); 1; 2set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4’s libdisp; 1energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; 1; 2; 3; 4; 5; 6molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14>>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dftd3-1.html:7427,optimiz,optimization,7427,psi4manual/1.3.2/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dftd3-1.html,2,['optimiz'],['optimization']
Performance,",; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:6736,queue,queue,6736,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['queue'],['queue']
Performance,",; e.g., 6-311++G** for 6-311ppgss. corresponding_dualfit(name)[source]¶; Function to return an appropriate DUAL helper basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. corresponding_jkfit(name)[source]¶; Function to return an appropriate JK fitting basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. corresponding_orbital(name)[source]¶; Function to validate if the orbital basis name in coded or; ornate form is in Psi4’s standard installed bases list. None; is returned if the orbital basis is not found. corresponding_rifit(name)[source]¶; Function to return an appropriate RI fitting basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. load_basis_families()[source]¶; Function to load into the array basisfamily_list; BasisFamily objects for all Psi4’s standard installed bases. print_basis_families()[source]¶; Function to print to the output file a formatted summary; of all the BasisFamily objects in basisfamily_list, by; default all Psi4’s standard installed bases. sanitize_basisname(name)[source]¶; Function to return name in coded form, stripped of; characters that confuse filenames, characters into lowercase,; + into p, * into s, and (, ), & ,; into _. Module with utility functions used by several Python functions. all_casings(input_string)[source]¶; Function to return a generator of all lettercase permutations; of input_string. drop_duplicates(seq)[source]¶; Function that given an array seq, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. extract_sowreap_from_output(sowout, quantity, sownum, linkage, allvital=False)[source]¶; Function to examine file sowout from a sow/reap distributed job; for formatted line with electronic e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:29013,load,load,29013,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['load'],['load']
Performance,",; method call) starts building a *CFOUR(...) directive for the; ZMAT file. Since the contents of the cfour {...} block are; blindly appended to any input interpreted from PSI4 format, mixing; of PSI4 and Cfour input formats likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between PSI4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM (as opposed to CFOUR_SPHERICAL). Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. PSI4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles. Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; qcdb.cfour.muster_modelchem() for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; 1; 2set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; 1; 2; 3set cfour_calc_level ccsd; set c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:30292,optimiz,optimization,30292,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['optimiz'],['optimization']
Performance,",; method call) starts building a *CFOUR(...) directive for the; ZMAT file. Since the contents of the cfour {...} block are; blindly appended to any input interpreted from Psi4 format, mixing; of Psi4 and Cfour input formats likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between Psi4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM (as opposed to CFOUR_SPHERICAL). Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. Psi4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles. Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; qcdb.cfour.muster_modelchem() for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:31316,optimiz,optimization,31316,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['optimiz'],['optimization']
Performance,",; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.0014294",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:7584,optimiz,optimizer,7584,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['optimiz'],['optimizer']
Performance,",; though implementations of the language can differ in the details. If you; want to overload on pointer types and/or use pointer types with templates,; use nullptr to signal the null pointer. The correct overload/template; parameter will then be deduced. Using nullptr also makes the code more; readable, especially if auto is used consistently throughout.; Reference: Item 8 in [Effective Modern C++]. Prefer std::make_shared to direct use of new¶; Using std::make_shared:. Reduces code verbosity, especially when coupled with auto:; 1; 2; 3; 4; 5; 6; 7; 8// Type information given 3 TIMES!!!; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // So much typing...; std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. // Much better!!!!; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Ensures exception safety and prevents resource leaks. Improves efficiency:; 1; 2; 3; 4; 5// Performs TWO allocations; std::shared_ptr<Matrix> F = std::shared_ptr<Matrix>(new Matrix(""Fock matrix"", nso, nso));. // Performs ONE allocation; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso);. Reference: Item 21 in [Effective Modern C++]. Prefer auto to explicit type declarations¶; Using auto reduces and/or avoids:. Verbosity in variable declarations:; 1; 2std::shared_ptr<Matrix> F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // So much typing...; auto F = std::make_shared<Matrix>(""Fock matrix"", nso, nso); // Much better!. Problems with uninitialized variables. auto works like template type; deduction, hence the right-hand side of the declaration needs to have an; initializer:; 1; 2; 3int x1; // fine, but uninitialized :(; auto x2; // WON'T COMPILE!!!; auto x3 = 1; // fine and initialized. Problems with unintended type casts and type mismatches that are hard; to impossible to catch:; 1; 2; 3; 4std::vector<int> v;; // !!! The size of a vector is of type std::vector<int>::size_type and is compiler- AND ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/prog_style_c-1.html:1169,Perform,Performs,1169,psi4manual/1.3.2/prog_style_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/prog_style_c-1.html,2,['Perform'],['Performs']
Performance,", arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Rese",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:2676,Perform,Perform,2676,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,4,['Perform'],['Perform']
Performance,", options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an input dictionary. tdscf(wfn, **kwargs). temp_circular_import_blocker(). vibanal_wfn(wfn[, hess, irrep, molecule, ...]); Function to perform analysis of a hessian or hessian block, specifically. write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. Classes¶. AtomicComputer(**data); Computer for analytic single-geometry computations. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. Dftd3Error(msg). EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs). MissingMethodError(msg); Error called when method not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. Table([rows, row_label_width, ...]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. Validati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:22287,optimiz,optimizer,22287,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,1,['optimiz'],['optimizer']
Performance,"-+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:56339,perform,perform,56339,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"-+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:57937,perform,perform,57937,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,2,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"-- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57683,optimiz,optimizer,57683,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['optimiz'],['optimizer']
Performance,"---- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58025,optimiz,optimizer,58025,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['optimiz'],['optimizer']
Performance,"----+---------------------------------------------------------------------------------------+; | cepa0 | coupled electron pair approximation(0) :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------+. .. include:: autodoc_dft_opt.rst. .. warning:: Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:48686,Optimiz,Optimizations,48686,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Optimiz'],['Optimizations']
Performance,"----+---------------------------------------------------------------------------------------+; | cepa0 | coupled electron pair approximation(0) :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------+. .. include:: autodoc_dft_opt.rst. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:48930,Optimiz,Optimizations,48930,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Optimiz'],['Optimizations']
Performance,--------+---------------------------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <tlmp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp25>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tllccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccd | coupled cl,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:53817,optimiz,optimized,53817,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,12,['optimiz'],['optimized']
Performance,----------+---------------------------------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <tlmp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order Moller-Plesset perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp25>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tllccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccd | coupled cl,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:52391,optimiz,optimized,52391,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,2,['optimiz'],['optimized']
Performance,----------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp25>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tllccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccd | coupled cluster doubles (CCD) :ref:`[manual] <sec:occ_nonoo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+-------------------------------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:54290,optimiz,optimized,54290,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,6,['optimiz'],['optimized']
Performance,-----------+---------------------------------------------------------------------------------------------------------------------------------------+; | qcisd | quadratic CI singles doubles (QCISD) :ref:`[manual] <sec:fnocc>` :ref:`[details] <dd_qcisd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-qcisd | QCISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | remp2 | 2nd-order retaining-the-excitation-degree MP hybrid perturbation theory :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_remp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-lccd | LCCD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_olccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cc2 | approxi,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:16763,optimiz,optimized,16763,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimized']
Performance,-----------+; | mp3 | 3rd-order Moller-Plesset perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp25>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tllccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccd | coupled cluster doubles (CCD) :ref:`[manual] <sec:occ_nonoo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+-------------------------------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:52864,optimiz,optimized,52864,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimized']
Performance,"------------ ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Ma",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57469,optimiz,optimizer,57469,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['optimiz'],['optimizer']
Performance,"------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734908 -76.026632734908 0.01523518 0.01245755 0.02742222 0.02277530 ~; 2 -76.027022666011 -0.000389931104 0.00178779 0.00142946 0.01008137 0.00594928 ~; 3 -76.027032729374 -0.000010063363 0.00014019 0.00008488 0.00077463 0.00044738 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:8944,optimiz,optimized,8944,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,2,['optimiz'],['optimized']
Performance,"-------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if cus",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:54323,optimiz,optimize,54323,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,--------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-mp4 | full MP4 with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | mp\ *n* | *n*\ th-order |MollerPlesset| (MP) perturbation theory :ref:`[manual] <sec:arbpt>` :ref:`[details] <dd_mp4>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) :ref:`[manual] <sec:arbpt>` :ref:`[details] <dd_zapt2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp2 | spin-component scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp2 | spin-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+------------------------------------------------------------------------------------------------------------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:11504,optimiz,optimized,11504,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimized']
Performance,"--------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:9145,optimiz,optimized,9145,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,8,['optimiz'],['optimized']
Performance,"---------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57669,optimiz,optimizer,57669,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['optimiz'],['optimizer']
Performance,"----------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:56447,perform,perform,56447,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,"----------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:58045,perform,perform,58045,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,"-----------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements"").",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:56201,optimiz,optimization,56201,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"-----------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowerna",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:57799,optimiz,optimization,57799,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"-----------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66668,optimiz,optimize,66668,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['optimiz'],['optimize']
Performance,"-----------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', Fals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:69242,optimiz,optimize,69242,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimize']
Performance,"-----------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_histo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:61877,optimiz,optimize,61877,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"------------------+; | hf | HF Self-consistent field method(s) | RHF/ROHF/UHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | mp2 | MP2 with density fitting only (mp2_type df) | RHF | Listed :ref:`here <sec:oeprop>` |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cc2 | 2nd-order approximate CCSD | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | ccsd | Coupled cluster singles and doubles (CCSD) | RHF | dipole, quadrupole, polarizability, rotation, roa_tensor |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | dct | density cumulant (functional) theory | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:dct>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2 | orbital-optimized second-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:47322,optimiz,optimized,47322,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,14,['optimiz'],['optimized']
Performance,"------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:9150,optimiz,optimized,9150,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,18,['optimiz'],['optimized']
Performance,"--------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | olccd | orbital optimized LCCD | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | cisd, cisdt, | Configuration interaction | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | cisdt, cisdtq, | | | transition_quadrupole |; | ci5, ..., fci | | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | casscf, rasscf | Multi-configurational SCF | RHF/ROHF | Listed :ref:`here <sec:oeprop>`, transition_dipole, |; | | | | transition_quadrupole |; +--------------------+-----------------------------------------------+---",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:48285,optimiz,optimized,48285,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['optimiz'],['optimized']
Performance,"---------------------+---------------------------------------------------------------------------------------+. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. # are we in sow/reap mode?; isSowReap = False; if ('mode' in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:37691,optimiz,optimization,37691,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['optimiz'],['optimization']
Performance,"---------------------+---------------------------------------------------------------------------------------+. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. wh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:35331,optimiz,optimization,35331,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['optimiz'],['optimization']
Performance,----------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` |; +-------------------------+---------------------------------------------------------------------------------------+; | df-mp2 | MP2 with density fitting :ref:`[manual] <sec:dfmp2>` |; +-------------------------+---------------------------------------------------------------------------------------+; | conv-mp2 | conventional MP2 (non-density-fitting) :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2.5 | MP2.5 :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp3 | third-order MP perturbation theory :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ocepa | orbital-optimized coupled electron pair approximation :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | cepa0 | coupled electron pair approximation(0) :ref:`[manual] <sec:convocc>` |; +-------------------------+-------------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:47063,optimiz,optimized,47063,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['optimiz'],['optimized']
Performance,"----------------------+; | ccsd | coupled cluster singles and doubles (CCSD) |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD |; +-------------------------+---------------------------------------------------------------------------------------+. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:35026,perform,performs,35026,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['perform'],['performs']
Performance,"-----------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: autodoc_dft_opt.rst. .. include:: cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; psi4.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = psi4.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and psi4.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:54769,optimiz,optimization,54769,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"-----------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------+. .. include:: autodoc_dft_opt.rst. .. warning:: Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:49232,perform,performed,49232,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['perform'],['performed']
Performance,-----------------------+; | df-mp2 | MP2 with density fitting :ref:`[manual] <sec:dfmp2>` |; +-------------------------+---------------------------------------------------------------------------------------+; | conv-mp2 | conventional MP2 (non-density-fitting) :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2.5 | MP2.5 :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp3 | third-order MP perturbation theory :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ocepa | orbital-optimized coupled electron pair approximation :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | cepa0 | coupled electron pair approximation(0) :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with per,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:47274,optimiz,optimized,47274,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['optimiz'],['optimized']
Performance,"------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:69049,perform,perform,69049,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['perform'],['perform']
Performance,"------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------+. .. include:: autodoc_dft_opt.rst. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:49475,perform,performed,49475,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['perform'],['performed']
Performance,"---------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:54130,perform,perform,54130,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,"----------------------------+; | dct | density cumulant (functional) theory | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:dct>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2 | orbital-optimized second-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp3 | orbital-optimized third-order | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | MP perturbation theory | | Density fitted only |; | | :ref:`[manual] <sec:occ_oo>` | | |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | olccd | orbital optimized LCCD | RHF/UHF | Listed :ref:`here <sec:oeprop>` |; | | :ref:`[manual] <sec:occ_oo>` | | Density fitted only |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-cc2 | 2nd-order approximate EOM-CCSD | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+----------------+---------------------------------------------------------------+; | eom-ccsd | Equation-of-motion CCSD (EOM-CCSD) | RHF | oscillator_strength, rotational_strength |; +--------------------+-----------------------------------------------+--------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:47991,optimiz,optimized,47991,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['optimiz'],['optimized']
Performance,"------------------------------ ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58000,optimiz,optimizer,58000,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['optimiz'],['optimizer']
Performance,"-------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowern",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66475,perform,perform,66475,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['perform'],['perform']
Performance,"-------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowerna",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:61684,perform,perform,61684,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,-----------------------------------------+; | scs(n)-omp2 | a special version of SCS-OMP2 for nucleobase interactions :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp2-vdw | a special version of SCS-OMP2 (from ethene dimers) :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-omp2 | spin-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-pi-omp2 | A special version of SOS-OMP2 for pi systems :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp3 | spin-component scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs(n)-omp3 | a special version of SCS-OMP3 for nucleobase interactions :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp3-vdw | a special version of SCS-OMP3 (from ethene dimers) :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-omp3 | spin-opposite scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +--------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:9772,optimiz,optimized,9772,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,7,['optimiz'],['optimized']
Performance,"-------------------------------------------+; | scs(n)-omp3 | a special version of SCS-OMP3 for nucleobase interactions :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp3-vdw | a special version of SCS-OMP3 (from ethene dimers) :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-omp3 | spin-opposite scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-pi-omp3 | A special version of SOS-OMP3 for pi systems :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccsd, cepa(0) | coupled electron pair approximation variant 0 :ref:`[manual] <sec:fnocepa>` :ref:`[details] <tllccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-lccsd, fno-cepa(0) | CEPA(0) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cepa(1) | coupled electron pair approximation variant 1 :ref:`[manual] <sec:fnocepa>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-cepa(1) | CEPA(1) with frozen natural orbitals :ref:`[manual] <sec:fnocc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:11156,optimiz,optimized,11156,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,7,['optimiz'],['optimized']
Performance,"----------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <dd_ccsd_prt_pr>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:68780,optimiz,optimization,68780,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimization']
Performance,"--------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:53861,optimiz,optimization,53861,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['optimiz'],['optimization']
Performance,"--------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:56030,optimiz,optimization,56030,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['optimiz'],['optimization']
Performance,"--------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:57628,optimiz,optimization,57628,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimization']
Performance,"------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66206,optimiz,optimization,66206,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,3,['optimiz'],['optimization']
Performance,"--------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: autodoc_dft_opt.rst. .. include:: cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; psi4.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = psi4.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and psi4.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:54598,optimiz,optimization,54598,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimization']
Performance,"---------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57404,Optimiz,Optimization,57404,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,14,"['Optimiz', 'optimiz']","['Optimization', 'optimizer']"
Performance,"----------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1775.65; Force c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:7630,Optimiz,Optimization,7630,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['Optimiz'],['Optimization']
Performance,"----------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True, dertype=1). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; 1; 2; 3; 4; 5; 6; 7 Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; 1; 2; 3; 4;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:8241,Optimiz,Optimization,8241,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['Optimiz'],['Optimization']
Performance,"----------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True, dertype=1). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1775.65; Force const",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:8268,Optimiz,Optimization,8268,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,9,['Optimiz'],['Optimization']
Performance,-------------------------------------------------------------+; | mp4 | full MP4 :ref:`[manual] <sec:fnompn>` :ref:`[details] <tlmp4>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-mp4 | full MP4 with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp\ *n* | *n*\ th-order Moller--Plesset (MP) perturbation theory :ref:`[manual] <sec:arbpt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) :ref:`[manual] <sec:arbpt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp2 | spin-component scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs(n)-omp2 | a special version of SCS-OMP2 for nucleobase interactions :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp2-vdw | a special version of SCS-OMP2 (from ethene dimers) :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-omp2 | spin-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:8389,optimiz,optimized,8389,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimized']
Performance,-------------------------------------------------------------+; | mp4 | full MP4 :ref:`[manual] <sec:fnompn>` :ref:`[details] <tlmp4>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-mp4 | full MP4 with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp\ *n* | *n*\ th-order |MollerPlesset| (MP) perturbation theory :ref:`[manual] <sec:arbpt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) :ref:`[manual] <sec:arbpt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp2 | spin-component scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs(n)-omp2 | a special version of SCS-OMP2 for nucleobase interactions :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scs-omp2-vdw | a special version of SCS-OMP2 (from ethene dimers) :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | sos-omp2 | spin-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:9107,optimiz,optimized,9107,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,6,['optimiz'],['optimized']
Performance,"-------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57623,optimiz,optimizer,57623,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['optimiz'],['optimizer']
Performance,"---------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:58391,optimiz,optimization,58391,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimization']
Performance,"----------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: autodoc_dft_opt.rst. .. include:: cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; psi4.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = psi4.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and psi4.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()). # If we are feezing cartesian, do not orien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:55332,Optimiz,Optimize,55332,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"------------------------------------------------------------------------ ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at the output from running the; previous example, we see that the OH bond length is about 0.9463 Ångstroms,; and the bond angle is about 104.575 degrees. It’s good to give this many; digits (or more) to make sure there’s not significant roundoff error in the; geometry when running a frequency computation. So, our frequency; computation input (which can be found as test case; tu4-h2o-freq) is:; #! Frequencies for H2O HF/cc-pVDZ at optimized geometry. memory 250 mb. molecule h2o {; O ; H 1 0.9463; H 1 0.9463 2 104.575; }. set basis cc-pVDZ; set scf_type pk; frequencies('scf'). Alternatively, it’s also possible for PSI4 to use Cartesian coordinate; input. Here, the Cartesian coordinates of the optimized geometry can be; extracted from the bottom of the optimization output. The input; would then look like this:; molecule h2o {; O 0.0000000000 0.0000000000 -0.0647163165; H 0.0000000000 -0.7490459647 0.5135474533; H 0.0000000000 0.7490459647 0.5135474533; }. set basis cc-pVDZ; frequencies('scf'). If either of the inputs above are run, the program should do some; computations and then finally report the following harmonic vibrational; frequencies (roundoff errors of around 0.1 cm-1 may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1776.2423; A1 4113.7717; B2 4211.8290; -----------------------------------------------.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:6651,optimiz,optimized,6651,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,4,['optimiz'],['optimized']
Performance,-----------------------------------------------------------------------------+; | mp3 | 3rd-order Moller-Plesset perturbation theory (MP3) :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp4(sdq) | 4th-order MP perturbation theory (MP4) less triples :ref:`[manual] <sec:fnompn>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp4 | full MP4 :ref:`[manual] <sec:fnompn>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp\ *n* | *n*\ th-order Moller--Plesset (MP) perturbation theory :ref:`[manual] <sec:arbpt>` |; +-------------------------+---------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) :ref:`[manual] <sec:arbpt>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ocepa | orbital-optimized coupled electron pair approximation :ref:`[manual] <sec:occ>` |; +-------------------------+-,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:10202,optimiz,optimized,10202,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['optimiz'],['optimized']
Performance,"--------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:54560,optimiz,optimization,54560,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,2,['optimiz'],['optimization']
Performance,"--------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ocepa | orbital-optimized coupled electron pair approximation :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | cepa0 | coupled electron pair approximation(0) :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------+. .. include:: autodoc_dft_opt.rst. .. warning:: Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Ind",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:47453,optimiz,optimized,47453,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['optimiz'],['optimized']
Performance,"--------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ocepa | orbital-optimized coupled electron pair approximation :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | cepa0 | coupled electron pair approximation(0) :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------+. .. include:: autodoc_dft_opt.rst. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:47697,optimiz,optimized,47697,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['optimiz'],['optimized']
Performance,"--------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57610,optimiz,optimizer,57610,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['optimiz'],['optimizer']
Performance,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:66905,optimiz,optimization,66905,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['optimiz'],['optimization']
Performance,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:69479,optimiz,optimization,69479,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['optimiz'],['optimization']
Performance,"------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_grad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:62114,optimiz,optimization,62114,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimization']
Performance,------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <dd_mp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_mp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | oremp2 | orbital-optimized REMP2 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_oremp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <dd_lccd>` |; +-------------------------+-------------------------------------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:65931,optimiz,optimized,65931,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['optimiz'],['optimized']
Performance,"--------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at the output from running the; previous example, we see that the OH bond length is about 0.9463 Ångstroms,; and the bond angle is about 104.575 degrees. It’s good to give this many; digits (or more) to make sure there’s not significant roundoff error in the; geometry when running a frequency computation. So, our frequency; computation input (which can be found as test case; tu4-h2o-freq) is:; #! Frequencies for H2O HF/cc-pVDZ at optimized geometry. memory 250 mb. molecule h2o {; O ; H 1 0.9463; H 1 0.9463 2 104.575; }. set basis cc-pVDZ; set scf_type pk; frequencies('scf'). Alternatively, it’s also possible for PSI4 to use Cartesian coordinate; input. Here, the Cartesian coordinates of the optimized geometry can be; extracted from the bottom of the optimization output. The input; would then look like this:; molecule h2o {; O 0.0000000000 0.0000000000 -0.0647163165; H 0.0000000000 -0.7490459647 0.5135474533; H 0.0000000000 0.7490459647 0.5135474533; }. set basis cc-pVDZ; frequencies('scf'). If either of the inputs above are run, the program should do some; computations and then finally report the following harmonic vibrational; frequencies (roundoff errors of around 0.1 cm-1 may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1776.2423; A1 4113.7717; B2 4211.8290; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1776.24; Force constant: 0.1194; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.418 0.538 1.007825; H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:6917,optimiz,optimized,6917,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,8,['optimiz'],"['optimization', 'optimized']"
Performance,---------------------------------------------------------------------------------------------+; | qcisd | quadratic CI singles doubles (QCISD) :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-qcisd | QCISD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | lccd | Linear CCD :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tllccd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | fno-lccd | LCCD with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | olccd | orbital optimized LCCD :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | cc2 | approximate coupled cluster singles and doubles (CC2) :ref:`[manual] <sec:cc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccd | coupled cluster doubles (CCD) :ref:`[manual] <sec:occ_nonoo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | bccd | Brueckner coupled cluster doubles (BCCD) :ref:`[manual] <sec:cc>` |; +-------------------------+--------------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:14532,optimiz,optimized,14532,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,7,['optimiz'],['optimized']
Performance,"----------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:6978,perform,perform,6978,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,6,"['optimiz', 'perform']","['optimization', 'optimized', 'perform']"
Performance,"----------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True, dertype=1). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:7616,perform,perform,7616,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,45,"['optimiz', 'perform']","['optimization', 'optimized', 'perform']"
Performance,"------------------------------------------------------------------------------------------------ ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2).; The program also print out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at \(1776\); cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.119",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:9199,optimiz,optimized,9199,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['optimiz'],['optimized']
Performance,"----------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:9203,optimiz,optimized,9203,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['optimiz'],['optimized']
Performance,"-------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind; that the values of the vibrational frequencies are a function of the; molecular geometry. Therefore, it’s important to obtain the vibrational; frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the; molecule with optimized geometry as it is being optimized. So, the; optimized geometry for H\(_2\)O is stored inside the h2o; molecule object, which we can access! To compute the frequencies, all we; need to do is to again pass the molecule=h2o argument to the; psi4.frequency(); API; function:. In [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True, dertype=1). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second; derivative matrix) of the electronic energy with respect to nuclear; displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around \(0.1\); cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:9084,OPTIMIZ,OPTIMIZED,9084,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['OPTIMIZ'],['OPTIMIZED']
Performance,"----------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s important to keep in mind that the values of the vibrational frequencies are a function of the molecular geometry. Therefore, it’s important to obtain the vibrational frequencies AT THE OPTIMIZED GEOMETRY. Luckily, Psi4 updates the molecule with optimized geometry as it is being optimized. So, the optimized geometry for H\(_2\)O is stored inside the h2o molecule object, which we can access! To compute the frequencies, all we need to do; is to again pass the molecule=h2o argument to the psi4.frequency() API function:. [6]:. scf_e, scf_wfn = psi4.frequency('scf/cc-pvdz', molecule=h2o, return_wfn=True). 6 displacements needed.; 1 2 3 4 5 6. Executing this cell will prompt Psi4 to compute the Hessian (second derivative matrix) of the electronic energy with respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specif",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:9090,OPTIMIZ,OPTIMIZED,9090,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['OPTIMIZ'],['OPTIMIZED']
Performance,"------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class PMLocalizer(Localizer); | docstring; | ; | Method resolution order:; | PMLocalizer; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Localizer:; | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | C++ signature :; | void localize(N3psi9LocalizerE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods inherited from Localizer:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi9LocalizerEEE build(Ss,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6MatrixEEE); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Localizer:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:576230,Perform,Perform,576230,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['Perform'],['Perform']
Performance,"--------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Boost.Python.class object>; | T.__new__(S, ...) -> a new object with type S, a subtype of T; ; class BoysLocalizer(Localizer); | docstring; | ; | Method resolution order:; | BoysLocalizer; | Localizer; | Boost.Python.instance; | __builtin__.object; | ; | Methods defined here:; | ; | __reduce__ = <unnamed Boost.Python function>(...); | ; | ----------------------------------------------------------------------; | Data and other attributes defined here:; | ; | __init__ = <built-in function __init__>; | Raises an exception; | This class cannot be instantiated from Python; | ; | ----------------------------------------------------------------------; | Methods inherited from Localizer:; | ; | localize(...); | localize( (Localizer)arg1) -> None :; | Perform the localization procedure; | ; | C++ signature :; | void localize(N3psi9LocalizerE {lvalue}); | ; | ----------------------------------------------------------------------; | Static methods inherited from Localizer:; | ; | build(...); | build( (str)arg1, (BasisSet)arg2, (Matrix)arg3) -> Localizer :; | docstring; | ; | C++ signature :; | N5boost10shared_ptrIN3psi9LocalizerEEE build(Ss,N5boost10shared_ptrIN3psi8BasisSetEEE,N5boost10shared_ptrIN3psi6MatrixEEE); | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Localizer:; | ; | L; | Localized orbital coefficients; | ; | U; | Orbital rotation matrix; | ; | converged; | Did the localization procedure converge?; | ; | ----------------------------------------------------------------------; | Data descriptors inherited from Boost.Python.instance:; | ; | __dict__; | ; | __weakref__; | ; | ----------------------------------------------------------------------; | Data and other attributes inherited from Boost.Python.instance:; | ; | __new__ = <built-in method __new__ of Bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:383482,Perform,Perform,383482,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['Perform'],['Perform']
Performance,"------------------------------; Step Energy Delta(E) MAX force MAX Delta(q); ----------------------------------------------------------------------; 1 -76.026653665892 -76.026653665892 1.52e-02 1.52e-02; 2 -76.026907793199 -0.000254127307 9.55e-03 9.55e-03; 3 -76.027052927171 -0.000145133972 4.47e-04 4.47e-04; 4 -76.027053472137 -0.000000544965 1.16e-04 1.16e-04; ----------------------------------------------------------------------. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at the output from running the; previous example, we see that the OH bond length is about 0.9463 Ångstroms,; and the bond angle is about 104.575 degrees. It’s good to give this many; digits (or more) to make sure there’s not significant roundoff error in the; geometry when running a frequency computation. So, our frequency; computation input (which can be found as test case; tu4-h2o-freq is:; #! Frequencies for H2O HF/cc-pVDZ at optimized geometry. memory 250 mb. molecule h2o {; O ; H 1 0.9463; H 1 0.9463 2 104.575; }. set basis cc-pVDZ; frequencies('scf'). Alternatively, it’s also possible for PSI4 to use Cartesian coordinate; input. Here, the Cartesian coordinates of the optimized geometry can be; extracted from the bottom of the optimization output. The input; would then look like this:; molecule h2o {; O 0.0000000000 -0.0000000000 -0.1224239500; H 0.0000000000 -1.4147069876 0.9714784639; H -0.0000000000 1.4147069876 0.9714784639; }. set basis cc-pVDZ; frequencies('scf'). If either of the inputs above are run, the program should do some; computations and then finally report the following harmonic vibrational; frequencies (roundoff errors of around 0.1 cm-1 may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1776.1735; A1 4113.8031; B2 4211.7879; -----------------------------------------------. Notice that th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:6271,optimiz,optimized,6271,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,2,['optimiz'],['optimized']
Performance,"------------------------------; Step Energy Delta(E) MAX force MAX Delta(q); ----------------------------------------------------------------------; 1 -76.026653665892 -76.026653665892 1.52e-02 1.52e-02; 2 -76.026907793199 -0.000254127307 9.55e-03 9.55e-03; 3 -76.027052927171 -0.000145133972 4.47e-04 4.47e-04; 4 -76.027053472137 -0.000000544965 1.16e-04 1.16e-04; ----------------------------------------------------------------------. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at the output from running the; previous example, we see that the OH bond length is about 0.9463 Ångstroms,; and the bond angle is about 104.575 degrees. It’s good to give this many; digits (or more) to make sure there’s not significant roundoff error in the; geometry when running a frequency computation. So, our frequency; computation input (which can be found as test case; tu4-h2o-freq is:; #! Frequencies for H2O HF/cc-pVDZ at optimized geometry. memory 250 mb. molecule h2o {; O ; H 1 0.9463; H 1 0.9463 2 104.575; }. set basis cc-pVDZ; set scf_type pk; frequencies('scf'). Alternatively, it’s also possible for PSI4 to use Cartesian coordinate; input. Here, the Cartesian coordinates of the optimized geometry can be; extracted from the bottom of the optimization output. The input; would then look like this:; molecule h2o {; O 0.0000000000 -0.0000000000 -0.1224239500; H 0.0000000000 -1.4147069876 0.9714784639; H -0.0000000000 1.4147069876 0.9714784639; }. set basis cc-pVDZ; frequencies('scf'). If either of the inputs above are run, the program should do some; computations and then finally report the following harmonic vibrational; frequencies (roundoff errors of around 0.1 cm-1 may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1776.1735; A1 4113.8031; B2 4211.7879; ----------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:6281,optimiz,optimized,6281,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,2,['optimiz'],['optimized']
Performance,"--; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis aug-cc-pvdz. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT is only available for computation of interactions between; closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module.; As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.0000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:9673,perform,performed,9673,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['perform'],['performed']
Performance,"-12$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. \(\mbox{ODC-13$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE RHF is only available for; ALGORITHM SIMULTANEOUS. To compute \((\lambda_3)\) correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dcft-1.html:14142,perform,perform,14142,psi4manual/1.1.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dcft-1.html,12,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]; def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:2085,optimiz,optimize,2085,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,1,['optimiz'],['optimize']
Performance,"-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; from __future__ import absolute_import; import re; import os; import math; import warnings; import pickle; import copy; import collections; import p4const; from driver import *; # never import aliases into this file. #########################; ## Start of Database ##; #########################. DB_RGT = {}; DB_RXN = {}. [docs]def database(name, db_name, **kwargs):; r""""""Function to access the molecule objects and reference energies of; popular chemical databases. :aliases: db(). :returns: (*float*) Mean absolute deviation of the database in kcal/mol. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`db_name DATABASE MEAN SIGNED DEVIATION <db_nameDATABASEMEANSIGNEDDEVIATION>`; * :psivar:`db_name DATABASE MEAN ABSOLUTE DEVIATION <db_nameDATABASEMEANABSOLUTEDEVIATION>`; * :psivar:`db_name DATABASE ROOT-MEAN-SQUARE DEVIATION <db_nameDATABASEROOT-MEAN-SQUARESIGNEDDEVIATION>`; * Python dictionaries of results accessible as ``DB_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html:1256,optimiz,optimize,1256,psi4manual/1.0.0/_modules/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_database.html,1,['optimiz'],['optimize']
Performance,"-38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~),",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:6728,optimiz,optimizing,6728,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,11,['optimiz'],['optimizing']
Performance,"-6. SS_R_CONVERGENCE¶. Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG¶. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT¶. SS vectors stored per root. Type: integer; Default: 5. T3_WS_INCORE¶. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. VECS_CC3¶. Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT¶. Vectors stored per root. Type: integer; Default: 12. Expert¶. EXCITATION_RANGE¶. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. WFN¶. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. table of contents. CCEOM; General; ABCD; CACHELEVEL; CACHETYPE; CC3_FOLLOW_ROOT; CC_NUM_THREADS; COLLAPSE_WITH_LAST; COMPLEX_TOLERANCE; EOM_GUESS; EOM_REFERENCE; E_CONVERGENCE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_GHOST; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; R_CONVERGENCE; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT. Expert; EXCITATION_RANGE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cceom-1.html:6784,CACHE,CACHELEVEL,6784,psi4manual/1.3.2/autodir_options_c/module__cceom-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cceom-1.html,4,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"-= 1 # A1 irrep is externally 1, internally 0; if dertype == 2:; core.print_out(""""""hessian() switching to finite difference by gradients for partial Hessian calculation.\n""""""); dertype = 1. # At stationary point?; if 'ref_gradient' in kwargs:; core.print_out(""""""hessian() using ref_gradient to assess stationary point.\n""""""); G0 = kwargs['ref_gradient']; else:; G0 = gradient(lowername, molecule=molecule, **kwargs); translations_projection_sound, rotations_projection_sound = _energy_is_invariant(G0); core.print_out('\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'.; format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). elif dertype == 1:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = core.fd_geoms_freq_1(moleculeclone, irrep); moleculeclone.reinterpret_coordentry(False); moleculeclone.fix_orientation(True). # Record undisplaced symmetry for projection of displaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:70682,perform,perform,70682,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,"-> NCH interconversion at the RHF/DZP level of theory. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. aediis-1; ADIIS test case, from 10.1063/1.3304922. scf-response2; Compute the dipole polarizability for water with custom basis set. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. cisd-sp; 6-31G** H2O Test CISD Energy Point. tdscf-7; TD-HF test variable access. mbis-2; MBIS calculation on OH- (Expanded Arrays). sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. mints3; Test individual integral objects for correctness. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. pubchem2; Superficial test of PubChem interface. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. matrix2; An exampl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:5939,Optimiz,Optimize,5939,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['Optimiz'],['Optimize']
Performance,"-> None :. docstring; C++ signature :. void gemm(N3psi6MatrixE {lvalue},b,b,d,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,d). psi4.Matrix.get()¶; Python Library Documentation: method get; get(...) unbound psi4.Matrix method. get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :. docstring; C++ signature :. d get(N3psi6MatrixE {lvalue},i,i [,i]). psi4.Matrix.identity()¶; Python Library Documentation: method identity; identity(...) unbound psi4.Matrix method. identity( (Matrix)arg1) -> None :. docstring; C++ signature :. void identity(N3psi6MatrixE {lvalue}). psi4.Matrix.invert()¶; Python Library Documentation: method invert; invert(...) unbound psi4.Matrix method. invert( (Matrix)arg1) -> None :. docstring; C++ signature :. void invert(N3psi6MatrixE {lvalue}). psi4.Matrix.load()¶; Python Library Documentation: method load; load(...) unbound psi4.Matrix method. load( (Matrix)arg1, (str)arg2) -> None :. docstring; C++ signature :. void load(N3psi6MatrixE {lvalue},Ss). psi4.Matrix.load_mpqc()¶; Python Library Documentation: method load_mpqc; load_mpqc(...) unbound psi4.Matrix method. load_mpqc( (Matrix)arg1, (str)arg2) -> None :. docstring; C++ signature :. void load_mpqc(N3psi6MatrixE {lvalue},Ss). psi4.Matrix.name()¶; Python Library Documentation: method name; name(...) unbound psi4.Matrix method. name( (Matrix)arg1) -> str :. docstring; C++ signature :. Ss name(N3psi6MatrixE {lvalue}). psi4.Matrix.nirrep()¶; Python Library Documentation: method nirrep; nirrep(...) unbound psi4.Matrix method. nirrep( (Matrix)arg1) -> int :. docstring; C++ signature :. i nirrep(N3psi6MatrixE {lvalue}). psi4.Matrix.np()¶; Python Library Documentation: property. psi4.Matrix.partial_cholesky_factorize()¶; Python Library Documentation: method partial_cholesky_factorize; partial_cholesky_factorize(...) unbound psi4.Matrix method. partial_cholesky_factorize( (Matrix)arg1, (float)arg2, (bool)arg3) -> Matrix :. docstring; C++ signature :. N5boost10shared",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:208975,load,load,208975,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['load'],['load']
Performance,"-B1.cube, and Psi_a_6_4-A1.cube. The subscript a in; Psi_a_5_1-B1.cube indicates an alpha orbital. The first number (5) is the index of the; orbital while 1-B1 indicates that this is the first orbital that belongs to the B1 irrep.; The file Psi_a_5_1-B1.cube begins with two comment lines:; 1; 2Psi4 Gaussian Cube File.; Property: Psi_a_5_1-B1. Isocontour range for 85% of the density: (0.0787495,-0.0787495). The second line reports the isocontour values that capture 85% of the probability density using; the least amount of grid points. This quantity is determined for orbitals and densities. The; fraction of the density captured by the isocontour values is by default 0.85, but can; be changed via the option CUBEPROP_ISOCONTOUR_THRESHOLD. Note; If your cube plots are too coarse, try to decrease the grid spacing via; the option CUBIC_GRID_SPACING. If the edges of your plot are cut then; increase the size of the grid via the option CUBIC_GRID_OVERAGE. Cubeprop Tasks¶; The cubeprop utility can be provided a list of tasks to perform.; Tasks are specified by the CUBEPROP_TASKS option, which is a list of strings; that identify the tasks. Several tasks are available. These include:. ORBITALS [Default if CUBEPROP_TASKS is not specified]; Produces cube representations of the molecular orbitals; \(\psi_q(\mathbf{r})\). Orbitals are sorted according to increasing; orbital energy ignoring symmetry.; FRONTIER_ORBITALS; Produces cube representations of the frontier molecular orbitals. For closed shell; species, the highest occupied (HOMO) and the lowest unoccupied (LUMO) alpha orbitals (ie.; \(\psi_{\alpha}(\mathbf{r})\)) are printed, while for open shell species a total; of \((4 + M_s)\) orbitals are printed (\(\alpha\) and \(\beta\); spin for both lowest virtual (LVMO) and highest doubly occupied; orbitals (DOMO), along with all \(\alpha\) singly occupied (SOMO) orbitals).; DENSITY; This task can be used to obtain the alpha and beta electron densities,; \(\rho_\alpha(\mathbf{r})\) ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cubeprop-1.html:3321,perform,perform,3321,psi4manual/1.3.2/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cubeprop-1.html,2,['perform'],['perform']
Performance,"-Body: Complex Energy (fragments = (1,), basis = (1, 2): -128.70932405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table; of the different R values and the CP-corrected CCSD(T) energies,; converted from atomic units (Hartree) to kcal mol\(^{-1}\) by; multiplying by the automatically-defined conversion factor; psi4.constants.hartree2kcalmol. Psi4 provides several built-in; physical constants and conversion factors, as described in the Psi4; manual section Physical; Constants.; The table can be printed either to the screen, by using standard Python; ``print()`; syntax <https://docs.python.org/3/whatsnew/3.0.html#print-is-a-function>`__,; or to the designated output file output.dat using Psi4’s built-in; function psi4.core.print_out(); API; (C style printing).; As we’ve seen so far, the combination of Psi4 and Python creates a; unique, interactive approach to quantum chemistry. The next section will; explore this synergistic relationship in greater detail, describing how; even very complex tasks can be done very easily with Psi4. In [ ]:. table of contents. PsiAPI Tutorial: Using Psi4 as a Python Module; I. Basic Input Structure; II. Running a Basic Hartree-Fock Calculation; III. Geometry Optimization and Vibrational Frequency Analysis; IV. Analysis of Intermolecular Interactions; V. Potential Surface Scans and Counterpoise Correction Made Easy. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. A PSI4 Tutorial. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:23667,Optimiz,Optimization,23667,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,2,['Optimiz'],['Optimization']
Performance,"-CCSD/DZ on the lowest two states of each irrep in CH2. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. min_input; This checks that all energy methods can run with a minimal input and set symmetry. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. scf6; Tests RHF/ROHF/UHF SCF gradients. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DCFT-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DCFT-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. fci-h2o; 6-31G H2O Test FCI Energy Point. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:1249,perform,performs,1249,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['perform'],['performs']
Performance,"-Correlation Functional. x1b95; X1B95 Hyb-GGA Exchange-Correlation Functional. x3lyp; X3LYP Hyb-GGA Exchange-Correlation Functional. x3lyp-d3bj. xb1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:12775,optimiz,optimization,12775,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,30,['optimiz'],"['optimization', 'optimize']"
Performance,"-D3 [4] w/ original zero-damping through dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\alpha_6\)]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]. -D3M; alias to -D3MZERO;  . -D3MZERO; -D3 [6] w/ reparameterized and more flexible original zero-damping through dftd3; [\(s_6\), \(s_8\), \(s_{r,6}\), \(\beta\)]. -D3MBJ; -D3 [6] w/ reparameterized newer Becke-Johnson rational damping through dftd3; [\(s_6\), \(s_8\), \(a_1\), \(a_2\)]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, have nothing to do with this table. [2][Grimme:2004:1463]. [3](1, 2) [Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. [6](1, 2) [Smith:2016:2197]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); 1energy('bp86-d'). DFT-D3BJ optimization with default parameters; 1optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; 1; 2set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); 1; 2set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; 1; 2; 3; 4; 5; 6molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14>>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dftd3-1.html:6669,optimiz,optimization,6669,psi4manual/1.1.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dftd3-1.html,4,['optimiz'],['optimization']
Performance,"-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE¶. Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG¶. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT¶. SS vectors stored per root. Type: integer; Default: 5. T3_WS_INCORE¶. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. VECS_CC3¶. Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT¶. Vectors stored per root. Type: integer; Default: 12. Expert¶. EXCITATION_RANGE¶. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. WFN¶. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. table of contents. CCEOM; General; ABCD; CACHELEVEL; CACHETYPE; CC3_FOLLOW_ROOT; CC_NUM_THREADS; COLLAPSE_WITH_LAST; COMPLEX_TOLERANCE; EOM_GUESS; EOM_REFERENCE; E_CONVERGENCE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_GHOST; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; R_CONVERGENCE; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT. Expert; EXCITATION_RANGE; WFN. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cceom-1.html:6784,CACHE,CACHELEVEL,6784,psi4manual/1.1.0/autodir_options_c/module__cceom-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cceom-1.html,4,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"-MP2 cc-pVDZ gradient for the NO molecule. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. scf-guess-read2; Test if the the guess read in the same basis converges. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mbis-1; MBIS calculation on H2O. phi-ao; Test computing values of basis functions (puream and non-puream) at points. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. sapt-sf1; Tests the Psi4 SF-SAPT code. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. opt11; Transition-state optimizations of HOOH to both torsional transition states. dft-dsd; DSD S22 Ammonia test. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. pywrap-molecule; Check that C++ Molecule cl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:19465,perform,performed,19465,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dft-grad-lr3; wB97X-D test for a large UKS molecule. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. pywrap-db2; Database calculation, run in sow/reap mode. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:10641,perform,performed,10641,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dft-grad-lr3; wB97X-D test for a large UKS molecule. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. pywrap-db2; Database calculation, run in sow/reap mode. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. sapt-ecp; sapt0 of charged system in ECP basis set. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfcasscf-fzc-sp; CASSCF/6-31G** energy point.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:11331,perform,performed,11331,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"-ccsd_t_; single-point CCSD(T)/qz2p. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html:2932,optimiz,optimization,2932,psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,2,['optimiz'],['optimization']
Performance,"-channel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.8 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4. Uninstall PSI4 from current environment. >>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 --channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. >>> conda install psi4 python=3.8 -c psi4/label/dev. Update to latest PSI4 nightly build. >>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4/label/dev. table of contents. Conda Binary Distribution; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of PSI4; Useful Commands. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Installation and Runtime Configuration; Conda Binary Distribution. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/conda.html:18254,load,loaded,18254,psi4manual/master/conda.html,https://psicode.org,https://psicode.org/psi4manual/master/conda.html,1,['load'],['loaded']
Performance,"-channel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.8 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4. Uninstall PSI4 from current environment. >>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 --channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. >>> conda install psi4 python=3.8 -c psi4/label/dev. Update to latest PSI4 nightly build. >>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4/label/dev. table of contents. Conda Binary Distribution; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of PSI4; Useful Commands. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Installation and Runtime Configuration; Conda Binary Distribution. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/conda-1.html:17760,load,loaded,17760,psi4manual/1.4.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/conda-1.html,2,['load'],['loaded']
Performance,"-channel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.8 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4. Uninstall PSI4 from current environment. >>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 --channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. >>> conda install psi4 python=3.8 -c psi4/label/dev. Update to latest PSI4 nightly build. >>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4/label/dev. table of contents. Conda Binary Distribution; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of PSI4; Useful Commands. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Installation and Runtime Configuration; Conda Binary Distribution. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/conda-1.html:17760,load,loaded,17760,psi4manual/1.5.0/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/conda-1.html,2,['load'],['loaded']
Performance,"-channel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.8 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4. Uninstall PSI4 from current environment. >>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 --channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. >>> conda install psi4 python=3.8 -c psi4/label/dev. Update to latest PSI4 nightly build. >>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4/label/dev. table of contents. Conda Binary Distribution; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of PSI4; Useful Commands. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Installation and Runtime Configuration; Conda Binary Distribution. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/conda.html:17751,load,loaded,17751,psi4manual/1.6.x/conda.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/conda.html,1,['load'],['loaded']
Performance,"-channel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.8 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4. Uninstall PSI4 from current environment. >>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 --channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. >>> conda install psi4 python=3.8 -c psi4/label/dev. Update to latest PSI4 nightly build. >>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4/label/dev. table of contents. Conda Binary Distribution; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of PSI4; Useful Commands. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Installation and Runtime Configuration; Conda Binary Distribution. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/conda.html:17961,load,loaded,17961,psi4manual/1.7.x/conda.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/conda.html,1,['load'],['loaded']
Performance,"-channel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.8 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4. Uninstall PSI4 from current environment. >>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 --channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. >>> conda install psi4 python=3.8 -c psi4/label/dev. Update to latest PSI4 nightly build. >>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4/label/dev. table of contents. Conda Binary Distribution; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of PSI4; Useful Commands. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Installation and Runtime Configuration; Conda Binary Distribution. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/conda.html:18247,load,loaded,18247,psi4manual/1.8.x/conda.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/conda.html,1,['load'],['loaded']
Performance,"-channel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.8 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4. Uninstall PSI4 from current environment. >>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 --channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. >>> conda install psi4 python=3.8 -c psi4/label/dev. Update to latest PSI4 nightly build. >>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=1.4 -c psi4/label/dev. table of contents. Conda Binary Distribution; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of PSI4; Useful Commands. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Installation and Runtime Configuration; Conda Binary Distribution. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/conda.html:18247,load,loaded,18247,psi4manual/1.9.x/conda.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/conda.html,1,['load'],['loaded']
Performance,"-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/sp-rhf-scf; single-point HF/qz2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html:3240,optimiz,optimization,3240,psi4manual/1.7.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"-fragment opt of C2h methane dimer with user-combined reference points. casscf-sp; CASSCF/6-31G** energy point. mbis-3; MBIS calculation on OH radical. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ao-casscf-sp; CASSCF/6-31G** energy point. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. fnocc6; Test method/basis with disk_df. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cepa1; cc-pvdz H2O Test CEPA(1) Energy. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. ao-dfcasscf-sp; CASSCF/6-31G** energy poin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:39307,optimiz,optimization,39307,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). casscf-sp; CASSCF/6-31G** energy point. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. pywrap-cbs1; Various basis set extrapolation tests. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. psimrcc-fd-freq2; Mk-MRCCSD frequencies. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. mp2-1; All-electron MP2 6-31G** geometry optimization of water. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt11; Transition-state optimizations of HOOH to both torsional transition states. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. pywrap-opt-sowreap; F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:27289,optimiz,optimization,27289,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-custom; DFT custom functional test. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dft-grad-meta; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:25002,perform,performed,25002,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-custom; DFT custom functional test. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dft-grad-meta; meta-GGA gradients of water and ssh molecules. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:25971,perform,performed,25971,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"-pVDZ energy for the NO molecule. fnocc5; Test FNO-DF-CCSD(T) energy. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cc12; Single point energies of multiple excited states with EOM-CCSD. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. opt-multi-frozen-dimer-c2h; Frozen-fragment opt of C2h methane dimer with user-combined reference points. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. mp2-h; check that methods can act on single atom. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-dip",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:18008,optimiz,optimization,18008,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. soscf-large; Second-order SCF convergnece: Benzene. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc12; Single point energies of multiple excited states with EOM-CCSD. dft2; DFT Functional Test. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:31114,perform,performs,31114,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"-pVDZ static polarizability of HOF. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-cbs1; Various basis set extrapolation tests. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. dcft5; DCFT-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. opt2; SCF DZ allene geometry optimzation, with Cartesian input. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc54; CCSD dipole with user-specified basis set. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/testsuite-1.html:9911,optimiz,optimization,9911,psi4manual/4.0b3/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ; assign C 3-21G; assign H1 sto-3g; assign C1 sto-3g; }. The first line in this block assigns the DZ basis set to all atoms. The next; line then assigns 3-21G to all carbon atoms, leaving the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:16196,perform,performed,16196,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,4,['perform'],['performed']
Performance,"-particle energy; correction . Methods Summary¶; The table below summarizes current DCFT code features:. Method; Available algorithms; Energy; Gradient; Reference. ODC-06; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-12; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-13; SIMULTANEOUS, QC; Y; Y; UHF. SIMULTANEOUS, QC; Y; N; UHF. SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE = RHF is only available for; ALGORITHM = SIMULTANEOUS. To compute correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS = DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS = DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:12923,perform,perform,12923,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['perform'],['perform']
Performance,"-point CC3/qz2p on NH2. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html:1282,optimiz,optimization,1282,psi4manual/1.9.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"-point CCSD/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using autom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_cfour-1.html:1948,optimiz,optimization,1948,psi4manual/1.1.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_cfour-1.html,6,['optimiz'],['optimization']
Performance,"-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are feezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:57711,Optimiz,Optimize,57711,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Optimiz'],['Optimize']
Performance,"-scaling F-SAPT data within input file directory. Type: string; Default: s-fsapt/. FISAPT_LINK_ASSIGNMENT (FISAPT)¶FISAPT — Where do sigma links go (to C or to AB)?. Type: string; Possible Values: C, AB; Default: C. FISAPT_LINK_SELECTION (FISAPT)¶FISAPT — Specification algorithm for link bonds in ISAPT. Type: string; Possible Values: AUTOMATIC, MANUAL; Default: AUTOMATIC. FISAPT_MANUAL_LINKS (FISAPT)¶FISAPT — Manual link bond specification [[Atom1, Atom2], …]. Type: array; Default: No Default. FISAPT_MEM_SAFETY_FACTOR (FISAPT)¶FISAPT (Expert) — Memory safety factor for heavy FISAPT operations. Type: double; Default: 0.9. FISAPT_PLOT_FILEPATH (FISAPT)¶FISAPT — Filepath to drop scalar data within input file directory. Type: string; Default: plot/. FIXED_BEND (OPTKING)¶OPTKING — Specify angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_COORD_FORCE_CONSTANT (OPTKING)¶OPTKING — In constrained optimizations, for coordinates with user-specified equilibrium values, this is the initial force constant (in au) used to apply an additional force to each coordinate. Type: double; Default: 0.5. FIXED_DIHEDRAL (OPTKING)¶OPTKING — Specify dihedral angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DISTANCE (OPTKING)¶OPTKING — Specify distances between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FLEXIBLE_G_CONVERGENCE (OPTKING)¶OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOLLOW_ROOT (DETCI)¶DETCI — The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 0. FOLLOW_ROOT (MCSCF)¶MCSCF — Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FOLLOW_ROOT (PSIMRCC)¶PSIMRC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:129531,optimiz,optimizations,129531,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['optimiz'],['optimizations']
Performance,"-scenes function or if you don’t want the bother of dealing with reStructuredText, just write an ordinary docstring. It will get slurped into the documentation in plain text. Your python function should follow PEP8 conventions (without the line-length restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case (make tests, NOT make longtests) from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap_ is suggested. Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the ‘current energy’ variable. This last is needed to communicate with the optimizer.; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25). Once your python function is fairly stable on its own, it’s potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/bestpractices_py-1.html:4333,optimiz,optimizer,4333,psi4manual/4.0b4/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/bestpractices_py-1.html,6,['optimiz'],['optimizer']
Performance,"-scenes function or if you don’t want the bother of dealing with reStructuredText, just write an ordinary docstring. It will get slurped into the documentation in plain text. Your python function should follow PEP8 conventions (without the line-length restriction). I’m aiming for files to pass the line below, unless for good reason. The second line is for database Python files.; >>> pep8.py -r --ignore=E501 pythonfile.py; >>> pep8.py -r --ignore=E501,E221,E222,E241,E201,E202 databasefile.py. Your python function should not prevent any test case (make tests, NOT make longtests) from passing. A test case(s) should be written and checked in for any major python function, so that others do not break your code. If most of your work was on the python (as opposed to c++) side, the test case prefix pywrap_ is suggested. Be sure to set any new PSI variables through lines like those below. Especially if the function returns an energy, set the ‘current energy’ variable. This last is needed to communicate with the optimizer.; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25); psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25). Once your python function is fairly stable on its own, it’s potential for interoperability with energy()/opt()/cp()/db()/cbs()/etc. should be evaluated. If it makes physical sense that it should work, you should strive to make that interoperability a reality. Some steps:. If any interoperability is possible, define an argument xx_func, where xx is a short name for your function. Add near the top of your function code like the below (less the final two lines). The net result of this code is that if the user specifies no *_func arguments, then energy() gets called. If the user defines xx_func, then its value gets called. If the user defines func, then its value gets reassigned to xx_func, func itself is deleted, and xx_func() gets called. Whatever is getting called is stored in func within the function.; # Estab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/bestpractices_py-1.html:4331,optimiz,optimizer,4331,psi4manual/4.0b5/bestpractices_py-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/bestpractices_py-1.html,2,['optimiz'],['optimizer']
Performance,"-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Exa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:17416,perform,perform,17416,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,4,['perform'],['perform']
Performance,"-scf; single-point HF/qz2p on NH2. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Test Suite and Sample Inputs; CFOUR. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html:4677,optimiz,optimization,4677,psi4manual/1.8.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-1; testing best practices options, part i. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html:2766,optimiz,optimization,2766,psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,2,['optimiz'],['optimization']
Performance,". (Default: OFF). Type: string; Possible Values: OFF, CARTESIAN, INTERNAL, QUADRATURE; Default: OFF. CFOUR_GUESS (CFOUR)¶CFOUR — Where the initial SCF eigenvectors are read from. MOREAD means to read from the disk (the JOBARC file) and CORE means to use a core Hamiltonian initial guess. If MOREAD is chosen but no disk file is present, the core Hamiltonian is used. (Default: MOREAD). Type: string; Possible Values: MOREAD, CORE; Default: MOREAD. CFOUR_HBAR (CFOUR)¶CFOUR — This keyword determines which action is taken by the linear response program. ON (=1) the full effective Hamiltonian is calculated and written to disk; OFF (=0) the “lambda” linear response equations are solved. Type: boolean; Default: false. CFOUR_HFSTABILITY (CFOUR)¶CFOUR — Control analysis of the stability of RHF, ROHF and UHF wavefunctions, as well as a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC), after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE (CFOUR)¶CFOUR — This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the \(\langle ab\vert\vert cd\rangle\) molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the \(\langle ab\vert\vert cd\rangle\) and \(\langle ab\vert\vert ci\rangle\) integrals are held in core; (=5) \(\langle ij\vert\vert kl\rangle\) and",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:51173,perform,performs,51173,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,9,['perform'],['performs']
Performance,". (OCC). OCC_PERCENTAGE (FNOCC). OCC_TOLERANCE (FNOCC). (SAPT). OCEPA(0)CORRELATIONENERGY. OCEPA(0)TOTALENERGY. ODC_GUESS (DCFT). OEProp. theory. OEPROP (DFOCC). (OCC). oeprop() in module p4util. in module p4util.util. oeprop_validator() in module procedures.proc_util. OFFDIAGONAL_CCSD_T (PSIMRCC). OLCCD; . setting keywords. theory. OMEGA (CCRESPONSE). (CCSORT). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8], [9]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). OPDM_AVG (DETCI). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (DFMP2). operate() SymmetryOperation method. SymRep method. opt(); . see optimize(); . OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). optimize(); . setting keywords. optimize() in module driver. OptionsState class in p4util.optproc. OptionState class in p4util.optproc. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orca_gradient_list() in module qcdb.orca. orca_list() in module qcdb.orca. order() CharacterTable method. IrreducibleRepresentation method. OrderedDict class in qcdb.oldpymodules. orientation_fixed() LibmintsMolecule method. OrientMols class in qcdb.orient. origin() PointGroup method. original_coef() ShellInfo method. original_coefs() ShellInfo method. ORTH_TYPE (DFOCC). (OCC). oss WrappedDatabase attribute. output; . SAPT. cbs(). database(). geometry optimization. vibrational analysis. OVERLAP_CHECK (CCEOM). oxcom() i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:54583,optimiz,optimize,54583,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['optimiz'],['optimize']
Performance,". -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options() API, to the input. This function takes a Python dictionary as its argument, which is a key-value list which associates a Psi4 keyword with its user-defined value. For open shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree-Fock, or UHF) or restricted orbitals (restricted open-shell Hartree-Fock, or ROHF). Usually, UHF is a little easier to converge (although it may be more susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:6638,optimiz,optimize,6638,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,11,['optimiz'],['optimize']
Performance,". :aliases: frequencies(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:82975,perform,performed,82975,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,7,['perform'],['performed']
Performance,". :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +---------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:49317,perform,perform,49317,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,". ; setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRONENERGY. one_electron_integrals() psi4.core.MintsHelper method, [1], [2]. OneBodyAOInt class in psi4.core, [1]. onel_Hx() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. option_exists_in_module() in module psi4.core, [1]. Options class in psi4.core, [1]. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orbital_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. OrbitalSpace class in psi4.core, [1]. order() psi4.core.CharacterTable method, [1], [2]. psi4.core.PointGroup method, [1], [2]. ordered_params psi4.driver.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. orientation_fixed() psi4.core.Molecule method, [1], [2]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:102239,Optimiz,OptimizationConvergenceError,102239,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['Optimiz'],['OptimizationConvergenceError']
Performance,". >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('conv-mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('conv-mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('conv-mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations required.; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:7592,perform,performed,7592,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,2,['perform'],['performed']
Performance,". Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Algebraic-Diagrammatic Construction methods (ADC)¶; General ADC theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid development of; algebraic-diagrammatic construction methods,”; M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.; WIREs Comput. Mol. Sci., (2020).; (DOI: 10.1002/wcms.1462, Preprint https://adc-connect.org/q/publications. Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:19877,Optimiz,Optimized,19877,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,4,['Optimiz'],['Optimized']
Performance,". Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Algebraic-Diagrammatic Construction methods (ADC)¶; General ADC theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Implementation inside adcc,; the ADC backend used for most ADC methods available in PSI4. “adcc: A versatile toolkit for rapid development of; algebraic-diagrammatic construction methods,”; M. F. Herbst, M. Scheurer, T. Fransson, D. R. Rehn, and A. Dreuw.; WIREs Comput. Mol. Sci., (2020).; (DOI: 10.1002/wcms.1462, Preprint https://adc-connect.org/q/publications. “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:19428,Optimiz,Optimized,19428,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,5,['Optimiz'],['Optimized']
Performance,". Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:16348,Optimiz,Optimized,16348,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,6,['Optimiz'],['Optimized']
Performance,". Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; Second-Order Perturbation Theory with Density-Fitting Approximation: An; Efficient Implementation,” U. Bozkaya, J. Chem. Theory Comput. 10, 4389 (2014).; (doi: 10.1021/ct500634s). Density-Fitted and Cholesky-Decomposed Orbital-optimized MP3 and MP2.5 (DF-OMP3 and DF-OMP2.5). “Orbital-Optimized MP3 and MP2.5 with Density-Fitting; and Cholesky Decomposition Approximations,”; U. Bozkaya, J. Chem. Theory Comput. 12, 1179 (2016).; (doi: 10.1021/acs.jctc.5b01128). Density-Fitted and Cholesky-Decomposed Orbital-Optimized Linearized Coupled-Cluster Doubles Method (DF-OLCCD). “Orbital-optimized linearized coupled-cluster doubles with density-fitting; and Cholesky decomposition approximations: an efficient implementation,”; U. Bozkaya, Phys. Chem. Chem. Phys. 18, 11362 (2016).; (doi: 10.1039/c6cp00164e). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in Psi4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Density Matrix Renormalization Group (DMRG)¶. “CheMPS2: a free open-s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:14044,Optimiz,Optimized,14044,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,2,['Optimiz'],['Optimized']
Performance,". CACHELEVEL (CCSORT); CCSORT —. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 —. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 —. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM —. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (MP2); MP2 — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CAS_FILES_WRITE (CLAG); CLAG — Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. CC (DETCI); DETCI — Do coupled-cluster computation?. Type: boolean; Default: false. CC3_FOLLOW_ROOT (CCEOM); CCEOM — Do ?. Type: boolean; Default: false. CC_A_RAS3_MAX (DETCI); DETCI — maximum number of alpha electrons in RAS III, for CC. Type: integer; Default: -1. CC_B_RAS3_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:7534,CACHE,CACHETYPE,7534,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,4,"['CACHE', 'cache']","['CACHETYPE', 'cached']"
Performance,". CC_DIIS_MIN_VECS¶. Minimum number of vectors used in amplitude DIIS. Type: integer; Default: 2. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CEPA_OS_SCALE¶. CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE¶. CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE¶. CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__occ-1.html:1976,perform,perform,1976,psi4manual/1.0.0/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__occ-1.html,24,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,". Chem. Phys. 112, 9213 (2000). ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. cc51; EOM-CC3/cc-pVTZ on H2O. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. opt11; Transition-state optimizations of HOOH to both torsional transition states. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. scf-occ; force occupations in scf. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. scf6; Tests RHF/ROHF/UHF SCF gradients. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. linK-3; UHF and ROHF Linear Exchange Algorithm test for benzyl cation. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dft-freq-analytic; Analytic SVWN frequencies, com",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:39025,Optimiz,Optimize,39025,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['Optimiz'],['Optimize']
Performance,". DIIS_MAX_VECS (OCC)¶OCC — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MAX_VECS (PSIMRCC)¶PSIMRCC — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (SCF)¶SCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS (DCT)¶DCT (Expert) — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 3. DIIS_MIN_VECS (DETCI)¶DETCI — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_MIN_VECS (OCC)¶OCC — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_MIN_VECS (SCF)¶SCF — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_RMS_ERROR (SCF)¶SCF — Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. DIIS_START (PSIMRCC)¶PSIMRCC — The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. DIIS_START (SCF)¶SCF — The minimum iteration to start storing DIIS vectors. Type: integer; Default: 1. DIIS_START_CONVERGENCE (DCT)¶DCT — Value of RMS of the density cumulant residual and SCF error vector below which DIIS extrapolation starts. Same keyword controls the DIIS extrapolation for the solution of the response equations. Type: conv double; Default: 1e-3. DIIS_START_ITER (DETCI)¶DETCI — Iteration at which to start using DIIS. Type: integer; Default: 1. DIPMOM (DETCI)¶DETCI — Do compute the dipole moment?. Type: boolean; Default: false. DIPMOM (FNOCC)¶FNOCC — Compute the dipole moment? Note that dipole moments are only available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods. Type: boolean; Default: false. DISP_SIZE (FINDIF)¶FINDIF — Displacement size in au for finite-differences. Type: double; Default: 0.005. DISTRIBUTED_MATRIX (SCF)¶SCF (Expert) — The dimension sizes of the distri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:108939,perform,performed,108939,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,4,['perform'],['performed']
Performance,". Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:7732,cache,cache,7732,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,12,['cache'],['cache']
Performance,". Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. Type: conv double; Default: 1e-8. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. MAXITER¶. Maximum number of CPHF iterations",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__sapt-1.html:2017,perform,perform,2017,psi4manual/1.1.0/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__sapt-1.html,4,['perform'],['perform']
Performance,". Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. Type: conv double; Default: 1e-8. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. MAXITER¶. Maxi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__sapt-1.html:2020,perform,perform,2020,psi4manual/1.3.2/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__sapt-1.html,6,['perform'],['perform']
Performance,". Do print spin-adapted pair energies?. Type: boolean; Default: false. T2_COUPLED¶. Do ?. Type: boolean; Default: false. T3_WS_INCORE¶. Do ?. Type: boolean; Default: false. Expert¶. AO_BASIS¶. The algorithm to use for the terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. FORCE_RESTART¶. Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Possible Values: CCSD, CCSD_T, EOM_CCSD, LEOM_CCSD, BCCD, BCCD_T, CC2, CC3, EOM_CC2, EOM_CC3, CCSD_MVD; Default: NONE. Table Of Contents. CCENERGY; General; ABCD; ANALYZE; BRUECKNER_ORBS_R_CONVERGENCE; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC_OS_SCALE; CC_SS_SCALE; DIIS; LOCAL; LOCAL_CUTOFF; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; MP2_AMPS_PRINT; MP2_OS_SCALE; MP2_SS_SCALE; NEW_TRIPLES; NUM_AMPS_PRINT; PAIR_ENERGIES_PRINT; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SCSN_MP2; SCS_CCSD; SCS_MP2; SEMICANONICAL; SPINADAPT_ENERGIES; T2_COUPLED; T3_WS_INCORE. Expert; AO_BASIS; FORCE_RESTART; WFN. Previous topic; ZETA; Next topic; ABCD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html:5712,CACHE,CACHELEVEL,5712,psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html,4,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,". During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; \(C_{2v}\) water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3, 0, 1, 1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Broken Symmetry¶; For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to differ in closed-shell computations can be advantageous;; this is known as symmetry breaking. The resulting unrestricted wavefunction; will often provide superior energetics, due to the increased flexibility,; but it will suffer non-physical spin contamination from higher multiplicity states.; A convenient approach to break symmetry is to perform a UHF or UKS calculation; with the guess HOMO and LUMO orbitals mixed.; Mixing of the guess orbitals can be requested by setting the GUESS_MIX; keyword to true:; set reference uhf; set guess_mix true; energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital; basis (known as the AO basis). The Molecular Orbital basis (MO basis); is then built as a particular unitary transformation of the OSO; basis. In PSI4, the determination of the OSO basis is; accomplished via either symmetric, canonical, or partial Cholesky; orthogonalization.; Symmetric orthogonalization uses the symmetric inverse square root of; the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and; thereby MOs) as AO functions. However, this may lead to numerical; problems if the overlap matrix has small eigenvalues, which may occur; for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:11118,perform,perform,11118,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,9,['perform'],['perform']
Performance,". For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with . If set to a value , performs scaling with . Type: string; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT modu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:10667,perform,performs,10667,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['performs']
Performance,. For DFT orbitals one should use “reference uks” and “dft_functional b3lyp” options. Of; course users can use any DFT functional available in Psi4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; Psi4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through ‘type select’ values; see rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. omp2.5; Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. olccd; Orbital-Optimized Linear CCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE CONV. Density-Fitted Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE DF. Cholesky-Decomposed Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; —; CC_TYPE CD. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimi,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:7025,Optimiz,Optimized,7025,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['Optimiz'],['Optimized']
Performance,". For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; # all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; # setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory; usage of the major data structures, and actual total memory usage; is slightly",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:2396,perform,perform,2396,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,9,['perform'],['perform']
Performance,". For; some atoms, cc-pVDZ-JKFIT is not defined, so this procedure will fail. In these; cases, you will see an error message of the form:; RuntimeError: sanity check failed! Gaussian94BasisSetParser::parser:; Unable to find the basis set for HE. This failure can be fixed by either setting DF_BASIS_SCF to an auxiliary; basis set defined for all atoms in the system, or by setting DF_SCF_GUESS; to false, which disables this acceleration entirely. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2](1, 2) This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defined; according to the quantu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:21561,optimiz,optimization,21561,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,4,['optimiz'],['optimization']
Performance,". HTBH (module), [1]. I. ICORE (DETCI). IGNORE_TAU (DCFT). input (module). INTCO_FIXED_EQ_FORCE_CONSTANT (OPTKING). INTCOS_GENERATE_EXIT (OPTKING). INTERFRAG_DIST_INV (OPTKING). INTERFRAG_HESS (OPTKING). INTERFRAG_MODE (OPTKING). INTERFRAG_STEP_LIMIT (OPTKING). INTERNAL_ROTATIONS (MCSCF). INTRAFRAG_HESS (OPTKING). INTRAFRAG_STEP_LIMIT (OPTKING). INTRAFRAG_STEP_LIMIT_MAX (OPTKING). INTRAFRAG_STEP_LIMIT_MIN (OPTKING). INTS_TOLERANCE (CCDENSITY). (CCSORT). (DCFT). (DFMP2). (LMP2). (MRCC). (SAPT). (SCF). (TRANSQT). (TRANSQT2). ip_fitting() (in module frac). IRC; . geometry optimization. IRC_DIRECTION (OPTKING). IRC_STEP_SIZE (OPTKING). IRC_STOP (OPTKING). ISTOP (DETCI). IVO (TRANSQT). J. J_FILE (TRANSQT). JOBTYPE (CCLAMBDA). (MP2). JSCH (module), [1]. K. KEEP_INTCOS (OPTKING). KEEP_J (TRANSQT). KEEP_OEIFILE (CCSORT). KEEP_PRESORT (TRANSQT). KEEP_TEIFILE (CCSORT). keywords; . C-side, setting. cbs(), setting. cp(), setting. database(), setting. energy(), setting. molecule, setting. optimize(), setting. property(), setting. kwargs_lower() (in module procutil). L. LAG_IN_FILE (TRANSQT). LAGRAN_DOUBLE (TRANSQT). LAGRAN_HALVE (TRANSQT). LAMBDA_MAXITER (DCFT). LCC2(+LMP2)TOTALENERGY. LCCSD(+LMP2)TOTALENERGY. LEVEL_SHIFT (MCSCF). (OMP2). LINEAR (CCRESPONSE). LOCAL (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CIS). LOCAL_AMPS_PRINT_CUTOFF (CIS). LOCAL_CORE_CUTOFF (CCSORT). LOCAL_CPHF_CUTOFF (CCLAMBDA). (CCRESPONSE). (CCSORT). LOCAL_CUTOFF (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CIS). (LMP2). LOCAL_DO_SINGLES (CCEOM). LOCAL_DOMAIN_MAG (CCSORT). LOCAL_DOMAIN_POLAR (CCSORT). LOCAL_DOMAIN_SEP (CCSORT). LOCAL_FILTER_SINGLES (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). LOCAL_GHOST (CCEOM). (CIS). LOCAL_METHOD (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CIS). LOCAL_PAIRDEF (CCENERGY). (CCLAMBDA). (CCRESPONSE). (CCSORT). LOCAL_PRECONDITIONER (CCEOM). LOCAL_WEAKP (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). (CIS). LOCK_OCC (DCFT). L",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/genindex.html:15711,optimiz,optimize,15711,psi4manual/4.0b2/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/genindex.html,1,['optimiz'],['optimize']
Performance,". Here, note that none of capitalization, equals sign, or whitespace matter; for the keyword commands. Specifcation of strings and integers requires no; translation; booleans have extended freedom of; format; arrays must be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into Psi4 format. Note; Psi4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in Psi4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; Psi4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:6550,optimiz,optimizations,6550,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,6,['optimiz'],['optimizations']
Performance,". LOCAL_METHOD¶. Type: string; Default: WERNER. LOCAL_PAIRDEF¶. Type: string; Default: NONE. LOCAL_WEAKP¶. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. Table Of Contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. Previous topic; ZETA; Next topic; ABCD; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccresponse-1.html:2714,CACHE,CACHELEVEL,2714,psi4manual/4.0b2/autodir_options_c/module__ccresponse-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccresponse-1.html,2,['CACHE'],['CACHELEVEL']
Performance,". LOCAL_PAIRDEF¶. Definition of local pair domains. Type: string; Default: No Default. LOCAL_WEAKP¶. Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique available option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. PROP_ALL¶. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. RESTART¶. Do restart the coupled-cluster iterations from old \(\lambda_1\) and \(\lambda_2\) amplitudes?. Type: boolean; Default: false. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. JOBTYPE¶. Type of job being performed. Type: string; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCLAMBDA; General; ABCD; AO_BASIS; CACHELEVEL; DIIS; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; RESTART; ROOTS_PER_IRREP; R_CONVERGENCE; SEKINO; ZETA. Expert; JOBTYPE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__cclambda.html:3268,perform,performed,3268,psi4manual/1.8.x/autodir_options_c/module__cclambda.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__cclambda.html,2,"['CACHE', 'perform']","['CACHELEVEL', 'performed']"
Performance,". LOCAL_PAIRDEF¶. Definition of local pair domains. Type: string; Default: No Default. LOCAL_WEAKP¶. Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique available option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. PROP_ALL¶. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. RESTART¶. Do restart the coupled-cluster iterations from old \(\lambda_1\) and \(\lambda_2\) amplitudes?. Type: boolean; Default: false. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. JOBTYPE¶. Type of job being performed. Type: string; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCLAMBDA; General; ABCD; AO_BASIS; CACHELEVEL; DIIS; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; RESTART; ROOTS_PER_IRREP; R_CONVERGENCE; SEKINO; ZETA. Expert; JOBTYPE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CCLAMBDA. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__cclambda.html:3268,perform,performed,3268,psi4manual/1.9.x/autodir_options_c/module__cclambda.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__cclambda.html,2,"['CACHE', 'perform']","['CACHELEVEL', 'performed']"
Performance,". MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MOGRAD_DAMPING¶. Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__occ-1.html:4694,optimiz,optimized-,4694,psi4manual/4.0b4/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__occ-1.html,4,['optimiz'],['optimized-']
Performance,". MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MOGRAD_DAMPING¶. Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__occ-1.html:4701,optimiz,optimized-,4701,psi4manual/1.0.0/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__occ-1.html,6,['optimiz'],['optimized-']
Performance,". MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Secord order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_R_START¶. When to start second-order SCF iterations based on gradient RMS. Type: double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indice",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html:6595,perform,performed,6595,psi4manual/1.0.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html,2,['perform'],['performed']
Performance,". MP2_CCSD_METHOD (PSIMRCC); PSIMRCC — How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS (PSIMRCC); PSIMRCC — Do start from a MP2 guess?. Type: boolean; Default: true. MP2_OS_SCALE (CCENERGY); CCENERGY — MP2 opposite-spin scaling value. Type: double; Default: 1.20. MP2_OS_SCALE (DFMP2); DFMP2 — OS Scale. Type: double; Default: 6.0. MP2_OS_SCALE (DFOCC); DFOCC — MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_OS_SCALE (OCC); OCC — MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_SCALE_OS (FNOCC); FNOCC — Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. MP2_SCALE_SS (FNOCC); FNOCC — Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0. MP2_SOS_SCALE (DFOCC); DFOCC — MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE (OCC); OCC — MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2 (DFOCC); DFOCC — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SOS_SCALE2 (OCC); OCC — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE (CCENERGY); CCENERGY — MP2 same-spin scaling value. Type: double; Default: 1.0. MP2_SS_SCALE (DFMP2); DFMP2 — SS Scale. Type: double; Default: 1.0. MP2_SS_SCALE (DFOCC); DFOCC — MP2 same-spin scaling value. Type: double; Default: 1.0. MP2_SS_SCALE (OCC); OCC — MP2 same-spin scaling value. Type: double; Default: 1.0. MP2_TYPE (GLOBALS); GLOBALS — Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE (GLOBALS); GLOBALS — Algorithm to use for MPn ( \(n>2\) ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. MPN (DETCI); DETCI — Do compute the MPn series out to kth order where k is determined by MA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:166327,optimiz,optimized-,166327,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized-']
Performance,". Monomers are specified using Cartesian coordinates. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/opt-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html:3430,optimiz,optimization,3430,psi4manual/1.7.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,". NUM_DETS_PRINT (DETCI). NUM_FROZEN_DOCC (GLOBALS). NUM_FROZEN_UOCC (GLOBALS). NUM_INIT_VECS (DETCI). NUM_ROOTS (DETCI). NUM_VECS_PRINT (STABILITY). NUM_VECS_WRITE (DETCI). NumberValue class in qcdb.libmintscoordentry. nunique() LibmintsMolecule method. O. OCC_TOLERANCE (SAPT). OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OEProp. theory. oeprop() in module util. OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). (RESPONSE). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2_ORBS_PRINT (OMP2). OMP3; . setting keywords. theory. OMP3_ORBS_PRINT (OMP3). OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (DETCI). (MP2). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (MP2). opt(); . see optimize(); . OPT_METHOD (OMP2). (OMP3). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in optproc. OptionState class in optproc. optproc module. Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OMP2). (OMP3). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_multiline_array() in module input. PATH, [1], [2], [3]. PEP1. perp_unit() in module qcdb.vecutil. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). PHI_POINTS (SCF). physconst module. physical constants. PITZER (TRANSQT). point_group() LibmintsMolecule method. POINTS (FINDIF). POL",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/genindex.html:29941,optimiz,optimize,29941,psi4manual/4.0b3/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/genindex.html,1,['optimiz'],['optimize']
Performance,". Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module ». CCENERGY¶; Computes coupled cluster energies. Called as part of any coupled cluster computation. General¶. ABCD¶. Type: string; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do ?. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Type: double; Default: 1.27. CC_SS_SCALE¶. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CUTOFF¶. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html:1035,CACHE,CACHETYPE,1035,psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html,2,['CACHE'],['CACHETYPE']
Performance,". Navigation. index. modules |; PSI4 [beta2] » ; Module code ». Source code for aliases; """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import PsiMod; import re; import os; import input; import math; import warnings; from driver import *; from wrappers import *; from molutil import *; from text import *; from procutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrillgroup_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> energy('sherrillgroup_gold_standard'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html:1044,perform,performed,1044,psi4manual/4.0b2/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/aliases.html,1,['perform'],['performed']
Performance,". O. OCC_TOLERANCE (SAPT). OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OEProp. theory. oeprop() in module util. OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). (RESPONSE). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2_ORBS_PRINT (OMP2). OMP3; . setting keywords. theory. OMP3_ORBS_PRINT (OMP3). OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (DETCI). (MP2). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (MP2). opt(); . see optimize(); . OPT_METHOD (OMP2). (OMP3). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in optproc. OptionState class in optproc. optproc module. Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OMP2). (OMP3). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_multiline_array() in module input. PATH, [1], [2], [3]. PEP1. perp_unit() in module qcdb.vecutil. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). PHI_POINTS (SCF). physconst module. physical constants. PITZER (TRANSQT). point_group() LibmintsMolecule method. POINTS (FINDIF). POLE_MAXITER (ADC). populateExtern() Diffuse method. QMMM method. PR (ADC). PRECONDITIONER (DETCI). prerequisites. PRESORT_FILE (TRANSQT). PRINT (CPHF). (GLOBALS). (SAPT). PRINT_BASIS (SCF). print_basis_families() in module basislist. print_bond_angles() Li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/genindex.html:30193,Optimiz,Optimized,30193,psi4manual/4.0b3/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/genindex.html,1,['Optimiz'],['Optimized']
Performance,. OMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP2.5 level of theory. OMP2.5 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized MP3 level of theory. OMP3 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized MP3 level of theory. OREMP2 TOTAL ENERGY¶. OREMP2 CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the orbital-optimized retaining-the-excitation-degree Møller–Plesset; hybrid perturbation theory level. OREMP2 REFERENCE CORRECTION ENERGY¶; The difference [E_h] between the single-determinant energy of the final and; initial orbitals for the orbital-optimized retaining-the-excitation-degree; Møller–Plesset hybrid perturbation theory level. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [E_h] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [E_h] from the polarizable continuum model for solvation. DD SOLVATION ENERGY¶; The energy contribution [Eh] from continuum solvation models based on a; domain-decomposition ansatz. PE ENERGY¶; The energy contribution [E_h] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [E_h] and correlation energy component [E_h]; for the quadratic configuration interaction singles and doubles level; of theory. ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/glossary_psivariables.html:43745,optimiz,optimized,43745,psi4manual/master/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/master/glossary_psivariables.html,4,['optimiz'],['optimized']
Performance,". OMP2.5 TOTAL ENERGY. OMP3. ; setting keywords. theory. OMP3 CORRELATION ENERGY. OMP3 DOUBLES ENERGY. OMP3 TOTAL ENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRON ENERGY. one_electron_integrals() psi4.core.MintsHelper method. OneBodyAOInt class in psi4.core. OneBodySOInt class in psi4.core. onel_Hx() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() psi4.core.CIWavefunction method. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.Charac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:101008,OPTIMIZ,OPTIMIZATION,101008,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['OPTIMIZ'],['OPTIMIZATION']
Performance,". OMP2.5 TOTAL ENERGY. OMP3. ; setting keywords. theory. OMP3 CORRELATION ENERGY. OMP3 DOUBLES ENERGY. OMP3 TOTAL ENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRON ENERGY. one_electron_integrals() psi4.core.MintsHelper method. OneBodyAOInt class in psi4.core. OneBodySOInt class in psi4.core. onel_Hx() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() psi4.core.CIWavefunction method. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:99973,OPTIMIZ,OPTIMIZATION,99973,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['OPTIMIZ'],['OPTIMIZATION']
Performance,". OPDM (DCT). (DETCI). opdm() (psi4.core.CIWavefunction method). OPDM_ONLY (CCDENSITY). OPDM_RELAX (CCDENSITY). (DFMP2). open() (psi4.core.IO method). open_check() (psi4.core.IO method). operate() (psi4.core.SymmetryOperation method). opt(). . see optimize(). opt() (in module psi4.driver). OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_RESTART (OPTKING). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() (in module psi4.driver). optimize_geometric() (in module psi4.driver). option_exists_in_module() (in module psi4.core). Options (class in psi4.core). options() (psi4.core.Wavefunction method). options_to_python() (in module psi4.core). OptionsState (class in psi4.driver.p4util). OptionsStateCM() (in module psi4.driver.p4util). OptionState (class in psi4.driver.p4util). ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() (psi4.core.PointFunctions method). ORBITALS_WRITE (SCF). OrbitalSpace (class in psi4.core). order() (psi4.core.CharacterTable method). (psi4.core.PointGroup method). ordered_params (psi4.driver.EmpiricalDispersion attribute). (psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute). OREMP. ; setting keywords. OREMP2 CORRELATION ENERGY. OREMP2 DOUBLES ENERGY. OREMP2 OPPOSITE-SPIN CORRELATION ENERGY. OREMP2 REFERENCE CORRECTION ENERGY. OREMP2 SAME-SPIN CORRELATION ENERGY. OREMP2 SINGLES ENERGY. OREMP2 TOTAL ENERGY. orientation() (psi4.core.MolecularGrid method). orientation_fixed() (psi4.core.Molecule method). origin (psi4.core.OneBodyAOInt attribute). original_coef() (psi4.core.GaussianShell method). ORTH_TYPE (DFOCC). (OCC). OS_SCALE (OCC). outfile_name() (in module psi4.core). output. ; cbs(). database(). geometry optimization. SAPT. vibr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:88115,Optimiz,Optimized,88115,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['Optimiz'],['Optimized']
Performance,". Optionally, use CTest and Pytest to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. >>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; >>> cmake --install . 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++17 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.8+) https://www.python.org/; CMake (3.15+) https://cmake.org/download/; NumPy (needed at runtime and buildtime) https://numpy.org/; System utilities: GNU make and GNU install or Ninja, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. gau2grid — [what is gau2grid?] [gau2grid min version]; Libint — [what is Libint?] [Libint min version] (Libint2 as of Nov 2020; added by v1.4). Eigen https://eigen.tuxfamily.org/index.php?title=Main_Page; Boost https://www.boost.org/ header-only preprocessor library. Libxc — [what is Libxc?] [Libxc min version]; pybind11 — [what is Pybind11?] [Pybind11 min version]; QCElemental — [what is QCElemental?]; QCEngine — [what is QCEngine?] (March 2019; added by v1.4); optking — [what is optking] (runtime dependency, required at build-time). Additionally, there are runtime-o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_planning.html:4817,Optimiz,Optimized,4817,psi4manual/1.8.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_planning.html,1,['Optimiz'],['Optimized']
Performance,". PSI4. Appendices; Keywords by Module; DFMP2. DFMP2¶; Performs density-fitted MP2 computations for RHF/UHF/ROHF reference wavefunctions. General¶. BASIS¶. Primary basis set. Type: string; Possible Values: basis string; Default: NONE. DFMP2_MEM_FACTOR¶. % of memory for DF-MP2 three-index buffers. Type: double; Default: 0.9. DFMP2_P2_TOLERANCE¶. Minimum error in the 2-norm of the P(2) matrix for corrections to Lia and P. Type: conv double; Default: 0.0. DFMP2_P_TOLERANCE¶. Minimum error in the 2-norm of the P matrix for skeleton-core Fock matrix derivatives. Type: conv double; Default: 0.0. DF_BASIS_MP2¶. Auxiliary basis set for MP2 density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_INTS_NUM_THREADS¶. Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. MP2_OS_SCALE¶. OS Scale. Type: double; Default: 6.0. MP2_SS_SCALE¶. SS Scale. Type: double; Default: 1.0. ONEPDM¶. Do compute one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: true. Expert¶. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. MADMP2_SLEEP¶. A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. table of contents. DFMP2; General; BASIS; DFMP2_MEM_FACTOR; DFMP2_P2_TOLERANCE; DFMP2_P_TOLERANCE; DF_BASIS_MP2; DF_INTS_NUM_THREADS; INTS_TOLERANCE; MP2_OS_SCALE; MP2_SS_SCALE; ONEPDM; OPDM_RELAX. Expert; DF_INTS_IO; MADMP2_SLEEP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Appendices; Keywords by Module; DFMP2. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dfmp2.html:1447,LOAD,LOAD,1447,psi4manual/1.7.x/autodir_options_c/module__dfmp2.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dfmp2.html,1,['LOAD'],['LOAD']
Performance,". SAPTINDENERGY. SAPTSAPT0ENERGY. SAPTSAPT2+(3)ENERGY. SAPTSAPT2+3ENERGY. SAPTSAPT2+ENERGY. SAPTSAPT2ENERGY. save() (Table method). SAVE_JK (SCF). SCALE (STABILITY). scale() (Table method). SCF. theory. scf_helper() (in module proc). SCF_MAXITER (DCFT). SCF_MEM_SAFETY_FACTOR (SCF). SCF_TYPE (CPHF). (JK), [1]. (SCF). scf_xtpl_helgaker_2() (in module wrappers). scf_xtpl_helgaker_3() (in module wrappers). SCFTOTALENERGY. SCHMIDT_ADD_RESIDUAL_TOLERANCE (CCEOM). SCHWARZ_CUTOFF (CPHF). (JK), [1]. scratch files. SCREEN_INTS (LMP2). SCS (LMP2). (MP2). SCS_CCSD (CCENERGY). SCS_MP2 (CCENERGY). SCS_N (LMP2). (MP2). SCSN_MP2 (CCENERGY). SEKINO (CCLAMBDA). (CCRESPONSE). SEM_MAX (PLUGIN_DFADC), [1]. SEM_MAXITER (ADC). SEMICANONICAL (CCENERGY). (CCEOM). (CCSORT). (CCTRIPLES). (PLUGIN_CCSORT), [1]. (TRANSQT2). set_memory() (in module util). set_num_threads() (in module util). setting; . keywords C-side. keywords cbs(). keywords cp(). keywords database(). keywords energy(). keywords molecule. keywords optimize(). keywords property(). SF_RESTRICT (DETCI). sherrillgroup_gold_standard() (in module aliases). SIGMA_OVERLAP (DETCI). single-point. SINGLES_PRINT (CCEOM). SMALL_CUTOFF (PSIMRCC). SO_S_FILE (TRANSQT). SO_T_FILE (TRANSQT). SO_TEI_FILE (TRANSQT). SO_V_FILE (TRANSQT). SOCC (GLOBALS). (MCSCF). SOLVER_CONVERGENCE (CPHF). (SOLVER), [1]. SOLVER_EXACT_DIAGONAL (CPHF). SOLVER_MAX_SUBSPACE (CPHF). (SOLVER), [1]. SOLVER_MAXITER (CPHF). (SOLVER), [1]. SOLVER_MIN_SUBSPACE (CPHF). (SOLVER), [1]. SOLVER_N_GUESS (CPHF). (SOLVER), [1]. SOLVER_N_ROOT (CPHF). (SOLVER), [1]. SOLVER_NORM (CPHF). (SOLVER), [1]. SOLVER_PRECONDITION (CPHF). (SOLVER), [1]. SOLVER_PRECONDITION_MAXITER (CPHF). SOLVER_PRECONDITION_STEPS (CPHF). SOLVER_QUANTITY (CPHF). SOLVER_TYPE (CPHF). SORTED_TEI_FILE (TRANSQT). SOS_SCALE (OMP2). SOS_SCALE2 (OMP2). SPINADAPT_ENERGIES (CCENERGY). split_menial() (in module wrappers). SS_E_CONVERGENCE (CCEOM). SS_R_CONVERGENCE (CCEOM). SS_SKIP_DIAG (CCEOM). SS_VECS_PER_ROOT (CCEOM). STEP_T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/genindex.html:26436,optimiz,optimize,26436,psi4manual/4.0b2/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/genindex.html,1,['optimiz'],['optimize']
Performance,". Some of these libraries may not be found correctly. How to set up the scratch directory¶; The scratch directory is where Psi4 stores potentially large files during; computation. It should thus be on a local, fast disk to minimize any; computational inefficiencies caused by I/O. The scratch directory is; commonly set up through the PSI_SCRATCH environment variable:; # csh, tcsh: add to shell or ~/.tcshrc file; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. See also the more general scratch documentation. How do I retain specific Psi4 scratch files¶; You can set up a specific path for PSI4 scratch file and keep them; for later use through the psi4_io handler. How to use Psi4 within a PBS queue¶; You will usually need to set up a PBS job script that is setting all; necessary environment variables, making sure the scratch directories are; set up, and invoking the executable. An example PBS script; is provided in the manual, but make sure to also consult your own PBS; documentation for appropriate setup. How to update and rebuild Psi4¶; Obtain code updates as appropriate from Binary Installer,; Clone from GitHub Repository, or Fork from GitHub Repository. Move into; objdir and reissue make or cmake --build ., whereupon CMake may reconfigure but; will only rebuild objects and libraries depending on changed files. It is; scarcely ever necessary for the user to reinvoke cmake to update; objdir based on changes to the PSI4 repository.; Upon switching conda environments, though, one should; make a new objdir since there are many full paths baked into; objdir/CMakeCache.txt. How to run a minute’s worth of tests¶; When you want to do a very minimal test of the build and have; CTest installed, the following command can be useful.; >>> ctest -L smoke -j`getc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:52553,queue,queue,52553,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,9,['queue'],['queue']
Performance,". The derivation of the second-order exchange terms without the single-exchange; approximation are found in the following two works:. “Intermolecular exchange-induction energies without the overlap expansion,”; R. Schäffer and G. Jansen, Theor. Chem. Acc. 131, 1235 (2012).; (doi: 10.1007/s00214-012-1235-6); “Single-determinant-based symmetry-adapted perturbation theory without; single-exchange approximation,”; R. Schäffer and G. Jansen, Mol. Phys. 111, 2570 (2013).; (doi: 10.1080/00268976.2013.827253). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:16845,optimiz,optimized,16845,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,9,['optimiz'],['optimized']
Performance,". The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-9. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FROZEN_DOCC¶. The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC¶. The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. NO_SINGLES¶. Do ?. Type: boolean; Default: false. OFFDIAGONAL_CCSD_T¶. Do include the off-diagonal corrections in (T) computations?. Type: boolean; Default: true. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. RESTRICTED_DOCC¶. The number of doubly occupied orbitals per irrep. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-9. SMALL_CUTOFF¶. Type: integer; Default: 0. TIKHONOW_MAX¶. The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html:3161,perform,perform,3161,psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html,2,['perform'],['perform']
Performance,". The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-9. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FROZEN_DOCC¶. The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC¶. The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. NO_SINGLES¶. Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. OFFDIAGONAL_CCSD_T¶. Do include the off-diagonal corrections in (T) computations?. Type: boolean; Default: true. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. RESTRICTED_DOCC¶. The number of doubly occupied orbitals per irrep. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-9. SMALL_CUTOFF¶. Type: integer; Default: 0. TIKHONOW_MAX¶. The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the den",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__psimrcc-1.html:3021,perform,perform,3021,psi4manual/4.0b3/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__psimrcc-1.html,2,['perform'],['perform']
Performance,". The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. fd-gradient; SCF STO-3G finite-difference tests. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. nbo; Generation of NBO file. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. dft-smoke; DFT Functional Smoke Test. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. dcft1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. scf-guess-read2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:34538,perform,performed,34538,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,". This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For the “frozen” bonds, angles and dihedrals, these coordinates are constrained to remain at their initial values. For “fixed” bonds, angles, or dihedrals, the equilibrium (final) value of the coordinate is provided by the user. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. omp2_5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. omp2_5-2; OMP2 cc-pVDZ energy for the H2O molecule. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al.,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:16662,optimiz,optimization,16662,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,". This keyword applies only to Hydrogen and Helium atoms and specifies the number of contracted Gaussian functions per shell. There is usually no need to use this keyword, but it can be useful for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2¶. This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3¶. This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4¶. This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV¶. Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below Hartree/bohr, where is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC¶. Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP¶. Specifies largest step (in millibohr) which is allowed in geometry optimizati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:29335,perform,performs,29335,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['perform'],['performs']
Performance,". This keyword applies only to Hydrogen and Helium atoms and specifies the number of contracted Gaussian functions per shell. There is usually no need to use this keyword, but it can be useful for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2¶. This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3¶. This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4¶. This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV¶. Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC¶. Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP¶. Specifies largest step (in millibohr) which is allowed in g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html:29594,perform,performs,29594,psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,15,['perform'],['performs']
Performance,". This; procedure is continued until either convergence is reached or a preset maximum; number of iterations is exceeded. Convergence is determined by both change in; energy and root-mean-square change in density matrix values, which must be below; the user-specified E_CONVERGENCE and D_CONVERGENCE, respectively.; The maximum number of iterations is specified by the MAXITER option. It; should be noted that SCF is a chaotic process, and, as such, often requires; careful selection of initial orbitals and damping during iterations to ensure; convergence. This is particularly likely for large systems, metallic systems,; multireference systems, open-shell systems, anions, and systems with diffuse; basis sets.; For initial orbital selection, several options are available. These include:. CORE; Diagonalization of the core Hamiltonian, removing even mean-field electron; repulsion. Simple, but often too far from the final solution for larger; systems. READ becomes the default for the second and later iterations; of geometry optimizations.; SAD [Default]; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH [Default]; Generalized Wolfsberg-Helmholtz, a simple Hückel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. This becomes the; default for the second and later iterations of geomet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:16377,optimiz,optimizations,16377,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['optimiz'],['optimizations']
Performance,". Type: array; Default: No Default. FROZEN_UOCC (GLOBALS); GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. FROZEN_UOCC (PSIMRCC); PSIMRCC — The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING); OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM); CCEOM — Do ?. Type: boolean; Default: false. FZC_A_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_OEI. FZC_B_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_OEI. FZC_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_OEI. G_CONVERGENCE (OPTKING); OPTKING — Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. GAUGE (CCDENSITY); CCDENSITY — The type of gauge to use for properties. Type: string; Default: LENGTH. GAUGE (CCRESPONSE); CCRESPONSE — Specifies the choice of representation of the electric dipole operator. Acceptable values are LENGTH for the usual length-gauge representation, VELOCITY for the modified velocity-gauge representation in which the static-limit optical rotation tensor is subtracted from the frequency- dependent tensor, or BOTH. Note that, for optical rotation calculations, only the choices of VELOCITY or BOTH will yield origin-independent results. Type: string; Possible Values: LENGTH, VELOCITY, BOTH; De",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:38534,optimiz,optimization,38534,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,". Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, FAST_DF, CD, INDEPENDENT; Default: PK. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 100.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the cc-pVDZ-RI basis set (when available for all elements). Type: string; Possible Values: basis string; Default: FALSE. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html:3579,perform,performed,3579,psi4manual/1.0.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html,2,['perform'],['performed']
Performance,". Type: boolean; Default: false. SCS (CPHF); CPHF — Do perform a spin component scaled MP2 computation?. Type: boolean; Default: false. SCS_CCSD (CCENERGY); CCENERGY — Do spin-component-scaled CCSD. Type: boolean; Default: false. SCS_CCSD (FNOCC); FNOCC — Do SCS-CCSD?. Type: boolean; Default: false. SCS_CEPA (FNOCC); FNOCC — Do SCS-CEPA? Note that the scaling factors will be identical to those for SCS-CCSD. Type: boolean; Default: false. SCS_MP2 (CCENERGY); CCENERGY — Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SCS_MP2 (FNOCC); FNOCC — Do SCS-MP2?. Type: boolean; Default: false. SCS_N (CCENERGY); CCENERGY — Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SCS_N (CPHF); CPHF — Do perform a spin component scaled (N) MP2 computation?. Type: boolean; Default: false. SCS_TYPE (OCC); OCC — Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SCSN_MP2 (CCENERGY); CCENERGY — Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SEKINO (CCLAMBDA); CCLAMBDA — Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. SEKINO (CCRESPONSE); CCRESPONSE — Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. SEM_MAXITER (ADC); ADC — Maximum iteration number in simultaneous expansion method. Type: integer; Default: 30. SEMICANONICAL (CCENERGY); CCENERGY — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SEMICANONICAL (CCEOM); CCEOM — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SEMICANONICAL (CCSORT); CCSORT — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SEMICANONICAL (CCTRIPLES); CCTRIPLES — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SEMICANONICAL (TRANSQT2); TRANSQT2 — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SF_RESTRICT (DETCI); DETCI (Expert) — Do eliminate determinants not vali",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:117128,optimiz,optimized,117128,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,". Type: string; Default: No Default. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. H_UPDATE_DEN_TOL¶. Denominator check for hessian update. Type: conv double; Default: 1e-7. INTERFRAG_STEP_LIMIT¶. Maximum step size in bohr or radian along an interfragment coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT¶. Initial maximum step size in bohr or radian along an internal coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT_MAX¶. Upper bound for dynamic trust radius [au]. Type: double; Default: 1.0. INTRAFRAG_STEP_LIMIT_MIN¶. Lower bound for dynamic trust radius [au]. Type: double; Default: 0.001. IRC_DIRECTION¶. IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE¶. IRC step size in bohr(amu)\(^{1/2}\). Type: double; Default: 0.2. IRC_STOP¶. Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. OPT_COORDINATES¶. Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. PRINT_OPT_PARAMS¶. Print all optking parameters. Type: boolean; Default: false. PRINT_TRAJECTORY_XYZ_FILE¶. Should an xyz trajectory file be kept (useful for visualization)?. Type: boolean; Default: false. RFO_FOLLOW_ROOT¶. Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX¶. Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT¶. Root for RFO to follow, 0 being lowest (for a m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__optking-1.html:2380,optimiz,optimization,2380,psi4manual/1.1.0/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__optking-1.html,11,['optimiz'],['optimization']
Performance,". Vector. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; Vector. Vector¶. class psi4.core.Vector¶; Bases: pybind11_builtins.pybind11_object; Class for creating and manipulating vectors; Attributes Summary. name; The name of the Vector. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Summary. array_interface(self). axpy(self, a, other); Adds to this vector another vector scaled by a. clone(self); Clone the vector. copy(self, arg0); Returns a copy of the matrix. dim(self[, h]); Returns the dimensions of the vector per irrep h. dimpi(self); Returns the Dimension object. from_array([name, dim1, dim2]); Converts a numpy array or list of numpy arrays into a Psi4 Matrix (irreped if list). from_list(x). from_serial(json_data); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get_block(self, slice); Get a vector block. load(self, psio, file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read(filename[, prefix]); Reads the data from a NumPy compress file. np_write([filename, prefix]); Writes the irreped matrix to a NumPy zipped file. print_out(self); Prints the vector to the output file. save(self, psio, file); Save the vector to disk. scale(self, sc); Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set_block(self, slice, block); Set a vector block. to_array([copy, dense]); Converts a Psi4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self, other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name¶; The name of the Vector. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. array_interface(self: psi4.core.Vector) → list¶. axpy(self: psi4.core.Vector, a: floa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html:977,load,load,977,psi4manual/1.6.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html,2,"['Load', 'load']","['Load', 'load']"
Performance,". What C and C++ compilers and versions are approved¶; On Linux, the following work nicely. GNU: gcc, g++; Intel: icc, icpc; Clang: clang, clang++. On Mac, the following work nicely. Apple Clang: clang, clang++; Intel: icc, icpc. PSI4 requires full C++11 compliance, meaning, most importantly, GCC; >= 4.9. This compliance is checked for at build-time with file; psi4/cmake/custom_cxxstandard.cmake, so either consult that file or; try a test build to ensure your compiler is approved. Note that Intel; compilers also rely on GCC, so both icpc and gcc versions are checked. How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS. How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew¶; The easiest compiler to obtain is clang which is a drop-in replacement; for gcc and g++. Just install XCode. Some old versions; of XCode can’t handle some of the advanced C++ language features, but this; is a software not hardware limitation. Checks for version compliance; performed at build-time. How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS¶; # See if GCC too old (in this case, yes); >>> gcc --version; gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4). Even if you’re not using GCC as a compiler, your Intel compiler seeks; gcc to generate code compatible with your current GCC version. If your; GCC is too old (like above), you can update your system GCC through your; package manager or install an acceptable version elsewhere on your; system. The latter route, tested on Linux with Intel compilers, is below.; # Install GCC 5.2 into a non-primary conda environment; >>> conda create -n gcc52 -c psi4 gcc-5-mp. # To Build, either:. # (A) activate environment (prepends PATH); >>> source activate gcc52. # (B) tell CMake to tell the compiler which GCC to use; >>> vi do-configure; GCC5=/path/to/miniconda/envs/gcc52; cmake -H. -Bbuild \; -DCMAKE_C_COMPILER=icc \; -DCMAKE_CXX_COMPILER=icpc \; -DCMAKE_C_FLAGS=""-gcc-name=${GCC5}/bin/gcc"" \; -",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:27174,perform,performed,27174,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['perform'],['performed']
Performance,". When BASIS used, CFOUR_SPHERICAL is set appropriately. Type: string; Possible Values: STO-3G, 3-21G, 4-31G, 6-31G, 6-31G*, 6-31G**, 6-311G, 6-311G*, 6-311G**, DZ, DZP, TZ, TZP, TZ2P, PVDZ, PVTZ, PVQZ, PV5Z, PV6Z, PCVDZ, PCVTZ, PCVQZ, PCV5Z, PCV6Z, AUG-PVDZ, AUG-PVTZ, AUG-PVTZ, AUG-PVQZ, AUG-PV5Z, AUG-PV6Z, D-AUG-PVDZ, D-AUG-PVTZ, D-AUG-PVQZ, D-AUG-PV5Z, D-AUG-PV6Z, cc-pVDZ, cc-pVTZ, cc-pVQZ, cc-pV5Z, cc-pV6Z, cc-pCVDZ, cc-pCVTZ, cc-pCVQZ, cc-pCV5Z, cc-pCV6Z, PWCVDZ, PWCVTZ, PWCVQZ, PWCV5Z, PWCV6Z, PwCVDZ, PwCVTZ, PwCVQZ, PwCV5Z, PwCV6Z, svp, dzp, tzp, tzp2p, qz2p, pz3d2f, 13s9p4d3f, WMR, ANO0, ANO1, ANO2, EVEN_TEMPERED, SPECIAL; Default: SPECIAL. CFOUR_BRUCK_CONV¶. experimental use. Type: integer; Default: 4. CFOUR_BRUECKNER¶. Specifies whether Brueckner orbitals are to be determined for the specified CC method. OFF(=0) Brueckner orbitals are not to be determined, ON (=1) they are to be determined. Type: boolean; Default: false. CFOUR_CACHE_RECS¶. The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL¶. Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Possible Values: SCF, HF, MBPT(2), MP2, MBPT(3), MP3, SDQ-MBPT(4), SDQ-MP4, MBPT(4), MP4, CCD, CCSD, CCSD(T), CCSDT-1, CCSDT-1b, CCSDT-2, CCSDT-3, CCSDT-4, CCSDT, CC2, CC3, QCISD, QCISD(T), CID, CISD, UCC(4), B-CCD; Default: SCF. CFOUR_CC_CONV¶. Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than , where is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER¶. Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:8095,cache,cache,8095,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['cache'],['cache']
Performance,". When BASIS used, CFOUR_SPHERICAL is set appropriately. Type: string; Possible Values: STO-3G, 3-21G, 4-31G, 6-31G, 6-31G*, 6-31G**, 6-311G, 6-311G*, 6-311G**, DZ, DZP, TZ, TZP, TZ2P, PVDZ, PVTZ, PVQZ, PV5Z, PV6Z, PCVDZ, PCVTZ, PCVQZ, PCV5Z, PCV6Z, AUG-PVDZ, AUG-PVTZ, AUG-PVTZ, AUG-PVQZ, AUG-PV5Z, AUG-PV6Z, D-AUG-PVDZ, D-AUG-PVTZ, D-AUG-PVQZ, D-AUG-PV5Z, D-AUG-PV6Z, cc-pVDZ, cc-pVTZ, cc-pVQZ, cc-pV5Z, cc-pV6Z, cc-pCVDZ, cc-pCVTZ, cc-pCVQZ, cc-pCV5Z, cc-pCV6Z, PWCVDZ, PWCVTZ, PWCVQZ, PWCV5Z, PWCV6Z, PwCVDZ, PwCVTZ, PwCVQZ, PwCV5Z, PwCV6Z, svp, dzp, tzp, tzp2p, qz2p, pz3d2f, 13s9p4d3f, WMR, ANO0, ANO1, ANO2, EVEN_TEMPERED, SPECIAL; Default: SPECIAL. CFOUR_BRUCK_CONV¶. experimental use. Type: integer; Default: 4. CFOUR_BRUECKNER¶. Specifies whether Brueckner orbitals are to be determined for the specified CC method. OFF(=0) Brueckner orbitals are not to be determined, ON (=1) they are to be determined. Type: boolean; Default: false. CFOUR_CACHE_RECS¶. The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL¶. Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Possible Values: SCF, HF, MBPT(2), MP2, MBPT(3), MP3, SDQ-MBPT(4), SDQ-MP4, MBPT(4), MP4, CCD, CCSD, CCSD(T), CCSDT-1, CCSDT-1b, CCSDT-2, CCSDT-3, CCSDT-4, CCSDT, CC2, CC3, QCISD, QCISD(T), CID, CISD, UCC(4), B-CCD; Default: SCF. CFOUR_CC_CONV¶. Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than \(10^N\), where \(N\) is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER¶. Specifies the maximum number of expansion vectors used in the iterative subspace to enhance ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html:8193,cache,cache,8193,psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,4,['cache'],['cache']
Performance,". Within the DF portion; of the computation, the zeroth-iteration uses a non-idempotent density matrix; obtained from the SAD guess, so the energy is unphysically low. However, the; first true iteration is quite close to the final DF energy, highlighting the; efficiency of the SAD guess. Pulay’s DIIS procedure is then used to accelerate; SCF convergence, with the DF phase reaching convergence in eight true; iterations. When used together, SAD and DIIS are usually sufficient to converge; the SCF for all but the most difficult systems. Additional convergence; techniques are available for more difficult cases, and are detailed below. At; this point, the code switches on the requested Direct integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in Psi4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamilt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf.html:3625,perform,performed,3625,psi4manual/1.0.0/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf.html,2,['perform'],['performed']
Performance,". Within the DF portion; of the computation, the zeroth-iteration uses a non-idempotent density matrix; obtained from the SAD guess, so the energy is unphysically low. However, the; first true iteration is quite close to the final DF energy, highlighting the; efficiency of the SAD guess. Pulay’s DIIS procedure is then used to accelerate; SCF convergence, with the DF phase reaching convergence in eight true; iterations. When used together, SAD and DIIS are usually sufficient to converge; the SCF for all but the most difficult systems. Additional convergence; techniques are available for more difficult cases, and are detailed below. At; this point, the code switches on the requested Direct integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree–Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) \(\{\psi_i\}\),. \[\psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1).\]; Here, \(\{\phi_{\mu}\}\) are the basis functions, which, in PSI4 are; contracted Cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix \(C_{\mu i}\) contains the MO coefficients, which are the; constrained variational parameters in Hartree–Fock. The molecular orbitals are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. \[\begin{split}| \Psi_0 \rangle =; \frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}; \psi_1 (\vec x_1) & \psi_2(\vec x_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:3634,perform,performed,3634,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,15,['perform'],['performed']
Performance,". [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-core F. [3]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [4]; (1,2,3,4,5); Also available for DFT references RKS/UKS. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:12898,Optimiz,Optimized,12898,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['Optimiz'],['Optimized']
Performance,". [7]; Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:22034,optimiz,optimizer,22034,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,8,['optimiz'],"['optimize', 'optimizer']"
Performance,". [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta3] » ; Module code ». © Copyright 2012, The Psi4 Project.; La",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:7130,Queue,Queue,7130,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,1,['Queue'],['Queue']
Performance,". [docs] def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». © Copyright 2013, The Psi4 Project.; La",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:7130,Queue,Queue,7130,psi4manual/4.0b4/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html,1,['Queue'],['Queue']
Performance,". cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft2; DFT Functional Test. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). dft1; DFT Functional Test. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-cbs1; Various basis set extrapolation tests. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. opt2; SCF DZ allene geometry optimzation, with Cartesian input. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc54; CCSD dipole with user-specified basis set. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, eithe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:10171,optimiz,optimize,10171,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,8,['optimiz'],['optimize']
Performance,". cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_cfour-1.html:1851,optimiz,optimization,1851,psi4manual/1.1.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_cfour-1.html,6,['optimiz'],['optimization']
Performance,". cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/kw-1; testing best practices options, part i. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/mints5; geometries fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html:1275,optimiz,optimization,1275,psi4manual/1.8.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,". core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:65268,optimiz,optimized,65268,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['optimiz'],['optimized']
Performance,". else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:35421,optimiz,optimize,35421,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['optimiz'],['optimize']
Performance,". fnocc2; Test G2 method for H2O. mints2-bse; Similar to mints2, but using the BSE to specify the basis sets. isapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). fcidump; test FCIDUMP functionality for rhf/uhf. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. matrix2; An example of using BLAS and LAPACK calls ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:19372,optimiz,optimization,19372,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,". lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix – Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; side",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:4464,optimiz,optimization,4464,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,2,['optimiz'],['optimization']
Performance,". maximum number of beta electrons in RAS III. Type: integer; Default: -1. CALC_S_SQUARED¶. Do calculate the value of for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CIBLKS_PRINT¶. Do print a summary of the CI blocks?. Type: boolean; Default: false. CI_MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 24. CI_NUM_THREADS¶. Number of threads for DETCI. Type: integer; Default: 1. DETCI_FREEZE_CORE¶. Do freeze core orbitals?. Type: boolean; Default: true. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. ISTOP¶. Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. MS0¶. Do use the component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NUM_DETS_PRINT¶. Number of important determinants to print. Type: integer; Default: 20. NUM_ROOTS¶. number of CI roots to find. Type: integer; Default: 1. RAS34_MAX¶. maximum number of electrons in RAS III + IV. Type: integer; Default: -1. RAS3_MAX¶. maximum number of electrons in RAS III. Type: integer; Default: -1. RAS4_MAX¶. maximum number of electrons in RAS IV. Type: integer; Default: -1. REFERENCE¶. Reference wavefunction type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__detci-1.html:1923,perform,perform,1923,psi4manual/1.0.0/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__detci-1.html,2,['perform'],['perform']
Performance,". modules |. next |. previous |; PSI4 [beta2] » ; Emerging Theoretical Methods: Plugins DFADC to RQCHF ». plugin_omega¶. C-side Documentation¶. DEBUG (PLUGIN_OMEGA); The amount of information printed to the output file. Type: integer; Default: 0. DFT_FUNCTIONAL (PLUGIN_OMEGA); The Omega functional selected for this procedure. Type: string; Default: No Default. OMEGA_BRACKET_ALPHA (PLUGIN_OMEGA); Multiplier to use to backet omega (>1). Type: double; Default: 2.0. OMEGA_CONVERGE (PLUGIN_OMEGA); Convergence threshold for omega, 10^-thresh. See the note at the beginning of Section ref{keywords}. Type: conv double; Default: 1e-3. OMEGA_GUESS (PLUGIN_OMEGA); Procedure used to guess initial omega. Type: string; Possible Values: HOMO_SIZE, DEFAULT; Default: HOMO_SIZE. OMEGA_GUESS_A (PLUGIN_OMEGA); a in w_0^-1 = a <R>_HOMO + b. Type: double; Default: 2.0. OMEGA_GUESS_B (PLUGIN_OMEGA); b in w_0^-1 = a <R>_HOMO + b. Type: double; Default: 0.0. OMEGA_GUESS_INTERPOLATE (PLUGIN_OMEGA); Interpolate Fock matrices at omega steps?. Type: boolean; Default: true. OMEGA_MAXITER (PLUGIN_OMEGA); Maximum number of omega iterations to perform. Type: integer; Default: 30. OMEGA_PROCEDURE (PLUGIN_OMEGA); The Omega optimization procedure. Type: string; Possible Values: IP; Default: IP. OMEGA_ROOT_ALGORITHM (PLUGIN_OMEGA); The Omega optimization root-finding algorithm. Type: string; Possible Values: BISECTION, REGULA_FALSI, REGULA_FALSI2, REGULA_FALSI3, BRENT; Default: REGULA_FALSI3. PRINT (PLUGIN_OMEGA); The amount of information printed to the output file. Type: integer; Default: 1. Table Of Contents. plugin_omega; C-side Documentation. Previous topic; PRINT; Next topic; <no title>; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Emerging Theoretical Methods: Plugins DFADC to RQCHF ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_plugins/module__plugin_omega-1.html:1191,perform,perform,1191,psi4manual/4.0b2/autodir_plugins/module__plugin_omega-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_plugins/module__plugin_omega-1.html,6,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,". mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). 1; 2; 3; 4; 5; 6; 7; 8>>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:4666,perform,perform,4666,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,". mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix – Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. 1; 2; 3; 4; 5; 6>>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). Navigation. Index. modules  ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:4453,perform,perform,4453,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,". name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.optimize.html:13138,perform,perform,13138,psi4manual/1.6.x/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.optimize.html,8,"['Optimiz', 'optimiz', 'perform']","['OptimizationConvergenceError', 'optimization', 'optimize', 'perform']"
Performance,". psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() psi4.core.CIWavefunction method. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. orientation_fixed() psi4.core.Molecule method. origin psi4.core.AngularMomentumInt attribute. psi4.core.DipoleInt attribute. psi4.core.ElectricFieldInt attribute. psi4.core.ElectrostaticInt attribute. psi4.core.KineticInt attribute. psi4.core.MultipoleInt attribute. psi4.core.NablaInt attribute. psi4.core.OneBodyAOInt attribute. psi4.core.OverlapInt attribute. psi4.cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:100349,Optimiz,Optimized,100349,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,". psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. option_exists_in_module() in module psi4.core, [1]. Options class in psi4.core, [1]. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orbital_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. OrbitalSpace class in psi4.core, [1]. order() psi4.core.CharacterTable method, [1], [2]. psi4.core.PointGroup method, [1], [2]. ordered_params psi4.driver.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. orientation_fixed() psi4.core.Molecule method, [1], [2]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt attribute, [1]. psi4.core.OneBodyAOInt attribute, [1], [2]. psi4.core.OverlapInt attribute, [1]. psi4.core.PotentialInt attribute, [1]. psi4.core.Pseudospec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:102607,Optimiz,Optimized,102607,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,". psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. option_exists_in_module() in module psi4.core, [1]. Options class in psi4.core, [1]. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orbital_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. OrbitalSpace class in psi4.core, [1]. orientation() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. orientation_fixed() psi4.core.Molecule method, [1], [2]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt attribute, [1]. psi4.core.OneBodyAOInt attribute, [1], [2]. psi4.core.OverlapInt attribute, [1]. psi4.core.PotentialInt attribute, [1]. psi4.core.PseudospectralInt attribute, [1]. psi4.core.QuadrupoleInt attribute, [1]. psi4.core.TracelessQuadrupoleInt attribute, [1]. original_coef() psi4.core.GaussianS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:88187,Optimiz,Optimized,88187,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,". scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-db2; Database calculation, run in sow/reap mode. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dft1; DFT Functional Test. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorith",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:9604,perform,performs,9604,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,8,"['optimiz', 'perform']","['optimization', 'performs']"
Performance,". scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. fci-h2o-2; 6-31G H2O Test FCI Energy Point. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fnocc7; Test fnocc with linear dependencies. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:10713,optimiz,optimized,10713,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimized']
Performance,". soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). cubeprop-esp; RHF orbitals and density for water. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dft-grac; Gradient regularized asymptotic correction (GRAC) test. dct7; DCT calculation for the triplet O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:43785,optimiz,optimization,43785,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,". symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); psi4.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3973,Queue,Queue,3973,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Queue'],['Queue']
Performance,". wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.compute_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energy_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:67359,perform,perform,67359,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,".  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_builtins.pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.symmetryoperation.html:1058,Perform,Performs,1058,psi4manual/1.4.0/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.symmetryoperation.html,1,['Perform'],['Performs']
Performance,".  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_builtins.pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.symmetryoperation.html:1058,Perform,Performs,1058,psi4manual/1.5.0/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.symmetryoperation.html,1,['Perform'],['Performs']
Performance,".  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_builtins.pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.SymmetryOperation.html:1058,Perform,Performs,1058,psi4manual/1.6.x/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,".(Default: ON if analytic Hessian is available, OFF otherwise). Type: boolean; Default: true. CFOUR_DBOC¶. Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions. Type: boolean; Default: false. CFOUR_DCT¶. Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0). Type: boolean; Default: false. CFOUR_DERIV_LEVEL¶. Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually needs not be set in any calculation since it is automatically set if the appropriate other options in the CFOUR namelist are turned on. Psi4 Interface: Keyword set from type of computation command: ZERO if energy(), FIRST if gradient() or optimize(), etc. Type: string; Possible Values: ZERO, FIRST, SECOND; Default: ZERO. CFOUR_DIFF_TYPE¶. Specifies whether orbital-relaxed (RELAXED =0) or orbital-unrelaxed (UNRELAXED =1) derivatives are computed in the CC calculation. Type: string; Possible Values: RELAXED, UNRELAXED; Default: RELAXED. CFOUR_DROPMO¶. Specifies which molecular orbitals will be dropped from the post-SCF calculation. The orbitals are numbered in ascending order from the most stable (negative energy) to the most unstable (largest positive energy). Individual orbitals must be separated with a dash, while x>y means orbitals x through y inclusive. For example, the string 1>10-55-58>64, would result in orbitals 1,2,3,4,5,6,7,8,9,10,55,58,59,60,61,62,63 and 64 being dropped. For UHF calculations, the appropriate orbitals are deleted for both spin cases. No dropped virtual MOs are currently allowed for gradient or property calculations. Psi4 Interface: The array above is",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cfour-1.html:14606,optimiz,optimize,14606,psi4manual/1.4.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cfour-1.html,9,['optimiz'],['optimize']
Performance,"..); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:2758,Perform,Perform,2758,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,8,"['Perform', 'perform']","['Perform', 'performance']"
Performance,".., c) TOTAL ENERGY¶; The total energy [Eh] of a component of the requested N-Body energy.; The first parenthetical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [Eh] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The additional correction to the SCF reference energy [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy cont",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:33192,optimiz,optimized,33192,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['optimiz'],['optimized']
Performance,"...); Comparison function for output data in FCHK (formatted checkpoint) file format. compare_fcidumps(expected, computed, label); Comparison function for FCIDUMP files. compare_moldenfiles(expected, computed[, ...]); Comparison function for output data in Molden file format. copy_file_from_scratch(filename, prefix, ...); Function to move file out of scratch with correct naming convention. copy_file_to_scratch(filename, prefix, ...); Function to move file into scratch with correct naming convention. create_plugin(name, template). rtype; None. cubeprop(wfn, **kwargs); Evaluate properties on a grid and generate cube files. dynamic_variable_bind(cls); Function to dynamically add extra members to the core.Molecule class. energies_from_fcidump(intdump). energy(name, **kwargs); Function to compute the single-point electronic energy. fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fchkfile_to_string(fname); Load FCHK file into a string. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psi4api.html:18123,Load,Load,18123,psi4manual/1.6.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psi4api.html,1,['Load'],['Load']
Performance,".0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. psi4.driver.inputparser.process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python.; :rtype: str; Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Parameters:. raw_input (str) – Input in a mixture of Python and PSIthon syntax.; print_level (int) – raw_input is printed to the output file unless print_level =0. Return type:; str. psi4.driver.frac.ip_fitting(name, omega_l=0.05, omega_r=2.5, omega_convergence=0.001, maxiter=20, **kwargs)[source]¶; Optimize DFT omega parameter for molecular system. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l (float) – Minimum omega to be considered during fitting.; omega_r (float) – Maximum omega to be considered during fitting.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence (float) – Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter (int) – Maximum number of iterations towards omega convergence. Returns:; Optimal omega parameter. Return type:; float. psi4.driver.frac.frac_traverse(name, **kwargs)[source]¶; Scan electron occupancy from +1 electron to -1. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not las",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/external_apis.html:3144,Optimiz,Optimize,3144,psi4manual/1.9.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/external_apis.html,1,['Optimiz'],['Optimize']
Performance,".0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). Convergence Stabilization¶; With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via options.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations \(N,N+2,\ldots\), invoking; MOM_START N can often rescue the convergence of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:18930,optimiz,optimized,18930,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['optimiz'],['optimized']
Performance,".0. INTS_TOLERANCE (TRANSQT); TRANSQT — Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. INTS_TOLERANCE (TRANSQT2); TRANSQT2 — Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. IRC_DIRECTION (OPTKING); OPTKING — IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE (OPTKING); OPTKING — IRC step size in bohr(amu). Type: double; Default: 0.2. IRC_STOP (OPTKING); OPTKING — Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. ISTOP (DETCI); DETCI — Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. IVO (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. J_FILE (TRANSQT); TRANSQT —. Type: integer; Default: 91. JOBTYPE (CCLAMBDA); CCLAMBDA (Expert) — Type of job being performed. Type: string; Default: No Default. JOBTYPE (MP2); MP2 (Expert) — Type of job being performed. Type: string; Default: SP. KEEP_INTCOS (OPTKING); OPTKING — Keep internal coordinate definition file. Type: boolean; Default: false. KEEP_J (TRANSQT); TRANSQT — Do keep half-transformed integrals?. Type: boolean; Default: false. KEEP_OEIFILE (CCSORT); CCSORT — Do retain the input one-electron integrals?. Type: boolean; Default: false. KEEP_PRESORT (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. KEEP_TEIFILE (CCSORT); CCSORT — Do retain the input two-electron integrals?. Type: boolean; Default: false. LAG_IN_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_MO_LAG. LAGRAN_DOUBLE (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. LAGRAN_HALVE (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. LAMBDA_MAXITER (DCFT); DCFT — Maximum number of density cumulant update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same keyword controls the maximum number of density cumulant response micro-iterations per macro-iterati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:48880,perform,performed,48880,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,.0.0 6a9a71b] Docs; ABCD — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; DIIS — Psi4 [1.0.0 6a9a71b] Docs; JOBTYPE — Psi4 [1.0.0 6a9a71b] Docs; LOCAL — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CPHF_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_FILTER_SINGLES — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_METHOD — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_PAIRDEF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_WEAKP — Psi4 [1.0.0 6a9a71b] Docs; MAXITER — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; PROP_ALL — Psi4 [1.0.0 6a9a71b] Docs; PROP_ROOT — Psi4 [1.0.0 6a9a71b] Docs; PROP_SYM — Psi4 [1.0.0 6a9a71b] Docs; R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; RESTART — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [1.0.0 6a9a71b] Docs; SEKINO — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; ZETA — Psi4 [1.0.0 6a9a71b] Docs; ABCD — Psi4 [1.0.0 6a9a71b] Docs; ANALYZE — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; DIIS — Psi4 [1.0.0 6a9a71b] Docs; GAUGE — Psi4 [1.0.0 6a9a71b] Docs; LINEAR — Psi4 [1.0.0 6a9a71b] Docs; LOCAL — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CPHF_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_FILTER_SINGLES — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_METHOD — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_PAIRDEF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_WEAKP — Psi4 [1.0.0 6a9a71b] Docs; MAXITER — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; OMEGA — Psi4 [1.0.0 6a9a71b] Docs; PROPERTY — Psi4 [1.0.0 6a9a71b] Docs; R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; RESTART — Psi4 [1.0.0 6a9a71b] Docs; SEKINO — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; EOM_REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; INTS_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; KEEP_OEIFILE — Psi4 [1.0.0 6a9a71b] Docs; KEEP_TEI,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:43980,CACHE,CACHELEVEL,43980,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,".000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions; for each atom along the normal mode coordinate. (This information could; be used to animate the vibrational frequency using visualization; software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation. You; can see this in the next section of the output file output.dat. The; vibrational frequencies are sufficient to obtain vibrational; contributions to enthalpy (H), entropy (S), and Gibbs free energy (G).; Similarly, the molecular geometry is used to obtain rotational; constants, which are then used to obtain rotational contributions to H,; S, and G.; Note: Psi4 has several synonyms for the functions called in this; example. For instance, psi4.frequency(); API; will compute molecular vibrational frequencies, and psi4.optimize(); API; will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains; code to analyze the nature of intermolecular interactions between two; molecules, via symmetry-adapted perturbation theory (SAPT); (Jeziorski:1994:1887).; This kind of analysis gives a lot of insight into the nature of; intermolecular interactions, and Psi4 makes these computations easier; than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for each molecule, and separate the two with two; dashes, like this:. In [7]:. # Example SAPT computation for ethene*ethyne (*i.e.*, ethylene*acetylene).; # Test case 16 from S22 Database. dimer = psi4.geometry(""""""; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:11285,optimiz,optimize,11285,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,12,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,".01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; ---------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:7347,optimiz,optimization,7347,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,6,['optimiz'],"['optimization', 'optimized']"
Performance,".01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True, dertype=1). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; 1; 2; 3; 4; 5; 6; 7 Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:7958,optimiz,optimization,7958,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,18,['optimiz'],"['optimization', 'optimized']"
Performance,".01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True, dertype=1). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:7985,optimiz,optimization,7985,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,27,['optimiz'],"['optimization', 'optimized']"
Performance,".0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf.html:16902,optimiz,optimized,16902,psi4manual/1.0.0/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf.html,8,['optimiz'],['optimized']
Performance,".0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; guess sad; }. energy('scf', cast_up = '3-21G'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically visible in the output as a non-converging; SCF which eventually settles down to steady oscillation between two (or more); different total energies. This behavior can be ameliorated by choosing occupied; orbitals by “shape” instead of by orbital eigenvalue, i.e., by choosing the set; of new orbitals which looks most like some previously known “good” set. The; “good” set is typically the occupied orbitals from an one of the oscillating; iterations with the lowest total energy. For an oscillating system where the; lowest total energy occurs on iterations , invoking; MOM_START can often rescue the convergence of the SCF. MOM c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:15394,optimiz,optimized,15394,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['optimiz'],['optimized']
Performance,".0e-30. OPDM_GRID_DUMP¶. Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. OPDM_GRID_STEPSIZE¶. Step size (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: false. PROP_ALL¶. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. WRITE_NOS¶. Do write natural orbitals (molden). Type: boolean; Default: false. XI¶. Do compute Xi?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. AEL¶. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. OPDM_ONLY¶. For internal use only! Compute the one-particle density matrix, but not the two-particle density matrix. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: SCF. XI_CONNECT¶. Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. table of contents. CCDENSITY; General; AO_BASIS; CACHELEVEL; DEBUG; GAUGE; INTS_TOLERANCE; ONEPDM; ONEPDM_GRID_CUTOFF; ONEPDM_GRID_DUMP; ONEPDM_GRID_STEPSIZE; OPDM_GRID_CUTOFF; OPDM_GRID_DUMP; OPDM_GRID_STEPSIZE; OPDM_RELAX; PROP_ALL; PROP_ROOT; PROP_SYM; REFERENCE; ROOTS_PER_IRREP; WRITE_NOS; XI; ZETA. Expert; AEL; OPDM_ONLY; WFN; XI_CONNECT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; CCDENSITY. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__ccdensity.html:2767,CACHE,CACHELEVEL,2767,psi4manual/1.6.x/autodir_options_c/module__ccdensity.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__ccdensity.html,1,['CACHE'],['CACHELEVEL']
Performance,".1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Brea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:9080,Optimiz,Optimized,9080,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,2,['Optimiz'],['Optimized']
Performance,".2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:cla",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:59130,optimiz,optimize,59130,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,9,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,".2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally retu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:60881,optimiz,optimize,60881,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,3,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,".4;  · . PSI4. PSI4 API: Linking C++ and Python; properties. properties¶. psi4.driver.properties(*args, **kwargs)[source]¶; Function to compute various properties. Aliases; prop(). Returns; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.properties-1.html:1026,optimiz,optimized,1026,psi4manual/1.4.0/api/psi4.driver.properties-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.properties-1.html,2,['optimiz'],['optimized']
Performance,".5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12409,Queue,Queue,12409,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Queue'],['Queue']
Performance,".5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True, zero=ZERO):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt, zero). [docs] def inertia_tensor_partial(self, part, masswt=True, zero=ZERO):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:29797,Queue,Queue,29797,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Queue'],['Queue']
Performance,".5. KEEP_INTCOS¶. Keep internal coordinate definition file. Type: boolean; Default: false. LINESEARCH_STATIC_MAX¶. If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.100. LINESEARCH_STATIC_MIN¶. If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.001. LINESEARCH_STATIC_N¶. If doing a static line search, scan this many points. Type: integer; Default: 8. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. table of contents. OPTKING; Optimization Algorithm; CONSECUTIVE_BACKSTEPS; DYNAMIC_LEVEL; ENSURE_BT_CONVERGENCE; FIXED_BEND; FIXED_DIHEDRAL; FIXED_DISTANCE; FROZEN_BEND; FROZEN_CARTESIAN; FROZEN_DIHEDRAL; FROZEN_DISTANCE; GEOM_MAXITER; H_UPDATE_DEN_TOL; INTERFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT_MAX; INTRAFRAG_STEP_LIMIT_MIN; IRC_DIRECTION; IRC_STEP_SIZE; IRC_STOP; OPT_COORDINATES; OPT_TYPE; PRINT_OPT_PARAMS; PRINT_TRAJECTORY_XYZ_FILE; RFO_FOLLOW_ROOT; RFO_NORMALIZATION_MAX; RFO_ROOT; RSRFO_ALPHA_MAX; STEP_TYPE; SYMM_TOL. Convergence Control; FLEXIBLE_G_CONVERGENCE; G_CONVERGENCE; MAX_DISP_G_CONVERGENCE; MAX_ENERGY_G_CONVERGENCE; MAX_FORCE_G_CONVERGENCE; RMS_DISP_G_CONVERGENCE; RMS_FORCE_G_CONVERGENCE. Hessian Update; CART_HESS_READ; FULL_HESS_EVERY; HESS_UPDATE; HESS_UPDATE_LIMIT; HESS_UPDATE_LIMIT_MAX; HESS_UPDATE_LIMIT_SCALE; HESS_UPDATE_USE_LAST; INTRAFRAG_HESS. Fragment/Internal Coordinate Control; ADD_AUXILIARY_BONDS; AUXILIARY_BOND_FACTOR; COVALENT_CONNECT; FRAG_MODE; FRAG_REF_ATOMS; FREEZE_INTERFRAG; FREEZE_INTRAFRAG; H_BOND_CONNECT; H_GUESS_EVERY; INTCOS_GENERATE_EXIT; INTERFRAGMENT_CONNECT; INTERFRAG_DIST_INV; INTERFRAG_HESS; INTERFRAG_MODE. Misc.; FINAL_GEOM_WRITE; FIXED_COORD_FORCE_CONSTANT; KEEP_INTCOS; LINESEARCH_STATIC_MAX; LIN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__optking-1.html:10030,Optimiz,Optimization,10030,psi4manual/1.1.0/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__optking-1.html,11,['Optimiz'],['Optimization']
Performance,".5;  · . PSI4. PSI4 API: Linking C++ and Python; properties. properties¶. psi4.driver.properties(*args, **kwargs)[source]¶; Function to compute various properties. Aliases; prop(). Returns; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.properties-1.html:1026,optimiz,optimized,1026,psi4manual/1.5.0/api/psi4.driver.properties-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.properties-1.html,2,['optimiz'],['optimized']
Performance,".649232019048, 0.0, -2.356023604706); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN',Chrgfield.extern). First a QMMM object is created, then three separate particles are added to this; object before the SCF code is told about its existence on the last line. The; calls to addCharge take the atomic charge, x coordinate, y coordinate, and; z coordinate in that order. The atomic charge is specified in atomic units,; and the coordinates always use the same units as the geometry specification in; the regular QM region. Additional MM molecules may be specified by adding; extra calls to addCharge to describe the full MM region. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2](1, 2) This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf.html:30594,optimiz,optimization,30594,psi4manual/1.0.0/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf.html,2,['optimiz'],['optimization']
Performance,".6;  · . PSI4. PSI4 API: Linking C++ and Python; properties. properties¶. psi4.driver.properties(*args, **kwargs)[source]¶; Function to compute various properties. Aliases; prop(). Returns; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.properties.html:1026,optimiz,optimized,1026,psi4manual/1.6.x/api/psi4.driver.properties.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.properties.html,1,['optimiz'],['optimized']
Performance,".92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.0270226684",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:5423,optimiz,optimize,5423,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,6,['optimiz'],['optimize']
Performance,".; """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class TestComparisonError(PsiException):; """"""Error called when a test case fails due to a failed; compare_values() call. Prints error message *msg* to standard; output stream and output file. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nPsiException: %s\n\n' % msg. [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging and iterative method. Parameters; ----------; eqn_description : str; Type of QC routine that has failed (e.g., SCF); iteration : int; What iteration we failed on. """""". def __init__(self, eqn_description, iteration):; msg = ""Could not converge %s in %d iterations."" % (eqn_description, iteration); PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer."""""". def __init__(self, eqn_description, iteration, wfn):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; wfn : psi4.core.Wavefunction; Wavefunction at time of exception; e_conv : float; Change in energy for last iteration; d_conv : float; RMS change in density for last iteration. """""". def __init__(self, eqn_description, iteration, wfn, e_conv, d_conv):; ConvergenceError.__init__(self, eqn_description, iteration); self.e_conv = e_conv; self.d_conv = d_conv; self.wfn = wfn. [docs]class CSXError(PsiException):; """"""Error called when CSX generation fails. """""". def __init__(self, msg):; PsiException.__init__(self, msg); self.message = '\nCSXException: %s\n\n' % msg. [docs]class ManagedMethodError(PsiException):; def __init__(self, circs):; if circs[5] == '':; msg = """"""{0}: Method '",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/exceptions.html:3004,Optimiz,OptimizationConvergenceError,3004,psi4manual/1.3.2/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/exceptions.html,2,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimizer']"
Performance,".; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; #@END LICENSE; #. """"""Module with functions that call the four main :py:mod:`driver`; functions: :py:mod:`driver.energy`, :py:mod:`driver.optimize`,; :py:mod:`driver.response`, and :py:mod:`driver.frequency`. """"""; import re; import os; import math; import warnings; import pickle; import copy; import collections; import psi4; import p4const; import p4util; from driver import *; #from extend_Molecule import *; from molutil import *; from p4regex import *; # never import aliases into this file. # Function to make calls among wrappers(), energy(), optimize(), etc.; [docs]def call_function_in_1st_argument(funcarg, **largs):; r""""""Function to make primary function call to energy(), opt(), etc.; with options dictionary *largs*.; Useful when *funcarg* to call is stored in variable. """"""; return funcarg(**largs). [docs]def convert(p, symbol):; if symbol[p] == 'H':; d = 1.001; if symbol[p] == 'He':; d = 1.012; if symbol[p] == 'Li':; d = 0.825; if symbol[p] == 'Be':; d = 1.408; if symbol[p] == 'B':; d = 1.485; if symbol[p] == 'C':; d = 1.452; if symbol[p] == 'N':; d = 1.397; if symbol[p] == 'O':; d = 1.342; if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:1492,optimiz,optimize,1492,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['optimiz'],['optimize']
Performance,".; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; 1; 2; 3; 4; 5; 6set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2; 1; 2; 3; 4freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3; 1; 2; 3; 4; 5freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4; 1; 2; 3; 4; 5; 6set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:6268,optimiz,optimize,6268,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimize']
Performance,".; Note: gradients with LRC functionals and DF integrals technology are not; currently enabled. We hope to have a patch for this deficit soon. Please let us; know if you have a strong need for this capability, and we will move the; priority up. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:23499,perform,performs,23499,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,2,['perform'],['performs']
Performance,".; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; 1UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and ob",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html:1513,load,loaded,1513,psi4manual/1.3.2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psithoninput-1.html,2,['load'],['loaded']
Performance,".; \(\Rightarrow\) 'HSGA' \(\Leftarrow\) Marshall et al. JCP 135 194102 (2011). subset. 'small'; 'large'. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. NHTBH¶. Database (Truhlar) of non-hydrogen-transfer barrier height reactions.; Geometries and Reaction energies from Truhlar and coworkers at site http://t1.chem.umn.edu/misc/database_group/database_therm_bh/non_H.htm (broken link). cp 'off'; rlxd 'off'; subset. 'small'; 'large'. CORE¶. Database of Pulay corannulene structures. Subsumed into CFLOW. cp 'off' || 'on'; rlxd 'off'. BBI¶. Database (Merz) of protein backbone-backbone interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from Sherrill group, Georgia Tech.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. table of contents. Database — database(); Output; Available Databases; BAKERJCC96; HBC6; NBC10; S22; NCB31; A24; RSE42; O24by5; O24by5mb; RGC10; S66by8; JSCH; ACENES; A24alt; SSI; HTBH; BASIC; S66; S22by5; HTR40; HSG; BENCH12; NHTBH; CORE; BBI; BAKERJCC93. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Database — database(). © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/db.html:25569,optimiz,optimize,25569,psi4manual/1.6.x/db.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/db.html,1,['optimiz'],['optimize']
Performance,".Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). [docs]def tdscf(wfn, **kwargs):; return proc.run_tdscf_excitations(wfn,**kwargs). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.7;  · . PSI4. Module code; psi4.driver.driver. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:103800,optimiz,optimize,103800,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,".Molecule and qcdb.Molecule. cc13c; Tests RHF CCSD(T)gradients. ao-casscf-sp; CASSCF/6-31G** energy point. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. ao-dfcasscf-sp; CASSCF/6-31G** energy point. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dct10; The multiple guesses for DCT amplitudes for ODC-12. pubchem2; Superficial test of PubChem interface. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fnocc5; Test FNO-DF-CCSD(T) energy. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cc12; Single point energies of multiple excited states with EOM-CCSD. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, eith",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:16673,Optimiz,Optimization,16673,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['Optimiz'],['Optimization']
Performance,".OptionsState(; ['GLOBALS', 'DERTYPE']). psi4.set_global_option('DERTYPE', 'FIRST'); run_ocepa(name, **kwargs); psi4.deriv(). optstash.restore(). [docs]def run_cepa0(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CEPA (LCCD) computation. """"""; optstash = p4util.OptionsState(; ['OCC', 'WFN_TYPE'],; ['OCC', 'ORB_OPT']). psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); run_ocepa(name, **kwargs). optstash.restore(). [docs]def run_cepa0_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CEPA(0) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'ORB_OPT']). psi4.set_global_option('DERTYPE', 'FIRST'); psi4.set_local_option('OCC', 'WFN_TYPE', 'OCEPA'); psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); run_ocepa(name, **kwargs); psi4.deriv(). optstash.restore(). [docs]def run_omp2_5(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an orbital-optimized MP2.5 computation. """"""; optstash = p4util.OptionsState(; ['OCC', 'WFN_TYPE']). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); psi4.occ(). optstash.restore(). [docs]def run_omp2_5_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; OMP2.5 gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['OCC', 'WFN_TYPE']). psi4.set_global_option('DERTYPE', 'FIRST'); psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP2.5'); run_omp2_5(name, **kwargs); psi4.deriv(). optstash.restore(). [docs]def run_mp2_5(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a MP2.5 calculation. """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT']). psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); run_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:11088,optimiz,optimized,11088,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['optimiz'],['optimized']
Performance,".SuperFunctional method, [1], [2]. C_clear() psi4.core.JK method, [1], [2]. psi4.core.VBase method, [1], [2]. c_functional() psi4.core.SuperFunctional method, [1], [2]. C_left_add() psi4.core.JK method, [1], [2]. c_omega() psi4.core.SuperFunctional method, [1], [2]. c_os_alpha() psi4.core.SuperFunctional method, [1], [2]. C_right_add() psi4.core.JK method, [1], [2]. c_ss_alpha() psi4.core.SuperFunctional method, [1], [2]. Ca() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Ca_subset() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. CACHELEVEL (ADC). (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (DCFT). (OCC). CACHETYPE (CCENERGY). (CCEOM). CALC_S_SQUARED (DETCI). CANONICALIZE_ACTIVE_FAVG (MCSCF). CANONICALIZE_INACTIVE_FAVG (MCSCF). CART_HESS_READ (OPTKING). Cartesian psi4.core.GaussianType attribute, [1], [2]. Cb() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Cb_subset() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. cbs(). ; extrapolation schemes. output. setting keywords. theory, [1]. cbs() in module psi4. in module psi4.driver. CBSCORRELATIONENERGY. CBSREFERENCEENERGY. CBSTOTALENERGY. CC. ; theory. CC (DETCI). CC(n-1)(n)_LCORRELATIONENERGY. CC(n-1)(n)_LTOTALENERGY. CC(n-1)(n)CORRELATIONENERGY. CC(n-1)(n)TOTALENERGY. CC, coupled cluster. CC2CORRELATIONENERGY. CC2TOTA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:13114,CACHE,CACHETYPE,13114,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['CACHE'],['CACHETYPE']
Performance,".core.HF method). ONEPDM (DFMP2). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() (psi4.core.CIWavefunction method). OPDM_ONLY (CCDENSITY). OPDM_RELAX (CCDENSITY). (DFMP2). open() (psi4.core.IO method). open_check() (psi4.core.IO method). operate() (psi4.core.SymmetryOperation method). opt(). . see optimize(). opt() (in module psi4.driver). OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_RESTART (OPTKING). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() (in module psi4.driver). optimize_geometric() (in module psi4.driver). option_exists_in_module() (in module psi4.core). Options (class in psi4.core). options() (psi4.core.Wavefunction method). options_to_python() (in module psi4.core). OptionsState (class in psi4.driver.p4util). OptionsStateCM() (in module psi4.driver.p4util). OptionState (class in psi4.driver.p4util). ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() (psi4.core.PointFunctions method). ORBITALS_WRITE (SCF). OrbitalSpace (class in psi4.core). order() (psi4.core.CharacterTable method). (psi4.core.PointGroup method). ordered_params (psi4.driver.EmpiricalDispersion attribute). (psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute). OREMP. ; setting keywords. OREMP2 CORRELATION ENERGY. OREMP2 DOUBLES ENERGY. OREMP2 OPPOSITE-SPIN CORRELATION ENERGY. OREMP2 REFERENCE CORRECTION ENERGY. OREMP2 SAME-SPIN CORRELATION ENERGY. OREMP2 SINGLES ENERGY. OREMP2 TOTAL ENERGY. orientation() (psi4.core.MolecularGrid method). orientation_fixed() (psi4.core.Molecule method). origin (psi4.core.OneBodyAOInt attribute). original_coef() (psi4.core.GaussianShell method). ORTH_TYPE (DFOCC). (OCC). OS_SCALE (OCC). outfile_name() (in module ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:88044,Optimiz,Optimized,88044,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['Optimiz'],['Optimized']
Performance,".core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. orientation_fixed() psi4.core.Molecule method. origin psi4.core.AngularMomentumInt attribute. psi4.core.DipoleInt attribute. psi4.core.ElectricFieldInt attribute. psi4.core.ElectrostaticInt attribute. psi4.core.KineticInt attribute. psi4.core.MultipoleInt attribute. psi4.core.NablaInt attribute. psi4.core.OneBodyAOInt attribute. psi4.core.OverlapInt attribute. psi4.core.PotentialInt attribute. psi4.core.PseudospectralInt attribute. psi4.core.QuadrupoleInt attribute. psi4.core.TracelessQuadrupoleInt attribute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:101777,Optimiz,Optimized,101777,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,".core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. orientation_fixed() psi4.core.Molecule method. origin psi4.core.AngularMomentumInt attribute. psi4.core.DipoleInt attribute. psi4.core.ElectricFieldInt attribute. psi4.core.ElectrostaticInt attribute. psi4.core.KineticInt attribute. psi4.core.MultipoleInt attribute. psi4.core.NablaInt attribute. psi4.core.OneBodyAOInt attribute. psi4.core.OverlapInt attribute. psi4.core.PotentialInt attribute. psi4.core.QuadrupoleInt attribute. psi4.core.TracelessQuadrupoleInt attribute. original_coef() psi4.core.GaussianShe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:104852,Optimiz,Optimized,104852,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['Optimiz'],['Optimized']
Performance,".core.Matrix class method, [1], [2]. psi4.core.Vector class method, [1], [2]. from_string() psi4.core.Molecule class method, [1], [2]. Frozen natural orbital coupled cluster. Frozen Natural Orbitals. FROZEN_BEND (OPTKING). FROZEN_CARTESIAN (OPTKING). FROZEN_DIHEDRAL (OPTKING). FROZEN_DISTANCE (OPTKING). FROZEN_DOCC (GLOBALS). FROZEN_UOCC (GLOBALS). frzcpi() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. frzvpi() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Full psi4.core.SaveType attribute, [1], [2]. FULL_HESS_EVERY (OPTKING). FULL_MATRIX (CCEOM). function call. ; geometry optimization. gradient. hessian. vibrational analysis. function_index psi4.core.GaussianShell attribute, [1], [2]. function_to_center() psi4.core.BasisSet method, [1], [2]. function_to_shell() psi4.core.BasisSet method, [1], [2]. Functional class in psi4.core, [1]. functional() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.VBase method, [1], [2]. functionals. functions_local_to_global() psi4.core.BlockOPoints method, [1], [2]. fx() psi4.core.Molecule method, [1], [2]. fy() psi4.core.Molecule method, [1], [2]. fZ() psi4.core.Molecule method, [1], [2]. fz() psi4.core.Molecule method, [1], [2]. fzc() psi4.core.MOSpace method, [1], [2]. fzv() psi4.core.MOSpace method, [1], [2]. G. G_CONVERGENCE (OPTKING). gau2grid. GAUGE (CCDENSITY). (CCRESPONSE). Gaussian Formatted Checkpoint. GaussianShell class in psi4.core, [1]. GaussianType class in psi4.core, [1]. gCP. GDMA. gdma() in module psi4. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:56175,optimiz,optimization,56175,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['optimiz'],['optimization']
Performance,".core.SymmetryOperation) → Annotated[List[Annotated[List[float], FixedSize(3)]], FixedSize(3)]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. table of contents. SymmetryOperation; SymmetryOperation; SymmetryOperation.E(); SymmetryOperation.c2_x(); SymmetryOperation.c2_y(); SymmetryOperation.c2_z(); SymmetryOperation.i(); SymmetryOperation.matrix(); SymmetryOperation.operate(); SymmetryOperation.rotate_n(); SymmetryOperation.rotate_theta(); SymmetryOperation.sigma_xy(); SymmetryOperation.sigma_xz(); SymmetryOperation.sigma_yz(); SymmetryOperation.trace(); SymmetryOperation.transform(); SymmetryOperation.transpose(); SymmetryOperation.unit(); SymmetryOperation.zero(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. © Copyright 2007-2024",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html:2645,Perform,Performs,2645,psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,".core.SymmetryOperation) → Annotated[list[Annotated[list[float], FixedSize(3)]], FixedSize(3)]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. table of contents. SymmetryOperation; SymmetryOperation; SymmetryOperation.E(); SymmetryOperation.c2_x(); SymmetryOperation.c2_y(); SymmetryOperation.c2_z(); SymmetryOperation.i(); SymmetryOperation.matrix(); SymmetryOperation.operate(); SymmetryOperation.rotate_n(); SymmetryOperation.rotate_theta(); SymmetryOperation.sigma_xy(); SymmetryOperation.sigma_xz(); SymmetryOperation.sigma_yz(); SymmetryOperation.trace(); SymmetryOperation.transform(); SymmetryOperation.transpose(); SymmetryOperation.unit(); SymmetryOperation.zero(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. © Copyright 20",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.SymmetryOperation.html:2652,Perform,Performs,2652,psi4manual/master/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,".core.Wavefunction method, [1], [2]. OFFDIAGONAL_CCSD_T (PSIMRCC). OLCCD. ; setting keywords. theory. OMEGA (CCRESPONSE). omega() psi4.core.Functional method, [1], [2]. OMEGA_ERF (MINTS). OMP2. ; setting keywords. theory. OMP2.5. ; setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3. ; setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRONENERGY. one_electron_integrals() psi4.core.MintsHelper method, [1], [2]. OneBodyAOInt class in psi4.core, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). OrbitalSpace class in psi4.core, [1]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt attribute, [1]. psi4.core.OneBodyAOInt attribute, [1], [2]. psi4.core.OverlapInt attribute, [1]. psi4.core.PotentialInt attribute, [1]. psi4.core.PseudospectralInt attri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:71571,optimiz,optimize,71571,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['optimiz'],['optimize']
Performance,".core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → psi::Matrix¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference gradient computation, from energy points. psi4.core.fd_geoms_freq_0(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_geoms_freq_1(arg0: psi::Molecule, arg1: int) → List[psi::Matrix]¶; Gets list of displacements needed fof a finite difference frequency computation, from gradients, for a given irrep. psi4.core.finalize() → None¶. psi4.core.fisapt(arg0: psi::Wavefunction) → float¶; Runs the functional-group intramolecular symmetry adapted perturbation theory code. psi4.core.flush_outfile() → None¶; Flushes the output file. psi4.core.fnocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the fno-ccsd(t)/qcisd(t)/mp4/cepa energy code. psi4.core.get_acti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:147933,Perform,Performs,147933,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['Perform'],['Performs']
Performance,".dat and writes by default to a file called output.dat, in this; case one could also just type psi4). If it works, it should print; the final energy as; @UHF Final Energy: -38.92534160932308. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt.; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After about 4 cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; ----------------------------------------------------------------------; Step Energy Delta(E) MAX force MAX Delta(q); ----------------------------------------------------------------------; 1 -76.026653665892 -76.026653665892 1.52e-02 1.52e-02",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:4391,optimiz,optimizing,4391,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,4,['optimiz'],['optimizing']
Performance,".exceptions import *; isP4regime = False; from .dashparam import *; from .molecule import Molecule. [docs]def run_dftd3(mol, func=None, dashlvl=None, dashparam=None, dertype=None, verbose=False):; """"""Compute dispersion correction using Grimme's DFTD3 executable. Function to call Grimme's dftd3 program to compute the -D correction; of level `dashlvl` using parameters for the functional `func`.; `dashparam` can supply a full set of dispersion parameters in the; absence of `func` or individual overrides in the presence of `func`. The DFTD3 executable must be independently compiled and found in; :envvar:`PATH` or :envvar:`PSIPATH`. Parameters; ----------; mol : qcdb.Molecule or psi4.core.Molecule or str; 	 Molecule on which to run dispersion calculation. Both qcdb and; 	 psi4.core Molecule classes have been extended by this method, so; 	 either allowed. Alternately, a string that can be instantiated; 	 into a qcdb.Molecule.; func : str or None; 	 Density functional (Psi4, not Turbomole, names) for which to; 	 load parameters from dashcoeff[dashlvl][func]. This is not; 	 passed to DFTD3 and thus may be a dummy or `None`. Any or all; 	 parameters initialized can be overwritten via `dashparam`.; dashlvl : {'d2p4', 'd2gr', 'd3zero', 'd3bj', 'd3mzero', d3mbj', 'd', 'd2', 'd3', 'd3m'}; 	 Flavor of a posteriori dispersion correction for which to load; 	 parameters and call procedure in DFTD3. Must be a keys in; 	 dashcoeff dict (or a key in dashalias that resolves to one).; dashparam : dict, optional; 	 Dictionary of the same keys as dashcoeff[dashlvl] used to; 	 override any or all values initialized by; 	 dashcoeff[dashlvl][func].; dertype : {None, 0, 'none', 'energy', 1, 'first', 'gradient'}, optional; 	 Maximum derivative level at which to run DFTD3. For large; 	 `mol`, energy-only calculations can be significantly more; 	 efficient. Also controls return values, see below.; verbose : bool, optional; When `True`, additionally include DFTD3 output in output. Returns; -------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html:2448,load,load,2448,psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/qcdb/interface_dftd3.html,1,['load'],['load']
Performance,".extras['qcvars']['CURRENT GRADIENT']. dipole_available = False; if 'CURRENT DIPOLE' in task.extras['qcvars']:; reference['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']; dipole_available = True. # load AtomicComputer results into findifrec[displacements]; for label, displacement in self.findifrec[""displacements""].items():; task = results_list[label]; response = task.return_result. if task.driver == 'energy':; displacement['energy'] = response. elif task.driver == 'gradient':; displacement['gradient'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif task.driver == 'hessian':; displacement['hessian'] = response; displacement['energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; displacement['gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; displacement['dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. # apply finite difference formulas and load derivatives into findifrec[reference]; if self.metameta['mode'] == '1_0':; G0 = assemble_gradient_from_energies(self.findifrec); self.findifrec[""reference""][self.driver.name] = G0. elif self.metameta['mode'] == '2_1':; if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_gradients(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. elif self.metameta['mode'] == '2_0':; try:; G0 = assemble_gradient_from_energies(self.findifrec); except KeyError:; core.print_out(""Unable to construct reference gradient from Hessian displacements.""); # TODO: this happens properly when the requested symmetry block; # of displacements don't have the totally symmetric displacements; # needed for gradient. For both this case; # and distributed computing are-we-there-yet? queries,; # should have a probe as to whether all the; # findif[displacemen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:48229,load,load,48229,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['load'],['load']
Performance,".format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, dertype=dertype, **kwargs); fmaster.write((""""""retE, retwfn = optimize('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1). # Build string of title banner; banners = ''; banners += """"""core.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""core.print_out('\\n')\n\n"""""". if opt_mode == 'continuous':. # print progress to file and screen; core.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(core.get_variable('CURRENT ENERGY')). # S/R: Write each displaced geometry to an input file; elif opt_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); freagent.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); freagent.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write((""""""electronic_energy = energy('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); freagent.write((""""""core.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)).encode('utf-8')); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n"""""".encod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:42478,Perform,Perform,42478,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['Perform'],['Perform']
Performance,".format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(fmaster, lmode=2, return_wfn=True, dertype=dertype, **kwargs); fmaster.write((""""""retE, retwfn = optimize('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); fmaster.write(instructionsM.encode('utf-8')). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if opt_mode == 'continuous':. # print progress to file and screen; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)); print("""""" %d"""""" % (n + 1), end=('\n' if (n + 1 == ndisp) else '')); sys.stdout.flush(). # Load in displacement into the active molecule; moleculeclone.set_geometry(displacement). # Perform the energy calculation; E, wfn = energy(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); energies.append(psi4.get_variable('CURRENT ENERGY')). # S/R: Write each displaced geometry to an input file; elif opt_mode == 'sow':; moleculeclone.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; with open('%s.in' % (rfile), 'wb') as freagent:; freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); freagent.write(p4util.format_molecule_for_input(moleculeclone).encode('utf-8')); freagent.write(p4util.format_options_for_input().encode('utf-8')); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write((""""""electronic_energy = energy('%s', **kwargs)\n\n"""""" % (lowername)).encode('utf-8')); freagent.write((""""""psi4.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)).encode('utf-8')); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n"""""".encod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:41144,Perform,Perform,41144,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Perform'],['Perform']
Performance,".get_option('OPTKING', 'INTCOS_GENERATE_EXIT'):; if not core.get_option('OPTKING', 'KEEP_INTCOS'):; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if not core.get_option('OPTKING', 'KEEP_INTCOS'):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). n += 1. if not core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT'):; if not core.get_option('OPTKING', 'KEEP_INTCOS'):; core.opt_clean(). optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hart",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:68695,Optimiz,Optimizer,68695,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,4,"['Optimiz', 'optimiz']","['Optimization', 'Optimizer', 'optimization']"
Performance,".library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]). [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; return False; else:; return True. @staticmethod; [docs] def load_pickled(dbname, path=None):; """""". """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; picklefile = psiutil.findfile_ignorecase(dbname,; pre=os.path.abspath(path) + os.sep, post='_WDb.pickle'); if not picklefile:; raise ValidationError(""Pickle file for loading database data from file %s does not exist"" % (; os.path.abspath(path) + os.sep + dbname + '.pickle')); # with open('/var/www/html/bfdb_devel/bfdb/scratch/ASDFlogfile.txt', 'a') as handle:; # handle.write('<!-- PICKLE %s\n' % (picklefile)); with open(picklefile, 'rb') as handle:; instance = pickle.load(handle); return instance. [docs] def available_modelchems(self, union=True):; """"""Returns all the labels of model chemistries that have been; loaded. Either all modelchems that have data for any reaction if; *union* is True or all modelchems that have data for all reactions; if *union* is False. """"""; mcs = [set(v.data) for v in self.hrxn.itervalues()]; if union:; return sorted(set.union(*mcs)); else:; return sorted(set.intersection(*mcs)). [docs] def benchmark(self):; """"""Returns the model chemistry label for the database's benchmark.""""""; bm = None; rxns = self.hrxn.itervalues(); while bm is None:; try:; bm = next(rxns).benchmark; except StopIteration:; break; return bm; # return next(self.hrxn.itervalues()).benchmark; # TODO all rxns have same bench in db module so all have same here in obj; # but the way things stored in Reactions, this doesn't have to be so. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""Loads subsets from all functions in module *modname*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:41654,load,loaded,41654,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loaded']
Performance,".n == 5:; self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[4][4] = 1.0. [docs] def c2_y(self):; """"""Set equal to C2 about the y axis. """"""; self.i(); if self.n == 2 or self.n == 3 or self.n == 4:; self.d[1][1] = 1.0; if self.n == 4:; self.d[2][2] = 1.0; elif self.n == 5:; self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[3][3] = 1.0. [docs] def c2_z(self):; """"""Set equal to C2 about the z axis. """"""; self.i(); if self.n == 2 or self.n == 3 or self.n == 4:; self.d[1][1] = 1.0; if self.n == 4:; self.d[2][2] = 1.0; elif self.n == 5:; self.d[0][0] = 1.0; self.d[1][1] = 1.0; self.d[3][3] = 1.0. # <<< Methods for Operations >>>. [docs] def operate(self, r):; """"""This operates on this with r (i.e. return r * this). """"""; if r.n != self.n:; raise ValidationError(""SymRep::operate(): dimensions don't match""). ret = SymRep(self.n); for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += r[i][k] * self.d[k][j]; ret[i][j] = t; return ret. [docs] def transform(self, r):; """"""This performs the transform r * this * r~. """"""; if r.n != self.n:; raise ValidationError(""SymRep::operate(): dimensions don't match""). foo = SymRep(n); # foo = r * d; for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += r[i][k] * d[k][j]; foo[i][j] = t. ret = SymRep(n); # ret = (r*d)*r~ = foo*r~; for i in range(self.n):; for j in range(self.n):; t = 0.0; for k in range(self.n):; t += foo[i][k] * r[j][k]; ret[i][j] = t. return ret. [docs] def rotation(self, theta):; """"""Set equal to a clockwise rotation by 2pi/n or theta degrees. """"""; if isinstance(theta, int):; theta = 2.0 * math.pi if theta == 0 else 2.0 * math.pi / theta. ctheta = math.cos(theta); stheta = math.sin(theta); c2theta = math.cos(2 * theta); s2theta = math.sin(2 * theta). self.zero(); if self.n == 1:; self.d[0][0] = 1.0. elif self.n == 3:; self.d[0][0] = ctheta; self.d[0][1] = stheta; self.d[1][0] = -stheta; self.d[1][1] = ctheta; self.d[2][2] = 1.0. elif self.n == 2 or self.n == 4:; self.d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:14027,perform,performs,14027,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['perform'],['performs']
Performance,".py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; 1; 2>>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). 1; 2>>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). 1; 2>>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; 1; 2>>> # [1] single-poin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:18916,optimiz,optimization,18916,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,8,['optimiz'],"['optimization', 'optimize']"
Performance,".rst. * Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy. The cbs() function requires, at a minimum, ``name='scf'`` and ``scf_basis``; keywords to be specified for reference-step only jobs and ``name`` and; ``corl_basis`` keywords for correlated jobs. The following energy methods have been set up for cbs(). .. hlist::; :columns: 5. * scf; * mp2; * mp2.5; * mp3; * mp4(sdq); * mp4; * mp\ *n*; * omp2; * omp2.5; * omp3; * olccd; * lccd; * lccsd; * cepa(0); * cepa(1); * cepa(3); * acpf; * aqcc; * qcisd; * cc2; * ccsd; * fno-ccsd; * bccd; * cc3; * qcisd(t); * ccsd(t); * fno-ccsd(t); * bccd(t); * cisd; * cisdt; * cisdtq; * ci\ *n*; * fci; * mrccsd; * mrccsd(t); * mrccsdt; * mrccsdt(q). :type name: string; :param name: ``'scf'`` || ``'ccsd'`` || etc. First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be ``'scf'``. Overruled if stage_wfn keywords supplied. :type scf_wfn: string; :param scf_wfn: |dl| ``'scf'`` |dr| || ``'c4-scf'`` || etc. Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as 'scf' is *the* scf in |PSIfour| but; can be used to direct lone scf components to run in |PSIfour| or Cfour; in a mixed-program composite method. :type corl_wfn: string; :param corl_wfn: ``'mp2'`` || ``'ccsd(t)'`` || etc. Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with ``name`` or as the unlabeled; first argument to the function. :type delta_wfn: string; :param delta_wfn: ``'ccsd'`` || ``'ccsd(t)'`` || etc. Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. :type delta_wfn_lesser: string; :param delta_wfn_lesser: |dl| ``corl_wfn`` |dr| || ``'mp2'`` || etc. Indicates t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html:20013,perform,performed,20013,psi4manual/1.0.0/_modules/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver_cbs.html,1,['perform'],['performed']
Performance,".set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:61210,Optimiz,OptimizationConvergenceError,61210,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,1,['Optimiz'],['OptimizationConvergenceError']
Performance,".set_global_option('PUREAM', PsiMod.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; molecule.set_multiplicity(3); PsiMod.print_out('\n'); banner(' Computing high-spin triplet guess '); PsiMod.print_out('\n'). # cast set-up; if (cast):. if yes.match(str(cast)):; guessbasis = '3-21G'; else:; guessbasis = cast. if (castdf):; if yes.match(str(castdf)):; guessbasisdf = corresponding_jkfit(guessbasis); else:; guessbasisdf = castdf. # Switch to the guess namespace; namespace = PsiMod.IO.get_default_namespace(); PsiMod.IO.set_default_namespace((namespace + '.guess')). # Setup initial SCF; PsiMod.set_global_option('BASIS', guessbasis); if (castdf):; PsiMod.set_local_option('SCF', 'SCF_TYPE', 'DF'); PsiMod.set_local_option('SCF', 'DF_INTS_IO', 'none'); PsiMod.set_global_option('DF_BASIS_SCF', guessbasisdf). # Print some info about the guess; PsiMod.print_out('\n'); banner('Guess SCF, %s Basis' % (guessbasis)); PsiMod.print_out('\n'). # the FIRST scf call; if cast or do_broken:; # Perform the guess scf; PsiMod.scf(). # broken clean-up; if do_broken:; molecule.set_multiplicity(1); PsiMod.set_local_option('SCF', 'GUESS', 'READ'); PsiMod.print_out('\n'); banner(' Computing broken symmetry solution from high-spin triplet guess '); PsiMod.print_out('\n'). # cast clean-up; if (cast):. # Move files to proper namespace; PsiMod.IO.change_file_namespace(180, (namespace + '.guess'), namespace); PsiMod.IO.set_default_namespace(namespace). # Set to read and project, and reset bases to final ones; optstash2.restore(); PsiMod.set_local_option('SCF', 'GUESS', 'READ'). # Print the banner for the standard operation; PsiMod.print_out('\n'); banner(name.upper()); PsiMod.print_out('\n'). # the SECOND scf call; e_scf = PsiMod.scf(precallback, postcallback). optstash.restore(); return e_scf. [docs]def run_mp2_select(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing toward the OCC (conv MP2) or the DFMP2 modules. """"""; if (PsiMod.get_opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:17670,Perform,Perform,17670,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Perform'],['Perform']
Performance,.txt; sapt.txt; scf.txt; sowreap.txt; testsuite.txt; thermo.txt; tutorial.txt. /_static; ; basic.css; doctools.js; favicon-psi4.ico; jquery.cookie.js; jquery.js; psi4.css; pygments.css; searchtools.js; toggle_codeprompt.js; toggle_sections.js; toggle_sidebar.js; underscore.js. ADC: Ab Initio Polarization Propagator — Psi4 [1.0.0 6a9a71b] Docs; ADC: Ab Initio Polarization Propagator — Psi4 [1.0.0 6a9a71b] Docs; Appendices — Psi4 [1.0.0 6a9a71b] Docs; Appendices — Psi4 [1.0.0 6a9a71b] Docs. /autodir_options_c; ; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; MEMORY — Psi4 [1.0.0 6a9a71b] Docs; NEWTON_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; NORM_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; POLE_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; PR — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [1.0.0 6a9a71b] Docs; SEM_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; AEL — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; GAUGE — Psi4 [1.0.0 6a9a71b] Docs; INTS_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_DUMP — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_STEPSIZE — Psi4 [1.0.0 6a9a71b] Docs; OPDM_RELAX — Psi4 [1.0.0 6a9a71b] Docs; PROP_ALL — Psi4 [1.0.0 6a9a71b] Docs; PROP_ROOT — Psi4 [1.0.0 6a9a71b] Docs; PROP_SYM — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; XI — Psi4 [1.0.0 6a9a71b] Docs; XI_CONNECT — Psi4 [1.0.0 6a9a71b] Docs; ZETA — Psi4 [1.0.0 6a9a71b] Docs; ABCD — Psi4 [1.0.0 6a9a71b] Docs; ANALYZE — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; BCCD_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; BRUECKNER_ORBS_R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; CACHETYPE — Psi4 [1.0.0 6a9a71b] Docs; CC_NUM_THREADS — Psi4 [1.0.0 6a9a71b],MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:182178,CACHE,CACHELEVEL,182178,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['CACHE'],['CACHELEVEL']
Performance,.txt; thermo.txt; tutorial.txt. _static; ; basic.css; doctools.js; favicon-psi4.ico; jquery.cookie.js; jquery.js; psi4.css; pygments.css; searchtools.js; toggle_codeprompt.js; toggle_sections.js; toggle_sidebar.js; underscore.js. Programmers’ Manual — Psi4 [1.0.0 6a9a71b] Docs; ADC: Ab Initio Polarization Propagator — Psi4 [1.0.0 6a9a71b] Docs; ADC: Ab Initio Polarization Propagator — Psi4 [1.0.0 6a9a71b] Docs; Appendices — Psi4 [1.0.0 6a9a71b] Docs; Appendices — Psi4 [1.0.0 6a9a71b] Docs. autodir_options_c; ; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; MEMORY — Psi4 [1.0.0 6a9a71b] Docs; NEWTON_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; NORM_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; POLE_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; PR — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [1.0.0 6a9a71b] Docs; SEM_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; AEL — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; GAUGE — Psi4 [1.0.0 6a9a71b] Docs; INTS_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_DUMP — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_STEPSIZE — Psi4 [1.0.0 6a9a71b] Docs; OPDM_RELAX — Psi4 [1.0.0 6a9a71b] Docs; PROP_ALL — Psi4 [1.0.0 6a9a71b] Docs; PROP_ROOT — Psi4 [1.0.0 6a9a71b] Docs; PROP_SYM — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; XI — Psi4 [1.0.0 6a9a71b] Docs; XI_CONNECT — Psi4 [1.0.0 6a9a71b] Docs; ZETA — Psi4 [1.0.0 6a9a71b] Docs; ABCD — Psi4 [1.0.0 6a9a71b] Docs; ANALYZE — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; BCCD_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; BRUECKNER_ORBS_R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; CACHETYPE — Psi4 [1.0.0 6a9a71b] Docs; CC_NUM_THREADS — Psi4 [1.0.0 6a9a71b],MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:38777,CACHE,CACHELEVEL,38777,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['CACHE'],['CACHELEVEL']
Performance,"/ 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while White or Queue: # Iterates to the next fragment; Fragment.append([]). while Queue: # BFS within a fragment; for u in Queue: # find all white neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt(; (self.x(i) - self.x(u)) ** 2 +; (self.y(i) - self.y(u)) ** 2 +; (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + \; vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # & remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if White: # can't move White -> Queue if empty; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the psi4.Molecule class. """"""; cls.__setattr__ = new_set_attr; cls.__getattr__ = new_get_attr; cls.BFS = BFS. dynamic_variable_bind(psi4.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name*; from the geometry in string *geom*. Permitted for user use but deprecated in; driver in favor of explicit molecule-passing. """"""; molecule = psi4.Molecule.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html:6676,Queue,Queue,6676,psi4manual/1.0.0/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html,1,['Queue'],['Queue']
Performance,"/ 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH`. """"""; # Validate arguments; if self is Non",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:6800,Queue,Queue,6800,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Queue'],['Queue']
Performance,/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. omp2.5; Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. olccd; Orbital-Optimized Linear CCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE CONV. Density-Fitted Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE DF. Cholesky-Decomposed Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; —; CC_TYPE CD. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for -systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for -systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (resid,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:8048,Optimiz,Optimized,8048,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['Optimiz'],['Optimized']
Performance,/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. omp2.5; Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. olccd; Orbital-Optimized Linear CCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE CONV. Density-Fitted Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE DF. Cholesky-Decomposed Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; —; CC_TYPE CD. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amp,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:10891,Optimiz,Optimized,10891,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,11,['Optimiz'],['Optimized']
Performance,"/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Treatment; Functional Selection; Grid Selection; ERI Algorithms; IP Fitting; Fractional Particle Curves; Dispersion Corrections; Recommendations. DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory; Introduction; Theory; Recommendations; Conventional MP2. OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory; Introduction; Theory; Methods; Basic Keywords; Advanced Keywords. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Implementation. SAPT: Symmetry-Adapted Perturbation Theory; A First Example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Interpreting SAPT Results. CEPA: Coupled-Pair Methods; Basic Coupled Pair Keywords; Advanced Coupled Pair Keywords. CC: Coupled Cluster Methods; Basic Keywords; Larger Calculations; Excited State Coupled Cluster Calculations; Linear Response (CCLR) Calculations. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. Interface to MRCC by M. Kállay; Installation; Running MRCC. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Basis Sets; Next topic; Notes on Options; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » . © Copyright 2012, The Psi4 Project.; Last updated on Oct 21, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/methods-1.html:2076,Optimiz,Optimization,2076,psi4manual/4.0b3/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/methods-1.html,6,['Optimiz'],"['Optimization', 'Optimizations', 'Optimizing']"
Performance,/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:7190,optimiz,optimized,7190,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['optimiz'],['optimized']
Performance,/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Methods. Name; Calls Method; Energy; Gradient; Reference. ocepa; Orbital-Optimized CEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-ocepa; Spin-Component Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-ocepa; Spin-Opposite Scaled Orbital-Optimized CEPA; Y; N; RHF/ROHF/UHF/RKS/UKS. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Basic Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:6593,optimiz,optimized,6593,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,2,['optimiz'],['optimized']
Performance,"/UHF; RHF/UHF; MP_TYPE CONV. Density-Fitted MP3; RHF/UHF; RHF/UHF; MP_TYPE DF. Cholesky-Decomposed MP3; RHF/UHF; —; MP_TYPE CD. mp2.5; MP2.5; RHF/UHF; RHF/UHF; MP_TYPE CONV. Density-Fitted MP2.5; RHF/UHF; RHF/UHF; MP_TYPE DF. Cholesky-Decomposed MP2.5; RHF/UHF; —; MP_TYPE CD. lccd; Linearized CCD; RHF/UHF; RHF/UHF; CC_TYPE CONV. Density-Fitted LCCD; RHF/UHF; RHF/UHF; CC_TYPE DF. Cholesky-Decomposed LCCD; RHF/UHF; —; CC_TYPE CD. ccd; CCD; —; —; CC_TYPE CONV. Density-Fitted CCD; RHF; RHF; CC_TYPE DF. Cholesky-Decomposed CCD; RHF; —; CC_TYPE CD. ccsd; CCSD; —; —; CC_TYPE CONV. Density-Fitted CCSD; RHF; RHF; CC_TYPE DF. Cholesky-Decomposed CCSD; RHF; —; CC_TYPE CD. ccsd(t); CCSD(T); —; —; CC_TYPE CONV. Density-Fitted CCSD(T); RHF; RHF; CC_TYPE DF. Cholesky-Decomposed CCSD(T); RHF; —; CC_TYPE CD. ccsd(at); Lambda-CCSD(T); —; —; CC_TYPE CONV. Density-Fitted Lambda-CCSD(T); RHF; —; CC_TYPE DF. Cholesky-Decomposed Lambda-CCSD(T); RHF; —; CC_TYPE CD. table of contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced OCC Keywords; OPT_METHOD; MO_DIIS_NUM_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Basic DFOCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ORB_OPT. Advanced DFOCC Keywords; OPT_METHOD; HESS_TYPE; MO_DIIS_NUM_VECS; ORTH_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/occ-1.html:17766,Optimiz,Optimized,17766,psi4manual/1.2.1/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/occ-1.html,2,['Optimiz'],['Optimized']
Performance,"/cc-pVDZ (C4), and; CCSD(T)/cc-pVTZ (C4) single-points.; molecule {; H 0.0 0.0 0.0; H 1.0 0.0 0.0; }. set mp2_type conv. cbs('mp2', corl_basis='cc-pV[TQ]Z', delta_wfn='c4-ccsd(t)', delta_basis='cc-pV[DT]Z'). This yields:; ==> CBS <==. ---------------------------------------------------------------------------------------------------------; Stage Method / Basis Energy [H] Scheme; ---------------------------------------------------------------------------------------------------------; scf scf / cc-pvqz -1.10245974 highest_1; corl mp2 / cc-pv[tq]z -0.03561890 corl_xtpl_helgaker_2; delta c4-ccsd(t) - mp2 / cc-pv[dt]z 0.03507767 corl_xtpl_helgaker_2; total CBS -1.10300098; ---------------------------------------------------------------------------------------------------------. Note that especially for cbs(), the; basis set needs to be specified through BASIS, not; CFOUR_BASIS. Many of the wrappers can be used in combination to,; for example, apply a compound method to every molecule in a database or to; optimize a molecule with an extrapolated basis set (findif only for the; moment- analytics coming).; Finally, any number and combination of jobs can be run from a single; PSI4 input file. Depending on the nature of preceding or following; jobs, it is prudent to separate them with the following:; clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties the cfour block. Warning; Because p4c4 does not inspect the contents of the cfour {...}; block, once the user specifies a PSI4-style molecule, the; interface cannot judge whether a sandwich mode (drop the PSI4 molecule; and use the cfour block as the entirety of the ZMAT) or a standard mode; (translate the PSI4 molecule and append additional input from the; cfour block) is intended. The latter is what actually occurs. If; there is both a PSI4 molecule and a molecule in the cfour block,; ZMAT will end up with multiple molecules and multiple *CFOUR(...); blocks, and it will ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:17383,optimiz,optimize,17383,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,9,['optimiz'],['optimize']
Performance,"/cc-pVDZ energy of H2O+. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dcft1; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. Previous topic; Bibliography; Next topic; <no title>; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 07, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/testsuite-1.html:23585,perform,performs,23585,psi4manual/4.0b4/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/testsuite-1.html,2,['perform'],['performs']
Performance,"/disk/for/scratch/files. PSI4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are written to the; designated scratch numbered by content and labeled; with the process id, then are deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the PSI4 I/O management routines is available,; and is called psi4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to your input; file:; 1psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; 1; 2; 3; 4import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; 1; 2; 3; 4; 5; 6psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). # equivalent to above; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calcu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:5932,queue,queue,5932,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['queue'],['queue']
Performance,"/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir. cd {top-level-psi4-dir} && cmake -S. -Bobjdir; cd {top-level-psi4-dir} && cmake -S. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-level-psi4-dir are permitted. How to save configuration settings for a future compilation¶; Create a file like do-configure with the cmake command and options; on one line.; >>> cd {top-level-psi4-dir}; >>> cat do-configure; cmake -S. -B{objdir} \; -DCMAKE_INSTALL_PATH=""/Users/",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:23839,optimiz,optimizations,23839,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,9,['optimiz'],['optimizations']
Performance,"/local/psi4¶; The installation directory is the filesystem location for the executable; script, the Python module, basis set data, and other administrative files.; Unless using the conda package, which is relocatable, the installation; directory must be specified with CMake variable CMAKE_INSTALL_PREFIX; before compiling. Build with Specific Install Directory; cmake -DCMAKE_INSTALL_PREFIX=/nfs/common/software/psi4. Relevant CMake Options:; CMAKE_INSTALL_PREFIX=PATH # Location to which Psi4 and internally built; # add-ons are installed (default: /usr/local/psi4). Note; It’s not guaranteed, but if, in a pinch, you need to install a; built Psi4 to a location not configured by CMAKE_INSTALL_PREFIX,; recursively copy the folders under objdir/stage/prefix to; the desired location, chown them if needed, edit the shebang in; bin/psi4 if needed, and recursively delete all the “.pyc” files. It; may just run. How to compile for debugging¶; Flags to turn optimizations off and debugging on can be set across the; project and plugins with CMake variable CMAKE_BUILD_TYPE before; compiling. Note that these flags will not propagate to any add-ons that; are detected pre-built rather than built. Build without optimization; cmake -DCMAKE_BUILD_TYPE=debug. set the CMake build type [default: release]. Relevant CMake Options:; CMAKE_BUILD_TYPE=[debug|release] # Build type (Release or Debug)"" [default: release]. How to fix error “RuntimeError: value for ERI”¶; You will need to rebuild Libint. Reissue cmake or edit; CMakeCache.txt with larger MAX_AM_ERI and rebuild. How to configure code to use high angular momentum basis sets; How to get high angular momentum integrals from conda. How to choose the compilation directory, {objdir}¶. there is no default; common choices are objdir or build under top-level-psi4-dir; cd {top-level-psi4-dir} && cmake -H. -Bobjdir; cd {top-level-psi4-dir} && cmake -H. -Bbuild. in-source builds (*.cc and *.o in same directory) are disallowed; builds outside top-leve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:18060,optimiz,optimizations,18060,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,4,['optimiz'],['optimizations']
Performance,"/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/psi-ghost-grad; MP2 optimization of dimers with",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html:1523,optimiz,optimization,1523,psi4manual/1.6.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"0 -0.114520000000 0.000000000000; H -1.934259000000 0.762503000000 0.000000000000; H -0.599677000000 0.040712000000 0.000000000000; O 1.350625000000 0.111469000000 0.000000000000; H 1.680398000000 -0.373741000000 -0.758561000000; H 1.680398000000 -0.373741000000 0.758561000000. Elemental masses (most common isotope), symbols, and atomic numbers from psi4.; Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_values(expected, computed, digits, label)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits.; Performs a system exit on failure. Used in input files in the test suite. query_yes_no(question, default=True)[source]¶; Ask a yes/no question via raw_input() and return their answer.; question is a string that is presented to the user.; default is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user).; The return value is one of True or False. File for accessory procedures in the chem module.; Credit for the libmints vector3 class to Justin M. Turney and; incremental improvements by other psi4 developers. add(v, u)[source]¶; Compute sum of vectors v and u. cross(v, u)[source]¶; Compute cross product of length 3 vectors v and u. determinant(mat)[source]¶; Given 3x3 matrix mat, compute the determinat. diagonalize3x3symmat(M)[source]¶; Given an real symmetric 3x3 matrix M, compute the eigenvalues. distance(v, u)[source]¶; Compute the distance between points defined by vectors v and u. dot(v, u)[source]¶; Compute dot prod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:67256,Perform,Performs,67256,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['Perform'],['Performs']
Performance,"0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. """"""; # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(); molname = molecule.name(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = list(range(numatoms)); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(numatoms):; A = F[f + 1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < _autofragment_convert(u, symbol) + _autofragment_convert(i, symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". moleculenew = psi4.Molecule.create_molecule_from_stri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html:3400,Queue,Queue,3400,psi4manual/1.0.0/_modules/wrapper_autofrag.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html,3,['Queue'],['Queue']
Performance,"0 6a9a71b] Docs; Counterpoise Correct — Psi4 [1.0.0 6a9a71b] Docs; Counterpoise Correct — Psi4 [1.0.0 6a9a71b] Docs; Notes on Options — Psi4 [1.0.0 6a9a71b] Docs; Notes on Options — Psi4 [1.0.0 6a9a71b] Docs; Notes on Options — Psi4 [1.0.0 6a9a71b] Docs; Notes on Options — Psi4 [1.0.0 6a9a71b] Docs; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories — Psi4 [1.0.0 6a9a71b] Docs; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories — Psi4 [1.0.0 6a9a71b] Docs; oeprop() Evaluation of One-Electron Properties — Psi4 [1.0.0 6a9a71b] Docs; oeprop() Evaluation of One-Electron Properties — Psi4 [1.0.0 6a9a71b] Docs; Geometry Optimization, optimize() and gradient() — Psi4 [1.0.0 6a9a71b] Docs; Geometry Optimization, optimize() and gradient() — Psi4 [1.0.0 6a9a71b] Docs; LibOptions: globals, locals, has_changed and all that — Psi4 [1.0.0 6a9a71b] Docs; LibOptions: globals, locals, has_changed and all that — Psi4 [1.0.0 6a9a71b] Docs; Geometry Optimization — Psi4 [1.0.0 6a9a71b] Docs; Geometry Optimization — Psi4 [1.0.0 6a9a71b] Docs; Interface to PCMSolver — Psi4 [1.0.0 6a9a71b] Docs; Interface to PCMSolver — Psi4 [1.0.0 6a9a71b] Docs; PEP1: Proposing PsiPEP for Psi4 — Psi4 [1.0.0 6a9a71b] Docs; PEP1: Proposing PsiPEP for Psi4 — Psi4 [1.0.0 6a9a71b] Docs; Plugins: Adding New Functionality to Psi4 — Psi4 [1.0.0 6a9a71b] Docs; Plugins: Adding New Functionality to Psi4 — Psi4 [1.0.0 6a9a71b] Docs; Adding Methods to Driver — Psi4 [1.0.0 6a9a71b] Docs; Adding Methods to Driver — Psi4 [1.0.0 6a9a71b] Docs; BasisSet — Psi4 [1.0.0 6a9a71b] Docs; BasisSet — Psi4 [1.0.0 6a9a71b] Docs; Programming: Using the Core Libraries — Psi4 [1.0.0 6a9a71b] Docs; Programming: Using the Core Libraries — Psi4 [1.0.0 6a9a71b] Docs; Property — Psi4 [1.0.0 6a9a71b] Docs; Property — Psi4 [1.0.0 6a9a71b] Docs; PSIMRCC Implementation of Mk-MRCC Theory — Psi4 [1.0.0 6a9a71b] Docs; PSIMRCC Implementation of Mk-MRCC Theory — Psi4 [1.0.0 6a9a71b] Docs; PsiP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:144135,Optimiz,Optimization,144135,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['Optimiz'],['Optimization']
Performance,"0)}; + E_{ind,resp}^{(30)})\]; Additionally, high-order coupling between induction and dispersion can be; extracted from the supermolecular MP2 interaction energy:. \[\delta_{MP2}^{(2)} = E_{int}^{MP2, corr} - (E_{elst}^{(12)} +; E_{exch}^{(11)} + E_{exch}^{(12)} + \; ^{t}\!E_{ind}^{(22)}; + \; ^{t}\!E_{exch-ind}^{(22)} + E_{disp}^{(20)} + E_{exch-disp}^{(20)})\]. \[\delta_{MP2}^{(3)} = \delta_{MP2}^{(2)} - (E_{ind-disp}^{(30)} + E_{exch-ind-disp}^{(30)})\]; where \(E_{int}^{MP2, corr}\) is the correlation part of the supermolecular MP2; interaction energy. \(\delta_{MP2}^{(2)}\) and \(\delta_{MP2}^{(3)}\) also improve the; description of electrostatically dominated complexes. \(\delta_{MP2}^{(2)}\); can be applied to SAPT2+ or SAPT2+(3) energies whereas \(\delta_{MP2}^{(3)}\); should be applied to SAPT2+3 energies.; A thorough analysis of the performance of these truncations of closed-shell SAPT can be; found in a review by Hohenstein and Sherrill [Hohenstein:2012:WIREs],; and a systematic study of the accuracy of these truncations (with and; without an improved CCD treatment of dispersion) using different basis sets; is reported in [Parker:2014:094106].; The closed-shell SAPT module relies entirely on the density-fitting approximation; of the two-electron integrals. The factorization of the SAPT energy; expressions, as implemented in PSI4, assumes the use of density-fitted; two-electron integrals, therefore, the closed-shell SAPT module cannot be run with; exact integrals. In practice, we have found that the density-fitting; approximation introduces negligible errors into the SAPT energy; (often less than 0.01 kcal/mol for small dimers) and greatly; improves efficiency.; The latest addition to the SAPT code is the SAPT0 method for open-shell; monomers [Gonthier:2016:134106]. This code is available for both exact and density fitted integrals,; except for the dispersion terms which implementation relies on a density fitting; factorization. Both UHF and ROHF REFERENC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:8064,perform,performance,8064,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,15,['perform'],['performance']
Performance,"0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]¶. right = [1.0, 0.0, 0.0]¶. save_density(filename='rho', overlap=2.0, n=[40, 40, 40], caxis=[0.0, 1.0])[source]¶. save_molecule(filename)[source]¶. set_camera(location, sky, up, right, look_at, light, light_color)[source]¶. set_color(Z, color)[source]¶. set_define(key, value)[source]¶. set_radius(Z, radius)[source]¶. set_size(width, height)[source]¶. set_view(azimuth, elevation, zoom=0.7)[source]¶. sky = [0.0, -1.0, 0.0]¶. up = [0.0, 0.75, 0.0]¶. update_geometry()[source]¶. width = 1200¶. zoom = 0.5¶. Module with utility functions for use in input files. compare_arrays(expected, computed, digits, label)[source]¶; Function to compare two numpy arrays. Prints util.success(); when elements of vector computed match elements of vector expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. compare_csx()[source]¶; Function to validate energies in CSX files against PSIvariables. Only; active if write_csx flag on. compare_cubes(expected, computed, label)[source]¶; Function to compare two cube files. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_integers(expected, computed, label)[source]¶; Function to compare two integers. Prints util.success(); when value computed matches value expected.; Performs a system exit on failure. Used in input files in the test suite. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:131831,Perform,Performs,131831,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Perform'],['Performs']
Performance,"0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). classmethod from_list(x)¶. classmethod from_serial()¶; Converts serialized data to the correct Psi4 data type; :rtype: Union[Matrix, Vector]. Parameters:. self – Pointer to which class to be constructed.; json_data (Dict[str, Any]) – Serialization of class. See to_serial() for data layout. Return type:; Matrix | Vector. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice) → psi4.core.Vector¶; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension) → None¶; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Load the vector from disk. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:5258,Load,Load,5258,psi4manual/1.9.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html,1,['Load'],['Load']
Performance,0.0 6a9a71b] Docs; EFP — Psi4 [1.0.0 6a9a71b] Docs; FINDIF — Psi4 [1.0.0 6a9a71b] Docs; FISAPT — Psi4 [1.0.0 6a9a71b] Docs; FNOCC — Psi4 [1.0.0 6a9a71b] Docs; GDMA — Psi4 [1.0.0 6a9a71b] Docs; GLOBALS — Psi4 [1.0.0 6a9a71b] Docs; MCSCF — Psi4 [1.0.0 6a9a71b] Docs; MINTS — Psi4 [1.0.0 6a9a71b] Docs; MRCC — Psi4 [1.0.0 6a9a71b] Docs; OCC — Psi4 [1.0.0 6a9a71b] Docs; OPTKING — Psi4 [1.0.0 6a9a71b] Docs; PSIMRCC — Psi4 [1.0.0 6a9a71b] Docs; SAPT — Psi4 [1.0.0 6a9a71b] Docs; SCF — Psi4 [1.0.0 6a9a71b] Docs; THERMO — Psi4 [1.0.0 6a9a71b] Docs; TRANSQT2 — Psi4 [1.0.0 6a9a71b] Docs; E_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; INTS_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; MRCC_LEVEL — Psi4 [1.0.0 6a9a71b] Docs; MRCC_METHOD — Psi4 [1.0.0 6a9a71b] Docs; MRCC_NUM_DOUBLET_ROOTS — Psi4 [1.0.0 6a9a71b] Docs; MRCC_NUM_SINGLET_ROOTS — Psi4 [1.0.0 6a9a71b] Docs; MRCC_NUM_TRIPLET_ROOTS — Psi4 [1.0.0 6a9a71b] Docs; MRCC_OMP_NUM_THREADS — Psi4 [1.0.0 6a9a71b] Docs; MRCC_RESTART — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; CC_DIIS_MAX_VECS — Psi4 [1.0.0 6a9a71b] Docs; CC_DIIS_MIN_VECS — Psi4 [1.0.0 6a9a71b] Docs; CC_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; CCL_ENERGY — Psi4 [1.0.0 6a9a71b] Docs; CEPA_OS_SCALE — Psi4 [1.0.0 6a9a71b] Docs; CEPA_SOS_SCALE — Psi4 [1.0.0 6a9a71b] Docs; CEPA_SS_SCALE — Psi4 [1.0.0 6a9a71b] Docs; CEPA_TYPE — Psi4 [1.0.0 6a9a71b] Docs; CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; DO_DIIS — Psi4 [1.0.0 6a9a71b] Docs; DO_LEVEL_SHIFT — Psi4 [1.0.0 6a9a71b] Docs; DO_SCS — Psi4 [1.0.0 6a9a71b] Docs; DO_SOS — Psi4 [1.0.0 6a9a71b] Docs; E_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; E3_SCALE — Psi4 [1.0.0 6a9a71b] Docs; EA_POLES — Psi4 [1.0.0 6a9a71b] Docs; EKT_EA — Psi4 [1.0.0 6a9a71b] Docs; EKT_IP — Psi4 [1.0.0 6a9a71b] Docs; EP_EA_POLES — Psi4 [1.0.0 6a9a71b] Docs; EP_IP_POLES — Psi4 [1.0.0 6a9a71b] Docs; EP_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; IP_POLES — Psi4 [1.0.0 6a9a71b] Docs; LEVEL_SHIFT — Psi4 [1.0.0 6a9a71b] Docs; LINEQ_SOLVER — Psi4 [1.0.0 6a9a71b] Docs,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:72613,CACHE,CACHELEVEL,72613,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,0.0 6a9a71b] Docs; LOCAL_WEAKP — Psi4 [1.0.0 6a9a71b] Docs; MAXITER — Psi4 [1.0.0 6a9a71b] Docs; NEW_TRIPLES — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; OVERLAP_CHECK — Psi4 [1.0.0 6a9a71b] Docs; PROP_ROOT — Psi4 [1.0.0 6a9a71b] Docs; PROP_SYM — Psi4 [1.0.0 6a9a71b] Docs; R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; RESTART_EOM_CC3 — Psi4 [1.0.0 6a9a71b] Docs; RHF_TRIPLETS — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [1.0.0 6a9a71b] Docs; SCHMIDT_ADD_RESIDUAL_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; SEMICANONICAL — Psi4 [1.0.0 6a9a71b] Docs; SINGLES_PRINT — Psi4 [1.0.0 6a9a71b] Docs; SS_E_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; SS_R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; SS_SKIP_DIAG — Psi4 [1.0.0 6a9a71b] Docs; SS_VECS_PER_ROOT — Psi4 [1.0.0 6a9a71b] Docs; T3_WS_INCORE — Psi4 [1.0.0 6a9a71b] Docs; VECS_CC3 — Psi4 [1.0.0 6a9a71b] Docs; VECS_PER_ROOT — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; EOM_REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; T_AMPS — Psi4 [1.0.0 6a9a71b] Docs; WABEI_LOWDISK — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; ABCD — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; DIIS — Psi4 [1.0.0 6a9a71b] Docs; JOBTYPE — Psi4 [1.0.0 6a9a71b] Docs; LOCAL — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CPHF_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_FILTER_SINGLES — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_METHOD — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_PAIRDEF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_WEAKP — Psi4 [1.0.0 6a9a71b] Docs; MAXITER — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; PROP_ALL — Psi4 [1.0.0 6a9a71b] Docs; PROP_ROOT — Psi4 [1.0.0 6a9a71b] Docs; PROP_SYM — Psi4 [1.0.0 6a9a71b] Docs; R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; RESTART — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [1.0.0 6a9a71b] Docs; SEK,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:42807,CACHE,CACHELEVEL,42807,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,"0.001, maxiter=20, **kwargs)[source]¶; Optimize DFT omega parameter for molecular system. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l (float) – Minimum omega to be considered during fitting.; omega_r (float) – Maximum omega to be considered during fitting.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence (float) – Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter (int) – Maximum number of iterations towards omega convergence. Returns:; Optimal omega parameter. Return type:; float. psi4.driver.frac.frac_traverse(name, **kwargs)[source]¶; Scan electron occupancy from +1 electron to -1. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult (Optional[int]) – Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult (Optional[int]) – Multiplicity of anion, if not neutral multiplicity + 1.; frac_start (Optional[int]) – Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs (Optional[List]) – Occupations to step through for cation, by default [1 - 0.1 * x for x in range(11)].; LUMO_occs (Optional[List]) – Occupations to step through for anion, by default [1 - 0.1 * x for x in range(11)].; HOMO (Optional[int]) – Index of HOMO.; LUMO (Optional[int]) – Index of LUMO.; frac_diis (Optional[bool]) – Do use DIIS for non-1.0-occupied points?; neutral_guess (Optional[bool]) – Do use neutral orbitals as guess for the anion?; hf_guess (Optional[bool]) – Do use UHF guess before UKS?; continuous_guess (Optional[bool]) – Do carry along guess rather than reguessing at each occupation?; filename (Optional[str]) –",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/external_apis.html:4128,tune,tuned,4128,psi4manual/master/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/master/external_apis.html,4,['tune'],['tuned']
Performance,"0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. psi4.driver.inputparser.process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Parameters:. raw_input (str) – Input in a mixture of Python and PSIthon syntax.; print_level (int) – raw_input is printed to the output file unless print_level =0. Return type:; str. psi4.driver.frac.ip_fitting(name, omega_l=0.05, omega_r=2.5, omega_convergence=0.001, maxiter=20, **kwargs)[source]¶; Optimize DFT omega parameter for molecular system. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l (float) – Minimum omega to be considered during fitting.; omega_r (float) – Maximum omega to be considered during fitting.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence (float) – Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter (int) – Maximum number of iterations towards omega convergence. Returns:; Optimal omega parameter. Return type:; float. psi4.driver.frac.frac_traverse(name, **kwargs)[source]¶; Scan electron occupancy from +1 electron to -1. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not las",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/external_apis.html:3130,Optimiz,Optimize,3130,psi4manual/1.7.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/external_apis.html,2,['Optimiz'],['Optimize']
Performance,0.229015; —; —; —; —; —. SB98-1B; SB98-1b Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.199352; —; —; —; —; —. SB98-1C; SB98-1c Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.192416; —; —; —; —; —. SB98-2A; SB98-2a Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.232055; —; —; —; —; —. SB98-2B; SB98-2b Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.237978; —; —; —; —; —. SB98-2C; SB98-2c Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.219847; —; —; —; —; —. SOGGA11-X; SOGGA11-X Hybrid Exchange-Correlation Functional; Y; —; —; 0.401500; —; —; —; —; —. SOGGA11-X-D3BJ; SOGGA11-X Hybrid Exchange-Correlation Functional; Y; —; —; 0.401500; —; —; —; Y;  . TPSSH; TPSSh Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TPSSH-D3BJ; TPSSh-d3bj Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y;  . TPSSH-NL; TPSSh-nl Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TUNED-CAM-B3LYP; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; 0.150000; 0.079900; —; —; —; —; —. WB97M-D3BJ; wB97M-V with D3(BJ) instead of VV10 dispersion; Y; Y; 0.300000; 0.150000; —; —; —; Y;  . WB97M-V; wB97M-V Hyb-GGA Exchange-Correlation Functional; Y; Y; 0.300000; 0.150000; —; —; —; —; —. WB97X; wB97X Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; —; —. WB97X-D; wB97X-D Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.222036; —; —; —; Y;  . WB97X-D3BJ; wB97X-V with D3(BJ) instead of VV10 dispersion; Y; —; 0.300000; 0.167000; —; —; —; Y;  . WB97X-V; wB97X-V Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.167000; —; —; —; —; —. WPBE0; PBE0 SR-XC Functional (HJS Model); Y; —; 0.300000; 0.250000; —; —; —; —; —. X1B95; X1B95 Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.300000; —; —; —; —; —. X3LYP; X3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.218000; —; —; —; —; —. X3LYP-D3BJ; X3LYP-d3bj Hyb-GGA Exchange-Correlation Functional; Y; —; —; ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_dft_hybrid-1.html:14204,TUNE,TUNED-CAM-,14204,psi4manual/1.3.2/autodoc_dft_hybrid-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_dft_hybrid-1.html,8,['TUNE'],['TUNED-CAM-']
Performance,0.229015; —; —; —; —; —. SB98-1B; SB98-1b Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.199352; —; —; —; —; —. SB98-1C; SB98-1c Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.192416; —; —; —; —; —. SB98-2A; SB98-2a Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.232055; —; —; —; —; —. SB98-2B; SB98-2b Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.237978; —; —; —; —; —. SB98-2C; SB98-2c Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.219847; —; —; —; —; —. SOGGA11-X; SOGGA11-X Hybrid Exchange-Correlation Functional; Y; —; —; 0.401500; —; —; —; —; —. SOGGA11-X-D3BJ; SOGGA11-X Hybrid Exchange-Correlation Functional; Y; —; —; 0.401500; —; —; —; Y;  . TPSSH; TPSSh Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TPSSH-D3BJ; TPSSh-d3bj Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y;  . TPSSH-NL; TPSSh-nl Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TUNED-CAM-B3LYP; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; 0.150000; 0.079900; —; —; —; —; —. WB97M-V; wB97M-V Hyb-GGA Exchange-Correlation Functional; Y; Y; 0.300000; 0.150000; —; —; —; —; —. WB97X; wB97X Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; —; —. WB97X-D; wB97X-D Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.222036; —; —; —; Y;  . WB97X-V; wB97X-V Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.167000; —; —; —; —; —. WPBE0; PBE0 SR-XC Functional (HJS Model); Y; —; 0.300000; 0.250000; —; —; —; —; —. X1B95; X1B95 Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.300000; —; —; —; —; —. X3LYP; X3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.218000; —; —; —; —; —. X3LYP-D3BJ; X3LYP-d3bj Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.218000; —; —; —; Y;  . XB1K; XB1K Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.430000; —; —; —; —; —. Double-Hybrid¶. Double-Hybrid functionals available in PSI4¶. Name; Description; GGA?; Meta,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft_byfunctional-1.html:52400,TUNE,TUNED-CAM-,52400,psi4manual/1.2.1/dft_byfunctional-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft_byfunctional-1.html,4,['TUNE'],['TUNED-CAM-']
Performance,0.229015; —; —; —; —; —. SB98-1B; SB98-1b Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.199352; —; —; —; —; —. SB98-1C; SB98-1c Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.192416; —; —; —; —; —. SB98-2A; SB98-2a Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.232055; —; —; —; —; —. SB98-2B; SB98-2b Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.237978; —; —; —; —; —. SB98-2C; SB98-2c Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.219847; —; —; —; —; —. SOGGA11-X; SOGGA11-X Hybrid Exchange-Correlation Functional; Y; —; —; 0.401500; —; —; —; —; —. SOGGA11-X-D3BJ; SOGGA11-X Hybrid Exchange-Correlation Functional; Y; —; —; 0.401500; —; —; —; Y;  . TPSSH; TPSSh Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TPSSH-D3BJ; TPSSh-d3bj Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y;  . TPSSH-NL; TPSSh-nl Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TUNED-CAM-B3LYP; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; 0.150000; 0.079900; —; —; —; —; —. WB97M-V; wB97M-V Hyb-GGA Exchange-Correlation Functional; Y; Y; 0.300000; 0.150000; —; —; —; —; —. WB97X; wB97X Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; —; —. WB97X-D; wB97X-D Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.222036; —; —; —; Y;  . WB97X-V; wB97X-V Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.167000; —; —; —; —; —. WPBE0; PBE0 SR-XC Functional (HJS Model); Y; —; 0.300000; 0.250000; —; —; —; —; —. X1B95; X1B95 Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.300000; —; —; —; —; —. X3LYP; X3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.218000; —; —; —; —; —. X3LYP-D3BJ; X3LYP-d3bj Hyb-GGA Exchange-Correlation Functional; Y; —; —; 0.218000; —; —; —; Y;  . XB1K; XB1K Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.430000; —; —; —; —; —. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_dft_hybrid-1.html:14408,TUNE,TUNED-CAM-,14408,psi4manual/1.2.1/autodoc_dft_hybrid-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_dft_hybrid-1.html,4,['TUNE'],['TUNED-CAM-']
Performance,"000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation; options:. In [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). Out[8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options(); API; are “global” options (meaning that they are visible to all parts of the; program). Most common Psi4 options can be set like this. If an option; needs to be visible only to one part of the program (e.g., we only; want to increase the energy convergence in the SCF code, but not the; rest of the code), it can be set by with the; psi4.set_module_options(); API; function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like; psi4.set_options(); API,; psi4.set_module_options(); API,; psi4.energy(); API,; psi4.optimize(); API,; psi4.frequency(); API,; etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT; computations (i.e., SAPT0), a good error cancellation is found; (Hohenstein:2012:WIREs); with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but; without diffuse functions on hydrogen and without diffuse \(d\); functions on heavy atoms); (Papajak:2011:10).; So, we’ll use that as our standard basis set. The SAPT code is designed; to use density fitting techniques, because they introduce minimal errors; while providing much faster computations; (Hohenstein:2010:184111,Hohenstein:2010:014101).; Since we’re using density fitting for the SAPT, we might as well also; use it for the Hartree-Fock computations that are performed as part of; the SAPT. We can specify that by adding 'scf_type': 'df' to the; dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:13374,optimiz,optimize,13374,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['optimiz'],['optimize']
Performance,"0000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation options:. [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': 'true'}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). [8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options() API are “global” options (meaning that they are visible to all parts of the program). Most common Psi4 options can be set like this. If an option needs to be visible only to one part of the program (e.g., we only want to increase the energy convergence in the SCF code, but not the rest of the code), it can be set by with the; psi4.set_module_options() API function, psi4.set_module_options('scf', {'e_convergence': '1e-8'}).; Note: The arguments to the functions we’ve used so far, like psi4.set_options() API, psi4.set_module_options() API, psi4.energy() API, psi4.optimize(); API, psi4.frequency() API, etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT computations (i.e., SAPT0), a good error cancellation is found (Hohenstein:2012:WIREs) with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and without diffuse \(d\) functions on heavy atoms) (Papajak:2011:10). So,; we’ll use that as our standard basis set. The SAPT code is designed to use density fitting techniques, because they introduce minimal errors while providing much faster computations (Hohenstein:2010:184111,Hohenstein:2010:014101). Since we’re using density fitting for the SAPT, we might as well also use it for the Hartree-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:13304,optimiz,optimize,13304,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['optimiz'],['optimize']
Performance,"0043793.; Variant with ghosted hydrogen as midbonds in the COM. no | name | subset. 1 | CN - He | DD; 2 | NH - He | DD; 3 | C2H3 - C2H4 | DD; 4 | O2 - H2 | DD; 5 | NH - Ar | DD; 6 | CN - Ar | DD; 7 | O2 - N2 | DD; 8 | H2O - O2(sp) | DD; 9 | O2 - O2 | DD. 10 | NH - NH | ED; 11 | CH2O - NH2 | ED; 12 | H2O - Na | ED; 13 | H2O - OH | ED; 14 | H2O - O2H | ED; 15 | Li - NH3(gm) | ED; 16 | Li - O2 | MX; 17 | CN - H2 | MX; 18 | Li - NH3(lm) | MX; 19 | H2O - O2(gm) | MX; 20 | Na - Li | MX; 21 | CO2 - O2 | MX; 22 | C2H3 - CO2 | MX; 23 | He* - He* | MX; 24 | HF - CO+ | MX. cp 'on'; subset; - 'DD' dispersion-dominated systems; - 'ED' electrostatically-dominated systems; - 'MX' mixed-interaction systems. BBI¶. Database (Merz) of protein backbone-backbone interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from Sherrill group, Georgia Tech.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. NBC10¶. Database (Sherrill) of interaction energies for dissociation curves of dispersion-bound bimolecular complexes.; Geometries and Reference interaction energies from the following articles:. Benzene Dimers from Sherrill et al. JPCA 113 10146 (2009).; Benzene-Hydrogen Sulfide from Sherrill et al. JPCA 113 10146 (2009).; Benzene-Methane from Sherrill et al. JPCA 113 10146 (2009).; Methane Dimer from Takatani et al. PCCP 9 6106 (2007).; Pyridine Dimers from Hohenstein et al. JPCA 113 878 (2009).; Collection into NBC10 from Burns et al. JCP 134 084107 (2011).; Revised reference interaction energies (NBC10A) from Marshall et al. JCP 135 194102 (2011). cp 'off' || 'on'; rlxd 'off'; benchmark. 'NBC100' Burns et al. JCP 134 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_available_databases-1.html:4784,optimiz,optimize,4784,psi4manual/1.4.0/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_available_databases-1.html,4,['optimiz'],['optimize']
Performance,"0249. Type: double; Default: 1.0e-4. SCF_INITIAL_START_DIIS_TRANSITION¶. SCF error at which to start the linear interpolation between DIIS steps and steps of the initial SCF accelerator. Value taken from Garza and Scuseria, DOI: 10.1063/1.4740249. Type: double; Default: 1.0e-1. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html:8835,perform,performed,8835,psi4manual/1.6.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html,1,['perform'],['performed']
Performance,"05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6. optimization; 8. frequency [7]; 8. CC property [2]; 8. Footnotes. [1]; Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2]; (1,2); This applies to properties computed through the properties() function. [3]; Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]; Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]; The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]; The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defined; according to the q",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:56754,optimiz,optimization,56754,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,4,['optimiz'],['optimization']
Performance,"05488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table of the different R values and the CP-corrected CCSD(T) energies, converted from atomic units (Hartree) to kcal mol\(^{-1}\) by multiplying by the automatically-defined conversion factor psi4.constants.hartree2kcalmol. Psi4 provides several built-in physical constants and conversion factors, as described in the Psi4 manual section Physical; Constants. The table can be printed either to the screen, by using standard Python ``print()` syntax <https://docs.python.org/3/whatsnew/3.0.html#print-is-a-function>`__, or to the designated output file output.dat using Psi4’s built-in function psi4.core.print_out() API (C style printing).; As we’ve seen so far, the combination of Psi4 and Python creates a unique, interactive approach to quantum chemistry. The next section will explore this synergistic relationship in greater detail, describing how even very complex tasks can be done very easily with Psi4. table of contents. PsiAPI Tutorial: Using Psi4 as a Python Module; I. Basic Input Structure; II. Running a Basic Hartree-Fock Calculation; III. Geometry Optimization and Vibrational Frequency Analysis; IV. Analysis of Intermolecular Interactions; V. Potential Surface Scans and Counterpoise Correction Made Easy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:23168,Optimiz,Optimization,23168,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,1,['Optimiz'],['Optimization']
Performance,"06) paper defining the functional. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dft1-alt; DFT Functional Test. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. dcft3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dcft-grad3; Restricted DF-DCFT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mints3; Test individual integral objects for correctness. options1; check all variety of opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:4244,perform,performs,4244,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"0740325136 -9.73841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to; 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamilt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:3013,perform,performed,3013,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['perform'],['performed']
Performance,"087; # (1.1, 102) -75.990085 -76.201498 -76.204676. h2o = psi4.geometry(""""""; O; H 1 R; H 1 R 2 A; """"""). Rvals = [0.9, 1.0, 1.1]; Avals = range(100, 103, 2). rows = []; table = []. psi4.set_options({""basis"": ""cc-pvdz""}). for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; psi4.energy('mp2'); escf = psi4.variable('SCF TOTAL ENERGY'); edfmp2 = psi4.variable('MP2 TOTAL ENERGY'); escsmp2 = psi4.variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.221605; # (1.0, 100) -76.021264 -76.224987 -76.228727; # (1.0, 102) -76.021460 -76.224946 -76.228668; # (1.1, 100) -75.990195 -76.201891 -76.205087; # (1.1, 102) -75.990085 -76.201498 -76.204676. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; As seen in the neon dimer example from the tutorial section,; the nbody() wrapper provides automatic computation of; counterpoise-corrected interaction energies between two molecules. For; example,. PSIthonPsiAPIenergy('mp2', bsse_type='cp'). psi4.energy('mp2', bsse_type='cp'). will compute the counterpoise-corrected density-fitted MP2 interaction energy; between two molecules.; PSI4 also provides the cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,. PSIthonPsiAPI# all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). energy('mp2/cc-pv[dt]z'). # all equivalent. psi4.energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). psi4.energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapola",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:16039,perform,performed,16039,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['perform'],['performed']
Performance,"0942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:7503,optimiz,optimization,7503,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['optimiz'],['optimization']
Performance,"0942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True, dertype=1). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; 1; 2; 3; 4; 5; 6; 7 Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:8114,optimiz,optimization,8114,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['optimiz'],['optimization']
Performance,"0942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s important to obtain the vibrational frequencies; at the OPTIMIZED GEOMETRY. We could set up a second input file to perform; the vibrational frequency analysis, being very careful to copy over the; optimized geometry from the bottom of the output file for the geometry; optimization. This geometry could be specified in either z-matrix or; Cartesian formats. However, there’s a much easier way to do this. If we; specify a vibrational frequency analysis in the same input file as the; optimization, after the optimization function has been called, then the; optimized geometry will automatically be carried over.; So, it’s easiset to do the optimization and vibrational frequency analysis; together. This can be specified as follows (see test case; tu4-h2o-freq):; #! Optimization followed by frequencies H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'); scf_e, scf_wfn = frequencies('scf', return_wfn=True, dertype=1). The program will do the same optimization as in our previous example,; but then it will follow it with some computations to obtain the Hessian; (second derivative matrix) of the electronic energy with respect to; nuclear displacements. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:8141,optimiz,optimization,8141,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,9,['optimiz'],['optimization']
Performance,"0; aHCC2 = 109.0; aHCC3 = 109.0; dHCCC1 = 0.0; dHCCC2 = 120.0; dHCCC3 = 240.0; }. Here, we remove the hydrogen from the alpha carbon of glycine and replace it; with a methyl group. Applying this patch using Cartesian coordinates is; difficult, because it depends on the orientation of the existing glycine unit.; In this example, we use Z-Matrix coordinates to define the methyl group, and; define the orientation in terms of the existing glycine Cartesian coordinates; which is much easier to visualize than the corresponding Cartesian-only; approach. Multiple Molecules¶; To facilitate more elaborate computations, it is possible to provide a name for; each molecule, and tell PSI4 which one should be used in a given; calculation. For example, consider the following input file:; molecule h2{; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; energy('scf'). molecule h{; H; }. set basis cc-pvdz; set reference uhf; energy('scf'). Here, two separate jobs are performed on two different molecules; the first is; performed on H2, while the second is for H atom. The last molecule to be; specified is the “active” molecule by default. To explicitly activate a named; molecule, the activate keyword is provided. Using this keyword, the above input; file can be equivalently written as follows:; molecule h2{; H; H 1 0.9; }. molecule h{; H; }. activate(h2); set basis cc-pvdz; set reference rhf; energy('scf'). activate(h); set basis cc-pvdz; set reference uhf; energy('scf'). Note that whenever the molecule is changed, the basis set must be specified; again. The following section provides more details about the job control; keywords used in the above examples. Molecule Keywords¶; In addition to specifying the geometry, additional information can be; provided in the molecule optional_molecule_name {...} block.; If two integers charge multiplicity are encountered on any; line of the molecule block, they are interpreted as the molecular charge; and multiplicity (), respectively. The symmetry;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:6787,perform,performed,6787,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,8,['perform'],['performed']
Performance,"1 file. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'); }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'); }; delta = {; 'w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html:2958,perform,performed,2958,psi4manual/1.6.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/aliases.html,1,['perform'],['performed']
Performance,"1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = { 'energy' : step_energies ,; 'gradient' : step_gradients ,; 'coordinates' : step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:64454,optimiz,optimized,64454,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimized']
Performance,"1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_wfn:; return (thisenergy, wfn); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); return thisenergy. core.print_out('\n Structure for next step:\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:62071,optimiz,optimized,62071,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['optimiz'],['optimized']
Performance,"1):; pass; # Do nothing; user said to read existing hessian once; else:; psi4.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; psi4.set_legacy_molecule(moleculeclone); optking_rval = psi4.optking(); moleculeclone = psi4.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == psi4.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if psi4.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); psi4.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if psi4.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if psi4.get_option('OPTKING', 'KEEP_INTCOS') == False:; psi4.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); psi4.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup binary file 1; if custom_gradient or ('/' in lowername):; psi4.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_wfn:; return (thisenergy, wfn); else:; return thisenergy. elif optking_rval == psi4.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); if (psi4.get_option('OPTKING', 'KEEP_INTCOS') == False):; psi4.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); psi4.clean(); optstash.restore(); return thisenergy. psi4.print_out('\n Structure for next step:\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:60229,optimiz,optimized,60229,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimized']
Performance,"1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 benzenesulfonamide; 636822 1,2,4-trimethoxy-5-[(E)-prop-1-enyl]benzene; 7369 benzenesulfonyl chloride; 12932 N-[2-di(propan-2-yloxy)phosphinothioylsulfanylethyl]benzenesulfonamide; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; 1; 2; 3molecule benzene {; pubchem:637563; }. or; 1; 2; 3molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Molecule Keywords, can be; used in conjunction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly, a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4¶. Point Group; 1; 2; 3; 4; 5; 6; 7; 8. \(C_1\); \(A\);  ;  ;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:10304,optimiz,optimized,10304,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['optimiz'],['optimized']
Performance,1.0.0 6a9a71b] Docs; LOCAL_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_METHOD — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_PAIRDEF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_WEAKP — Psi4 [1.0.0 6a9a71b] Docs; MAXITER — Psi4 [1.0.0 6a9a71b] Docs; MP2_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; MP2_OS_SCALE — Psi4 [1.0.0 6a9a71b] Docs; MP2_SS_SCALE — Psi4 [1.0.0 6a9a71b] Docs; NEW_TRIPLES — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; PAIR_ENERGIES_PRINT — Psi4 [1.0.0 6a9a71b] Docs; PROPERTY — Psi4 [1.0.0 6a9a71b] Docs; R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; RESTART — Psi4 [1.0.0 6a9a71b] Docs; SCS_CCSD — Psi4 [1.0.0 6a9a71b] Docs; SCS_MP2 — Psi4 [1.0.0 6a9a71b] Docs; SCSN_MP2 — Psi4 [1.0.0 6a9a71b] Docs; SEMICANONICAL — Psi4 [1.0.0 6a9a71b] Docs; SPINADAPT_ENERGIES — Psi4 [1.0.0 6a9a71b] Docs; T2_COUPLED — Psi4 [1.0.0 6a9a71b] Docs; T3_WS_INCORE — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; ABCD — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; CACHETYPE — Psi4 [1.0.0 6a9a71b] Docs; CC_NUM_THREADS — Psi4 [1.0.0 6a9a71b] Docs; CC3_FOLLOW_ROOT — Psi4 [1.0.0 6a9a71b] Docs; COLLAPSE_WITH_LAST — Psi4 [1.0.0 6a9a71b] Docs; COMPLEX_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; E_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; EOM_GUESS — Psi4 [1.0.0 6a9a71b] Docs; EOM_REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; EXCITATION_RANGE — Psi4 [1.0.0 6a9a71b] Docs; FULL_MATRIX — Psi4 [1.0.0 6a9a71b] Docs; LOCAL — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_DO_SINGLES — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_FILTER_SINGLES — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_GHOST — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_METHOD — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_PRECONDITIONER — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_WEAKP — Psi4 [1.0.0 6a9a71b] Docs; MAXITER — Psi4 [1.0.0 6a9a71b] Docs; NEW_TRIPLES — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; OVERLAP_CHECK — Psi4 [1.0.0 6a9a71b] Docs; PROP_ROOT — Psi,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:41047,CACHE,CACHELEVEL,41047,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,"1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3058,Queue,Queue,3058,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Queue'],['Queue']
Performance,"1.4 supports Python 3.6, 3.7, 3.8, and 3.9.; PSI4 1.5 supports Python 3.7, 3.8, and 3.9.; PSI4 1.6 supports Python 3.8, 3.9, and 3.10.; PSI4 1.7 supports Python 3.8, 3.9, 3.10, and 3.11 (no binary packages for 3.11).; The future plan is to support the approximately three latest Python versions.; The current master supports 3.8, 3.9, 3.10, and 3.11. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties.; For more tables with capabilities details:. Full Capabilities (first below) lists all methods; Capabilities Breakdown (second below) lists selected methods by reference, etc.; Module Capabilities lists selected methods by implementation; Energy, Energy (DFT), Energy (MRCC), Energy (CFOUR) fully list energy target methods; Gradient, Gradient (CFOUR) fully list gradient target methods; Frequency fully lists Hessian target methods. Summary of theoretical methods available in PSI4¶. Method [1]; Reference[2]; Type[2]; Variants[3]. Canonical; OO; FNO [4]; DLPNO. HF; RHF/UHF/ROHF/CUHF; CONV/DF/CD; E/G/H. DFT; RKS/UKS; CONV/DF/CD; E/G. DFT-D2, DFT-NL; RKS/UKS; CONV/DF/CD; E/G. DCT; RHF/UHF; CONV/DF; E/G. MP2; RHF/UH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/introduction.html:23523,optimiz,optimization,23523,psi4manual/1.7.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/introduction.html,2,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = physconst.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in ; :envvar:`PATH`. """"""; # Validate arguments; if self is No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:5962,Queue,Queue,5962,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Queue'],['Queue']
Performance,"1.5. Type: boolean; Default: true. DO_LINK (SCF)¶SCF — Perform the linear scaling exchange (LinK) algorithm, as described in [Ochsenfeld:1998:1663]. Only applies to Direct SCF. Type: boolean; Default: false. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:117341,perform,perform,117341,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,2,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = physconst.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in ; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = PsiMod.get_active_molecule(). dashlvl ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:5998,Queue,Queue,5998,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Queue'],['Queue']
Performance,"1.639; if symbol[p] == 'Ar':; d = 1.595. return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n0 1\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:3374,Queue,Queue,3374,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,1,['Queue'],['Queue']
Performance,"1.9, 1.85, 1.8]. symbol = list(range(numatoms)); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(numatoms):; A = F[f + 1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < _autofragment_convert(u, symbol) + _autofragment_convert(i, symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". moleculenew = psi4.Molecule.create_molecule_from_string(new_geom); moleculenew.set_name(molname); moleculenew.update_geometry(); moleculenew.print_cluster(); psi4.print_out("""""" Exiting auto_fragments\n""""""). return moleculenew. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html:3910,Queue,Queue,3910,psi4manual/1.0.0/_modules/wrapper_autofrag.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html,1,['Queue'],['Queue']
Performance,"10-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:2081,optimiz,optimize,2081,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,1,['optimiz'],['optimize']
Performance,"1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). ODC-06 and ODC-12:. “Orbital-optimized density cumulant functional theory,” A. Yu. Sokolov, and; H. F. Schaefer, J. Chem. Phys. 139, 204110 (2013).; (doi: 10.1063/1.4833138). ODC-13:. “Density cumulant functional theory from a unitary transformation:; N-representability, three-particle correlation effects, and application; to O4+,” A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,; J. Chem. Phys. 141, 074111 (2014).; (doi: 10.1063/1.4892946). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:8265,optimiz,optimized,8265,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,17,['optimiz'],['optimized']
Performance,"11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * 1.00e-06 * 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -76.33224285 -7.63e+01 2.41e-03 1.60e-03 1.51e-02 8.82e-03 o ~; 2 -76.33226097 -1.81e-05 4.84e-04 4.03e-04 7.71e-04 * 7.04e-04 o ~; 3 -76.33226140 -4.39e-07 * 4.31e-05 * 3.58e-05 9.89e-05 * 8.93e-05 o ~; 4 -76.33226141 -4.26e-09 * 9.76e-07 * 6.58e-07 * 6.22e-06 * 3.71e-06 o ~; ----------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:7940,optimiz,optimization,7940,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['optimiz'],['optimization']
Performance,"11; 12; 13molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; 1; 2; 3; 4; 5; 6set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2; 1; 2; 3; 4freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3; 1; 2; 3; 4; 5freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4; 1; 2; 3; 4; 5; 6set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:7374,optimiz,optimizing,7374,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimizing']
Performance,"1304; O -6.944245 -0.111984 -2.805375; H -7.058224 0.807436 -3.049180; C -6.990227 -0.143507 2.907714; H -8.018305 -0.274985 3.264065; H -6.592753 0.807024 3.281508; H -6.368443 -0.968607 3.273516; nocom; unit angstrom; }. # Create a python dictionary and convert to string for pass through to optking; MTdimer = """"""{; ""Natoms per frag"": [12, 16],; ""A Frag"": 1,; ""A Ref Atoms"": [[1, 3, 4, 6, 8], [8], [11]],; ""A Label"": ""methylthiophene"",; ""B Frag"": 2,; ""B Ref Atoms"": [[13, 14, 15, 16, 17, 18], [13], [15]],; ""B Label"": ""tyrosine"",; ""Frozen"": [""theta_A"", ""theta_B"", ""tau"", ""phi_A"", ""phi_B""],; }"""""". set {; basis 6-31+G; frag_mode MULTI; interfrag_coords $MTdimer; }. optimize(""mp2""). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the dynamic level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by loca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:16510,optimiz,optimizer,16510,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,4,['optimiz'],['optimizer']
Performance,"14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mp2_1; All-electron MP2 6-31G** geometry optimization of water. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dcft1; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. Previous topic; Bibliography; Next topic; <no title>; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/testsuite-1.html:16979,perform,performs,16979,psi4manual/4.0b2/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/testsuite-1.html,2,['perform'],['performs']
Performance,"1;  · . PSI4. Installation and Runtime Configuration. Obtaining PSI4¶. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}¶; Take a quiz to find the best version of the codebase for; your needs, be it binary, tarball, or version-controlled repository. Or,; select outright among:. Binary Installer; Clone from GitHub Repository (read-only unless core developer); Fork from GitHub Repository; Tarball from GitHub Repository; Psi3 from SourceForge. Find-the-code Quiz¶. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base.; Provided I still get good, threaded BLAS/LAPACK, I’m willing to; sacrifice processor architecture tuning to avoid compiling it myself.; I’m on Linux or Mac or Windows with Ubuntu Bash Shell.; I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself for best performance on my computer.; I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4.; In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub. I really like parentheses and/or DBOC, so I want Psi3. —; Goto Psi3-from-SourceForge. Binary Installer¶. Get Initially; Just go to http://www.psicode.org/downloads.html and follow the; instructions there. Build; Not applicable as binary is pre-built. Get Updates directions; >>> conda update psi4. Contribute Back; Not applicable as not under git control. Clone from GitHub Repository¶. Get Initially; The PSI4 repository at https://github.com/psi4/psi4 works like; every othe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_obtaining-1.html:1079,perform,performance,1079,psi4manual/1.1.0/build_obtaining-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_obtaining-1.html,2,['perform'],['performance']
Performance,"1], [2]. C_clear() psi4.core.JK method, [1], [2]. c_functional() psi4.core.SuperFunctional method, [1], [2]. c_functionals() psi4.core.SuperFunctional method, [1], [2]. C_left_add() psi4.core.JK method, [1], [2]. c_omega() psi4.core.SuperFunctional method, [1], [2]. c_os_alpha() psi4.core.SuperFunctional method, [1], [2]. C_right_add() psi4.core.JK method, [1], [2]. c_ss_alpha() psi4.core.SuperFunctional method, [1], [2]. Ca() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.SADGuess method, [1], [2]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Ca_subset() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. CACHELEVEL (ADC). (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (DCFT). (OCC). CACHETYPE (CCENERGY). (CCEOM). CALC_S_SQUARED (DETCI). CANONICALIZE_ACTIVE_FAVG (MCSCF). CANONICALIZE_INACTIVE_FAVG (MCSCF). CART_HESS_READ (OPTKING). Cartesian psi4.core.GaussianType attribute, [1], [2]. Cb() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.SADGuess method, [1], [2]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Cb_subset() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. cbs(). ; extrapolation schemes. output. setting keywords. theory, [1]. cbs() in module psi4. in module psi4.driver. CBSC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:16160,CACHE,CACHELEVEL,16160,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['CACHE'],['CACHELEVEL']
Performance,1b] Docs; INDEPENDENT_J_TYPE — Psi4 [1.0.0 6a9a71b] Docs; MODULE — Psi4 [1.0.0 6a9a71b] Docs; OMP_N_THREAD — Psi4 [1.0.0 6a9a71b] Docs; PRINT — Psi4 [1.0.0 6a9a71b] Docs; SCF_TYPE — Psi4 [1.0.0 6a9a71b] Docs; SCHWARZ_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_EXACT_DIAGONAL — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_MAX_SUBSPACE — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_MIN_SUBSPACE — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_N_GUESS — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_N_ROOT — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_NORM — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_PRECONDITION — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_PRECONDITION_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_PRECONDITION_STEPS — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_QUANTITY — Psi4 [1.0.0 6a9a71b] Docs; SOLVER_TYPE — Psi4 [1.0.0 6a9a71b] Docs; TDHF_MEM_SAFETY_FACTOR — Psi4 [1.0.0 6a9a71b] Docs; ALGORITHM — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; DAMPING_PERCENTAGE — Psi4 [1.0.0 6a9a71b] Docs; DCFT_FUNCTIONAL — Psi4 [1.0.0 6a9a71b] Docs; DCFT_GUESS — Psi4 [1.0.0 6a9a71b] Docs; DCFT_TYPE — Psi4 [1.0.0 6a9a71b] Docs; DF_BASIS_DCFT — Psi4 [1.0.0 6a9a71b] Docs; DIIS_MAX_VECS — Psi4 [1.0.0 6a9a71b] Docs; DIIS_MIN_VECS — Psi4 [1.0.0 6a9a71b] Docs; DIIS_START_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; E_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; ENERGY_LEVEL_SHIFT — Psi4 [1.0.0 6a9a71b] Docs; GUESS_R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; IGNORE_TAU — Psi4 [1.0.0 6a9a71b] Docs; INTS_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; MAXITER — Psi4 [1.0.0 6a9a71b] Docs; MO_RELAX — Psi4 [1.0.0 6a9a71b] Docs; MOLDEN_WRITE — Psi4 [1.0.0 6a9a71b] Docs; ODC_GUESS — Psi4 [1.0.0 6a9a71b] Docs; ORBITAL_LEVEL_SHIFT — Psi4 [1.0.0 6a9a71b] Docs; QC_COUPLING — Psi4 [1.0.0 6a9a71b] Docs; QC_TYPE — Psi4 [1.0.0 6a9a71b] Docs; R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; RELAX_GUESS_ORBITALS,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:54448,CACHE,CACHELEVEL,54448,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,"1e-5. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with PSI4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user sh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cc-1.html:5403,cache,cache,5403,psi4manual/4.0b4/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cc-1.html,8,['cache'],['cache']
Performance,"1e-5. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with Psi4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. Thus, the user sh",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cc-1.html:5454,cache,cache,5454,psi4manual/1.0.0/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cc-1.html,2,['cache'],['cache']
Performance,"1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj2b. xlyp-d3bjatm. xlyp-d3zero2b. xlyp-d3zeroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:17147,optimiz,optimization,17147,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,4,['optimiz'],['optimization']
Performance,"1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj2b. xlyp-d3bjatm. xlyp-d3zero2b. xlyp-d3zeroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). «; hide menu. menu; sidebar; »",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16022,optimiz,optimization,16022,psi4manual/1.8.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html,3,['optimiz'],['optimization']
Performance,"1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj2b. xlyp-d3bjatm. xlyp-d3zero2b. xlyp-d3zeroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). «; hide menu. menu; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16050,optimiz,optimization,16050,psi4manual/1.8.x/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html,3,['optimiz'],['optimization']
Performance,"1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj2b. xlyp-d3bjatm. xlyp-d3zero2b. xlyp-d3zeroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html:15816,optimiz,optimization,15816,psi4manual/1.7.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html,2,['optimiz'],['optimization']
Performance,"2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR); CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:48176,optimiz,optimizations,48176,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimizations']
Performance,"2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. G",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:7257,optimiz,optimize,7257,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,4,['optimiz'],['optimize']
Performance,"2 OPDM) below which virtual natural orbitals are discarded for evaluating the triples contribution to dispersion. Type: conv double; Default: 1.0e-6. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK¶. Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. Expert¶. DO_CCD_DISP¶. Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_THIRD_ORDER¶. Do compute third-order corrections?. Type: boolean; Default: false. Table Of Contents. SAPT; General; AIO_CPHF; AIO_DF_INTS; BASIS; CCD_E_CONVERGENCE; CCD_MAXITER; CCD_T_CONVERGENCE; DENOMINATOR_ALGORITHM; DENOMINATOR_DELTA; DF_BASIS_ELST; DF_BASIS_SAPT; D_CONVERGENCE; E_CONVERGENCE; FREEZE_CORE; INTS_TOLERANCE; MAXITER; MAX_CCD_DIISVECS; MIN_CCD_DIISVECS; NAT_ORBS; NAT_ORBS_T2; NO_RESPONSE; OCC_TOLERANCE; PRINT; SAPT_LEVEL; SAPT_MEM_CHECK; SAPT_MEM_SAFETY; SAPT_OS_SCALE; SAPT_SS_SCALE. Expert; DO_CCD_DISP; DO_THIRD_ORDER. Previous topic; REFERENCE; Next topic; AIO_CPHF; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module ». © Copyright 2013, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__sapt-1.html:4611,perform,performed,4611,psi4manual/4.0b4/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__sapt-1.html,2,['perform'],['performed']
Performance,"2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. df",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:17630,optimiz,optimization,17630,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. omp3-3; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. sapt3; SAPT2+3 aug-cc-pVDZ computat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/testsuite-1.html:14739,optimiz,optimization,14739,psi4manual/4.0b3/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. omp2_5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. omp2_5-2; OMP2 cc-pVDZ energy for the H2O molecule. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al.,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:16276,optimiz,optimization,16276,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)"", Tss, verbose). # pick positive roots; Tss = Tss[:, w2 > 1.0e-10]; w2 = w2[w2 > 1.0e-10]. # check for invalid eigvals; with np.errstate(invalid='raise'):; w = np.sqrt(w2). # sort roots; idx = w.argsort()[:nk]; Tss = Tss[:, idx]; w = w[idx]. # Extract Rss = H2^{1/2}Tss; Rss = np.dot(H2_ss_half, Tss). # Extract Lss = (H1 R)/ w; Lss = np.dot(H1_ss, Rss).dot(np.diag(1.0 / w)). # Biorthonormalize R/L solution vectors; inners = np.einsum(""ix,ix->x"", Rss, Lss, optimize=True); Rss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Rss, optimize=True); Lss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Lss, optimize=True). # Save best R/L vectors and eigenvalues; best_R = _best_vectors(engine, Rss[:, :nk], vecs); best_L = _best_vectors(engine, Lss[:, :nk], vecs); best_vals = w[:nk]. # check convergence of each solution; new_vecs = []; for k in range(nk):. # residual vectors for right and left eigenvectors; WR_k = engine.new_vector(); WL_k = engine.new_vector(); wk = w[k]; for i in range(l):; H1x_i = H1x[i]; H2x_i = H2x[i]; WL_k = engine.vector_axpy(Rss[i, k], H1x_i, WL_k); WR_k = engine.vector_axpy(Lss[i, k], H2x_i, WR_k). WL_k = engine.vector_axpy(-1.0 * wk, best_L[k], WL_k); WR_k = engine.vector_axpy(-1.0 * wk, best_R[k], WR_k). norm_R = np.sqrt(engine.vector_dot(WR_k, WR_k)); norm_L = np.sqrt(engine.vector_dot(WL_k, WL_k)). norm = norm_R + norm_L. iter_info['res_norm'][k] = norm; iter_info['delta_val'][k] = np.abs(old_w[k] - w[k]); iter_info['val'][k] = w[k]. # augment the guess space for non-converged roots; if (iter_info['res_norm'][k] > r_convergence):; iter_info['done'] = False; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:30681,optimiz,optimize,30681,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,4,['optimiz'],['optimize']
Performance,"2*NIRREP integers specifying the number of core orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION. Type: array; Default: No Default. CFOUR_CPHF_CONVER (CFOUR); CFOUR — Specifies the convergence criterion for the iterative solution of the CPHF and Z-vector equations. The solutions are considered to be converged when the residual norm of the error vector falls below \(10^N\). Type: integer; Default: 12. CFOUR_CPHF_MAXCYC (CFOUR); CFOUR — Specifies the maximum number of cycles allowed for the solution of the CPHF- and/or Z-vector equations. Type: integer; Default: 64. CFOUR_CURVILINEAR (CFOUR); CFOUR — Specifies whether or not Hessian matrix is transformed (nonlinearly) to curvilinear internal coordinates. A value of 0 (or OFF) turns the transformation off if the analytic force constants are not available, while it is always performed if CURVILINEAR=1 (or ON). Values higher than 1 (or NO) unconditionally turn the transformation off.(Default: ON if analytic Hessian is available, OFF otherwise). Type: boolean; Default: true. CFOUR_DBOC (CFOUR); CFOUR — Specifies whether the diagonal Born-Oppenheimer correction (DBOC) to the energy is evaluated (ON =1) or not (OFF =0). DBOC calculations are currently only available for HF-SCF and CCSD using RHF or UHF reference functions. Type: boolean; Default: false. CFOUR_DCT (CFOUR); CFOUR — Specifies whether the Dipole Coupling Tensor (DCT) is calculated (ON =1) or not (OFF =0). Type: boolean; Default: false. CFOUR_DERIV_LEVEL (CFOUR); CFOUR — Specifies whether or not energy derivatives are to be calculated and if so whether first or second derivatives are computed. ZERO (= 0) derivatives are not calculated, FIRST (=1) first derivatives are calculated, SECOND (=2) second derivatives are calculated. Note that this keyword usually",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:31177,perform,performed,31177,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['perform'],['performed']
Performance,"2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. cbs-xtpl-energy; Extrapolated water energies. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. soscf1; Second-order SCF convergnece: Benzene. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater dete",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:16180,optimiz,optimization,16180,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,8,['optimiz'],"['optimization', 'optimized']"
Performance,"2, arg3, arg4, arg5, ...); docstring. DSYR(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:2499,Perform,Perform,2499,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,4,['Perform'],['Perform']
Performance,"2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Rese",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:2731,Perform,Perform,2731,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['Perform'],['Perform']
Performance,"2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. pywrap_db2; Database calculation with psi4-generated input. Should not be used as a model input file but as a canary to avoid breaking database/input parser dependencies. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. dft2; DFT Functional Test. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis ). dft1; DFT Functional Test. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. dcft5; DCFT-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. opt2; SCF DZ allene geometry optimzation, with Cartesian input. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. opt5; 6-31G** UHF CH2 3B1 optimization. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. docs_dft; This test is used to construct the documentation; it is not suitable for emulation by users. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interactio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:7371,perform,performs,7371,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,8,"['optimiz', 'perform']","['optimization', 'performs']"
Performance,"2. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. sad-scf-type; Test SAD SCF guesses on noble gas atom. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. cc17; Single point energies of multiple excited states with EOM-CCSD. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, up",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:24411,optimiz,optimization,24411,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"2.5 SAME-SPIN CORRELATION ENERGY. OMP2.5 TOTAL ENERGY. OMP3. ; setting keywords. theory. OMP3 CORRELATION ENERGY. OMP3 DOUBLES ENERGY. OMP3 OPPOSITE-SPIN CORRELATION ENERGY. OMP3 REFERENCE CORRECTION ENERGY. OMP3 SAME-SPIN CORRELATION ENERGY. OMP3 TOTAL ENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRON ENERGY. one_electron_integrals() (psi4.core.MintsHelper method). OneBodyAOInt (class in psi4.core). OneBodySOInt (class in psi4.core). onel_Hx() (psi4.core.HF method). ONEPDM (DFMP2). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() (psi4.core.CIWavefunction method). OPDM_ONLY (CCDENSITY). OPDM_RELAX (CCDENSITY). (DFMP2). open() (psi4.core.IO method). open_check() (psi4.core.IO method). operate() (psi4.core.SymmetryOperation method). opt(). . see optimize(). opt() (in module psi4.driver). OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_RESTART (OPTKING). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() (in module psi4.driver). optimize_geometric() (in module psi4.driver). option_exists_in_module() (in module psi4.core). Options (class in psi4.core). options() (psi4.core.Wavefunction method). options_to_python() (in module psi4.core). OptionsState (class in psi4.driver.p4util). OptionsStateCM() (in module psi4.driver.p4util). OptionState (class in psi4.driver.p4util). ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() (psi4.core.PointFunctions method). ORBITALS_WRITE (SCF). OrbitalSpace (class in psi4.core). order() (psi4.core.CharacterTable method). (psi4.core.PointGroup method). ordered_params (psi4.driver.EmpiricalDispersion attribute). (psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:87535,Optimiz,OptimizationConvergenceError,87535,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['Optimiz'],['OptimizationConvergenceError']
Performance,"2011).; (doi: 10.1063/1.3624397). Implementation within Psi4. “Predicting Near Edge X-ray Absorption Spectra with the Spin-Free; Exact-Two-Component Hamiltonian and Orthogonality Constrained Density; Functional Theory,”; P. Verma, W. D. Derricotte and F. A. Evangelista,; J. Chem. Theory Comput. (2015).; (doi: 10.1021/acs.jctc.5b00817). Supported Architectures¶; The majority of Psi4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of Psi4.; Psi4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, we recommend at least 12.1 (we have; had trouble with version 12.0 and 13.0.1). GCC version 4.6 or above is; recommended. For some architectures, a precompiled binary is available. See Compiling and Installing for details. Capabilities¶; Psi4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of Psi4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in Psi4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Energy (CFOUR), Gradient,; Gradient (CFOUR), and Frequency. Summary of theoretical methods available in Psi4¶. Method; Energy; Gradient; Parallelism; Variants. Reference; Type; Reference; Type; OO [9]; FNO [1]. HF; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF/ROHF; CONV/DF; threaded;  ;  . DFT; RKS/UKS; CONV/DF/CD [7]; RKS/UKS; DF [4]; threaded;  ;  . EFP [5]; RHF;  ; —; —;  ;  ;  . DCFT; RHF/UHF; CONV/DF; RHF/UHF; CONV; partially threaded;  ;  . MP2; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded [3]; E/G;  . MP3; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded [3]; E/G; E. MP2.5; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded [3]; E/G;  . MP4; RHF; CONV; —; —; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:16724,perform,perform,16724,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,2,['perform'],['perform']
Performance,"2012 eq. 30). Type: double; Default: 1.0e-10. LS_THC_SPHERICAL_POINTS (GLOBALS)¶GLOBALS — Number of spherical points in LS-THC grid. Type: integer; Default: 50. LS_THC_WEIGHTS_TOLERANCE (GLOBALS)¶GLOBALS (Expert) — Grid weights cutoff for LS-THC grids. Type: conv double; Default: 1.0e-12. LSE (DETCI)¶DETCI — Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE (DETCI)¶DETCI — Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE (DETCI)¶DETCI — Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. MADMP2_SLEEP (DFMP2)¶DFMP2 (Expert) — A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. MAT_NUM_COLUMN_PRINT (GLOBALS)¶GLOBALS (Expert) — Number of columns to print in calls to Matrix::print_mat. Type: integer; Default: 5. MAX_ATTEMPTS (SCF)¶SCF (Expert) — When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. MAX_CCD_DIISVECS (SAPT)¶SAPT — Maximum number of vectors used in CCD-DIIS. Type: integer; Default: 10. MAX_DISP_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: maximum force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. MAX_MEM_BUF (SCF)¶SCF — Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MAX_MOGRAD_CONVERGENCE (DFOCC)¶DFOCC — Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:168090,optimiz,optimization,168090,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['optimiz'],['optimization']
Performance,"208 -1.6031427 0.4895864; C -3.9143727 -0.6838545 -0.4091028; C -3.2370496 0.4929609 -0.7096126; H -0.5106510 0.0566569 1.2642563; H -1.7151135 -2.0321452 1.7878417; H -3.9024664 -2.5173865 0.7197947; H -4.8670730 -0.8822939 -0.8811319; H -3.6431662 1.2134345 -1.4057590; --; 0 1; O 1.3531168 1.9382724 0.4723133; H 1.7842846 2.3487495 1.2297110; C 2.0369747 0.7865043 0.1495491; C 1.5904026 0.0696860 -0.9574153; C 2.2417367 -1.1069765 -1.3128110; C 3.3315674 -1.5665603 -0.5748636; C 3.7696838 -0.8396901 0.5286439; C 3.1224836 0.3383498 0.8960491; H 0.7445512 0.4367983 -1.5218583; H 1.8921463 -1.6649726 -2.1701843; H 3.8330227 -2.4811537 -0.8566666; H 4.6137632 -1.1850101 1.1092635; H 3.4598854 0.9030376 1.7569489; symmetry c1; no_reorient; no_com; }. set {; basis jun-cc-pvdz; scf_type df; guess sad; freeze_core true; }. energy('fisapt0'). This file runs a DF-HF computation on the full dimer using PSI4‘s existing; SCF code. The monomer SCF computations are performed inside the FISAPT module,; following which a complete DF-SAPT0 computation is performed. Additional bits of; analysis are performed to generate the order-2 partition of the SAPT terms to; the level of nuclei and localized occupied orbitals – this generally does not; incur much additional overhead beyond a standard SAPT0 computations. The; nuclear/orbital partition data is written to the folder fsapt/ in the same; directory as the input file (this can be changed by FISAPT_FSAPT_FILEPATH).; One obtains the desired F-SAPT partition by post-processing the data in; fsapt/. Within this dir, the user is expected to provide the ASCII files; fA.dat and fB.dat, which describe the assignment of atoms to chemical; functional groups using 1-based ordering. E.g., for the problem at hand,; fA.dat contains:; 1; 2OH 1 2; PH 3 4 5 6 7 8 9 10 11 12 13. while fB.dat contains:; 1; 2OH 14 15; PH 16 17 18 19 20 21 22 23 24 25 26. At this point, the user should run the fsapt.py post-processing script in; the fsapt directory as:; 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fisapt-1.html:4459,perform,performed,4459,psi4manual/1.1.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fisapt-1.html,4,['perform'],['performed']
Performance,"208 -1.6031427 0.4895864; C -3.9143727 -0.6838545 -0.4091028; C -3.2370496 0.4929609 -0.7096126; H -0.5106510 0.0566569 1.2642563; H -1.7151135 -2.0321452 1.7878417; H -3.9024664 -2.5173865 0.7197947; H -4.8670730 -0.8822939 -0.8811319; H -3.6431662 1.2134345 -1.4057590; --; 0 1; O 1.3531168 1.9382724 0.4723133; H 1.7842846 2.3487495 1.2297110; C 2.0369747 0.7865043 0.1495491; C 1.5904026 0.0696860 -0.9574153; C 2.2417367 -1.1069765 -1.3128110; C 3.3315674 -1.5665603 -0.5748636; C 3.7696838 -0.8396901 0.5286439; C 3.1224836 0.3383498 0.8960491; H 0.7445512 0.4367983 -1.5218583; H 1.8921463 -1.6649726 -2.1701843; H 3.8330227 -2.4811537 -0.8566666; H 4.6137632 -1.1850101 1.1092635; H 3.4598854 0.9030376 1.7569489; symmetry c1; no_reorient; no_com; }. set {; basis jun-cc-pvdz; scf_type df; guess sad; freeze_core true; }. energy('fisapt0'). This file runs a DF-HF computation on the full dimer using PSI4‘s existing; SCF code. The monomer SCF computations are performed inside the FISAPT module,; following which a complete DF-SAPT0 computation is performed. Additional bits of; analysis are performed to generate the order-2 partition of the SAPT terms to; the level of nuclei and localized occupied orbitals – this generally does not; incur much additional overhead beyond a standard SAPT0 computations. The; nuclear/orbital partition data is written to the folder fsapt/ in the same; directory as the input file (this can be changed by FISAPT_FSAPT_FILEPATH).; One obtains the desired F-SAPT partition by post-processing the data in; fsapt/. Within this dir, the user is expected to provide the ASCII files; fA.dat and fB.dat, which describe the assignment of atoms to chemical; functional groups using 1-based ordering. E.g., for the problem at hand,; fA.dat contains:; OH 1 2; PH 3 4 5 6 7 8 9 10 11 12 13. while fB.dat contains:; OH 14 15; PH 16 17 18 19 20 21 22 23 24 25 26. At this point, the user should run the fsapt.py post-processing script in; the fsapt directory as:; >>> fsapt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/fisapt.html:3572,perform,performed,3572,psi4manual/master/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/master/fisapt.html,18,['perform'],['performed']
Performance,"208 -1.6031427 0.4895864; C -3.9143727 -0.6838545 -0.4091028; C -3.2370496 0.4929609 -0.7096126; H -0.5106510 0.0566569 1.2642563; H -1.7151135 -2.0321452 1.7878417; H -3.9024664 -2.5173865 0.7197947; H -4.8670730 -0.8822939 -0.8811319; H -3.6431662 1.2134345 -1.4057590; --; 0 1; O 1.3531168 1.9382724 0.4723133; H 1.7842846 2.3487495 1.2297110; C 2.0369747 0.7865043 0.1495491; C 1.5904026 0.0696860 -0.9574153; C 2.2417367 -1.1069765 -1.3128110; C 3.3315674 -1.5665603 -0.5748636; C 3.7696838 -0.8396901 0.5286439; C 3.1224836 0.3383498 0.8960491; H 0.7445512 0.4367983 -1.5218583; H 1.8921463 -1.6649726 -2.1701843; H 3.8330227 -2.4811537 -0.8566666; H 4.6137632 -1.1850101 1.1092635; H 3.4598854 0.9030376 1.7569489; symmetry c1; no_reorient; no_com; }. set {; basis jun-cc-pvdz; scf_type df; guess sad; freeze_core true; }. energy('fisapt0'). This file runs a DF-HF computation on the full dimer using PSI4’s existing; SCF code. The monomer SCF computations are performed inside the FISAPT module,; following which a complete DF-SAPT0 computation is performed. Additional bits of; analysis are performed to generate the order-2 partition of the SAPT terms to; the level of nuclei and localized occupied orbitals – this generally does not; incur much additional overhead beyond a standard SAPT0 computations. The; nuclear/orbital partition data is written to the folder fsapt/ in the same; directory as the input file (this can be changed by FISAPT_FSAPT_FILEPATH).; One obtains the desired F-SAPT partition by post-processing the data in; fsapt/. Within this dir, the user is expected to provide the ASCII files; fA.dat and fB.dat, which describe the assignment of atoms to chemical; functional groups using 1-based ordering. E.g., for the problem at hand,; fA.dat contains:; 1; 2OH 1 2; PH 3 4 5 6 7 8 9 10 11 12 13. while fB.dat contains:; 1; 2OH 14 15; PH 16 17 18 19 20 21 22 23 24 25 26. At this point, the user should run the fsapt.py post-processing script in; the fsapt directory as:; 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/fisapt-1.html:4461,perform,performed,4461,psi4manual/1.2.1/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/fisapt-1.html,8,['perform'],['performed']
Performance,"214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memory usage is slightly higher. This is usually a negligible, except when setting tiny memory allowances.; One convenient way to override the PSI4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; 1set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:4551,perform,performs,4551,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,2,['perform'],['performs']
Performance,"2253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; units angstrom; """"""). Here’s the second half of the input, where we specify the computation options:. [8]:. psi4.set_options({'scf_type': 'df',; 'freeze_core': True}). psi4.energy('sapt0/jun-cc-pvdz', molecule=dimer). [8]:. -0.0022355825227244703. All of the options we have currently set using psi4.set_options() API are “global” options (meaning that they are visible to all parts of the program). Most common Psi4 options can be set like this. If an option needs to be visible only to one part of the program (e.g., we only want to increase the energy convergence in the SCF code, but not the rest of the code), it can be set by prefixing the option name with; [MODULE]__, for example psi4.set_options('scf__e_convergence': 1e-8}).; Note: The arguments to the functions we’ve used so far, like psi4.set_options() API, psi4.energy() API, psi4.optimize() API, psi4.frequency(); API, etc., are case-insensitive.; Back to our SAPT example, we have found that for basic-level SAPT computations (i.e., SAPT0), a good error cancellation is found (Hohenstein:2012:WIREs) with the jun-cc-pVDZ basis (this is the usual aug-cc-pVDZ basis, but without diffuse functions on hydrogen and without diffuse \(d\) functions on heavy atoms) (Papajak:2011:10). So,; we’ll use that as our standard basis set. The SAPT code is designed to use density fitting techniques, because they introduce minimal errors while providing much faster computations (Hohenstein:2010:184111,Hohenstein:2010:014101). Since we’re using density fitting for the SAPT, we might as well also use it for the Hartree-Fock; computations that are performed as part of the SAPT. We can specify that by adding 'scf_type': 'df' to the dictionary passed to psi4.set_options().; Density fitting procedures require the use of auxiliary basis sets that pair with the primary basis set. Fortunately, Psi4 is us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:13006,optimiz,optimize,13006,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,2,['optimiz'],['optimize']
Performance,"287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:2243,Queue,Queue,2243,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Queue'],['Queue']
Performance,"2; MP3 cc-pVDZ gradient for the NO radical. cc17; Single point energies of multiple excited states with EOM-CCSD. scf-ecp; Water-Argon complex with ECP present; check of energies and forces. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. scf-occ; force occupations in scf. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. fd-gradient; SCF STO-3G finite-difference tests. options1; check all variety of options parsing. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. scf7; Tests SCF gradient in the presence of a dipole field. fnocc3; Test FNO-QCISD(T) computation. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:29067,optimiz,optimized,29067,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimized']
Performance,"2; Test G2 method for H2O. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. fcidump; test FCIDUMP functionality for rhf/uhf. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/testsuite.html:49497,optimiz,optimization,49497,psi4manual/1.9.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/testsuite.html,2,['optimiz'],"['optimization', 'optimized']"
Performance,"2B1 state of H2O+ with EOM-CCSD. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). soscf2; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. dcft-grad1; DCFT DC-06 gradient for the O2 molecule with cc-pVDZ basis set. pubchem2; Superficial test of PubChem interface. cepa-module; routing check on lccd, lccsd, cepa(0). cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. dcft8; DCFT calculation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:1855,optimiz,optimize,1855,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,4,['optimiz'],['optimize']
Performance,"2O molecule. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. mbis-5; MBIS calculation on ZnO. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fd-freq-ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:11367,optimiz,optimization,11367,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRON ENERGY. one_electron_integrals() psi4.core.MintsHelper method. OneBodyAOInt class in psi4.core. OneBodySOInt class in psi4.core. onel_Hx() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() psi4.core.CIWavefunction method. OPDM_GRID_CUTOFF (CCDENSITY). OPDM_GRID_DUMP (CCDENSITY). OPDM_GRID_STEPSIZE (CCDENSITY). OPDM_ONLY (CCDENSITY). OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:104138,optimiz,optimize,104138,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['optimiz'],['optimize']
Performance,"2]. set_specific_retention() psi4.core.IOManager method, [1], [2]. set_title() psi4.core.OEProp method, [1]. psi4.core.Prop method, [1], [2]. set_tpdm_presorted() psi4.core.Deriv method, [1], [2]. set_variable() in module psi4.core, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.Molecule method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. set_x_alpha() psi4.core.SuperFunctional method, [1], [2]. set_x_omega() psi4.core.SuperFunctional method, [1], [2]. setAuxiliary() psi4.core.DFChargeFitter method, [1], [2]. setD() psi4.core.DFChargeFitter method, [1], [2]. setName() psi4.core.ExternalPotential method, [1], [2]. setPrimary() psi4.core.DFChargeFitter method, [1], [2]. setting. ; keywords anharmonicity(). keywords cbs(). keywords cp. keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords property(). keywords vmfc. SF_RESTRICT (DETCI). shallow_copy() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. shape psi4.core.Matrix attribute, [1], [2]. psi4.core.Vector attribute, [1], [2]. shared_object() psi4.core.IO method, [1], [2]. psi4.core.IOManager method, [1], [2]. shell() psi4.core.BasisSet method, [1], [2]. shell_to_ao_function() psi4.core.BasisSet method, [1], [2]. shell_to_basis_function() psi4.core.BasisSet method, [1], [2]. shell_to_center() psi4.core.BasisSet method, [1], [2]. ShellInfo class in psi4.core, [1]. shells_iterator() psi4.core.IntegralFactory method, [1], [2]. sherrill_gold_standard() in module psi4.driver.aliases. shift() psi4.core.CIVector method, [1], [2]. sigma() psi4.core.CIWavefunction method, [1], [2]. SIGMA_OVERLAP (DETCI). sigma_xy() psi4.core.SymmetryOperation m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:93302,optimiz,optimize,93302,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['optimiz'],['optimize']
Performance,"2]. subtract() psi4.core.Matrix method, [1], [2]. Success psi4.core.PsiReturnType attribute, [1], [2]. success() in module psi4.driver. sum_of_squares() psi4.core.Matrix method, [1], [2]. SuperFunctional class in psi4.core, [1]. symbol() psi4.core.Molecule method, [1], [2]. psi4.core.PointGroup method, [1], [2]. SYMM_TOL (OPTKING). SYMMETRIZE (OCC). symmetrize() psi4.core.Molecule method, [1], [2]. symmetrize_gradient() psi4.core.Matrix method, [1], [2]. symmetry. molecule. symmetry() psi4.core.Matrix method, [1], [2]. SymmetryOperation class in psi4.core, [1]. symnormalize() psi4.core.CIVector method, [1], [2]. T. T (THERMO). T2_COUPLED (CCENERGY). T3_WS_INCORE (CCENERGY). (CCEOM). T_AMPS (CCHBAR). Table class in psi4.driver. TDHF_MEM_SAFETY_FACTOR (CPHF). TDM (DETCI). TEST_B (OPTKING). TEST_DERIVATIVE_B (OPTKING). test_functional() psi4.core.SuperFunctional method, [1], [2]. TestComparisonError. theory. ; ADC. CC. CI. DCFT. DF-MP2. DFT. FISAPT. OEProp. OLCCD. OMP2. OMP3. Orbital-Optimized Methods. SAPT. SCF. cbs(), [1]. thermo() in module psi4.core, [1]. THETA_POINTS (SCF). THICKNESS (SCF). threading, [1]. THREE_PARTICLE (DCFT). ThreeCenterOverlapInt class in psi4.core, [1]. TIKHONOW_MAX (PSIMRCC). TIKHONOW_OMEGA (DCFT). (PSIMRCC). TIKHONOW_TRIPLES (PSIMRCC). TILE_SZ (SCF). to_array() psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. to_serial() psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. to_tuple() psi4.core.Dimension method, [1], [2]. tocclean() psi4.core.IO method, [1], [2]. tocprint() psi4.core.IO method, [1], [2]. tocwrite() psi4.core.IO method, [1], [2]. TPDM (DETCI). tpdm() psi4.core.CIWavefunction method, [1], [2]. TPDM_ABCD_TYPE (OCC). trace() psi4.core.Matrix method, [1], [2]. psi4.core.SymmetryOperation method, [1], [2]. TracelessQuadrupoleInt class in psi4.core, [1]. transform() psi4.core.Matrix method, [1], [2]. psi4.core.SymmetryOperation method, [1], [2]. transform_ci_integrals() psi4.core.CIWavefunction ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:98412,Optimiz,Optimized,98412,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,"2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE')",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:6443,perform,performance,6443,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). Note; As of October 2018, only two explicit `deltaN_[wfn,basis,scheme]` sets of options are active; if more delta functions are required, use the `cbs_metadata` interface. Also, temporarily extrapolations are performed on differences of target and scf total energies, rather than on correlation energies directly. This doesn’t affect the extrapolated values of the particular formulas defined here (though it does affect the betas, which are commented out), but it is sloppy and temporary and could affect any user-defined corl extrapolations. Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cbs.html:17241,perform,performed,17241,psi4manual/master/cbs.html,https://psicode.org,https://psicode.org/psi4manual/master/cbs.html,5,['perform'],['performed']
Performance,"2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60906,optimiz,optimize,60906,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,9,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. pywrap_alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. pywrap_all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:11865,optimiz,optimization,11865,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. isapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. sapt-sf1; Tests the Psi4 SF-SAPT code. dft-jk; DFT JK on-disk test. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. scf-auto-cholesky; Cholesky filter a complete basis. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. psimrcc-fd-freq1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega= (589 355 nm). fnocc2; Test G2 method for H2O. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:46987,optimiz,optimization,46987,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"3(ccd)-ct; SAPT2+3(CCD) plus CT [manual]. adc; 2nd-order algebraic diagrammatic construction (ADC) [manual]. eom-cc2; EOM-CC2 [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. eom-cc3; EOM-CC3 [manual]. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/energy-1.html:8390,perform,perform,8390,psi4manual/1.1.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/energy-1.html,4,['perform'],['perform']
Performance,"3, arg4, arg5, ...); docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:2554,Perform,Perform,2554,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['Perform'],['Perform']
Performance,"32405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table of the different R values and the CP-corrected CCSD(T) energies, converted from atomic units (Hartree) to kcal mol\(^{-1}\) by multiplying by the automatically-defined conversion factor psi4.constants.hartree2kcalmol. Psi4 provides several built-in physical constants and conversion factors, as described in the Psi4 manual section Physical; Constants. The table can be printed either to the screen, by using standard Python ``print()` syntax <https://docs.python.org/3/whatsnew/3.0.html#print-is-a-function>`__, or to the designated output file output.dat using Psi4’s built-in function psi4.core.print_out() API (C style printing).; As we’ve seen so far, the combination of Psi4 and Python creates a unique, interactive approach to quantum chemistry. The next section will explore this synergistic relationship in greater detail, describing how even very complex tasks can be done very easily with Psi4. [ ]:. table of contents. PsiAPI Tutorial: Using Psi4 as a Python Module; I. Basic Input Structure; II. Running a Basic Hartree-Fock Calculation; III. Geometry Optimization and Vibrational Frequency Analysis; IV. Analysis of Intermolecular Interactions; V. Potential Surface Scans and Counterpoise Correction Made Easy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psiapi-1.html:23363,Optimiz,Optimization,23363,psi4manual/1.4.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psiapi-1.html,2,['Optimiz'],['Optimization']
Performance,"32405488935); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table of the different R values and the CP-corrected CCSD(T) energies, converted from atomic units (Hartree) to kcal mol\(^{-1}\) by multiplying by the automatically-defined conversion factor psi4.constants.hartree2kcalmol. Psi4 provides several built-in physical constants and conversion factors, as described in the Psi4 manual section Physical; Constants. The table can be printed either to the screen, by using standard Python ``print()` syntax <https://docs.python.org/3/whatsnew/3.0.html#print-is-a-function>`__, or to the designated output file output.dat using Psi4’s built-in function psi4.core.print_out() API (C style printing).; As we’ve seen so far, the combination of Psi4 and Python creates a unique, interactive approach to quantum chemistry. The next section will explore this synergistic relationship in greater detail, describing how even very complex tasks can be done very easily with Psi4. [ ]:. table of contents. PsiAPI Tutorial: Using Psi4 as a Python Module; I. Basic Input Structure; II. Running a Basic Hartree-Fock Calculation; III. Geometry Optimization and Vibrational Frequency Analysis; IV. Analysis of Intermolecular Interactions; V. Potential Surface Scans and Counterpoise Correction Made Easy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psiapi-1.html:23363,Optimiz,Optimization,23363,psi4manual/1.5.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psiapi-1.html,2,['Optimiz'],['Optimization']
Performance,"340785; H 0.5244823836 -6.4459192939 -0.7478283184; H 4.0823309159 -4.4449979205 -0.7680411190; H -2.2074914566 -5.7109913627 2.2110247636; H -1.3768100495 -2.9846751653 5.1327625515; H 4.9209603634 -1.7288723155 2.1638694922; H 2.1923374156 -0.9964630692 5.1155773223; nocom; units au; }. set {; basis 6-31+G; frag_mode MULTI. # The line below specifies the reference points that will be used to construct the; # interfragment coordinates between the two fragments (called A and B).; # The format is the following:; # [[A-1], [A-2], [A-3]], [[B-1], [B-2], [B-3]]; #; # In terms of atoms within each fragment, the line below chooses, for water:; # H3 of water for the first reference point, O1 of water for the second reference point, and; # H2 of water for the third reference point.; # For benzene: the mean of the positions of all the C atoms, C2, one of the Carbon atoms,; # and C6, another one of the carbon atoms. frag_ref_atoms [; [[3], [1], [2]], [[4, 5, 6, 7, 8, 9], [5], [9]]; ]; }. optimize(""mp2""). For even greater control, a dictionary can be passed to INTERFRAG_COORDS; The coordinates that are created between two dimers depend upon the number of atoms present; The fragments A and B have up to 3 reference atoms each as shown in; Dimer coordinate table.; The interfragment coordinates are named and can be frozen according to their names as show in; example below. For specifying reference points, use 1 based indexing. Dimer coordinates¶. name; type; atom-labels; present, if. RAB; distance; A0-B0; always. theta_A; angle; A1-A0-B0; A has > 1 atom. theta_B; angle; A0-B0-B1; B has > 1 atom. tau; dihedral; A1-A0-B0-B1; A and B have > 1 atom. phi_A; dihedral; A2-A1-A0-B0; A has > 2 atoms. Is not linear. phi_B; dihedral; A0-B0-B1-B2; B has > 2 atoms. Is not linear. A constrained optimization is performed where the orientation of the two fragments is fixed but; the distance between the fragments and all intrafragment coordinates are allowed to relax. In this; example, the centers ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:13535,optimiz,optimize,13535,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,4,['optimiz'],['optimize']
Performance,"3468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; 1; 2set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:8649,optimiz,optimization,8649,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimization']
Performance,"3468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:8357,optimiz,optimization,8357,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,7,['optimiz'],['optimization']
Performance,"347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4];  . GAU_LOOSE [6];  . TURBOMOLE [4]. G",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optking-1.html:6927,optimiz,optimize,6927,psi4manual/4.0b4/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html,4,['optimiz'],['optimize']
Performance,"3472137 -0.000000544965 1.16e-04 1.16e-04; ----------------------------------------------------------------------. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at the output from running the; previous example, we see that the OH bond length is about 0.9463 Ångstroms,; and the bond angle is about 104.575 degrees. It’s good to give this many; digits (or more) to make sure there’s not significant roundoff error in the; geometry when running a frequency computation. So, our frequency; computation input (which can be found as test case; tu4-h2o-freq is:; #! Frequencies for H2O HF/cc-pVDZ at optimized geometry. memory 250 mb. molecule h2o {; O ; H 1 0.9463; H 1 0.9463 2 104.575; }. set basis cc-pVDZ; frequencies('scf'). Alternatively, it’s also possible for PSI4 to use Cartesian coordinate; input. Here, the Cartesian coordinates of the optimized geometry can be; extracted from the bottom of the optimization output. The input; would then look like this:; molecule h2o {; O 0.0000000000 -0.0000000000 -0.1224239500; H 0.0000000000 -1.4147069876 0.9714784639; H -0.0000000000 1.4147069876 0.9714784639; }. set basis cc-pVDZ; frequencies('scf'). If either of the inputs above are run, the program should do some; computations and then finally report the following harmonic vibrational; frequencies (roundoff errors of around 0.1 cm-1 may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1776.1735; A1 4113.8031; B2 4211.7879; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1776.17; Force constant: 0.1194; X Y Z; O 0.000 0.000 -0.067; H 0.000 0.416 0.536; H 0.000 -0.416 0.536. w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:6520,optimiz,optimized,6520,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,4,['optimiz'],"['optimization', 'optimized']"
Performance,"3841e-10 1.88088e-06 DIIS; @UHF iter 9: -149.62730740326214 -1.07718e-11 1.80706e-07 DIIS; @UHF iter 10: -149.62730740326231 -1.70530e-13 2.19128e-08 DIIS. The algorithm takes 10 true iterations to converge the energy and density to the; default of 1.0E-8, plus the trivial iteration due to the SAD guess.; The energy on the zero-th iteration is not variational due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamilt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:3005,perform,performed,3005,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['perform'],['performed']
Performance,"3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OCEPA; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. CEPA(0); Y; Y; RHF/UHF; threaded [3]. CEPA(n), n=0,1,3; Y; —; RHF; threaded [3]. ACPF/AQCC; Y; —; RHF; threaded [3]. QCISD; Y; —; RHF; threaded [3]. QCISD(T); Y; —; RHF; threaded [3]. CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-CCSD; Y; —; RHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). DF-CCSD(T); Y; —; RHF; threaded [3]. CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). Mk-MRPT2; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD; Y; —; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; —; RHF/ROHF/TCSCF; threaded [3]. CI(n); Y; —; RHF/ROHF; partially threaded. RAS-CI; Y; —; RHF/ROHF; partially threaded. SAPT; Y; —; RHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . ADC(2); Y; —; RHF; threaded [3]. EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu; or sherrill@gatech.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Alternatively, bug reports and comments can be submitted to the Issue; tracker on GitHub . This site; is viewable by all, but reporting bugs requires signing up for a free; GitHub accoun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:13382,optimiz,optimization,13382,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,8,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"3LYP/6-31G* at optimized geometry. cc12; Single point energies of multiple excited states with EOM-CCSD. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cbs-xtpl-func; optimization with method defined via cbs. fcidump; test FCIDUMP functionality for rhf/uhf. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. scf-level-shift-rohf; SCF level shift on an ROHF computation. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. scf3; File retention, docc, socc, and bond distances specified explicitly. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. nbo; Generation of NBO file. fnocc6; Test method/basis with disk_df. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. dft-vv10; He Dimer VV10 functional test. n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:34718,optimiz,optimizes,34718,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimizes']
Performance,"3bj;  . zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html:12129,perform,perform,12129,psi4manual/1.3.2/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html,8,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"3psi12WavefunctionEEE,N5boost6python4dictE); ; new_wavefunction(...); new_wavefunction( (Molecule)arg1, (str)arg2) -> Wavefunction :; Builds a new wavefunction from scratch.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE new_wavefunction(N5boost10shared_ptrIN3psi8MoleculeEEE,Ss); ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; C++ signature :; i nthread(); ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; C++ signature :; N5boost10shared_ptrIN3psi6VectorEEE nuclear_dipole(N5boost10shared_ptrIN3psi8MoleculeEEE); ; occ(...); occ( (Wavefunction)arg1) -> Wavefunction :; Runs the orbital optimized CC codes.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE occ(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; C++ signature :; void opt_clean(); ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; C++ signature :; i optking(); ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; C++ signature :; Ss outfile_name(); ; plugin(...); plugin( (str)arg1, (Wavefunction)arg2) -> Wavefunction :; docstring; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE plugin(Ss,N5boost10shared_ptrIN3psi12WavefunctionEEE); ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; C++ signature :; void plugin_close(Ss); ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; C++ signature :; void plugin_close_all(); ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; C++ signature :; i plugin_load(Ss); ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; C++ signature :; void prepare_options_for_module(Ss); ; print_global_options(...); print_global_option",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:689785,optimiz,optimization,689785,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['optimiz'],['optimization']
Performance,"4 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while White or Queue: # Iterates to the next fragment; Fragment.append([]). while Queue: # BFS within a fragment; for u in Queue: # find all white neighbors to vertex u; for i in White:; dist = constants.bohr2angstroms * math.sqrt(; (self.x(i) - self.x(u)) ** 2 +; (self.y(i) - self.y(u)) ** 2 +; (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + \; vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # & remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if White: # can't move White -> Queue if empty; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the core.Molecule class. """"""; cls.__setattr__ = molecule_set_attr; cls.__getattr__ = molecule_get_attr. cls.BFS = BFS. dynamic_variable_bind(core.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user use but deprecated; in driver in favor of explicit molecule-passing. Comments within; the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/molutil.html:6772,Queue,Queue,6772,psi4manual/1.1.0/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/molutil.html,1,['Queue'],['Queue']
Performance,"4 1.8 supports Python 3.8, 3.9, 3.10, and 3.11.; PSI4 1.9 supports Python 3.8, 3.9, 3.10, 3.11, and 3.12.; The future plan is to (1) be compatible with 3.8 and above until there is a good reason to drop; older versions but (2) only build and test for versions conda-forge supports.; The current master supports 3.8, 3.9, 3.10, 3.11, and 3.12. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; General GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties.; For more tables with capabilities details:. Full Capabilities (first below) lists all methods; Capabilities Breakdown (second below) lists selected methods by reference, etc.; Module Capabilities lists selected methods by implementation; Energy, Energy (DFT), Energy (MRCC), Energy (CFOUR) fully list energy target methods; Gradient, Gradient (CFOUR) fully list gradient target methods; Frequency fully lists Hessian target methods. Summary of theoretical methods available in PSI4¶. Method [1]; Reference[2]; Type[2]; Variants[3]. Canonical; OO; FNO [4]; DLPNO. HF; RHF/UHF/ROHF/CUHF; CONV/DF/CD; E/G/H. DFT; RKS/UKS; CONV/DF/CD; E/G. DFT-D2, DFT-NL; RKS/UKS; CONV/DF/CD; E/G. DCT; RHF/UHF; CONV/DF; E/G. MP2; RHF/UH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/introduction.html:24136,optimiz,optimization,24136,psi4manual/1.9.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/introduction.html,2,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,4 [1.0.0 6a9a71b] Docs; LOCAL_METHOD — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_PAIRDEF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_WEAKP — Psi4 [1.0.0 6a9a71b] Docs; MAXITER — Psi4 [1.0.0 6a9a71b] Docs; MP2_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; MP2_OS_SCALE — Psi4 [1.0.0 6a9a71b] Docs; MP2_SS_SCALE — Psi4 [1.0.0 6a9a71b] Docs; NEW_TRIPLES — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; PAIR_ENERGIES_PRINT — Psi4 [1.0.0 6a9a71b] Docs; PROPERTY — Psi4 [1.0.0 6a9a71b] Docs; R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; RESTART — Psi4 [1.0.0 6a9a71b] Docs; SCS_CCSD — Psi4 [1.0.0 6a9a71b] Docs; SCS_MP2 — Psi4 [1.0.0 6a9a71b] Docs; SCSN_MP2 — Psi4 [1.0.0 6a9a71b] Docs; SEMICANONICAL — Psi4 [1.0.0 6a9a71b] Docs; SPINADAPT_ENERGIES — Psi4 [1.0.0 6a9a71b] Docs; T2_COUPLED — Psi4 [1.0.0 6a9a71b] Docs; T3_WS_INCORE — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; ABCD — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; CACHETYPE — Psi4 [1.0.0 6a9a71b] Docs; CC_NUM_THREADS — Psi4 [1.0.0 6a9a71b] Docs; CC3_FOLLOW_ROOT — Psi4 [1.0.0 6a9a71b] Docs; COLLAPSE_WITH_LAST — Psi4 [1.0.0 6a9a71b] Docs; COMPLEX_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; E_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; EOM_GUESS — Psi4 [1.0.0 6a9a71b] Docs; EOM_REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; EXCITATION_RANGE — Psi4 [1.0.0 6a9a71b] Docs; FULL_MATRIX — Psi4 [1.0.0 6a9a71b] Docs; LOCAL — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_DO_SINGLES — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_FILTER_SINGLES — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_GHOST — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_METHOD — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_PRECONDITIONER — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_WEAKP — Psi4 [1.0.0 6a9a71b] Docs; MAXITER — Psi4 [1.0.0 6a9a71b] Docs; NEW_TRIPLES — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; OVERLAP_CHECK — Psi4 [1.0.0 6a9a71b] Docs; PROP_ROOT — Psi4 [1.0.0 6a9a71b] Docs; PROP_SYM — Psi4 ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:41087,CACHE,CACHETYPE,41087,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHETYPE']
Performance,4 [beta2] documentation; MOM_OCC — PSI4 [beta2] documentation; MOM_START — PSI4 [beta2] documentation; MOM_VIR — PSI4 [beta2] documentation; PARALLEL — PSI4 [beta2] documentation; PERTURB_H — PSI4 [beta2] documentation; PERTURB_MAGNITUDE — PSI4 [beta2] documentation; PERTURB_WITH — PSI4 [beta2] documentation; PROCESS_GRID — PSI4 [beta2] documentation; REFERENCE — PSI4 [beta2] documentation; S_ORTHOGONALIZATION — PSI4 [beta2] documentation; S_TOLERANCE — PSI4 [beta2] documentation; SAD_CHOL_TOLERANCE — PSI4 [beta2] documentation; SAD_D_CONVERGENCE — PSI4 [beta2] documentation; SAD_E_CONVERGENCE — PSI4 [beta2] documentation; SAD_F_MIX_START — PSI4 [beta2] documentation; SAD_MAXITER — PSI4 [beta2] documentation; SAD_PRINT — PSI4 [beta2] documentation; SAPT — PSI4 [beta2] documentation; SAVE_JK — PSI4 [beta2] documentation; SCF_MEM_SAFETY_FACTOR — PSI4 [beta2] documentation; SCF_TYPE — PSI4 [beta2] documentation; TILE_SZ — PSI4 [beta2] documentation; WFN — PSI4 [beta2] documentation; CACHELEVEL — PSI4 [beta2] documentation; FOLLOW — PSI4 [beta2] documentation; NUM_VECS_PRINT — PSI4 [beta2] documentation; REFERENCE — PSI4 [beta2] documentation; ROTATION_SCHEME — PSI4 [beta2] documentation; SCALE — PSI4 [beta2] documentation; AA_M_FILE — PSI4 [beta2] documentation; AB_M_FILE — PSI4 [beta2] documentation; AO_BASIS — PSI4 [beta2] documentation; BB_M_FILE — PSI4 [beta2] documentation; CHECK_C_ORTHONORM — PSI4 [beta2] documentation; DELETE_AO — PSI4 [beta2] documentation; DELETE_RESTR_DOCC — PSI4 [beta2] documentation; DELETE_TPDM — PSI4 [beta2] documentation; DO_ALL_TEI — PSI4 [beta2] documentation; FIRST_TMP_FILE — PSI4 [beta2] documentation; FZC_A_FILE — PSI4 [beta2] documentation; FZC_B_FILE — PSI4 [beta2] documentation; FZC_FILE — PSI4 [beta2] documentation; INTS_TOLERANCE — PSI4 [beta2] documentation; IVO — PSI4 [beta2] documentation; J_FILE — PSI4 [beta2] documentation; KEEP_J — PSI4 [beta2] documentation; KEEP_PRESORT — PSI4 [beta2] documentation; LAG_IN_FILE — PSI4 [b,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:932045,CACHE,CACHELEVEL,932045,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,"4 geometry convergence criteria unless overridden ; if 'convergence_set' not in optimizer_keywords:; optimizer_keywords['convergence_set'] = core.get_global_option('G_CONVERGENCE'). # GeomeTRIC doesn't know these convergence criterion; if optimizer_keywords['convergence_set'] in ['CFOUR', 'QCHEM', 'MOLPRO']:; core.print_out(f""\n Psi4 convergence criteria {optimizer_keywords['convergence_set']:6s} not recognized by GeomeTRIC, switching to GAU_TIGHT ~""); optimizer_keywords['convergence_set'] = 'GAU_TIGHT'. engine = Psi4NativeEngine(name, molecule, return_wfn, **kwargs); M = engine.M; ; # Handle constraints; constraints_dict = {k.lower(): v for k, v in optimizer_keywords.get(""constraints"", {}).items()}; constraints_string = geometric.run_json.make_constraints_string(constraints_dict); Cons, CVals = None, None; if constraints_string:; if 'scan' in constraints_dict:; raise ValueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.optimize.ParseConstraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:54872,optimiz,optimize,54872,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,3,['optimiz'],['optimize']
Performance,"4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. from __future__ import absolute_import; from math import sqrt, pi; import numpy as np. from psi4 import core; from psi4.driver import constants; from psi4.driver.p4util.exceptions import *. def least_squares_fit_polynomial(xvals, fvals, localization_point, no_factorials=True, weighted=True, polynomial_order=4):; """"""Performs and unweighted least squares fit of a polynomial, with specified order; to an array of input function values (fvals) evaluated at given locations (xvals).; See http://dx.doi.org/10.1063/1.4862157, particularly eqn (7) for details. """"""; xpts = np.array(xvals) - localization_point; if weighted:; R = 1.0; p_nu = 1; epsilon = 1e-3; zvals = np.square(xpts/R); weights = np.exp(-zvals) / (zvals**p_nu + epsilon**p_nu); else:; weights = None; fit = np.polynomial.polynomial.polyfit(xpts, fvals, polynomial_order, w=weights); # Remove the 1/n! coefficients; if no_factorials:; scalefac = 1.0; for n in range(2,polynomial_order+1):; scalefac *= n; fit[n] *= scalefac; return fit. [docs]def anharmonicity(rvals, energies, plot_fit='', mol = None):; """"""Generates spectroscopic constants for a diatomic molecules.; Fits a diatomic potential energy curve using a weighted least squares approach; (c.f. http://dx.doi.org/10.1063/1.4862157, particularly eqn. 7), locates the minimum; energy point, and then applies second ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/diatomic.html:1390,Perform,Performs,1390,psi4manual/1.1.0/_modules/psi4/driver/diatomic.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/diatomic.html,1,['Perform'],['Performs']
Performance,"4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/opt-1.html:13792,perform,perform,13792,psi4manual/1.4.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/opt-1.html,5,['perform'],['perform']
Performance,"4. Initially install PSI4 stable release with non-current python. 1>>> conda install psi4 python=3.6 -c psi4. Update to latest PSI4 stable release. 1>>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). 1; 2>>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. 1>>> conda install psi4=0.1.12 -c psi4. Uninstall PSI4 from current environment. 1>>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 –channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. 1>>> conda install psi4 python=3.6 -c psi4/label/dev. Update to latest PSI4 nightly build. 1>>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). 1; 2>>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. 1>>> conda install psi4=0.1.12 -c psi4/label/dev. Troubleshooting¶. If the target computer doesn’t have libc >= 2.7 (released c.2007; for reference, 2.10 is newer than 2.7; unlike most libraries, libc generally not available in multiple versions on a computer), the PSI4 conda package won’t work.; 1; 2; 3; 4; 5; 6# unsuitable computer; >>> ldd --version; ldd (GNU libc) 2.5; # suitable computer; >>> ldd --version; ldd (GNU libc) 2.17. It is of greatest importance that the PSI4 executable be linked against conda libpython.so not against any system libpython.so. This is arranged by setting RPATH to seek libraries relative to executable (thanks, conda binary relocation routine!). The conda PSI4 executable is not vulnerable to interference from your LD_LIBRARY_PATH settings. Below shows a well-linked executable. no libraries “not found”; fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/conda-1.html:21755,load,loaded,21755,psi4manual/1.2.1/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/conda-1.html,2,['load'],['loaded']
Performance,"4. Psithon Functions: Invoking a Calculation; Property. Property¶. psi4.properties(name[, properties, molecule])[source]; Function to compute various properties. Aliases:; prop(). Returns:; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prop.html:1045,optimiz,optimized,1045,psi4manual/master/prop.html,https://psicode.org,https://psicode.org/psi4manual/master/prop.html,4,['optimiz'],['optimized']
Performance,"4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. orientation_fixed() psi4.core.Molecule method. origin psi4.core.AngularMomentumInt attribute. psi4.core.DipoleInt attribute. psi4.core.ElectricFieldInt attribute. psi4.core.ElectrostaticInt attribute. psi4.core.KineticInt attribute. psi4.core.MultipoleInt attribute. psi4.core.NablaInt attribute. psi4.core.OneBodyAOInt attribute. psi4.core.OverlapInt attribute. psi4.core.PotentialInt attribute. psi4.core.PseudospectralInt attribute. psi4.core.QuadrupoleInt attribute. psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:101742,Optimiz,Optimized,101742,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,"4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. orientation_fixed() psi4.core.Molecule method. origin psi4.core.AngularMomentumInt attribute. psi4.core.DipoleInt attribute. psi4.core.ElectricFieldInt attribute. psi4.core.ElectrostaticInt attribute. psi4.core.KineticInt attribute. psi4.core.MultipoleInt attribute. psi4.core.NablaInt attribute. psi4.core.OneBodyAOInt attribute. psi4.core.OverlapInt attribute. psi4.core.PotentialInt attribute. psi4.core.QuadrupoleInt attribute. psi4.core.TracelessQuadrupoleInt attribute. or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:104817,Optimiz,Optimized,104817,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['Optimiz'],['Optimized']
Performance,"4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12) → psi4.core.Dimension¶; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile') → None¶; Print the matrix with atom labels, a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html:11240,Load,Load,11240,psi4manual/1.4.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html,3,['Load'],['Load']
Performance,"4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11583,Load,Load,11583,psi4manual/master/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html,1,['Load'],['Load']
Performance,"4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization pass",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:11648,Load,Load,11648,psi4manual/1.9.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html,1,['Load'],['Load']
Performance,"4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector]) – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11597,Load,Load,11597,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,1,['Load'],['Load']
Performance,"4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11577,Load,Load,11577,psi4manual/1.8.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html,1,['Load'],['Load']
Performance,"4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). classmethod from_list(x)¶. classmethod from_serial()¶; Converts serialized data to the correct Psi4 data type. Parameters:. self – Pointer to which class to be constructed.; json_data (Dict[str, Any]) – Serialization of class. See to_serial() for data layout. Return type:; Union[Matrix, Vector]. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice) → psi4.core.Vector¶; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension) → None¶; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Load the vector from disk. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serializ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Vector.html:5141,load,load,5141,psi4manual/master/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Vector.html,1,['load'],['load']
Performance,"4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). classmethod from_list(x)¶. classmethod from_serial()¶; Converts serialized data to the correct Psi4 data type. Parameters:. self – Pointer to which class to be constructed.; json_data (Dict[str, Any]) – Serialization of class. See to_serial() for data layout. Return type:; Union[Matrix, Vector]. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice) → psi4.core.Vector¶; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension) → None¶; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Load the vector from disk. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector]) – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When fil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Vector.html:4792,load,load,4792,psi4manual/1.7.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Vector.html,1,['load'],['load']
Performance,"4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). classmethod from_list(x)¶. classmethod from_serial()¶; Converts serialized data to the correct Psi4 data type. Parameters:. self – Pointer to which class to be constructed.; json_data (Dict[str, Any]) – Serialization of class. See to_serial() for data layout. Return type:; Union[Matrix, Vector]. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice) → psi4.core.Vector¶; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension) → None¶; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Load the vector from disk. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict seriali",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:5134,load,load,5134,psi4manual/1.8.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html,1,['load'],['load']
Performance,"4.core.SuperFunctional method, [1], [2]. c_os_alpha() psi4.core.SuperFunctional method, [1], [2]. C_right_add() psi4.core.JK method, [1], [2]. psi4.core.MemDFJK method, [1]. c_ss_alpha() psi4.core.SuperFunctional method, [1], [2]. Ca() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.SADGuess method, [1], [2]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Ca_subset() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. CACHELEVEL (ADC). (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (DCFT). (OCC). CACHETYPE (CCENERGY). (CCEOM). CALC_S_SQUARED (DETCI). CANONICALIZE_ACTIVE_FAVG (MCSCF). CANONICALIZE_INACTIVE_FAVG (MCSCF). CART_HESS_READ (OPTKING). Cartesian psi4.core.GaussianType attribute, [1], [2]. Cb() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.SADGuess method, [1], [2]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. Cb_subset() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. cbs(). ; extrapolation schemes. output. setting keywords. theory, [1]. cbs() in module psi4. in module psi4.driver. CBSCORRELATIONENERGY. CBSREFERENCEENERGY. CBSTO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:18020,CACHE,CACHETYPE,18020,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['CACHE'],['CACHETYPE']
Performance,"4.core.UHF method, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. option_exists_in_module() in module psi4.core, [1]. Options class in psi4.core, [1]. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orbital_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. OrbitalSpace class in psi4.core, [1]. order() psi4.core.CharacterTable method, [1], [2]. psi4.core.PointGroup method, [1], [2]. ordered_params psi4.driver.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. orientation_fixed() psi4.core.Molecule method, [1], [2]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt attribute, [1]. psi4.core.OneBodyAOInt attribute, [1], [2]. psi4.core.OverlapInt attribute, [1]. psi4.core.PotentialInt attribute, [1]. psi4.core.PseudospectralInt attribute, [1]. psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:102640,Optimiz,Optimized,102640,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,"4.core.UHF method, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. option_exists_in_module() in module psi4.core, [1]. Options class in psi4.core, [1]. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orbital_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. OrbitalSpace class in psi4.core, [1]. orientation() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. orientation_fixed() psi4.core.Molecule method, [1], [2]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt attribute, [1]. psi4.core.OneBodyAOInt attribute, [1], [2]. psi4.core.OverlapInt attribute, [1]. psi4.core.PotentialInt attribute, [1]. psi4.core.PseudospectralInt attribute, [1]. psi4.core.QuadrupoleInt attribute, [1]. psi4.core.TracelessQuadrupoleInt attribute, [1]. original_coef() psi4.core.GaussianShell method, [1], [2]. ORTH_TYPE ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:88220,Optimiz,Optimized,88220,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,"4.core.UHF method, [1]. psi4.core.VBase method, [1], [2]. functionals. functions_local_to_global() psi4.core.BlockOPoints method, [1], [2]. fx() psi4.core.Molecule method, [1], [2]. fy() psi4.core.Molecule method, [1], [2]. fZ() psi4.core.Molecule method, [1], [2]. fz() psi4.core.Molecule method, [1], [2]. fzc() psi4.core.MOSpace method, [1], [2]. fzv() psi4.core.MOSpace method, [1], [2]. G. G_CONVERGENCE (OPTKING). gau2grid. GAUGE (CCDENSITY). (CCRESPONSE). Gaussian Formatted Checkpoint. GaussianShell class in psi4.core, [1]. GaussianType class in psi4.core, [1]. gCP. GDMA. gdma() in module psi4. in module psi4.driver. GDMA_LIMIT (GDMA). GDMA_MULTIPOLE_UNITS (GDMA). GDMA_ORIGIN (GDMA). GDMA_RADIUS (GDMA). GDMA_SWITCH (GDMA). gemm() psi4.core.Matrix method, [1], [2]. genbas() psi4.core.BasisSet method, [1], [2]. general. ; setting keywords. general_invert() psi4.core.Matrix method, [1], [2]. generate_oei() psi4.core.IntegralTransform method, [1], [2]. GEOM_MAXITER (OPTKING). geometry optimization. ; IRC. constrained. convergence criteria. function call. minima. output. transition state. geometry optimization, optimization. geometry() in module psi4.driver. psi4.core.Molecule method, [1], [2]. GeometryUnits class in psi4.core, [1]. get() psi4.core.IntVector method, [1], [2]. psi4.core.Matrix method, [1], [2]. psi4.core.Vector method, [1], [2]. get_active_efp() in module psi4.core, [1]. get_active_molecule() in module psi4.core, [1]. get_algorithm() psi4.core.FittingMetric method, [1], [2]. get_AO_core() psi4.core.DFHelper method, [1], [2]. get_AO_size() psi4.core.DFHelper method, [1], [2]. get_array() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. get_array_variable() in module psi4.core, [1]. get_array_variables() in module psi4.core, [1]. get_atomic_point_charg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:57570,optimiz,optimization,57570,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['optimiz'],['optimization']
Performance,"4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. orientation_fixed() psi4.core.Molecule method. origin psi4.core.AngularMomentumInt attribute. psi4.core.DipoleInt attribute. psi4.core.ElectricFieldInt attribute. psi4.core.ElectrostaticInt attribute. psi4.core.KineticInt attribute. psi4.core.MultipoleInt attribute. psi4.core.NablaInt attribute. psi4.core.OneBodyAOInt attribute. psi4.core.OverlapInt attribute. psi4.core.PotentialInt attribute. psi4.core.QuadrupoleInt attribute. psi4.core.TracelessQuadrupoleInt attribute. original_coef() psi4.core.GaussianShell method. ORTH_TYPE (DFOCC). (OCC). OS_SCALE (OCC). outfile_name() in module psi4.core. output. ; cbs(). database(). geometry optimization. SAPT. vibrational analysis. overlap() psi4.core.FISAPT method. overlap_3c() psi4.core.IntegralFactory method. OVERLAP_CHECK (CCEOM). overlap_grad() psi4.core.MintsHelper method. OverlapInt class in psi4.core. P. p psi4.core.AOShellCombinationsIterator attribute. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parent_atom() psi4.core.BlockOPoints method. PARENT_SYMMETRY (GLOBALS). parse_file() psi4.driver.AtomicComputer class method. parse_obj() psi4.driver.AtomicComputer class method. parse_raw() psi4.driver.AtomicComputer class method. ParsingError. partial_cholesky_factorize() psi4.core.Matrix method. partition() psi4.core.FISAPT method. PastureRequiredError. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32]. PBS queueing system. PCG_BETA_TYPE (DFOCC). (OCC). PCG_CONVERGENCE (DFOCC). (OCC). PCG_MAXITER (D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:105987,optimiz,optimization,105987,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['optimiz'],['optimization']
Performance,"4.core.VBase) -> None. Initializes the V object. nblocks(self: psi4.core.VBase) → int¶; Total number of blocks. print_header(self: psi4.core.VBase) → None¶; Prints the objects header. properties(self: psi4.core.VBase) → List[psi::PointFunctions]¶; Returns the properties computer. quadrature_values(self: psi4.core.VBase) → Dict[str, float]¶; Returns the quadrature values. set_D(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; Sets the internal density. set_debug(self: psi4.core.VBase, arg0: int) → None¶; Sets the debug level of the object. set_print(self: psi4.core.VBase, arg0: int) → None¶; Sets the print level of the object. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None; Returns internal AO density. basis(self: psi4.core.VBase) → psi4.core.BasisSet; Returns the internal basis set. build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str) → psi4.core.VBase. build_collocation_cache(self: psi4.core.VBase, arg0: int) → None; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase) → None; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None; doctsring. compute_Vx(self: psi4.core.VBase, arg0: List[psi4.core.Matrix], arg1: List[psi4.core.Matrix]) → None; doctsring. compute_gradient(self: psi4.core.VBase) → psi4.core.Matrix; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase) → psi4.core.Matrix; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs); Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase) → psi4.core.SuperFunctional; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int) → psi::BlockOPoints; Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vbase.html:3988,cache,cache,3988,psi4manual/1.3.2/api/psi4.core.vbase.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vbase.html,1,['cache'],['cache']
Performance,"4.driver.freq¶. psi4.driver.freq(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html:1090,perform,performs,1090,psi4manual/1.1.0/api/psi4.driver.freq.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.freq.html,1,['perform'],['performs']
Performance,"4.get_active_molecule()); molecule.update_geometry(); molname = molecule.name(). geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]. symbol = list(range(numatoms)); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(numatoms):; A = F[f + 1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < _autofragment_convert(u, symbol) + _autofragment_convert(i, symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". moleculenew = psi4.Molecule.create_molecule_from_string(new_geom); moleculenew.set_name(molname); moleculenew.update_geometry(); moleculenew.print_cluster(); psi4.print_out("""""" Exiting auto_fragments\n""""""). return moleculenew. Quick search. Enter search terms or a module,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html:3799,Queue,Queue,3799,psi4manual/1.0.0/_modules/wrapper_autofrag.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html,1,['Queue'],['Queue']
Performance,"4.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); psi4.wavefunction().energy(). optstash.restore(); return psi4.get_variable('CURRENT ENERGY'). else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:35251,Optimiz,Optimize,35251,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"4/include/psi4/masses.h. See freq-isotope for about; the only use to which isotopologues can presently be put in PSI4. PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; 1; 2; 3molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whose name(s) contain “benzene”, but we’re not sure of the exact IUPAC; name, the following input can be used:; 1; 2; 3molecule benzene {; pubchem:benzene*; }. Appending the “*” prevents an exact match from being found and, at the time; of writing, the following results are displayed in the output file:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21Chemical ID IUPAC Name; 241 benzene; 7371 benzenesulfonic acid; 91526 benzenesulfonate; 244 phenylmethanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:8351,perform,performed,8351,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['perform'],['performed']
Performance,"4/plugins/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/plugins/sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:4634,load,load,4634,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,2,['load'],['load']
Performance,"4985 3.264065; H -6.592753 0.807024 3.281508; H -6.368443 -0.968607 3.273516; nocom; unit angstrom; }. # Create a python dictionary and convert to string for pass through to optking; MTdimer = """"""{; ""Natoms per frag"": [12, 16],; ""A Frag"": 1,; ""A Ref Atoms"": [[1, 3, 4, 6, 8], [8], [11]],; ""A Label"": ""methylthiophene"",; ""B Frag"": 2,; ""B Ref Atoms"": [[13, 14, 15, 16, 17, 18], [13], [15]],; ""B Label"": ""tyrosine"",; ""Frozen"": [""theta_A"", ""theta_B"", ""tau"", ""phi_A"", ""phi_B""],; }"""""". set {; basis 6-31+G; frag_mode MULTI; interfrag_coords $MTdimer; }. optimize(""mp2""). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the dynamic level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals.; Optking does support the specification of ghost atoms. Certain internal coordinates such; as torsions bec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:16680,perform,perform,16680,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,4,['perform'],['perform']
Performance,"4; 5; 6; 7; 8molecule {; H 0.0 0.0 0.0; H 1.0 0.0 0.0; }. set mp2_type conv. cbs('mp2', corl_basis='cc-pV[TQ]Z', delta_wfn='c4-ccsd(t)', delta_basis='cc-pV[DT]Z'). This yields:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10==> CBS <==. ---------------------------------------------------------------------------------------------------------; Stage Method / Basis Energy [H] Scheme; ---------------------------------------------------------------------------------------------------------; scf scf / cc-pvqz -1.10245974 highest_1; corl mp2 / cc-pv[tq]z -0.03561890 corl_xtpl_helgaker_2; delta c4-ccsd(t) - mp2 / cc-pv[dt]z 0.03507767 corl_xtpl_helgaker_2; total CBS -1.10300098; ---------------------------------------------------------------------------------------------------------. Note that especially for complete_basis_set(), the; basis set needs to be specified through BASIS, not; CFOUR_BASIS. Many of the wrappers can be used in combination to,; for example, apply a compound method to every molecule in a database or to; optimize a molecule with an extrapolated basis set (findif only for the; moment- analytics coming).; Finally, any number and combination of jobs can be run from a single; PSI4 input file. Depending on the nature of preceding or following; jobs, it is prudent to separate them with the following:; 1; 2; 3clean() # removes Psi4 scratch files; clean_variables() # empties the PSI variables list; cfour {} # empties the cfour block. Warning; Because p4c4 does not inspect the contents of the cfour {...}; block, once the user specifies a PSI4-style molecule, the; interface cannot judge whether a sandwich mode (drop the PSI4 molecule; and use the cfour block as the entirety of the ZMAT) or a standard mode; (translate the PSI4 molecule and append additional input from the; cfour block) is intended. The latter is what actually occurs. If; there is both a PSI4 molecule and a molecule in the cfour block,; ZMAT will end up with multiple molecules and multiple *CFOUR(...); blocks, and i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:18000,optimiz,optimize,18000,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,6,['optimiz'],['optimize']
Performance,"4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. scf-ecp2; Water-Argon complex with ECP present; check of RHF Hessian. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc12; Single point energies of multiple excited states with EOM-CCSD. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cbs-xtpl-func; optimization with method defined via cbs. fcidump; test FCIDUMP functionality for rhf/uhf. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. scf-level-shift-rohf; SCF level shift on an ROHF computation. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. scf3; File retention, docc, socc, and bond distances specified explicitly. opt16; SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:33608,perform,performed,33608,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"4; []. -D2GR; -D2 [3] through dftd3; [, ]. -D3; alias to -D3ZERO;  . -D3ZERO; -D3 [4] w/ original zero-damping through dftd3; [, , , ]. -D3BJ; -D3 [5] w/ newer Becke-Johnson rational damping through dftd3; [, , , ]. -D3M; alias to -D3MZERO;  . -D3MZERO; -D3 [6] w/ reparameterized and more flexible original zero-damping through dftd3; [, , , ]. -D3MBJ; -D3 [6] w/ reparameterized newer Becke-Johnson rational damping through dftd3; [, , , ]. Footnotes. [1]Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, have nothing to do with this table. [2][Grimme:2004:1463]. [3](1, 2) [Grimme:2006:1787]. [4][Grimme:2010:154104]. [5][Grimme:2011:1456]. [6](1, 2) [Smith:2016:2197]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same Psi4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene.run_dftd3(dashlvl='d3', dashparam={'s8': 2.0, 'alpha6': 14.0, 'sr6': 1.261, 's6': 1.0}); >>",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dftd3-1.html:6388,optimiz,optimize,6388,psi4manual/1.0.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dftd3-1.html,2,['optimiz'],['optimize']
Performance,"4;  · . PSI4. Appendices; Keywords by Module; DFMP2. DFMP2¶; Performs density-fitted MP2 computations for RHF/UHF/ROHF reference wavefunctions. General¶. BASIS¶. Primary basis set. Type: string; Possible Values: basis string; Default: NONE. DFMP2_MEM_FACTOR¶. % of memory for DF-MP2 three-index buffers. Type: double; Default: 0.9. DFMP2_P2_TOLERANCE¶. Minimum error in the 2-norm of the P(2) matrix for corrections to Lia and P. Type: conv double; Default: 0.0. DFMP2_P_TOLERANCE¶. Minimum error in the 2-norm of the P matrix for skeleton-core Fock matrix derivatives. Type: conv double; Default: 0.0. DF_BASIS_MP2¶. Auxiliary basis set for MP2 density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_INTS_NUM_THREADS¶. Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. MP2_OS_SCALE¶. OS Scale. Type: double; Default: 6.0. MP2_SS_SCALE¶. SS Scale. Type: double; Default: 1.0. ONEPDM¶. Do compute one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: true. Expert¶. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. MADMP2_SLEEP¶. A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. table of contents. DFMP2; General; BASIS; DFMP2_MEM_FACTOR; DFMP2_P2_TOLERANCE; DFMP2_P_TOLERANCE; DF_BASIS_MP2; DF_INTS_NUM_THREADS; INTS_TOLERANCE; MP2_OS_SCALE; MP2_SS_SCALE; ONEPDM; OPDM_RELAX. Expert; DF_INTS_IO; MADMP2_SLEEP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; DFMP2. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dfmp2-1.html:1447,LOAD,LOAD,1447,psi4manual/1.4.0/autodir_options_c/module__dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dfmp2-1.html,2,['LOAD'],['LOAD']
Performance,"4util.extract_sowreap_from_output(rfile, 'HESSIAN', n, freq_linkage, True)). # S/R: Quit sow after writing files. Initialize skeleton wfn to receive grad for reap; if freq_mode == 'sow':; optstash.restore(); optstash_conv.restore(); if return_wfn:; return (None, None); else:; return None; elif freq_mode == 'reap':; wfn = core.Wavefunction.build(molecule, core.get_global_option('BASIS')). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = core.fd_freq_1(molecule, gradients, irrep) # TODO or moleculeclone?; wfn.set_hessian(H); wfn.set_gradient(G0); wfn.set_frequencies(core.get_frequencies()). # The last item in the list is the reference energy, return it; core.set_variable('CURRENT ENERGY', energies[-1]). core.set_parent_symmetry(''); optstash.restore(); optstash_conv.restore(). _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = core.fd_geoms_freq_0(moleculeclone, irrep); moleculeclone.fix_orientation(True); moleculeclone.reinterpret_coordentry(False). # Record undisplaced symmetry for projection of diplaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:77896,perform,perform,77896,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,"4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the parallelism; afforded by OpenMP, and to make that code available to the front end as; described in Exposing C++ code to Python. The Python layer could then be; responsible for obtaining the input data and calling this C++ code to do the; manipulations, allowing each language layer to handle the subset of the work; that caters to their individual strengths.; A number of concrete examples of this workflow exist in the code already. For; finite difference computations of energy derivatives, the logic to determine; the type of stencil and which displacements are needed is not going to be rate; limiting for any reasonable quantum mechanical energy function. Therefore,; doing that work in the Pyth",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_ways_to_add.html:4778,perform,perform,4778,psi4manual/master/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_ways_to_add.html,9,['perform'],['perform']
Performance,"5 CORRELATION ENERGY. OMP2.5 DOUBLES ENERGY. OMP2.5 TOTAL ENERGY. OMP3. ; setting keywords. theory. OMP3 CORRELATION ENERGY. OMP3 DOUBLES ENERGY. OMP3 TOTAL ENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRON ENERGY. one_electron_integrals() psi4.core.MintsHelper method. OneBodyAOInt class in psi4.core. OneBodySOInt class in psi4.core. onel_Hx() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() psi4.core.CIWavefunction method. OPDM_GRID_CUTOFF (CCDENSITY). OPDM_GRID_DUMP (CCDENSITY). OPDM_GRID_STEPSIZE (CCDENSITY). OPDM_ONLY (CCDENSITY). OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:103935,optimiz,optimize,103935,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['optimiz'],['optimize']
Performance,"5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; 1procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; 1energy('mp2.5'). Navigation. Index. modules",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html:2778,optimiz,optimizations,2778,psi4manual/1.1.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html,2,['optimiz'],['optimizations']
Performance,"5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; 1procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; 1energy('mp2.5'). «; hide menu. menu; sideba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/quickaddalias-1.html:2780,optimiz,optimizations,2780,psi4manual/1.2.1/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/quickaddalias-1.html,4,['optimiz'],['optimizations']
Performance,"5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; Customizatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html:2529,optimiz,optimizations,2529,psi4manual/1.0.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html,2,['optimiz'],['optimizations']
Performance,"5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). Previous topic; User-Defined",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html:2467,optimiz,optimizations,2467,psi4manual/4.0b5/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/quickaddalias-1.html,2,['optimiz'],['optimizations']
Performance,"5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method to be called in the input file; with the following command.; energy('mp2.5'). «; hide menu. menu; sidebar;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/quickaddalias.html:2626,optimiz,optimizations,2626,psi4manual/master/quickaddalias.html,https://psicode.org,https://psicode.org/psi4manual/master/quickaddalias.html,9,['optimiz'],['optimizations']
Performance,"5); ...; N-Body: Computing complex (1/1) with fragments (1, 2) in the basis of fragments (1, 2).; ...; N-Body: Complex Energy (fragments = (1, 2), basis = (1, 2): -257.41867403127321); ...; ==> N-Body: Counterpoise Corrected (CP) energies <==. n-Body Total Energy [Eh] I.E. [kcal/mol] Delta [kcal/mol]; 1 -257.418648109779 0.000000000000 0.000000000000; 2 -257.418674031273 -0.016265984132 -0.016265984132. And that’s it! The only remaining part of the example is a little table of the different R values and the CP-corrected CCSD(T) energies, converted from atomic units (Hartree) to kcal mol\(^{-1}\) by multiplying by the automatically-defined conversion factor psi4.constants.hartree2kcalmol. Psi4 provides several built-in physical constants and conversion factors, as described in the Psi4 manual section Physical; Constants. The table can be printed either to the screen, by using standard Python ``print()` syntax <https://docs.python.org/3/whatsnew/3.0.html#print-is-a-function>`__, or to the designated output file output.dat using Psi4’s built-in function psi4.core.print_out() API (C style printing).; As we’ve seen so far, the combination of Psi4 and Python creates a unique, interactive approach to quantum chemistry. The next section will explore this synergistic relationship in greater detail, describing how even very complex tasks can be done very easily with Psi4. table of contents. PsiAPI Tutorial: Using Psi4 as a Python Module; I. Basic Input Structure; II. Running a Basic Hartree-Fock Calculation; III. Geometry Optimization and Vibrational Frequency Analysis; IV. Analysis of Intermolecular Interactions; V. Potential Surface Scans and Counterpoise Correction Made Easy. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. A PSI4 Tutorial; PsiAPI Tutorial: Using Psi4 as a Python Module. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psiapi.html:23175,Optimiz,Optimization,23175,psi4manual/master/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/master/psiapi.html,1,['Optimiz'],['Optimization']
Performance,"5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); tensor[1][1] += self.mass(i) * (self.x(i) * self.x(i) + self.z(i) * self.z(i)); ten",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12519,Queue,Queue,12519,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Queue'],['Queue']
Performance,"5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True, zero=ZERO):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt, zero). [docs] def inertia_tensor_partial(self, part, masswt=True, zero=ZERO):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); tensor[1][1] += self.mass(i) * (self.x(i) * self.x(i) +",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:29907,Queue,Queue,29907,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Queue'],['Queue']
Performance,"5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while White or Queue: # Iterates to the next fragment; Fragment.append([]). while Queue: # BFS within a fragment; for u in Queue: # find all white neighbors to vertex u; for i in White:; dist = constants.bohr2angstroms * math.sqrt(; (self.x(i) - self.x(u)) ** 2 +; (self.y(i) - self.y(u)) ** 2 +; (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + \; vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # & remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if White: # can't move White -> Queue if empty; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the core.Molecule class. """"""; cls.__setattr__ = molecule_set_attr; cls.__getattr__ = molecule_get_attr. cls.BFS = BFS. dynamic_variable_bind(core.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user use but deprecated; in driver in fa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/molutil.html:6710,queue,queue,6710,psi4manual/1.1.0/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/molutil.html,1,['queue'],['queue']
Performance,"5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. scf-guess-read2; Test if the the guess read in the same basis converges. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. fsapt-ext-abc; FSAPT with external charge on trimer. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. fsapt-allterms; This te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:36097,optimiz,optimization,36097,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"50. GRADIENT_WRITE (FINDIF)¶FINDIF — Do write a gradient output file? If so, the filename will end in .grad, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. GUESS (SCF)¶SCF — The type of guess orbitals. Defaults to READ for geometry optimizations after the first step, to CORE for single atoms, and to SAD otherwise. The HUCKEL guess employs on-the-fly calculations like SAD, as described in doi:10.1021/acs.jctc.8b01089 which also describes the SAP guess. Type: string; Possible Values: AUTO, CORE, GWH, SAD, SADNO, SAP, HUCKEL, READ; Default: AUTO. GUESS_MIX (SCF)¶SCF — Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST (SCF)¶SCF — If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. GUESS_R_CONVERGENCE (DCT)¶DCT — Convergence criterion for the density cumulant and orbital guess for the variationally orbital-optimized DFT methods. Currently only available for ALGORITHM = SIMULTANEOUS. Type: conv double; Default: 1e-3. GUESS_VECTOR (DETCI)¶DETCI (Expert) — Guess vector type. Accepted values are UNIT for a unit vector guess (NUM_ROOTS and NUM_INIT_VECS must both be 1); H0_BLOCK to use eigenvectors from the H0 BLOCK submatrix (default); DFILE to use NUM_ROOTS previously converged vectors in the D file;. Type: string; Possible Values: UNIT, H0_BLOCK, DFILE; Default: H0_BLOCK. H0_BLOCK_COUPLING (DETCI)¶DETCI (Expert) — Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE (DETCI)¶DETCI (Expert) — Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:139831,optimiz,optimization,139831,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimization']
Performance,"5097}}. DB_RXN; {'S22-16': {'CURRENT ENERGY': -0.0035470557928363178,; 'DF-MP2 CORRELATION ENERGY': -0.0014825844040612934},; 'S22-2': {'CURRENT ENERGY': -0.011500269334817403,; 'DF-MP2 CORRELATION ENERGY': -0.0024741470062974724},; 'S22-8': {'CURRENT ENERGY': -0.0002623068456699684,; 'DF-MP2 CORRELATION ENERGY': -0.0006910051439986686}}. mp2 interaction energy of water dimer (S22-2); -0.0115002693348. Available Databases¶; Below are documented for particular databases the availability of the generic; database function options cp, rlxd, benchmark, and the string; options for subset. The full reagent member list, which can also be used; in conjunction with subset, is not included here for consideration of space; and may be found in the database file. The database Python files are very; readable and should be consulted for more particular questions. CORE¶. Database of Pulay corannulene structures. Subsumed into CFLOW. cp 'off' || 'on'; rlxd 'off'. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. BAKERJCC96¶. Geometries from Baker and Chan J. Comput. Chem. 17 888 (1996),. as reported in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002). No reference energies defined. cp 'off'; rlxd 'off'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. HTR40¶. Database of Hydrogen transfer reactions.; Geometries from Bozkaya and Sherrill.; Reference energies from Bozkaya and Sherrill. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small' <members_description>; 'large' <members_description>; '<subset>' <members_description>. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/db.html:11979,optimiz,optimize,11979,psi4manual/1.7.x/db.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/db.html,1,['optimiz'],['optimize']
Performance,"51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re. # Relative hack for now; import sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; from p4util.exceptions import *; from molutil import *. from .functional import *; from .roa import *; from . import proc_util. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. [docs]def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP2_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:2105,perform,performance,2105,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"5100700 -0.11452000 0.00000000; H -1.93425900 0.76250300 0.00000000; H -0.59967700 0.04071200 0.00000000; --; 0 1; @X 0.00000000 0.00000000 0.00000000; O 1.35062500 0.11146900 0.00000000; H 1.68039800 -0.37374100 -0.75856100; H 1.68039800 -0.37374100 0.75856100; units Angstrom. Elemental masses (most common isotope), symbols, and atomic numbers from psi4.; Stuff stolen from psi. Should import or not as necessary; or some better way. Apologies to the coders. compare_matrices(expected, computed, digits, label)[source]¶; Function to compare two matrices. Prints util.success(); when elements of matrix computed match elements of matrix expected to; number of digits. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. compare_values(expected, computed, digits, label)[source]¶; Function to compare two values. Prints util.success(); when value computed matches value expected to number of digits.; Performs a system exit on failure. Used in input files in the test suite. query_yes_no(question, default=True)[source]¶; Ask a yes/no question via raw_input() and return their answer.; question is a string that is presented to the user.; default is the presumed answer if the user just hits <Enter>.; It must be yes (the default), no or None (meaning; an answer is required of the user).; The return value is one of True or False. File for accessory procedures in the chem module.; Credit for the libmints vector3 class to Justin M. Turney and; incremental improvements by other psi4 developers. add(v, u)[source]¶; Compute sum of vectors v and u. cross(v, u)[source]¶; Compute cross product of length 3 vectors v and u. determinant(mat)[source]¶; Given 3x3 matrix mat, compute the determinat. diagonalize3x3symmat(A)[source]¶; Given an real symmetric 3x3 matrix A, compute the eigenvalues. distance(v, u)[source]¶; Compute the distance between points defined by vectors v and u. dot(v, u)[source]¶; Compute dot prod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:63997,Perform,Performs,63997,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,4,['Perform'],['Performs']
Performance,"51077). F/I-SAPT. “Chemical Assignment of Symmetry-Adapted Perturbation Theory Interaction; Energy Components: The Functional-Group SAPT Partition,”; R. M. Parrish, T. M. Parker, and C. D. Sherrill,; J. Chem. Theory Comput. 10, 4417 (2014).; (doi: 10.1021/ct500724p).; “Communication: Practical Intramolecular Symmetry Adapted Perturbation Theory; via Hartree-Fock Embedding,”; R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C. D. Sherrill,; J. Chem. Phys. 143, 051103 (2015).; (doi: 10.1063/1.4927575). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:13316,optimiz,optimized,13316,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,6,['optimiz'],['optimized']
Performance,"544965 1.16e-04 1.16e-04; ----------------------------------------------------------------------. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at the output from running the; previous example, we see that the OH bond length is about 0.9463 Ångstroms,; and the bond angle is about 104.575 degrees. It’s good to give this many; digits (or more) to make sure there’s not significant roundoff error in the; geometry when running a frequency computation. So, our frequency; computation input (which can be found as test case; tu4-h2o-freq is:; #! Frequencies for H2O HF/cc-pVDZ at optimized geometry. memory 250 mb. molecule h2o {; O ; H 1 0.9463; H 1 0.9463 2 104.575; }. set basis cc-pVDZ; set scf_type pk; frequencies('scf'). Alternatively, it’s also possible for PSI4 to use Cartesian coordinate; input. Here, the Cartesian coordinates of the optimized geometry can be; extracted from the bottom of the optimization output. The input; would then look like this:; molecule h2o {; O 0.0000000000 -0.0000000000 -0.1224239500; H 0.0000000000 -1.4147069876 0.9714784639; H -0.0000000000 1.4147069876 0.9714784639; }. set basis cc-pVDZ; frequencies('scf'). If either of the inputs above are run, the program should do some; computations and then finally report the following harmonic vibrational; frequencies (roundoff errors of around 0.1 cm-1 may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1776.1735; A1 4113.8031; B2 4211.7879; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; Frequency: 1776.17; Force constant: 0.1194; X Y Z; O 0.000 0.000 -0.067; H 0.000 0.416 0.536; H 0.000 -0.416 0.536. w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:6547,optimiz,optimized,6547,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,4,['optimiz'],"['optimization', 'optimized']"
Performance,"5860; --; C -6.955593 -0.119764 -1.395442; C -6.977905 -0.135060 1.376787; C -7.111625 1.067403 -0.697024; C -6.810717 -1.314577 -0.707746; C -6.821873 -1.322226 0.678369; C -7.122781 1.059754 0.689090; H -7.226173 2.012097 -1.240759; H -6.687348 -2.253224 -1.259958; H -6.707325 -2.266920 1.222105; H -7.246150 1.998400 1.241304; O -6.944245 -0.111984 -2.805375; H -7.058224 0.807436 -3.049180; C -6.990227 -0.143507 2.907714; H -8.018305 -0.274985 3.264065; H -6.592753 0.807024 3.281508; H -6.368443 -0.968607 3.273516; nocom; unit angstrom; }. # Create a python dictionary and convert to string for pass through to optking; MTdimer = """"""{; ""Natoms per frag"": [12, 16],; ""A Frag"": 1,; ""A Ref Atoms"": [[1, 3, 4, 6, 8], [8], [11]],; ""A Label"": ""methylthiophene"",; ""B Frag"": 2,; ""B Ref Atoms"": [[13, 14, 15, 16, 17, 18], [13], [15]],; ""B Label"": ""tyrosine"",; ""Frozen"": [""theta_A"", ""theta_B"", ""tau"", ""phi_A"", ""phi_B""],; }"""""". set {; basis 6-31+G; frag_mode MULTI; interfrag_coords $MTdimer; }. optimize(""mp2""). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the dynamic level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:16230,optimiz,optimize,16230,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,4,['optimiz'],['optimize']
Performance,"59886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:6724,optimiz,optimize,6724,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['optimiz'],['optimize']
Performance,"5;  · . PSI4. Appendices; Keywords by Module; DFMP2. DFMP2¶; Performs density-fitted MP2 computations for RHF/UHF/ROHF reference wavefunctions. General¶. BASIS¶. Primary basis set. Type: string; Possible Values: basis string; Default: NONE. DFMP2_MEM_FACTOR¶. % of memory for DF-MP2 three-index buffers. Type: double; Default: 0.9. DFMP2_P2_TOLERANCE¶. Minimum error in the 2-norm of the P(2) matrix for corrections to Lia and P. Type: conv double; Default: 0.0. DFMP2_P_TOLERANCE¶. Minimum error in the 2-norm of the P matrix for skeleton-core Fock matrix derivatives. Type: conv double; Default: 0.0. DF_BASIS_MP2¶. Auxiliary basis set for MP2 density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_INTS_NUM_THREADS¶. Number of threads to compute integrals with. 0 is wild card. Type: integer; Default: 0. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. MP2_OS_SCALE¶. OS Scale. Type: double; Default: 6.0. MP2_SS_SCALE¶. SS Scale. Type: double; Default: 1.0. ONEPDM¶. Do compute one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: true. Expert¶. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. MADMP2_SLEEP¶. A helpful option, used only in debugging the MADNESS version. Type: integer; Default: 0. table of contents. DFMP2; General; BASIS; DFMP2_MEM_FACTOR; DFMP2_P2_TOLERANCE; DFMP2_P_TOLERANCE; DF_BASIS_MP2; DF_INTS_NUM_THREADS; INTS_TOLERANCE; MP2_OS_SCALE; MP2_SS_SCALE; ONEPDM; OPDM_RELAX. Expert; DF_INTS_IO; MADMP2_SLEEP. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; DFMP2. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__dfmp2-1.html:1447,LOAD,LOAD,1447,psi4manual/1.5.0/autodir_options_c/module__dfmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__dfmp2-1.html,2,['LOAD'],['LOAD']
Performance,"5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Consid",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:16185,perform,performance,16185,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"5rpa_c_functional() (in module functional). build_wb88_x_functional() (in module functional). build_wb88_x_superfunctional() (in module functional). build_wb97_superfunctional() (in module functional). build_wb97x_superfunctional() (in module functional). build_wb97xd_superfunctional() (in module functional). build_wblyp_superfunctional() (in module functional). build_wpbe0_superfunctional() (in module functional). build_wpbe_superfunctional() (in module functional). build_wpbe_x_functional() (in module functional). build_wpbe_x_superfunctional() (in module functional). build_wpbesol0_superfunctional() (in module functional). build_wpbesol_superfunctional() (in module functional). build_wpbesol_x_functional() (in module functional). build_wpbesol_x_superfunctional() (in module functional). build_ws_x_functional() (in module functional). build_ws_x_superfunctional() (in module functional). build_wsvwn_superfunctional() (in module functional). C. C-side; . setting keywords. CACHELEV (PLUGIN_MP2), [1]. (PLUGIN_TEST_MATRIX), [1]. CACHELEVEL (ADC). (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCSORT). (DCFT). (MP2). (OMP2). (STABILITY). (TRANSQT2). CACHETYPE (CCENERGY). (CCEOM). (MP2). call_function_in_1st_argument() (in module wrappers). CANONICALIZE_ACTIVE_FAVG (MCSCF). CANONICALIZE_INACTIVE_FAVG (MCSCF). CART_HESS_READ (OPTKING). CAS_FILES_WRITE (CLAG). cbs(); . extrapolation schemes. output. setting keywords. theory, [1]. CBSCORRELATIONENERGY. CBSREFERENCEENERGY. CBSTOTALENERGY. CC; . theory. CC (DETCI). CC, coupled cluster. CC2CORRELATIONENERGY. CC2TOTALENERGY. CC3_FOLLOW_ROOT (CCEOM). CC3CORRELATIONENERGY. CC3TOTALENERGY. CC_A_RAS3_MAX (DETCI). CC_B_RAS3_MAX (DETCI). CC_EX_LEVEL (DETCI). CC_FIX_EXTERNAL (DETCI). CC_FIX_EXTERNAL_MIN (DETCI). CC_MACRO (DETCI). CC_MAXITER (OMP2). CC_MIXED (DETCI). CC_NUM_THREADS (CCENERGY). (CCEOM). (CCTRIPLES). (PSIMRCC). CC_OS_SCALE (CCENERGY). CC_RAS34_MAX (DETCI). CC_RAS3_MAX (DETCI). CC_RAS4_MAX (DETCI).",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/genindex.html:5236,CACHE,CACHELEV,5236,psi4manual/4.0b2/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/genindex.html,1,['CACHE'],['CACHELEV']
Performance,"6 / 1.5, # Bondi JPC 68 441 (1964); 'B': 1.65 / 1.5, # Bondi JPC 68 441 (1964); 'C': 1.53 / 1.5, # Bondi JPC 68 441 (1964); 'N': 1.46 / 1.5, # Bondi JPC 68 441 (1964); 'O': 1.42 / 1.5, # Bondi JPC 68 441 (1964); 'F': 1.40 / 1.5, # Bondi JPC 68 441 (1964); 'SI': 1.93 / 1.5, # Bondi JPC 68 441 (1964); 'P': 1.86 / 1.5, # Bondi JPC 68 441 (1964); 'S': 1.80 / 1.5, # Bondi JPC 68 441 (1964); 'CL': 1.75 / 1.5, # Bondi JPC 68 441 (1964); 'GE': 1.98 / 1.5, # Bondi JPC 68 441 (1964); 'AS': 1.94 / 1.5, # Bondi JPC 68 441 (1964); 'SE': 1.90 / 1.5, # Bondi JPC 68 441 (1964); 'BR': 1.87 / 1.5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:29234,Queue,Queue,29234,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,2,['Queue'],['Queue']
Performance,"6. SS_R_CONVERGENCE¶. Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG¶. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT¶. SS vectors stored per root. Type: integer; Default: 5. T3_WS_INCORE¶. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. VECS_CC3¶. Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT¶. Vectors stored per root. Type: integer; Default: 12. Expert¶. EXCITATION_RANGE¶. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. WFN¶. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. table of contents. CCEOM; General; ABCD; CACHELEVEL; CACHETYPE; CC3_FOLLOW_ROOT; CC_NUM_THREADS; COLLAPSE_WITH_LAST; COMPLEX_TOLERANCE; EOM_GUESS; EOM_REFERENCE; E_CONVERGENCE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_GHOST; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; R_CONVERGENCE; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT. Expert; EXCITATION_RANGE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cceom-1.html:6786,CACHE,CACHELEVEL,6786,psi4manual/1.2.1/autodir_options_c/module__cceom-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cceom-1.html,4,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"62503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/sapt-1.html:3680,perform,performed,3680,psi4manual/4.0b3/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/sapt-1.html,8,['perform'],['performed']
Performance,"62503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard Psi4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; Psi4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of SAPT0 and other SAPT; truncations, using different basis sets, is reported in; [Parker:2014:094106]. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:6909,perform,performed,6909,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['performed']
Performance,"656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:8170,Optimiz,Optimized,8170,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,4,"['Optimiz', 'optimiz']","['Optimized', 'optimized']"
Performance,"656681).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010).; (doi: 10.1063/1.3426316). DF-SAPT2, DF-SAPT2+, DF-SAPT2+(3), DF-SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Sp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/introduction-1.html:8220,Optimiz,Optimized,8220,psi4manual/4.0b5/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/introduction-1.html,4,"['Optimiz', 'optimiz']","['Optimized', 'optimized']"
Performance,"7019107, 0.0, -3.799961446760); Chrgfield.extern.addCharge( 0.417, 0.544757019107, 0.0, -0.912085762652); psi4.set_global_option_python('EXTERN',Chrgfield.extern). First a QMMM object is created, then three separate particles are added to this; object before the SCF code is told about its existence on the last line. The; calls to addCharge take the atomic charge, x coordinate, y coordinate, and; z coordinate in that order. The atomic charge is specified in atomic units,; and the coordinates always use the same units as the geometry specification in; the regular QM region. Additional MM molecules may be specified by adding; extra calls to addCharge to describe the full MM region. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2](1, 2) This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf.html:30673,optimiz,optimization,30673,psi4manual/1.0.0/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf.html,2,['optimiz'],['optimization']
Performance,"71b] » ; Module code ». Source code for qcdb.libmintsbasissetparser; from __future__ import absolute_import; from __future__ import print_function; from __future__ import division; import os; import re; import sys; from .exceptions import *; from .libmintsgshell import *; if sys.version_info >= (3,0):; basestring = str. [docs]class Gaussian94BasisSetParser(object):; """"""Class for parsing basis sets from a text file in Gaussian 94; format. Translated directly from the Psi4 libmints class written; by Justin M. Turney and Andrew C. Simmonett. """""". def __init__(self, forced_puream=None):; """"""Constructor""""""; # If the parser needs to force spherical or cartesian (e.g., loading old guess); self.force_puream_or_cartesian = False if forced_puream is None else True; # Is the forced value to use puream? (Otherwise force Cartesian).; self.forced_is_puream = False if forced_puream is None else forced_puream; # string filename; self.filename = None. [docs] def load_file(self, filename, basisname=None):; """"""Load and return the file to be used by parse. Return only; portion of *filename* pertaining to *basisname* if specified (for; multi-basisset files) otherwise entire file as list of strings. """"""; # string filename; self.filename = filename. given_basisname = False if basisname is None else True; found_basisname = False; basis_separator = re.compile(r'^\s*\[\s*(.*?)\s*\]\s*$'). # Loads an entire file.; try:; infile = open(filename, 'r'); except IOError:; raise BasisSetFileNotFound(""""""BasisSetParser::parse: Unable to open basis set file: %s"""""" % (filename)); if os.stat(filename).st_size == 0:; raise ValidationError(""""""BasisSetParser::parse: given filename '%s' is blank."""""" % (filename)); contents = infile.readlines(). lines = []; for text in contents:; text = text.strip(); # If no basisname was given always save the line.; if given_basisname is False:; lines.append(text). if found_basisname:; # If we find another [*] we're done.; if basis_separator.match(text):; what = basis_separa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html:1124,Load,Load,1124,psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasissetparser.html,1,['Load'],['Load']
Performance,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimrcc-1.html:2596,optimiz,optimized,2596,psi4manual/4.0b3/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimrcc-1.html,19,['optimiz'],['optimized']
Performance,"74107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for hig",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2569,optimiz,optimized,2569,psi4manual/4.0b2/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html,2,['optimiz'],['optimized']
Performance,"7; Single point energies of multiple excited states with EOM-CCSD. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. cc25; Single point gra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:11254,optimiz,optimized,11254,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimized']
Performance,"8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; # print(""about to generate displacements""); displacements = core.fd_geoms_1_0(moleculeclone); # print(displacements); ndisp = len(displacements); # print(""generated d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:38842,Optimiz,Optimize,38842,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['Optimiz'],['Optimize']
Performance,"8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; # print(""about to generate displacements""); displacements = core.fd_geoms_1_0(moleculeclone); # print(displacements); ndisp = len(displacements); # print(""generated d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:37669,Optimiz,Optimize,37669,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Optimiz'],['Optimize']
Performance,"8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; psi4.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; psi4.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(moleculeclone); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:36438,Optimiz,Optimize,36438,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"8, 3.9, 3.10, 3.11, and 3.12.; PSI4 1.10 is anticipated to support Python 3.8, 3.9, 3.10, 3.11, and 3.12.; The future plan is to (1) be compatible with 3.8 and above until there is a good reason to drop; older versions but (2) only build and test for versions conda-forge supports.; The current master supports 3.8, 3.9, 3.10, 3.11, and 3.12. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; General GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties.; For more tables with capabilities details:. Full Capabilities (first below) lists all methods; Capabilities Breakdown (second below) lists selected methods by reference, etc.; Module Capabilities lists selected methods by implementation; Energy, Energy (DFT), Energy (MRCC), Energy (CFOUR) fully list energy target methods; Gradient, Gradient (CFOUR) fully list gradient target methods; Frequency fully lists Hessian target methods. Summary of theoretical methods available in PSI4¶. Method [1]; Reference[2]; Type[2]; Variants[3]. Canonical; OO; FNO [4]; DLPNO. HF; RHF/UHF/ROHF/CUHF; CONV/DF/CD; E/G/H. DFT; RKS/UKS; CONV/DF/CD; E/G. DFT-D2, DFT-NL; RKS/UKS; CONV/DF/CD; E/G. DCT; RHF/UHF; CONV/DF; E/G. MP2; RHF/UH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:24220,optimiz,optimization,24220,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,2,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"8.92534160932308. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt.; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After about 4 cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; ----------------------------------------------------------------------; Step Energy Delta(E) MAX force MAX Delta(q); ----------------------------------------------------------------------; 1 -76.026653665892 -76.026653665892 1.52e-02 1.52e-02; 2 -76.026907793199 -0.000254127307 9.55e-03 9.55e-03; 3 -76.027052927171 -0.000145133972 4.47e-04 4.47e-04; 4 -76.027053472137 -0.000000544965 1.16e-04 1.16e-04; ---------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:4604,optimiz,optimize,4604,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,4,['optimiz'],['optimize']
Performance,"8; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. omp2-3; OMP2 cc-pVDZ energy for the NO radical. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. scf-guess-read3; Test if the the guess read in the same basis converges. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. ao-dfcasscf-sp; CASSCF/6-31G** energy point. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. cc52; CCSD Response for H2O2. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:14034,perform,performs,14034,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-alpha; Extrapolated water energies. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. cbs-xtpl-dict; Extrapolated water energies. soscf-large; Second-order SCF convergnece: Benzene. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:31842,perform,performed,31842,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"8b01089). Density Cumulant Functional Theory (DCFT)¶; PSI4 features several formulations of newly-developed density cumulant; functional theory (DCFT). The theory and benchmark of this theory are; discussed in the following papers:; DC-06 (also known as DCFT-06):. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423). DC-12:. “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). ODC-06 and ODC-12:. “Orbital-optimized density cumulant functional theory,” A. Yu. Sokolov, and; H. F. Schaefer, J. Chem. Phys. 139, 204110 (2013).; (doi: 10.1063/1.4833138). ODC-13:. “Density cumulant functional theory from a unitary transformation:; N-representability, three-particle correlation effects, and application; to O4+,” A. Yu. Sokolov, H. F. Schaefer, and W. Kutzelnigg,; J. Chem. Phys. 141, 074111 (2014).; (doi: 10.1063/1.4892946). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/introduction-1.html:6431,optimiz,optimized,6431,psi4manual/1.3.2/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/introduction-1.html,2,['optimiz'],['optimized']
Performance,"903 [mEh] 0.48342016 [kcal/mol] 2.02263015 [kJ/mol]. Total HF -5.68662563 [mEh] -3.56841161 [kcal/mol] -14.93023559 [kJ/mol]; Total SAPT0 sc. -8.57944161 [mEh] -5.38368112 [kcal/mol] -22.52532395 [kJ/mol]; Total SAPT2 sc. -6.69968912 [mEh] -4.20411857 [kcal/mol] -17.59003378 [kJ/mol]; Total SAPT2+ sc. -7.31030140 [mEh] -4.58728357 [kcal/mol] -19.19319632 [kJ/mol]; Total SAPT2+(3) sc. -6.98526650 [mEh] -4.38332109 [kcal/mol] -18.33981720 [kJ/mol]; Total SAPT2+3 sc. -7.15142168 [mEh] -4.48758504 [kcal/mol] -18.77605762 [kJ/mol]; --------------------------------------------------------------------------------------------------------. The scaling factor is reported at the top (here 1.0072) together with the; \(\alpha\) parameter. All terms that are scaled are indicated by the sc.; label. Note that if Exch10 is less than \(10^{-5}\), the scaling factor is; set to \(1.0\). Caution; To density fit the dispersion terms in SAPT, the RI auxiliary; basis set (e.g., aug-cc-pVDZ-RI) controlled through; DF_BASIS_SAPT performs well. For Fock-type terms (i.e.,; electrostatics, exchange, induction, and core Fock matrix elements in; exchange-dispersion), the JKFIT density-fitting auxiliary basis; (e.g., aug-cc-pVDZ-JKFIT) is more appropriate. The FISAPT; module has always used JKFIT in this role. The; SAPT module newly (see fitting notes ) uses; JKFIT for computations targeting SAPT0 and sSAPT0 methods. But the; SAPT module still uses the RI basis for higher-order; SAPT. For heavier elements (i.e., second-row and beyond), the RI; auxiliary basis is unsound for this role (insufficiently flexible).; For higher-order methods in SAPT module, there is; no workaround; on-the-fly construction of an auxiliary basis through; Cholesky decomposition (not implemented) is the long-term solution. Spin-Flip SAPT¶; SAPT0 with two open-shell references will always yield a high-spin complex. In; order to obtain a SAPT-based estimate of the splittings between different spin; states of a complex the fir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/sapt.html:45558,perform,performs,45558,psi4manual/master/sapt.html,https://psicode.org,https://psicode.org/psi4manual/master/sapt.html,5,['perform'],['performs']
Performance,"903 [mEh] 0.48342016 [kcal/mol] 2.02263015 [kJ/mol]. Total HF -5.68662563 [mEh] -3.56841161 [kcal/mol] -14.93023559 [kJ/mol]; Total SAPT0 sc. -8.57944161 [mEh] -5.38368112 [kcal/mol] -22.52532395 [kJ/mol]; Total SAPT2 sc. -6.69968912 [mEh] -4.20411857 [kcal/mol] -17.59003378 [kJ/mol]; Total SAPT2+ sc. -7.31030140 [mEh] -4.58728357 [kcal/mol] -19.19319632 [kJ/mol]; Total SAPT2+(3) sc. -6.98526650 [mEh] -4.38332109 [kcal/mol] -18.33981720 [kJ/mol]; Total SAPT2+3 sc. -7.15142168 [mEh] -4.48758504 [kcal/mol] -18.77605762 [kJ/mol]; --------------------------------------------------------------------------------------------------------. The scaling factor is reported at the top (here 1.0072) together with the; \(\alpha\) parameter. All terms that are scaled are indicated by the sc.; label. Note that if Exch10 is less than \(10^{-5}\), the scaling factor is; set to \(1.0\). Caution; To density fit the dispersion terms in SAPT, the RI auxiliary; basis set (e.g., aug-cc-pVDZ-RI) controlled through; DF_BASIS_SAPT performs well. For Fock-type terms (i.e.,; electrostatics, exchange, induction, and core Fock matrix elements in; exchange-dispersion), the density-fitting auxiliary basis in the; SAPT module (both SAPT0 and higher-order) is RI (more; efficient for the small basis sets at which SAPT0 performs best) while; the FISAPT module uses the more appropriate JKFIT; (e.g., aug-cc-pVDZ-JKFIT). For heavier elements (i.e., second-row; and beyond), the RI auxiliary basis is unsound for this role; (insufficiently flexible). For SAPT0 in the SAPT; module, a workaround is to set DF_BASIS_ELST (which; controls Elst10 and Exch10 terms) to a JKFIT basis. For higher-order; methods in SAPT module, there is no workaround;; on-the-fly construction of an auxiliary basis through Cholesky; decomposition (not implemented) is the long-term solution. Spin-Flip SAPT¶; SAPT0 with two open-shell references will always yield a high-spin complex. In; order to obtain a SAPT-based estimate of the splitti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sapt-1.html:37255,perform,performs,37255,psi4manual/1.2.1/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sapt-1.html,8,['perform'],['performs']
Performance,"903 [mEh] 0.48342016 [kcal/mol] 2.02263015 [kJ/mol]. Total HF -5.68662563 [mEh] -3.56841161 [kcal/mol] -14.93023559 [kJ/mol]; Total SAPT0 sc. -8.57944161 [mEh] -5.38368112 [kcal/mol] -22.52532395 [kJ/mol]; Total SAPT2 sc. -6.69968912 [mEh] -4.20411857 [kcal/mol] -17.59003378 [kJ/mol]; Total SAPT2+ sc. -7.31030140 [mEh] -4.58728357 [kcal/mol] -19.19319632 [kJ/mol]; Total SAPT2+(3) sc. -6.98526650 [mEh] -4.38332109 [kcal/mol] -18.33981720 [kJ/mol]; Total SAPT2+3 sc. -7.15142168 [mEh] -4.48758504 [kcal/mol] -18.77605762 [kJ/mol]; --------------------------------------------------------------------------------------------------------. The scaling factor is reported at the top (here 1.0072) together with the; \(\alpha\) parameter. All terms that are scaled are indicated by the sc.; label. Note that if Exch10 is less than \(10^{-5}\), the scaling factor is; set to \(1.0\). Caution; To density fit the dispersion terms in SAPT, the RI auxiliary; basis set (e.g., aug-cc-pVDZ-RI) controlled through; DF_BASIS_SAPT performs well. For Fock-type terms (i.e.,; electrostatics, exchange, induction, and core Fock matrix elements in; exchange-dispersion), the density-fitting auxiliary basis in the; SAPT module (both SAPT0 and higher-order) is RI (more; efficient for the small basis sets at which SAPT0 performs best) while; the FISAPT module uses the more appropriate JKFIT; (e.g., aug-cc-pVDZ-JKFIT). For heavier elements (i.e., second-row; and beyond), the RI auxiliary basis is unsound for this role; (insufficiently flexible). For SAPT0 in the SAPT; module, a workaround is to set DF_BASIS_ELST (which; controls Elst10 and Exch10 terms) to a JKFIT basis. For higher-order; methods in SAPT module, there is no workaround;; on-the-fly construction of an auxiliary basis through Cholesky; decomposition (not implemented) is the long-term solution. table of contents. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Basic SAPT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:36423,perform,performs,36423,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['perform'],['performs']
Performance,"9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension “.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation of the system. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/optking-1.html:1935,optimiz,optimizer,1935,psi4manual/1.2.1/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/optking-1.html,9,['optimiz'],['optimizer']
Performance,"9160]. (However, for separated; fragments, we have chosen not to employ by default their “extra-redundant”; coordinates defined by their “auxiliary interfragment” bonds. These can be; included via the option ADD_AUXILIARY_BONDS).; The internal coordinates are generated automatically based on an assumed bond; connectivity. The connectivity is determined by testing if the interatomic; distance is less than the sum of atomic radii times the value of; COVALENT_CONNECT. If the user finds that some; connectivity is lacking by default, then this value may be increased.; Otherwise, the internal coordinate definitions may be modified directly. If one; desires to see or modify the internal coordinates being used, then one can set; INTCOS_GENERATE_EXIT to true. The internal coordinate; definitions are provided in the file with extension ”.intco”. See the Optimizing Minima; section for more detail. Warning; The selection of a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation of the system. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:1933,optimiz,optimizer,1933,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,4,['optimiz'],['optimizer']
Performance,"9423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) and Cholesky decomposition (CD); coupled cluster in PSI, and its performance for non-covalent interactions; and reaction energies, is discussed in. “Accuracy and Efficiency of Coupled-Cluster Theory Using; Density Fitting / Cholesky Decomposition, Frozen Natural Orbitals,; and a T1-Transformed Hamiltonian,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. in press.; (doi: 10.1021/ct400250u). Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC)¶; PSI4 features production-level Mukherjee-style state-specific; coupled-cluster theory, including perturbative triples and also associated; multi-reference perturbation theories. The theory and PSI4; im",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/introduction-1.html:4191,perform,performance,4191,psi4manual/4.0b5/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/introduction-1.html,2,['perform'],['performance']
Performance,"9423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) and Cholesky decomposition (CD); coupled cluster in PSI, and its performance for non-covalent interactions; and reaction energies, is discussed in. “Accuracy and Efficiency of Coupled-Cluster Theory Using; Density Fitting / Cholesky Decomposition, Frozen Natural Orbitals,; and a T1-Transformed Hamiltonian,” A. E. DePrince and C. D. Sherrill,; submitted. Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC)¶; PSI4 features production-level Mukherjee-style state-specific; coupled-cluster theory, including perturbative triples and also associated; multi-reference perturbation theories. The theory and PSI4; implementation of these methods is discussed in the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:4191,perform,performance,4191,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,2,['perform'],['performance']
Performance,"97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/opt-1.html:6877,Optimiz,Optimizations,6877,psi4manual/4.0b3/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html,2,['Optimiz'],['Optimizations']
Performance,9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; P — Psi4 [1.0.0 6a9a71b] Docs; ROTATIONAL_SYMMETRY_NUMBER — Psi4 [1.0.0 6a9a71b] Docs; T — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; DELETE_TEI — Psi4 [1.0.0 6a9a71b] Docs; INTS_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; NO_TEI — Psi4 [1.0.0 6a9a71b] Docs; PRINT_TEI — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; SEMICANONICAL — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; MEMORY — Psi4 [1.0.0 6a9a71b] Docs; NEWTON_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; NORM_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; POLE_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; PR — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [1.0.0 6a9a71b] Docs; SEM_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; AEL — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; GAUGE — Psi4 [1.0.0 6a9a71b] Docs; INTS_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_DUMP — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_STEPSIZE — Psi4 [1.0.0 6a9a71b] Docs; OPDM_RELAX — Psi4 [1.0.0 6a9a71b] Docs; PROP_ALL — Psi4 [1.0.0 6a9a71b] Docs; PROP_ROOT — Psi4 [1.0.0 6a9a71b] Docs; PROP_SYM — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; XI — Psi4 [1.0.0 6a9a71b] Docs; XI_CONNECT — Psi4 [1.0.0 6a9a71b] Docs; ZETA — Psi4 [1.0.0 6a9a71b] Docs; ABCD — Psi4 [1.0.0 6a9a71b] Docs; ANALYZE — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; BCCD_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; BRUECKNER_ORBS_R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; CACHETYPE — Psi4 [1.0.0 6a9a71b] Docs; CC_NUM_THREADS — Psi4 [1.0.0 6a9a71b],MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:86539,CACHE,CACHELEVEL,86539,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['CACHE'],['CACHELEVEL']
Performance,": 1. DIIS_START_ITER (LMP2); LMP2 — Iteration at which to start DIIS extrapolation. Type: integer; Default: 3. DIPMOM (CEPA); CEPA — Compute the dipole moment? Note that quadrupole moments will also be computed if PRINT >= 2. Type: boolean; Default: false. DIPMOM (DETCI); DETCI — Do compute the dipole moment?. Type: boolean; Default: false. DISP_SIZE (FINDIF); FINDIF — Displacement size in au for finite-differences. Type: double; Default: 0.005. DISTANT_PAIR_CUTOFF (LMP2); LMP2 — Distant pair cutoff. Type: double; Default: 8.0. DISTRIBUTED_MATRIX (SCF); SCF (Expert) — The dimension sizes of the distributed matrix. Type: array; Default: No Default. DO_ALL_TEI (TRANSQT); TRANSQT — Do transform all TEIs. Type: boolean; Default: false. DO_LEVEL_SHIFT (OMP2); OMP2 — Do apply level shifting?. Type: boolean; Default: false. DO_LEVEL_SHIFT (OMP3); OMP3 — Do apply level shifting to aid convergence. Type: boolean; Default: false. DO_SCS (OMP2); OMP2 — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OMP3); OMP3 — Do perform spin-component-scaled OMP3 (SCS-OMP3)? In all computation, SCS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP3, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (OMP2); OMP2 — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OMP3); OMP3 — Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:33480,perform,perform,33480,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,": 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def run_dftd3(self, func=None, dashlvl=None, dashparam=None, dertype=None):; """"""Function to call Grimme's dftd3 program (http://toc.uni-muenster.de/DFTD3/); to compute the -D correction of level *dashlvl* using parameters for; the functional *func*. The dictionary *dashparam* can be used to supply; a full set of dispersion parameters in the absense of *func* or to supply; individual overrides in the presence of *func*. Returns energy if *dertype* is 0,; gradient if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The dftd3 executable must be independently compiled and found in; :envvar:`PATH`. """"""; # Validate arguments; if self is None:; self = psi4.get_active_molecule(). dashlvl = d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html:6836,Queue,Queue,6836,psi4manual/4.0b5/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/molutil.html,1,['Queue'],['Queue']
Performance,": 1.75 / 1.5, # Bondi JPC 68 441 (1964); 'GE': 1.98 / 1.5, # Bondi JPC 68 441 (1964); 'AS': 1.94 / 1.5, # Bondi JPC 68 441 (1964); 'SE': 1.90 / 1.5, # Bondi JPC 68 441 (1964); 'BR': 1.87 / 1.5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor bas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12147,Queue,Queue,12147,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,2,['Queue'],['Queue']
Performance,": 1.75 / 1.5, # Bondi JPC 68 441 (1964); 'GE': 1.98 / 1.5, # Bondi JPC 68 441 (1964); 'AS': 1.94 / 1.5, # Bondi JPC 68 441 (1964); 'SE': 1.90 / 1.5, # Bondi JPC 68 441 (1964); 'BR': 1.87 / 1.5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True, zero=ZERO):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt, zero). [docs] def inertia_tensor_partial(self, part, masswt=True, zero=ZERO):; """,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:29535,Queue,Queue,29535,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,2,['Queue'],['Queue']
Performance,": Now computing %d-body complexes <==\n\n"" % n); total = len(compute_list[n]); for num, pair in enumerate(compute_list[n]):; core.print_out(""\n N-Body: Computing complex (%d/%d) with fragments %s in the basis of fragments %s.\n\n"" %; (num + 1, total, str(pair[0]), str(pair[1]))); ghost = list(set(pair[1]) - set(pair[0])). current_mol = molecule.extract_subsets(list(pair[0]), ghost); # Save energies info; ptype_dict[pair] = func(method_string, molecule=current_mol, **kwargs); energies_dict[pair] = core.get_variable(""CURRENT ENERGY""); var_key = ""N-BODY (%s)@(%s) TOTAL ENERGY"" % (', '.join([str(i) for i in pair[0]]), ; ', '.join([str(i) for i in pair[1]])); intermediates_dict[var_key] = core.get_variable(""CURRENT ENERGY""); core.print_out(""\n N-Body: Complex Energy (fragments = %s, basis = %s: %20.14f)\n"" %; (str(pair[0]), str(pair[1]), energies_dict[pair])); # Flip this off for now, needs more testing; #if 'cp' in bsse_type_list and (len(bsse_type_list) == 1):; # core.set_global_option('DF_INTS_IO', 'LOAD'). core.clean(). return {'energies': energies_dict, 'ptype': ptype_dict, 'intermediates': intermediates_dict}. def assemble_nbody_components(metadata, component_results):; """"""Assembles N-body components into interaction quantities according to requested BSSE procedure(s). Parameters; -----------; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'ptype'``: {'energy', 'gradient', 'hessian'}; Procedure which has generated the N-body components to be combined.; ``'bsse_type_list'``: list of str; List of requested BSSE treatments. Possible values include lowercase ``'cp'``, ``'nocp'``,; and ``'vmfc'``.; ``'max_nbody'``: int; Maximum number of bodies to include in the N-Body treatment.; Possible: `max_nbody` <= `max_frag`; Default: `max_nbody` = `max_frag`; ``'max_frag'``: int; Number of distinct fragments comprising full molecular supersystem.; ``'energies_dict'``: dict of set: float64; Dictionary containing all energy components r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html:15286,LOAD,LOAD,15286,psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_nbody.html,1,['LOAD'],['LOAD']
Performance,": PSIF_AO_OPDM. OPDM_PRINT (DETCI); DETCI — Do print the one-particle density matrix for each root?. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY); CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (DFMP2); DFMP2 — Do relax the one-particle density matrix?. Type: boolean; Default: true. OPT_METHOD (OCC); OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. OPT_TYPE (OPTKING); OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (OCC); OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (OCC); OCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE (OCC); OCC — The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. P (THERMO); THERMO — Pressure in Pascal for thermodynamic analysis. Type: double; Default: 101325. PAIR_ENERGIES_PRINT (CCENERGY); CCENERGY — Do print MP2 and CCSD pair energies for RHF references?. Type: boolean; Default: false. PARALLEL (SCF); SCF (Expert) — Do run in parallel?. Type: boolean; Default: false. PB_LAMBDA (DFTSAPT); DFTSAPT — Lambda in Pauli Blockade. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:93530,optimiz,optimize,93530,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimize']
Performance,": boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CPHF_CUTOFF¶. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_CUTOFF¶. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. LOCAL_METHOD¶. Type of local-CCSD sche",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html:1432,cache,cache,1432,psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__ccenergy-1.html,2,['cache'],['cache']
Performance,": boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Type: double; Default: 1.27. CC_SS_SCALE¶. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CUTOFF¶. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. LOCAL_METHOD¶. Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-J. Werner and co-workers, and AOBASIS selects the method developed by G.E. Scuseria and co-workers (currently inoperative). Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html:1360,cache,cache,1360,psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html,2,['cache'],['cache']
Performance,": boolean; Default: false. CC_DIIS_MAX_VECS¶. Maximum number of vectors used in amplitude DIIS. Type: integer; Default: 6. CC_DIIS_MIN_VECS¶. Minimum number of vectors used in amplitude DIIS. Type: integer; Default: 2. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CEPA_OS_SCALE¶. CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE¶. CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE¶. CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__occ-1.html:1845,perform,perform,1845,psi4manual/1.0.0/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__occ-1.html,12,['perform'],['perform']
Performance,": conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. LEVEL_SHIFT¶. Do use a level shift?. Type: double; Default: 0.0. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html:6737,perform,perform,6737,psi4manual/1.4.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,": false. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM —. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR —. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA —. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT —. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 —. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 —. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:6359,CACHE,CACHELEVEL,6359,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['CACHE'],['CACHELEVEL']
Performance,": integer; Default: 100. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MP2_AMP_TYPE¶. The algorithm that used to handle mp2 amplitudes. The DIRECT option means compute amplitudes on the fly * whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. PCG_BETA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: FLETCHER_REEVES, POLAK_RIBIERE; Default: FLETCHER_REEVES. PCG_CONVERGENCE¶. Convergence criterion for residual vect",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dfocc.html:4224,optimiz,optimization,4224,psi4manual/1.7.x/autodir_options_c/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dfocc.html,4,['optimiz'],['optimization']
Performance,: integer; Default: 5. DIIS_MAX_VECS (LMP2); LMP2 — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (MCSCF); MCSCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (OMP2); OMP2 — Number of vectors used in DIIS. Type: integer; Default: 4. DIIS_MAX_VECS (PSIMRCC); PSIMRCC — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (SCF); SCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS (DCFT); DCFT — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 3. DIIS_MIN_VECS (DETCI); DETCI — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_MIN_VECS (SCF); SCF — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_START (PSIMRCC); PSIMRCC — The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. DIIS_START (SCF); SCF — The minimum iteration to start storing DIIS vectors. Type: integer; Default: 1. DIIS_START_CONVERGENCE (DCFT); DCFT — Value of RMS of the density cumulant residual and SCF error vector below which DIIS extrapolation starts. Same keyword controls the DIIS extrapolation for the solution of the response equations. Type: conv double; Default: 1e-3. DIIS_START_ITER (DETCI); DETCI — Iteration at which to start using DIIS. Type: integer; Default: 1. DIIS_START_ITER (LMP2); LMP2 — Iteration at which to start DIIS extrapolation. Type: integer; Default: 3. DIPMOM (DETCI); DETCI — Do compute the dipole moment?. Type: boolean; Default: false. DISP_SIZE (FINDIF); FINDIF — Displacement size in au for finite-differences. Type: double; Default: 0.005. DISTANT_PAIR_CUTOFF (LMP2); LMP2 — Distant pair cutoff. Type: double; Default: 8.0. DISTRIBUTED_MATRIX (SCF); SCF (Expert) — The dimension sizes of the ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:25401,perform,performed,25401,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,": string; Possible Values: ANGSTROM, BOHR; Default: ANGSTROM. CFOUR_UPDATE_HESSIAN¶. Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION¶. Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF, EXACT; Default: NO. CFOUR_VTRAN¶. This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the \((ab \vert cd)\) integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD¶. Specifies the X-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword \(\times 10^{-6}\). This allows field strengths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL¶. The tolerance for st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cfour-1.html:64543,perform,performed,64543,psi4manual/1.2.1/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cfour-1.html,13,['perform'],['performed']
Performance,": string; Possible Values: ANGSTROM, BOHR; Default: ANGSTROM. CFOUR_UPDATE_HESSIAN¶. Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION¶. Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF; Default: NO. CFOUR_VTRAN¶. This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the \((ab \vert cd)\) integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD¶. Specifies the X-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword \(\times 10^{-6}\). This allows field strengths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL¶. The tolerance for storing t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html:64322,perform,performed,64322,psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__cfour-1.html,2,['perform'],['performed']
Performance,": string; Possible Values: ANGSTROM, BOHR; Default: ANGSTROM. CFOUR_UPDATE_HESSIAN¶. Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION¶. Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF; Default: NO. CFOUR_VTRAN¶. This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD¶. Specifies the X-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword . This allows field strengths to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL¶. The tolerance for storing transformed integrals. Integrals less than are neglected and not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:63646,perform,performed,63646,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['perform'],['performed']
Performance,": string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; 1; 2; 3; 4; 5; 6; 7molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; 1optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; 1; 2set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; 1optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; 1; 2set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; 1; 2; 3; 4; 5; 6; 7set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; 1; 2set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:3948,Optimiz,Optimizing,3948,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,2,['Optimiz'],['Optimizing']
Performance,": string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optking-1.html:3948,Optimiz,Optimizing,3948,psi4manual/4.0b4/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html,6,['Optimiz'],['Optimizing']
Performance,":. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. MAXITER¶. Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the st",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cc-1.html:4792,Cache,Cacheing,4792,psi4manual/4.0b2/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cc-1.html,4,['Cache'],['Cacheing']
Performance,":074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CASCI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CASCI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CASCI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psimrcc.html:3303,optimiz,optimized,3303,psi4manual/master/psimrcc.html,https://psicode.org,https://psicode.org/psi4manual/master/psimrcc.html,4,['optimiz'],['optimized']
Performance,":; """"""Function to compare two numpy arrays. Prints :py:func:`util.success`; when elements of vector *computed* match elements of vector *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimension, or element values. Used in input files in the test suite. """""". try:; expected = np.asarray(expected); computed = np.asarray(computed); shape1 = expected.shape; shape2 = computed.shape; except:; raise TestComparisonError(""Input objects do not have a shape attribute.""). if shape1 != shape2:; TestComparisonError(""Input shapes do not match.""). tol = 10**(-digits); if not np.allclose(expected, computed, atol=tol):; message = ""\tArray difference norm is %12.6f."" % np.linalg.norm(expected - computed); raise TestComparisonError(message); success(label); return True. [docs]def compare_cubes(expected, computed, label):; """"""Function to compare two cube files. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; # Grab grid points. Skip the first nine lines and the last one; evec = np.genfromtxt(expected, skip_header=9, skip_footer=1); cvec = np.genfromtxt(computed, skip_header=9, skip_footer=1); if evec.size == cvec.size:; if not np.allclose(cvec, evec, rtol=5e-05, atol=1e-10):; message = (""\t%s: computed cube file does not match expected cube file."" % label); raise TestComparisonError(message); else:; message = (""\t%s: computed cube file does not match size of expected cube file."" % label); raise TestComparisonError(message); success(label); return True. # Uncomment and use if compare_arrays above is inadequate; #def compare_lists(expected, computed, digits, label):; # """"""Function to compare two Python lists. Prints :py:func:`util.success`; # when elements of vector *computed* match elements of vector *expected* to; # number of *digits*. Performs a system exit on failure to match symmetry; # structure, dimension, or element value",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html:12751,Perform,Performs,12751,psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/util.html,1,['Perform'],['Performs']
Performance,":; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print ""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print ""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry()); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/util.html:2009,Perform,Performs,2009,psi4manual/4.0b2/_modules/util.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html,1,['Perform'],['Performs']
Performance,":; label = self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html:56204,load,load,56204,psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver_cbs.html,1,['load'],['load']
Performance,":; neutral_guess = kwargs['neutral_guess']. # By default, burn-in with UHF first, if UKS; hf_guess = False; if psi4.get_global_option('REFERENCE') == 'UKS':; hf_guess = True; if kwargs.has_key('hf_guess'):; hf_guess = kwargs['hf_guess']. # By default, re-guess at each N; continuous_guess = False; if kwargs.has_key('continuous_guess'):; continuous_guess = kwargs['continuous_guess']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; # => Traverse <= #; occs = []; energies = []; potentials = []; convs = []. # => Run the neutral for its orbitals, if requested <= #. old_df_ints_io = psi4.get_global_option(""DF_INTS_IO""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). old_guess = psi4.get_global_option(""GUESS""); if (neutral_guess):; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the anion first <= #. mol.set_molecular_charge(chargem); mol.set_multiplicity(multm). # => Burn the anion in with hf, if requested <= #; if (hf_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True); psi4.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E = energy('scf'); C = 1; if (E == 0.0):; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = psi4.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = psi4.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). psi4.set_global_option(""FR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:3740,LOAD,LOAD,3740,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,1,['LOAD'],['LOAD']
Performance,":; rank = k + 1; break. # do the promotion; reals[rank] = reals[rank] + 1. # demote the right portion of the register; val = 1; for k in range(nreal - 1, rank, -1):; reals[k] = val; val = val + 1. # boundary condition is promotion into; # [nfrag+1 nfrag-1 ...]; if (reals[0] > nfrag):; break. return clusters. [docs]def molecule_set_attr(self, name, value):; """"""Function to redefine __setattr__ method of molecule class.""""""; fxn = object.__getattribute__(self, ""is_variable""); isvar = fxn(name); if isvar:; fxn = object.__getattribute__(self, ""set_variable""); fxn(name, value); return. object.__setattr__(self, name, value). [docs]def molecule_get_attr(self, name):; """"""Function to redefine __getattr__ method of molecule class.""""""; fxn = object.__getattribute__(self, ""is_variable""); isvar = fxn(name). if isvar:; fxn = object.__getattribute__(self, ""get_variable""); return fxn(name). return object.__getattribute__(self, name). [docs]def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while White or Queue: # Iterates to t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/molutil.html:5252,Perform,Perform,5252,psi4manual/1.1.0/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/molutil.html,1,['Perform'],['Perform']
Performance,":; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if sapt_basis == 'dimer':; monomerA = sapt_dimer.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif sapt_basis == 'monomer':; monomerA = sapt_dimer.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = sapt_dimer.extract_subsets(2); monomerB.set_name('monomerB'). ri = psi4.get_option('SCF', 'SCF_TYPE'); df_ints_io = psi4.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. psi4.IO.set_default_namespace('dimer'); psi4.print_out('\n'); p4util.banner('Dimer HF'); psi4.print_out('\n'). if sapt_basis == 'dimer':; psi4.set_global_option('DF_INTS_IO', 'SAVE'); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = psi4.get_variable('MP2 CORRELATION ENERGY'); if sapt_basis == 'dimer':; psi4.set_global_option('DF_INTS_IO', 'LOAD'). if sapt_basis == 'dimer':; psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); psi4.print_out('\n'); p4util.banner('Monomer A HF'); psi4.print_out('\n'); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= psi4.get_variable('MP2 CORRELATION ENERGY'). if sapt_basis == 'dimer':; psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); psi4.print_out('\n'); p4util.banner('Monomer B HF'); psi4.print_out('\n'); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); if do_delta_mp2:; select_mp2(name, ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= psi4.get_variable('MP2 CORRELATION ENERGY'); psi4.set_variable('SAPT MP2 CORRELATION ENERGY', mp2_corl_interaction_e); psi4.set_global_option('DF_INTS_IO', df_ints_io). psi4.IO.change_file_namespace(p4const.PSIF_SAP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:81178,LOAD,LOAD,81178,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['LOAD'],['LOAD']
Performance,":`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:79883,perform,performs,79883,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['perform'],['performs']
Performance,":`util.compare_values` family when functions pass. """"""; print('\t{0:.<66}PASSED'.format(label)); sys.stdout.flush(). # Test functions; [docs]def compare_values(expected, computed, digits, label):; """"""Function to compare two values. Prints :py:func:`util.success`; when value *computed* matches value *expected* to number of *digits*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (abs(expected - computed) > 10 ** (-digits)):; print(""\t%s: computed value (%f) does not match (%f) to %d digits."" % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d digits.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/util.html:1999,Perform,Performs,1999,psi4manual/4.0b3/_modules/util.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/util.html,1,['Perform'],['Performs']
Performance,":func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry bein",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:60864,optimiz,optimizer,60864,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['optimiz'],"['optimization', 'optimizer']"
Performance,":module dbse_project and function load_project. Module search path; can be prepended with pythonpath. load_qcdata_hdf5_trusted(project, path=None)[source]¶; Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. load_qcdata_hrxn_byproject(project, path=None)[source]¶. load_subsets(modname='subsetgenerator', pythonpath=None)[source]¶; Loads subsets from all functions in module modname. oss = None¶; object of defined reaction subsets. sset = None¶; dict of defined reaction subsets.; Note that self.sset[‘default’] contains all the nonredundant information.; >>> print asdf.sset.keys(); ['meme', 'mxddpp', '5min', ... 'small']. tagl = None¶; description line; >>> print asdf.tagl; 'interaction energies of dissociation curves for non-bonded systems'. average_errors(*args)[source]¶; Each item in args should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in args. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undefined statistics or; when an item is missing. balanced_error(refrxn, refeq, rrat, m=0.03, p=10.0)[source]¶. Parameters:; refrxn – ; refeq – ; rrat – ; m – minimum permitted weight for a point; p – multiples of abs(refeq) above refeq to which zero-line in head is displaced. Returns:. cure_weight(refrxn, refeq, rrat, xi=0.2)[source]¶. Parameters:; refeq – value of benchmark for equilibrium Reaction; rrat – ratio of intermonomer separation for Reaction to equilibrium Reaction; xi – parameter. Returns:weight for CURE. fancify_mc_tag(mc, latex=False)[source]¶; From the usual MTD-opt1_opt2-bas model chemistry identifier, return; string based on fullname, if latex is False or latex if latex is True. format_errors(err, mode=1)[source]¶; From error dictionary err, returns a LaTeX-formatted string,; after handling None entries. initialize_errors()[source]¶; Form Or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:49623,Perform,Performs,49623,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Perform'],['Performs']
Performance,":ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. omp2.5; Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. olccd; Orbital-Optimized Linear CCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE CONV. Density-Fitted Orbital-Opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:9481,Optimiz,Optimized,9481,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,11,['Optimiz'],['Optimized']
Performance,":param filename: destination file name for file11 file. :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'); }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'); }; delta = {; 'w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/aliases.html:2952,perform,performed,2952,psi4manual/1.7.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/aliases.html,1,['perform'],['performed']
Performance,":py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:52372,optimiz,optimization,52372,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,2,['optimiz'],['optimization']
Performance,"; ""MDIEngine"",; ]. import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import (; MDI_DOUBLE,; MDI_INT,; MDI_Accept_Communicator,; MDI_Init,; MDI_MPI_get_world_comm,; MDI_Recv,; MDI_Recv_Command,; MDI_Register_Command,; MDI_Register_Node,; MDI_Send,; ); _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method: str, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI (MolSSI driver interface). Parameters; ----------; scf_method; Method (SCF or post-SCF) used when calculating energies or gradients.; molecule; The target molecule, if not the last molecule defined.; kwargs; Any additional arguments to pass to :func:`psi4.driver.energy` or; :func:`psi4.driver.gradient` computation. """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); _ini_cart = getattr(input_molecule, ""_initial_cartesian"", None); self.molecule = input_molecule.clone(); if _ini_cart:; self.molecule._initial_cartesian = _ini_cart; psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html:2283,optimiz,optimization,2283,psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/mdi_engine.html,2,['optimiz'],['optimization']
Performance,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2017 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re; import numpy as np. from psi4 import extras; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.p4util.exceptions import *; from psi4.driver.molutil import *. from .roa import *; from . import proc_util; from . import empirical_dispersion; from . import dft_functional; from . import mcscf. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:1207,optimiz,optimize,1207,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimize']
Performance,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2018 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import os; import shutil; import subprocess. import numpy as np. from psi4 import extras; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import constants; from psi4.driver.p4util.exceptions import *; from psi4.driver.molutil import *; # never import driver, wrappers, or aliases into this file. from .roa import *; from . import proc_util; from . import empirical_dispersion; from . import dft_funcs; from . import mcscf; from . import response. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:1209,optimiz,optimize,1209,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimize']
Performance,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2019 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import shutil; import subprocess. import numpy as np. from psi4 import extras; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import *; from psi4.driver.molutil import *; # never import driver, wrappers, or aliases into this file. from .roa import *; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:1209,optimiz,optimize,1209,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimize']
Performance,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import sys; import shutil; import subprocess; import warnings. import numpy as np; from qcelemental import constants. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:1237,optimiz,optimize,1237,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['optimiz'],['optimize']
Performance,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_scf_gradient(name, **kwa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:1237,optimiz,optimize,1237,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimize']
Performance,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import sol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:1237,optimiz,optimize,1237,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimize']
Performance,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import re; import shutil; import subprocess; import sys; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental.util import parse_version, which. from psi4 import core, extras. from .. import p4util; from .. import psifiles as psif; from .. import qcdb; from ..constants import constants; from ..p4util.exceptions import (; ManagedMethodError,; PastureRequiredError,; UpgradeHelper,; ValidationError,; docs_table_link,; ). #from psi4.driver.molutil import *; from ..qcdb.basislist import corresponding_basis; from . import dft, empirical_dispersion, mcscf, proc_util, response, solvent; from .proc_data import method_algorithm_type; from .roa import run_roa. # never import driver, wrappers, or aliases into this file. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:1239,optimiz,optimize,1239,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimize']
Performance,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import sol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:1239,optimiz,optimize,1239,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimize']
Performance,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2024 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import re; import shutil; import subprocess; import sys; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental.util import parse_version, which. from psi4 import core, extras. from .. import p4util; from .. import psifiles as psif; from .. import qcdb; from ..constants import constants; from ..p4util.exceptions import (; ManagedMethodError,; PastureRequiredError,; UpgradeHelper,; ValidationError,; docs_table_link,; ). #from psi4.driver.molutil import *; from ..qcdb.basislist import corresponding_basis; from . import dft, empirical_dispersion, mcscf, proc_util, response, solvent; from .proc_data import method_algorithm_type; from .roa import run_roa. # never import driver, wrappers, or aliases into this file. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/procrouting/proc.html:1246,optimiz,optimize,1246,psi4manual/master/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimize']
Performance,"; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""frac_nuke"",; ""frac_traverse"",; ""ip_fitting"",; ]. from typing import Callable, Dict, Union. from psi4 import core. from . import driver, p4util; from .p4util.exceptions import *. [docs]; def frac_traverse(name: Union[str, Callable], **kwargs) -> Dict[float, float]:; """"""Scan electron occupancy from +1 electron to -1. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult : Optional[int]; Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult : Optional[int]; Multiplicity of anion, if not neutral multiplicity + 1.; frac_start : Optional[int]; Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs : Optional[List]; Occupations to step through for cation, by default `[1 - 0.1 * x for x in range(11)]`.; LUMO_occs : Optional[List]; Occupations to step through for anion, by default `[1 - 0.1 * x for x in range(11)]`.; HOMO : Optional[int]; Index of HOMO.; LUMO : Optional[int]; Index of LUMO.; frac_diis : Optional[bool]; Do use DIIS for non-1.0-occupied points?; neutral_guess : Optional[bool]; Do use neutral orbitals as guess for the anion?; hf_guess: Optional[bool]; Do use UHF guess before ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/frac.html:1527,optimiz,optimized,1527,psi4manual/1.9.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/frac.html,2,['optimiz'],['optimized']
Performance,"; #'SI': 1.716 / 1.5, # JMol; #'P': 1.705 / 1.5, # JMol; #'S': 1.683 / 1.5, # JMol; #'CL': 1.639 / 1.5, # JMol; 'AR': 1.595 / 1.5, # JMol. 'H': 1.06 / 1.5, # Bondi JPC 68 441 (1964); 'B': 1.65 / 1.5, # Bondi JPC 68 441 (1964); 'C': 1.53 / 1.5, # Bondi JPC 68 441 (1964); 'N': 1.46 / 1.5, # Bondi JPC 68 441 (1964); 'O': 1.42 / 1.5, # Bondi JPC 68 441 (1964); 'F': 1.40 / 1.5, # Bondi JPC 68 441 (1964); 'SI': 1.93 / 1.5, # Bondi JPC 68 441 (1964); 'P': 1.86 / 1.5, # Bondi JPC 68 441 (1964); 'S': 1.80 / 1.5, # Bondi JPC 68 441 (1964); 'CL': 1.75 / 1.5, # Bondi JPC 68 441 (1964); 'GE': 1.98 / 1.5, # Bondi JPC 68 441 (1964); 'AS': 1.94 / 1.5, # Bondi JPC 68 441 (1964); 'SE': 1.90 / 1.5, # Bondi JPC 68 441 (1964); 'BR': 1.87 / 1.5, # Bondi JPC 68 441 (1964); 'SN': 2.16 / 1.5, # Bondi JPC 68 441 (1964); 'SB': 2.12 / 1.5, # Bondi JPC 68 441 (1964); 'TE': 2.08 / 1.5, # Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:29048,Queue,Queue,29048,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,2,['Queue'],['Queue']
Performance,"; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while White or Queue: # Iterates to the next fragment; Fragment.append([]). while Queue: # BFS within a fragment; for u in Queue: # find all white neighbors to vertex u; for i in White:; dist = p4const.psi_bohr2angstroms * math.sqrt(; (self.x(i) - self.x(u)) ** 2 +; (self.y(i) - self.y(u)) ** 2 +; (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + \; vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # & remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if White: # can't move White -> Queue if empty; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the psi4.Molecule class. """"""; cls.__setattr__ = new_set_attr; cls.__getattr__ = new_get_attr; cls.BFS = BFS. dynamic_variable_bind(psi4.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name*; from the geometry in string *geom*. Permitted for user use but deprecated in; driver in favor of exp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html:6614,queue,queue,6614,psi4manual/1.0.0/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/molutil.html,1,['queue'],['queue']
Performance,"; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while White or Queue: # Iterates to the next fragment; Fragment.append([]). while Queue: # BFS within a fragment; for u in Queue: # find all white neighbors to vertex u; for i in White:; dist = constants.bohr2angstroms * math.sqrt(; (self.x(i) - self.x(u)) ** 2 +; (self.y(i) - self.y(u)) ** 2 +; (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + \; vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # & remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if White: # can't move White -> Queue if empty; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs]def dynamic_variable_bind(cls):; """"""Function to dynamically add extra members to; the core.Molecule class. """"""; cls.__setattr__ = molecule_set_attr; cls.__getattr__ = molecule_get_attr. cls.BFS = BFS. dynamic_variable_bind(core.Molecule) # pass class type, not class instance. #; # Define geometry to be used by PSI4.; # The molecule created by this will be set in options.; #; # geometry(""; # O 1.0 0.0 0.0; # H 0.0 1.0 0.0; # H 0.0 0.0 0.0; #; [docs]def geometry(geom, name=""default""):; """"""Function to create a molecule object of name *name* from the; geometry in string *geom*. Permitted for user",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/molutil.html:6664,Queue,Queue,6664,psi4manual/1.1.0/_modules/psi4/driver/molutil.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/molutil.html,1,['Queue'],['Queue']
Performance,"; . setting keywords. theory. OCEPA(0)CORRELATIONENERGY. OCEPA(0)TOTALENERGY. OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OEProp. theory. oeprop() in module util. OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). (RESPONSE). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (DETCI). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (DFMP2). opt(); . see optimize(); . OPT_METHOD (OCC). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in optproc. OptionState class in optproc. optproc module. ORB_OPT (OCC). ORB_RESP_SOLVER (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OCEPA. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OCC). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_multiline_array() in module input. PATH, [1], [2], [3], [4]. PB_LAMBDA (DFTSAPT). PCG_BETA_TYPE (OCC). PCG_CONVERGENCE (OCC). PCG_MAXITER (OCC). PEP1. perp_unit() in module qcdb.vecutil. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). PHI_POINTS (SCF). physconst module. physical constants. PITZER (TRANSQT). point_group() Libmin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:31368,optimiz,optimize,31368,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['optimiz'],['optimize']
Performance,"; 0 3; C; H 1 {0}; H 1 {0} 2 {1}; """""".format(R, A); ). psi4.set_options({'reference': 'uhf'}); psi4.energy('scf/6-31g**'). Out[4]:. -38.925334628859886. Executing this cell should yield the final energy as; @DF-UHF Final Energy: -38.92533462887677. Notice the new command, psi4.set_options(); API,; to the input. This function takes a Python; dictionary; as its argument, which is a key-value list which associates a Psi4; keyword; with its user-defined value. For open shell molecules, we have a choice; of unrestricted orbitals (unrestricted Hartree-Fock, or UHF) or; restricted orbitals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:6576,perform,perform,6576,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,8,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"; 1.1;  · . PSI4. psi4.driver.optimize¶. psi4.driver.optimize(name, **kwargs)[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html:1111,perform,performed,1111,psi4manual/1.1.0/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.optimize.html,1,['perform'],['performed']
Performance,"; 11; 12; 13; 14; 15; 16; 17; 18; 19memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC_PROGRAM=ECC; unless explicitly set to VCC.; An advantage of PSI4‘s Python driver is that any number of common; work-up procedures can be automated and wrapped around the; conventional single-point and optimization procedures at the heart of all; quantum chemistry codes. Three core “wrappers” available in PSI4 are; nbody_gufunc(),; database(), and; complete_basis_set(); read their respective sections; for details, but an overview is provided here. nbody_gufunc(); computes the interaction energy of a bimolecular complex (counterpoise-corrected,; not, or both).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14molecule dimer {; Ne; --; Ne 1 R; symmetry c1; }. Rvals=[2.5, 3.0, 4.0]; set basis aug-cc-pVDZ. for R in Rvals:; dimer.R = R; ecp = cp('c4-mp2'); print_stdout('R [A] = %.1f IE [kcal/mol] = %.3f\n' % (R, psi_hartree2kcalmol * ecp)). yields; 1; 2; 3R [A] = 2.5 IE [kcal/mol] = 0.804; R [A] = 3.0 IE [kcal/mol] = 0.030; R [A] = 4.0 IE [kcal/mol] = -0.014. Next, the database() wrapper allows any computational; model chemistry to be applied a predefined collection of molecules. Thus; an input; 1; 2; 3; 4; 5; 6set {; basis jun-cc-pvdz; d_convergen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cfour-1.html:12825,optimiz,optimization,12825,psi4manual/1.1.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cfour-1.html,2,['optimiz'],['optimization']
Performance,"; 11; 12; 13; 14; 15; 16; 17; 18; 19memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC_PROGRAM=ECC; unless explicitly set to VCC.; An advantage of PSI4’s Python driver is that any number of common; work-up procedures can be automated and wrapped around the; conventional single-point and optimization procedures at the heart of all; quantum chemistry codes. Three core “wrappers” available in PSI4 are; nbody_gufunc(),; database(), and; complete_basis_set(); read their respective sections; for details, but an overview is provided here. nbody_gufunc(); computes the interaction energy of a bimolecular complex (counterpoise-corrected,; not, or both).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14molecule dimer {; Ne; --; Ne 1 R; symmetry c1; }. Rvals=[2.5, 3.0, 4.0]; set basis aug-cc-pVDZ. for R in Rvals:; dimer.R = R; ecp = cp('c4-mp2'); print_stdout('R [A] = %.1f IE [kcal/mol] = %.3f\n' % (R, psi_hartree2kcalmol * ecp)). yields; 1; 2; 3R [A] = 2.5 IE [kcal/mol] = 0.804; R [A] = 3.0 IE [kcal/mol] = 0.030; R [A] = 4.0 IE [kcal/mol] = -0.014. Next, the database() wrapper allows any computational; model chemistry to be applied a predefined collection of molecules. Thus; an input; 1; 2; 3; 4; 5; 6set {; basis jun-cc-pvdz; d_convergen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:12827,optimiz,optimization,12827,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,4,['optimiz'],['optimization']
Performance,"; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; 1procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 metho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html:2711,optimiz,optimizer,2711,psi4manual/1.1.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/quickaddalias-1.html,6,['optimiz'],['optimizer']
Performance,"; 21; 22; 23; 24; 25; 26; 27; 28; 29molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternate coordinates into molecule; formaldehyde.update_geometry() # update the molecule internals; formaldehyde.print_out() # print new molecule to output file; compare_values(28.9950517332, formaldehyde.nuclear_repulsion_energy(), 4, ""geom2 took""). Molecules can be initiated from XYZ files and fragmented for SAPT computations.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39# >>> cat mol1.xyz; #7; #; #O 0.00000000 -0.05786571 -1.47979303; #N 0.00000000 0.01436394 1.46454628; #H 0.00000000 0.82293384 -1.85541474; #H 0.81348351 0.39876776 1.92934049; #H 0.00000000 0.07949567 -0.51934253; #H 0.00000000 -0.98104857 1.65344779; #H -0.81348351 0.39876776 1.92934049. # >>> cat mol2.xyz; # 6 au; # stuff; # C 0.00000000000000 0.00000000000000 5.26601138679877; # C 0.00000000000000 0.00000000000000 -3.15195886530135; # H 0.00000000000000 0.00000000000000 7.28558683837122; # H 0.00000000000000 0.00000000000",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:18283,load,load,18283,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['load'],['load']
Performance,"; >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). [docs]; def tdscf(wfn, **kwargs):; return proc.run_tdscf_excitations(wfn,**kwargs). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.8.2;  · . PSI4. Module code; psi4.driver.driver. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:103839,optimiz,optimize,103839,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"; >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). [docs]; def tdscf(wfn, **kwargs):; return proc.run_tdscf_excitations(wfn,**kwargs). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.9.1;  · . PSI4. Module code; psi4.driver.driver. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:106293,optimiz,optimize,106293,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"; A Pitzer-ordered vector of the orbitals. Return type; Vector. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html:16337,load,load,16337,psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.ccwavefunction.html,2,['load'],['load']
Performance,"; A Pitzer-ordered vector of the orbitals. Return type; Vector. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consisten",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html:16616,load,load,16616,psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.DFEP2Wavefunction.html,2,['load'],['load']
Performance,"; A Pitzer-ordered vector of the orbitals. Return type; Vector. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html:16524,load,load,16524,psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.dfep2wavefunction.html,2,['load'],['load']
Performance,; AEL — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; GAUGE — Psi4 [1.0.0 6a9a71b] Docs; INTS_TOLERANCE — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_DUMP — Psi4 [1.0.0 6a9a71b] Docs; ONEPDM_GRID_STEPSIZE — Psi4 [1.0.0 6a9a71b] Docs; OPDM_RELAX — Psi4 [1.0.0 6a9a71b] Docs; PROP_ALL — Psi4 [1.0.0 6a9a71b] Docs; PROP_ROOT — Psi4 [1.0.0 6a9a71b] Docs; PROP_SYM — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; ROOTS_PER_IRREP — Psi4 [1.0.0 6a9a71b] Docs; WFN — Psi4 [1.0.0 6a9a71b] Docs; XI — Psi4 [1.0.0 6a9a71b] Docs; XI_CONNECT — Psi4 [1.0.0 6a9a71b] Docs; ZETA — Psi4 [1.0.0 6a9a71b] Docs; ABCD — Psi4 [1.0.0 6a9a71b] Docs; ANALYZE — Psi4 [1.0.0 6a9a71b] Docs; AO_BASIS — Psi4 [1.0.0 6a9a71b] Docs; BCCD_MAXITER — Psi4 [1.0.0 6a9a71b] Docs; BRUECKNER_ORBS_R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; CACHELEVEL — Psi4 [1.0.0 6a9a71b] Docs; CACHETYPE — Psi4 [1.0.0 6a9a71b] Docs; CC_NUM_THREADS — Psi4 [1.0.0 6a9a71b] Docs; CC_OS_SCALE — Psi4 [1.0.0 6a9a71b] Docs; CC_SS_SCALE — Psi4 [1.0.0 6a9a71b] Docs; DIIS — Psi4 [1.0.0 6a9a71b] Docs; E_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; FORCE_RESTART — Psi4 [1.0.0 6a9a71b] Docs; LOCAL — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CPHF_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_CUTOFF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_METHOD — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_PAIRDEF — Psi4 [1.0.0 6a9a71b] Docs; LOCAL_WEAKP — Psi4 [1.0.0 6a9a71b] Docs; MAXITER — Psi4 [1.0.0 6a9a71b] Docs; MP2_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; MP2_OS_SCALE — Psi4 [1.0.0 6a9a71b] Docs; MP2_SS_SCALE — Psi4 [1.0.0 6a9a71b] Docs; NEW_TRIPLES — Psi4 [1.0.0 6a9a71b] Docs; NUM_AMPS_PRINT — Psi4 [1.0.0 6a9a71b] Docs; PAIR_ENERGIES_PRINT — Psi4 [1.0.0 6a9a71b] Docs; PROPERTY — Psi4 [1.0.0 6a9a71b] Docs; R_CONVERGENCE — Psi4 [1.0.0 6a9a71b] Docs; REFERENCE — Psi4 [1.0.0 6a9a71b] Docs; RESTART — Psi4 [1.0.0 6a9a71b] Docs; SCS_CCSD — ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:39703,CACHE,CACHETYPE,39703,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHETYPE']
Performance,"; All the commands mentioned in section Scratch Files and Elementary Restart can be used in this file.; To set up the scratch path:; 1psi4_io.set_default_path('/scratch/user'). To set up the scratch path from a variable $MYSCRATCH:; 1; 2; 3; 4import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). To set up a specific path for the checkpoint file and instruct PSI4 not to delete it:; 1; 2; 3; 4; 5; 6psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). # equivalent to above; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instructions in the ~/.psi4rc file. During; execution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed.; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every PSI4 instance. Threading¶; Most new modules in PSI4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for PSI4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and C++; std::thread for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in PSI4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled PSI4 with OpenMP and MK",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:9149,load,loaded,9149,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['load'],['loaded']
Performance,"; CCSD Response for H2O2. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cbs-parser; mtd/basis syntax examples. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. mbis-4; MBIS calculation on NaCl. cbs-xtpl-func; optimization with method defined via cbs. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dft-smoke; DFT Functional Smoke Test. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:40408,optimiz,optimization,40408,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). cc37; CC2(UHF)/cc-pVDZ energy of H2O+. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). dft-dsd; DSD S22 Ammonia test. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-custom-mgga; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc3; Test FNO-QCISD(T) computation. scf3; File retention, docc, socc, and bond distances specified explicitly. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. dfcasscf-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. pubchem2; Superficial test of PubChem interface. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. ao-dfcasscf-sp; CASSCF/6-31G** energy point. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultane",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:23201,optimiz,optimization,23201,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['optimiz'],['optimization']
Performance,"; CPHF — Which states to save AO Natural Orbitals for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. CIS_OPDM_STATES (CPHF); CPHF — Which states to save AO OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. CIS_TOPDM_STATES (CPHF); CPHF — Which states to save AO transition OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. COLLAPSE_SIZE (DETCI); DETCI — Gives the number of vectors to retain when the Davidson subspace is collapsed (see MAX_NUM_VECS). If greater than one, the collapsed subspace retains the best estimate of the CI vector for the previous n iterations. Defaults to 1. Type: integer; Default: 1. COLLAPSE_WITH_LAST (CCEOM); CCEOM — Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC); PSIMRCC — Do include the terms that coupl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:18163,optimiz,optimization,18163,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC); FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:7013,CACHE,CACHELEVEL,7013,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['CACHE'],['CACHELEVEL']
Performance,"; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indices specified above (). Type: array; Default: No Default. Environmental Effects¶. EXTERN¶. An ExternalPotential (built by Python or NULL/None). Type: python; Default: No Default. ONEPOT_GRID_READ¶. Read an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html:5158,perform,perform,5158,psi4manual/4.0b5/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indices specified above (). Type: array; Default: No Default. Environmental Effects¶. EXTERN¶. An ExternalPotential (built by Python or NULL/None). Type: python; Default: No Default. ONEPOT_GRID_READ¶. Read an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html:4779,perform,perform,4779,psi4manual/4.0b3/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"; Default: 1e-8. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indices specified above (). Type: array; Default: No Default. Environmental Effects¶. EXTERN¶. An ExternalPotential (built by Python or NULL/None). Type: python; Default: No Default. ONEPOT_GRID_READ¶. Read an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__scf-1.html:5034,perform,perform,5034,psi4manual/4.0b4/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"; Default: DIRECT. SCF_TYPE (SCF); SCF — What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: PK. SCHMIDT_ADD_RESIDUAL_TOLERANCE (CCEOM); CCEOM — Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure. Type: conv double; Default: 1e-3. SCHWARZ_CUTOFF (CPHF); CPHF — The schwarz cutoff value. Type: double; Default: 1.0e-12. SCREEN_INTS (LMP2); LMP2 — Do screen integrals?. Type: boolean; Default: false. SCS (LMP2); LMP2 — Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SCS (MP2); MP2 — Do perform a spin component scaled MP2 computation?. Type: boolean; Default: false. SCS_CCSD (CCENERGY); CCENERGY — Do spin-component-scaled CCSD. Type: boolean; Default: false. SCS_CEPA (CEPA); CEPA — Perform SCS-CEPA? If true, note that the default values for the spin component scaling factors are optimized for the CCSD method. Type: boolean; Default: false. SCS_MP2 (CCENERGY); CCENERGY — Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SCS_N (LMP2); LMP2 — Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SCS_N (MP2); MP2 — Do perform a spin component scaled (N) MP2 computation?. Type: boolean; Default: false. SCS_TYPE (OMP2); OMP2 — Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SCS_TYPE (OMP3); OMP3 — Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SCSN_MP2 (CCENERGY); CCENERGY — Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SEKINO (CCLAMBDA); CCLAMBDA — Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. SEKINO (CCRESPONSE); CCRESPONSE — Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: fal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:112508,Perform,Perform,112508,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,"['Perform', 'optimiz']","['Perform', 'optimized']"
Performance,"; Default: SINGLE_POINT. CFOUR_MRCC (CFOUR); CFOUR — Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY (CFOUR); CFOUR — Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING (CFOUR); CFOUR — Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL (CFOUR); CFOUR — Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead. Type: string; Possible Values: ABORT, SWITCH, RFA; Default: ABORT. CFOUR_NEWNORM (CFOUR); CFOUR — All components of spherical AO’s are normalized to 1. This feature can help with numerical convergence issues if AO integrals are involved. Currently only working for single-point energy calculations. Type: boolean; Default: false. CFOUR_NONHF (CFOUR); CFOUR — Specifies whether the reference function used in the correlation energy calcu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:57499,optimiz,optimization,57499,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,8,['optimiz'],['optimization']
Performance,"; Default: false. DO_LEVEL_SHIFT (OMP3); OMP3 — Do apply level shifting to aid convergence. Type: boolean; Default: false. DO_SCS (OMP2); OMP2 — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OMP3); OMP3 — Do perform spin-component-scaled OMP3 (SCS-OMP3)? In all computation, SCS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP3, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (OMP2); OMP2 — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OMP3); OMP3 — Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SOS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CIS); CIS — Do print the domains?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT (LMP2); LMP2 — Do exit after printing the domains?. Type: bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:34290,perform,perform,34290,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"; Default: true. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SYMMETRIZE¶. Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. table of contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_DIIS_MAX_VECS; CC_DIIS_MIN_VECS; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; E_CONVERGENCE; IP_POLES; LEVEL_SHIFT; LINEQ_SOLVER; MAX_MOGRAD_CONVERGENCE; MOGRAD_DAMPING; MO_DIIS_NUM_VECS; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; NAT_ORBS; OCC_ORBS_PRINT; OEPROP; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; RELAXED; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_TYPE; SYMMETRIZE; TPDM_ABCD_TYPE; WFN_TYPE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html:7659,CACHE,CACHELEVEL,7659,psi4manual/1.3.2/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"; Default: true. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SYMMETRIZE¶. Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. table of contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_DIIS_MAX_VECS; CC_DIIS_MIN_VECS; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; E_CONVERGENCE; IP_POLES; LEVEL_SHIFT; LINEQ_SOLVER; MAX_MOGRAD_CONVERGENCE; MOGRAD_DAMPING; MO_DIIS_NUM_VECS; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; NAT_ORBS; OCC_ORBS_PRINT; OEPROP; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; RELAXED; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_TYPE; SYMMETRIZE; TPDM_ABCD_TYPE; WFN_TYPE. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__occ-1.html:7664,CACHE,CACHELEVEL,7664,psi4manual/1.2.1/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__occ-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"; Description. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/sp-rhf-ccsdt; s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html:1185,perform,performed,1185,psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,2,['perform'],['performed']
Performance,"; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). # power user returns; E, wfn = psi4.energy(..., return_wfn=True); E, wfn = psi4.optimize(..., return_wfn=True); E, wfn = psi4.frequency(..., return_wfn=True); G, wfn = psi4.gradient(..., return_wfn=True) # used by optimize(); H, wfn = psi4.hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print(wfn.gradient().rms()). # format output for other programs; psi4.molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:. PSIthonPsiAPIbasis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis_set; energy('scf'). basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; psi4.set_options({""basis"": basis_set}); psi4.energy('scf'). The declaration of basis_sets is completely standard Python, as is the next; line, which iterates over the list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:11758,optimiz,optimize,11758,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['optimiz'],['optimize']
Performance,"; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, (unpublished). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:8645,optimiz,optimized,8645,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,2,['optimiz'],['optimized']
Performance,"; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010).; (doi: 10.1063/1.3479400). Orbital-Optimized Post-Hartree-Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/introduction-1.html:8695,optimiz,optimized,8695,psi4manual/4.0b5/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/introduction-1.html,2,['optimiz'],['optimized']
Performance,"; Fully-featured electronic structure programs are large and complex. However,; the PSI4 ecosystem provides a path for easier and more rapid development; of new features. The earliest versions of PSI4 were written by merging; individual executables that performed specific tasks into a unified C++; executable. By linking this C++ executable against the Python interpreter, the; individual modules could be called in any sequence, enabling a very diverse; range of tasks to be accomplished within a given input. Although Python-driven; model allowed for great flexibility from a user’s perspective, programming was; still relatively difficult because it required modifications to be made in C++; code.; Since those early days, the code has undergone some important structural; changes that have greatly simplified the development workflow. These changes; were motivated by the realization that only a few bottlenecks exist in a typical; calculation; by focusing on optimized C++ implementations of these bottlenecks; and making these C++ functions available in Python, most of the code to implement; the overall calculation can be written in simpler Python code. Python is far; better suited to management tasks such as directory navigation and retrieval,; making it a natural choice for overall calculation layout than C++. With the; emergence of NumPy as a standard tool for executing almost any; mathematical technique efficiently in Python, the transitioning of code from; C++ to Python has facilitated a much simpler work flow for prototyping and; developing methods: this is detailed in the next section. Rapid initial development using Psi4NumPy¶; The Psi4NumPy project [Smith:2018:3504] is the recommended; mechanism for developing and prototyping new methods in Psi4. Because; NumPy provides such a rich set of features for efficient linear; algebra, Fourier transforms, and general tensor manipulations, a massive number; of methods can be easily implemented very easily using that library. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/prog_ways_to_add.html:1213,bottleneck,bottlenecks,1213,psi4manual/master/prog_ways_to_add.html,https://psicode.org,https://psicode.org/psi4manual/master/prog_ways_to_add.html,27,"['bottleneck', 'optimiz']","['bottlenecks', 'optimized']"
Performance,"; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/opt-1.html:1516,optimiz,optimization,1516,psi4manual/4.0b2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html,4,['optimiz'],['optimization']
Performance,"; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. # are we in sow/reap mode?; isSowReap = False; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; isSowReap = True; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; isSowReap = True; optstash = OptionsState(; ['SCF', 'GUESS']). n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. while n <= PsiMod.get_global_option('GEOM_MAXITER'):; kwargs['opt_iter'] = n. # Use orbitals from previous iteration as a guess; if (n > 1) and (not isSowReap):; PsiMod.set_local_option('SCF', 'GUESS', 'READ'). # Compute the gradient; thisenergy = gradient(name, **kwargs). # S/R: Quit after getting new displacements or if forming gradient fails; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'so",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:38440,optimiz,optimization,38440,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['optimiz'],['optimization']
Performance,"; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. while n <= PsiMod.get_option('GEOM_MAXITER'):; kwargs['opt_iter'] = n. # Compute the gradient; thisenergy = gradient(name, **kwargs). # S/R: Quit after getting new displacements or if forming gradient fails; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; return 0.0; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (thisenergy == 0.0):; return 0.0. # S/R: Move opt data file from last pass into namespace for this pass; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap') and (n != 0):; PsiMod.IOManager.shared_object().set_specific_retention(1, True); PsiMod.IOManager.shared_object().set_specific_path(1, './'); if",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:36080,optimiz,optimization,36080,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['optimiz'],['optimization']
Performance,"; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. # are we in sow/reap mode?; isSowReap = False; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; isSowReap = True; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; isSowReap = True; optstash = OptionsState(; ['SCF', 'GUESS']). n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. PsiMod.get_active_molecule().update_geometry(); mol = PsiMod.get_active_molecule(); mol.update_geometry(); initial_sym = mol.schoenflies_symbol(); while n <= PsiMod.get_global_option('GEOM_MAXITER'):; mol = PsiMod.get_active_molecule(); mol.update_geometry(); current_sym = mol.schoenflies_symbol(); if initial_sym != current_sym:; raise Exception(""Point group changed! You should restart using "" +\; ""th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:50392,optimiz,optimization,50392,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['optimiz'],['optimization']
Performance,"; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). full_hess_every = psi4.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. # are we in sow/reap mode?; isSowReap = False; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; isSowReap = True; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; isSowReap = True; optstash = p4util.OptionsState(; ['SCF', 'GUESS']). n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. psi4.get_active_molecule().update_geometry(); mol = psi4.get_active_molecule(); mol.update_geometry(); initial_sym = mol.schoenflies_symbol(); while n <= psi4.get_global_option('GEOM_MAXITER'):; mol = psi4.get_active_molecule(); mol.update_geometry(); current_sym = mol.schoenflies_symbol(); if initial_sym != current_sym:; raise Exception(""Point group changed! You should restart using "" +\;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:50635,optimiz,optimization,50635,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['optimiz'],['optimization']
Performance,"; Interfaces: Enhancing PSI4 Capabilities; Interfaces: Enhancing PSI4 Capabilities; Introduction; Introduction; Interface to LIBEFP by I. Kaliman; Interface to LIBEFP by I. Kaliman; Interface to Libint by E. Valeev; Interface to Libint by E. Valeev; Adding Add-Ons; Adding Add-Ons; Management FAQ; Management FAQ; Git, Versioning; Git, Versioning; Managing: Git, Conda, CMake and all that; Managing: Git, Conda, CMake and all that; Theoretical Methods: SCF to FCI; Theoretical Methods: SCF to FCI; Interface to Molden — molden(); Interface to Molden — molden(); Interface to MRCC by M. Kállay; Interface to MRCC by M. Kállay; <no title>; <no title>; Basis Set Superposition Corrections; Basis Set Superposition Corrections; Notes on Options; Notes on Options; Notes on Options; Notes on Options; Interface to NumPy; Interface to NumPy; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Evaluation of One-Electron Properties — oeprop(); Evaluation of One-Electron Properties — oeprop(); Geometry Optimization — optimize() and gradient(); Geometry Optimization — optimize() and gradient(); LibOptions: globals, locals, has_changed and all that; LibOptions: globals, locals, has_changed and all that; Geometry Optimization; Geometry Optimization; Interface to PCMSolver by R. Di Remigio; Interface to PCMSolver by R. Di Remigio; PEP1: Proposing PsiPEP for PSI4; PEP1: Proposing PsiPEP for PSI4; Plugin v2rdm_casscf by A. E. DePrince; Plugin v2rdm_casscf by A. E. DePrince; Plugins: Adding New Functionality to PSI4; Plugins: Adding New Functionality to PSI4; Adding Methods to Driver; Adding Methods to Driver; Programming: Using the Core Libraries; Programming: Using the Core Libraries; Property; Property; PSI4 API: Linking C++ and Python; PSI4 API: Linking C++ and Python; PsiAPI Tutorial: Using Psi4 as a Python Module; PsiAPI Tutorial: Using Psi4 as a Python Module; PSIMRCC Implementat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:329461,Optimiz,Optimized,329461,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,16,"['Optimiz', 'optimiz']","['Optimization', 'Optimized', 'optimize']"
Performance,; NUM_FROZEN_UOCC; PARENT_SYMMETRY; PCM; PE; PRINT; PRINT_NOONS; PROPERTIES; PROPERTIES_ORIGIN; PUREAM; QC_MODULE; RAS1; RAS2; RAS3; RAS4; RELATIVISTIC; RESTRICTED_DOCC; RESTRICTED_UOCC; SCF_TYPE; SCREENING; SOCC; WFN; WRITER_FILE_LABEL; CANONICALIZE_ACTIVE_FAVG; CANONICALIZE_INACTIVE_FAVG; CI_DIIS; D_CONVERGENCE; DIIS; DIIS_MAX_VECS; DOCC; E_CONVERGENCE; FAVG; FAVG_START; FOLLOW_ROOT; FORCE_TWOCON; INTERNAL_ROTATIONS; LEVEL_SHIFT; MAXITER; MO_READ; REFERENCE; ROTATE_MO_ANGLE; ROTATE_MO_IRREP; ROTATE_MO_P; ROTATE_MO_Q; SOCC; TURN_ON_ACTV; WFN_SYM; BASIS; OMEGA_ERF; ADC; CCDENSITY; CCENERGY; CCEOM; CCHBAR; CCLAMBDA; CCRESPONSE; CCTRANSORT; CCTRIPLES; CFOUR; CPHF; DCT; DETCI; DFEP2; DFMP2; DFOCC; DLPNO; DMRG; EFP; FINDIF; FISAPT; FNOCC; GDMA; GLOBALS; MCSCF; MINTS; MRCC; OCC; OPTKING; PCM; PE; PSIMRCC; SAPT; SCF; THERMO; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_METHOD; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS; MRCC_OMP_NUM_THREADS; MRCC_RESTART; CACHELEVEL; CC_DIIS_MAX_VECS; CC_DIIS_MIN_VECS; CC_MAXITER; CCL_ENERGY; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DIIS_MAX_VECS; DIIS_MIN_VECS; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E_CONVERGENCE; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; IP_POLES; LEVEL_SHIFT; LINEQ_SOLVER; MAX_MOGRAD_CONVERGENCE; MO_DIIS_NUM_VECS; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MOGRAD_DAMPING; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; NAT_ORBS; OCC_ORBS_PRINT; OEPROP; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; OS_SCALE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; R_CONVERGENCE; RELAXED; RMS_MOGRAD_CONVERGENCE; SCS_TYPE; SOS_TYPE; SPIN_SCALE_TYPE; SS_SCALE; SYMMETRIZE; TPDM_ABCD_TYPE; WFN_TYPE; ADD_AUXILIARY_BONDS; AUXILIARY_BOND_FACTOR; CART_HESS_READ; CONSECUTIVE_BACKSTEPS; COVALENT_CONNECT; DYNAMIC_LEVEL; ENSURE_BT_CONVERGENCE; FINAL_GEOM_WRITE; FIXED_BEND; FIXED_COORD_FORCE_CONSTANT; FIXED_DIHEDRAL; FIXED_DISTANCE; FLEXIBLE_G_,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:671810,CACHE,CACHELEVEL,671810,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,; NUM_FROZEN_UOCC; PARENT_SYMMETRY; PCM; PE; PRINT; PRINT_NOONS; PROPERTIES; PROPERTIES_ORIGIN; PUREAM; QC_MODULE; RAS1; RAS2; RAS3; RAS4; RELATIVISTIC; RESTRICTED_DOCC; RESTRICTED_UOCC; SCF_TYPE; SCREENING; SOCC; WFN; WRITER_FILE_LABEL; CANONICALIZE_ACTIVE_FAVG; CANONICALIZE_INACTIVE_FAVG; CI_DIIS; D_CONVERGENCE; DIIS; DIIS_MAX_VECS; DOCC; E_CONVERGENCE; FAVG; FAVG_START; FOLLOW_ROOT; FORCE_TWOCON; INTERNAL_ROTATIONS; LEVEL_SHIFT; MAXITER; MO_READ; REFERENCE; ROTATE_MO_ANGLE; ROTATE_MO_IRREP; ROTATE_MO_P; ROTATE_MO_Q; SOCC; TURN_ON_ACTV; WFN_SYM; BASIS; OMEGA_ERF; ADC; CCDENSITY; CCENERGY; CCEOM; CCHBAR; CCLAMBDA; CCRESPONSE; CCTRANSORT; CCTRIPLES; CFOUR; CPHF; DCT; DETCI; DFEP2; DFMP2; DFOCC; DLPNO; DMRG; EFP; FINDIF; FISAPT; FNOCC; GDMA; GLOBALS; MCSCF; MINTS; MRCC; OCC; OPTKING; PCM; PE; PSIMRCC; SAPT; SCF; THERMO; E_CONVERGENCE; INTS_TOLERANCE; MRCC_LEVEL; MRCC_METHOD; MRCC_NUM_DOUBLET_ROOTS; MRCC_NUM_SINGLET_ROOTS; MRCC_NUM_TRIPLET_ROOTS; MRCC_OMP_NUM_THREADS; MRCC_RESTART; CACHELEVEL; CC_MAXITER; CCL_ENERGY; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DIIS_MAX_VECS; DIIS_MIN_VECS; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E_CONVERGENCE; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; IP_POLES; LEVEL_SHIFT; LINEQ_SOLVER; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MOGRAD_DAMPING; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; NAT_ORBS; OCC_ORBS_PRINT; OEPROP; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; OS_SCALE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; R_CONVERGENCE; RELAXED; RMS_MOGRAD_CONVERGENCE; SCS_TYPE; SOS_TYPE; SPIN_SCALE_TYPE; SS_SCALE; SYMMETRIZE; TPDM_ABCD_TYPE; WFN_TYPE; ADD_AUXILIARY_BONDS; AUXILIARY_BOND_FACTOR; CART_HESS_READ; CONSECUTIVE_BACKSTEPS; COVALENT_CONNECT; DYNAMIC_LEVEL; ENSURE_BT_CONVERGENCE; FINAL_GEOM_WRITE; FIXED_BEND; FIXED_COORD_FORCE_CONSTANT; FIXED_DIHEDRAL; FIXED_DISTANCE; FLEXIBLE_G_CONVERGENCE; FRAG_MODE; FRAG_REF_ATOMS; FREEZE_INTERFR,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:776536,CACHE,CACHELEVEL,776536,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['CACHE'],['CACHELEVEL']
Performance,"; Overloaded function. array_interface(self). axpby(self, a, b, other); Adds to this vector scaled by b another vector scaled by a; self <- a * other + b * self. axpy(self, a, other); Adds to this vector (unscaled) another vector scaled by a; self <- a * other + self. clone(self); Clone the vector. copy(self, arg0); Copy another vector into this. dim(self[, h]); Returns the dimensions of the vector per irrep h. dimpi(self); Returns the Dimension object. from_array([name, dim1, dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. get(*args, **kwargs); Overloaded function. get_block(self, slice); Get a vector block. init(self, arg0); Reallocate the data of the Vector. load(self, psio, file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). print_out(self); Prints the vector to the output file. save(self, psio, file); Save the vector to disk. scale(self, sc); Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set_block(self, slice, block); Set a vector block. to_array([copy, dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self, other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name¶; The name of the Vector. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. add(*args, **kwargs)¶; Overloaded function. add(self: psi4.core.Vector, m: int, val: float) -> None. Add to a single element value located at m. add(self: psi4.core.Vector, h: int, m: int, val: fl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:1395,load,load,1395,psi4manual/1.8.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html,2,['load'],['load']
Performance,; PR — PSI4 [beta2] documentation; REFERENCE — PSI4 [beta2] documentation; ROOTS_PER_IRREP — PSI4 [beta2] documentation; SEM_MAXITER — PSI4 [beta2] documentation; AEL — PSI4 [beta2] documentation; AO_BASIS — PSI4 [beta2] documentation; CACHELEVEL — PSI4 [beta2] documentation; GAUGE — PSI4 [beta2] documentation; INTS_TOLERANCE — PSI4 [beta2] documentation; ONEPDM — PSI4 [beta2] documentation; OPDM_RELAX — PSI4 [beta2] documentation; PROP_ALL — PSI4 [beta2] documentation; PROP_ROOT — PSI4 [beta2] documentation; PROP_SYM — PSI4 [beta2] documentation; REFERENCE — PSI4 [beta2] documentation; ROOTS_PER_IRREP — PSI4 [beta2] documentation; WFN — PSI4 [beta2] documentation; XI — PSI4 [beta2] documentation; XI_CONNECT — PSI4 [beta2] documentation; ZETA — PSI4 [beta2] documentation; ABCD — PSI4 [beta2] documentation; ANALYZE — PSI4 [beta2] documentation; AO_BASIS — PSI4 [beta2] documentation; BRUECKNER_ORBS_R_CONVERGENCE — PSI4 [beta2] documentation; CACHELEVEL — PSI4 [beta2] documentation; CACHETYPE — PSI4 [beta2] documentation; CC_NUM_THREADS — PSI4 [beta2] documentation; CC_OS_SCALE — PSI4 [beta2] documentation; CC_SS_SCALE — PSI4 [beta2] documentation; DIIS — PSI4 [beta2] documentation; FORCE_RESTART — PSI4 [beta2] documentation; LOCAL — PSI4 [beta2] documentation; LOCAL_CUTOFF — PSI4 [beta2] documentation; LOCAL_METHOD — PSI4 [beta2] documentation; LOCAL_PAIRDEF — PSI4 [beta2] documentation; LOCAL_WEAKP — PSI4 [beta2] documentation; MAXITER — PSI4 [beta2] documentation; MP2_AMPS_PRINT — PSI4 [beta2] documentation; MP2_OS_SCALE — PSI4 [beta2] documentation; MP2_SS_SCALE — PSI4 [beta2] documentation; NEW_TRIPLES — PSI4 [beta2] documentation; NUM_AMPS_PRINT — PSI4 [beta2] documentation; PAIR_ENERGIES_PRINT — PSI4 [beta2] documentation; PROPERTY — PSI4 [beta2] documentation; R_CONVERGENCE — PSI4 [beta2] documentation; REFERENCE — PSI4 [beta2] documentation; RESTART — PSI4 [beta2] documentation; SCS_CCSD — PSI4 [beta2] documentation; SCS_MP2 — PSI4 [beta2] documentation; SCSN_,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:904411,CACHE,CACHETYPE,904411,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHETYPE']
Performance,"; PSI4 [beta5] » ; Appendices »; Keywords by Module ». OPTKING¶; Performs geometry optimizations and vibrational frequency analyses. Optimization Algorithm¶. CONSECUTIVE_BACKSTEPS¶. Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. FIXED_BEND¶. Specify angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DIHEDRAL¶. Specify dihedral angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DISTANCE¶. Specify distances between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FROZEN_BEND¶. Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL¶. Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE¶. Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. INTERFRAG_STEP_LIMIT¶. Maximum step size in bohr or radian along an interfragment coordinate. Type: double; Default: 0.4. INTRAFRAG_STEP_LIMIT¶. Initial maximum step size in bohr or radian along an internal coordinate. Type: double; Default: 0.4. INTRAFRAG_STEP_LIMIT_MAX¶. Upper bound for dynamic trust radius [au]. Type: double; Default: 1.0. INTRAFRAG_STEP_LIMIT_MIN¶. Lower bound for dynamic trust radius [au]. Type: double; Default: 0.001. IRC_DIRECTION¶. IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE¶. IRC step size in bohr(amu). Type: double; Default: 0.2. IRC_STOP¶. Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. RFO_FOLLOW_ROOT¶. Do follow the initial RFO vector after the first step?. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__optking-1.html:1109,optimiz,optimization,1109,psi4manual/4.0b5/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__optking-1.html,2,['optimiz'],['optimization']
Performance,"; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DF_BASIS_MP2¶. Auxiliary basis set for MP2 density fitting calculations. Type: string; Possible Values: basis string; Default: No Default. DF_LMP2¶. Do use density fitting? Turned on with specification of fitting basis. Type: boolean; Default: true. DIAG_METHOD¶. Diagonalization method for the CI matrix. Type: string; Possible Values: DAVIDSON, FULL; Default: DAVIDSON. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html:1320,cache,cache,1320,psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,2,['cache'],['cache']
Performance,"; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CPHF_CUTOFF¶. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_CUTOFF¶. Value (always between one and ze",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html:1345,cache,cache,1345,psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html,2,['cache'],['cache']
Performance,"; Possible Values: RHF, ROHF, UHF; Default: RHF. EOM_REFERENCE (CCHBAR); CCHBAR — Reference wavefunction type for EOM computations. Type: string; Default: RHF. EOM_REFERENCE (CCSORT); CCSORT — Reference wavefunction type for EOM computations. Type: string; Default: RHF. EP_EA_POLES (OCC); OCC — Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES (OCC); OCC — Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER (OCC); OCC — Maximum number of electron propagator iterations. Type: integer; Default: 30. EX_ALLOW (DETCI); DETCI (Expert) — An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. EX_LEVEL (DETCI); DETCI — The CI excitation level. Type: integer; Default: 2. EXCH_SCALE_ALPHA (SAPT); SAPT — Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with . If set to a value , performs scaling with . Type: string; Default: FALSE. EXCITATION_RANGE (CCEOM); CCEOM (Expert) — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. EXPLICIT_HAMILTONIAN (CPHF); CPHF — Do explicit hamiltonian only?. Type: boolean; Default: false. EXTERN (SCF); SCF — An ExternalPotential (built by Python or NULL/None). Type: python; Default: No Default. EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS); GLOBALS (Expert) — Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:118980,perform,perform,118980,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"; Psithon Functions: Invoking a Calculation ». Counterpoise Correct¶; Code author: Robert M. Parrish. cp(name[, func, check_bsse, molecule])[source]¶; The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. Aliases :counterpoise_correct(), counterpoise_correction(). Returns:(float) Counterpoise-corrected interaction energy in Hartrees. Psi variables:. CP-CORRECTED 2-BODY INTERACTION ENERGY; UNCP-CORRECTED 2-BODY INTERACTION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No values of func besides energy have been tested.; Table print-out needs improving. Add some PSI variables. Parameters:; name (string) – 'scf' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; energy(); however, SAPT is not appropriate. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; energy('name'), while optimize perfoms a geometry optimization; on each system, and cbs performs a compound single-point energy.; If a nested series of python functions is intended; (see Function Intercalls), use keyword cp_func instead of func. check_bsse (boolean) – 'on' || 'off' ; Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). n_body(name[, func, bsse, max_n_body, do_total, external, external_monomers, molecule])[source]¶. Previous topic; Property; Next topic; Optimize; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . ne",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cp-1.html:1094,optimiz,optimize,1094,psi4manual/4.0b4/cp-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cp-1.html,12,"['optimiz', 'perform']","['optimize', 'performed']"
Performance,"; Psithon Functions: Invoking a Calculation ». Counterpoise Correct¶; Code author: Robert M. Parrish. cp(name[, func, check_bsse, molecule])[source]¶; The cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. Aliases :counterpoise_correct(), counterpoise_correction(). Returns:(float) Counterpoise-corrected interaction energy in kcal/mol. Psi variables:. CP-CORRECTED 2-BODY INTERACTION ENERGY; UNCP-CORRECTED 2-BODY INTERACTION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No values of func besides energy have been tested.; Table print-out needs improving. Add some PSI variables. Parameters:; name (string) – 'scf' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; energy(); however, SAPT is not appropriate. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; energy('name'), while optimize perfoms a geometry optimization; on each system, and cbs performs a compound single-point energy.; If a nested series of python functions is intended; (see Function Intercalls), use keyword cp_func instead of func. check_bsse (boolean) – 'on' || 'off' ; Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). n_body(name[, func, bsse, max_n_body, do_total, external, external_monomers, molecule])[source]¶. Previous topic; Property; Next topic; Optimize; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cp-1.html:1079,optimiz,optimize,1079,psi4manual/4.0b2/cp-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cp-1.html,4,"['optimiz', 'perform']","['optimize', 'performed']"
Performance,"; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: do",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/occ-1.html:12430,optimiz,optimize,12430,psi4manual/1.3.2/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/occ-1.html,2,['optimiz'],['optimize']
Performance,"; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:12428,optimiz,optimize,12428,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,4,['optimiz'],['optimize']
Performance,"; SAPT — Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. BASIS (SCF); SCF — Primary basis set. Type: string; Possible Values: basis string; Default: No Default. BB_M_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_MO_BB_TEI. BENCH (GLOBALS); GLOBALS — Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM —. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR —. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA —. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT —. Type: int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:5576,CACHE,CACHELEVEL,5576,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,4,"['CACHE', 'cache']","['CACHELEVEL', 'cache']"
Performance,"; SCF (Expert) — The amount of SAD information to print to the output. Type: integer; Default: 0. SAPT (SCF); SCF (Expert) — Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. SAPT_LEVEL (SAPT); SAPT — The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK (SAPT); SAPT — Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY (SAPT); SAPT — Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE (SAPT); SAPT — The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE (SAPT); SAPT — The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. SAVE_JK (SCF); SCF — Keep JK object for later use?. Type: boolean; Default: false. SCALE (STABILITY); STABILITY — Scale factor (between 0 and 1) for orbital rotation step. Type: double; Default: 0.5. SCF_MAXITER (DCFT); DCFT — Maximum number of orbital update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same keyword controls the maximum number of orbital response micro-iterations per macro-iteration for the solution of the response equations (for RESPONSE_ALOGRITHM = TWOSTEP). Type: integer; Default: 50. SCF_MEM_SAFETY_FACTOR (SCF); SCF — Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE (CPHF); CPHF — SCF Type. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: DIRECT. SCF_TYPE (SCF); SCF — What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:110774,perform,performed,110774,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"; SCF (Expert) — The amount of SAD information to print to the output. Type: integer; Default: 0. SAPT (SCF); SCF (Expert) — Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. SAPT_LEVEL (SAPT); SAPT — The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK (SAPT); SAPT — Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY (SAPT); SAPT — Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE (SAPT); SAPT — The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE (SAPT); SAPT — The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. SAVE_JK (SCF); SCF — Keep JK object for later use?. Type: boolean; Default: false. SCALE (STABILITY); STABILITY — Scale factor (between 0 and 1) for orbital rotation step. Type: double; Default: 0.5. SCF_MAXITER (DCFT); DCFT — Maximum number of orbital update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same keyword controls the maximum number of orbital response micro-iterations per macro-iteration for the solution of the response equations (for RESPONSE_ALOGRITHM = TWOSTEP). Type: integer; Default: 50. SCF_MEM_SAFETY_FACTOR (SCF); SCF — Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE (CPHF); CPHF — SCF Type. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: DIRECT. SCF_TYPE (SCF); SCF — What algorithm to use for the SCF computation. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: PK. SCHMIDT_ADD_RESIDUAL_TOLERANCE (CCEOM); CCEOM — Min",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:89077,perform,performed,89077,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"; SCF (Expert) — The amount of SAD information to print to the output. Type: integer; Default: 0. SAPT (SCF); SCF (Expert) — Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. SAPT_LEVEL (SAPT); SAPT — The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. SAPT_MEM_CHECK (SAPT); SAPT — Do force SAPT2 and higher to die if it thinks there isn’t enough memory? Turning this off is ill-advised. Type: boolean; Default: true. SAPT_MEM_SAFETY (SAPT); SAPT — Memory safety. Type: double; Default: 0.9. SAPT_OS_SCALE (SAPT); SAPT — The scale factor used for opposite-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 6.0/5.0. SAPT_SS_SCALE (SAPT); SAPT — The scale factor used for same-spin pairs in SCS computations. SS/OS decomposition performed for and terms. Type: double; Default: 1.0/3.0. SAVE_JK (SCF); SCF — Keep JK object for later use?. Type: boolean; Default: false. SCALE (STABILITY); STABILITY — Scale factor (between 0 and 1) for orbital rotation step. Type: double; Default: 0.5. SCF_MAXITER (DCFT); DCFT — Maximum number of the orbital update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same keyword controls the maximum number of orbital response micro-iterations per macro-iteration for the solution of the response equations (for RESPONSE_ALOGRITHM = TWOSTEP). Type: integer; Default: 50. SCF_MEM_SAFETY_FACTOR (SCF); SCF — Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE (CPHF); CPHF — SCF Type. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: DIRECT. SCF_TYPE (SCF); SCF — What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:114601,perform,performed,114601,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE RHF is only available for; ALGORITHM SIMULTANEOUS. To compute \((\lambda_3)\) correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; 1; 2; 3; 4; 5; 6; 7; 8molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dcft-1.html:14289,optimiz,optimize,14289,psi4manual/1.1.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dcft-1.html,12,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,; T2_COUPLED; T3_WS_INCORE; WFN; ABCD; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC3_FOLLOW_ROOT; COLLAPSE_WITH_LAST; COLLAPSE_WITH_LAST_CC3; COMPLEX_TOLERANCE; E_CONVERGENCE; EOM_GUESS; EOM_REFERENCE; EXCITATION_RANGE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; R_CONVERGENCE; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT; WFN; CACHELEVEL; EOM_REFERENCE; T_AMPS; WABEI_LOWDISK; WFN; ABCD; AO_BASIS; CACHELEVEL; DIIS; JOBTYPE; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; R_CONVERGENCE; RESTART; ROOTS_PER_IRREP; SEKINO; WFN; ZETA; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; R_CONVERGENCE; REFERENCE; RESTART; SEKINO; WFN; AO_BASIS; CACHELEVEL; DELETE_TEI; REFERENCE; RUN_CCTRANSORT; SEMICANONICAL; WFN; CC_NUM_THREADS; REFERENCE; SEMICANONICAL; WFN; CFOUR_ABCDTYPE; CFOUR_ACTIVE_ORBI; CFOUR_ANH_ALGORITHM; CFOUR_ANH_DERIVATIVES; CFOUR_ANH_STEPSIZE; CFOUR_ANH_SYMMETRY; CFOUR_ANHARMONIC; CFOUR_AO_LADDERS; CFOUR_AV_SCF; CFOUR_BASIS; CFOUR_BRUCK_CONV; CFOUR_BRUECKNER; CFOUR_CACHE_RECS; CFOUR_CALC_LEVEL; CFOUR_CC_CONV; CFOUR_CC_EXPORDER; CFOUR_CC_EXTRAPOLATION; CFOUR_CC_MAXCYC; CFOUR_CC_PROGRAM; CFOUR_CHARGE; CFOUR_CIS_CONV; CFOUR_CONTINUUM; CFOUR_CONTRACTION; CFOUR_CONVERGENCE; CFOUR_COORDINATES; CFOUR_CORE_ORBITALS; CFOUR_CPHF_CONVER; CFOUR_CPHF_MAXCYC; CFOUR_CURVILINEAR; CFOUR_DBOC; CFOUR_DCT; CFOUR_DERIV_LEVEL; CFOUR_DIFF_TYPE; CFOUR_DROPMO; CFOUR_ECP; CFOUR_EIGENVECTOR; CFOUR_EL_ANHARM; CFO,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:766637,CACHE,CACHELEVEL,766637,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,7,['CACHE'],['CACHELEVEL']
Performance,"; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. tdscf-7; TD-HF test variable access. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. scf-guess-read1; Sample UHF/cc-pVDZ H2O computat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:27968,optimiz,optimized,27968,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimized']
Performance,"; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s import",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/tutorial.html:6407,optimiz,optimizer,6407,psi4manual/master/tutorial.html,https://psicode.org,https://psicode.org/psi4manual/master/tutorial.html,9,['optimiz'],['optimizer']
Performance,"; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; 1; 2; 3; 4; 5; 6; 7--------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. The",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:6361,optimiz,optimizer,6361,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['optimiz'],['optimizer']
Performance,"; The same basis “block” syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; 1; 2; 3; 4; 5; 6; 7set df_basis_mp2 cc-pvdz-ri. or. df_basis_mp2 {; assign cc-pVDZ-RI; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; 1; 2; 3df_basis_mp2 {; assign C aug-cc-pVDZ-RI; }. Decontracted Basis Sets¶; Decontraction of the basis set can be useful in certain situations. In; order to decontract a given basis set, simply add “-decon” to the name; of the primary basis set (e.g. decontract).; 1set basis cc-pvdz-decon. Obviously this will add significantly to the computational cost of any given calculation, however it can; be useful when checking the basis set dependence of a particular calculated property or in certain situations; where a large basis set is critical. Currently it is recommended that a decontracted basis is always used when performing relativistic calculations using the X2C Hamiltonian. User-Defined Basis Sets¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. There are three routes by which a basis set in G94 format can be introduced to PSI4‘s notice.; (1) Install new basis set file into PSI4 basis library.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Name the file wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/basissets-1.html:6566,perform,performing,6566,psi4manual/1.1.0/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/basissets-1.html,2,['perform'],['performing']
Performance,"; The same basis “block” syntax can be; used to specify basis sets other than that used to define orbitals. For; example,; 1; 2; 3; 4; 5; 6; 7set df_basis_mp2 cc-pvdz-ri. or. df_basis_mp2 {; assign cc-pVDZ-RI; }. are both equivalent ways to set the auxiliary basis set for density fitted MP2; computations. To assign the aug-cc-pVDZ-RI to carbon atoms, the following; command is used:; 1; 2; 3df_basis_mp2 {; assign C aug-cc-pVDZ-RI; }. Decontracted Basis Sets¶; Decontraction of the basis set can be useful in certain situations. In; order to decontract a given basis set, simply add “-decon” to the name; of the primary basis set (e.g. decontract).; 1set basis cc-pvdz-decon. Obviously this will add significantly to the computational cost of any given calculation, however it can; be useful when checking the basis set dependence of a particular calculated property or in certain situations; where a large basis set is critical. Currently it is recommended that a decontracted basis is always used when performing relativistic calculations using the X2C Hamiltonian. User-Defined Basis Sets¶. Note; No recompile of the PSI program is necessary for changes made to; files in $PSIDATADIR, including those described below. There are three routes by which a basis set in G94 format can be introduced to PSI4’s notice.; (1) Install new basis set file into PSI4 basis library.; Copy the basis set definitions for all elements into a blank file. Exclamation points denote comments.; As the first line of the file, add the word spherical or cartesian to indicate; whether the basis set will run in (5D/7F) or (6D/10F).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18cartesian; ****; H 0; S 3 1.00; 3.42525091 0.15432897; 0.62391373 0.53532814; 0.16885540 0.44463454; ****; O 0; S 3 1.00; 130.7093200 0.15432897; 23.8088610 0.53532814; 6.4436083 0.44463454; SP 3 1.00; 5.0331513 -0.09996723 0.15591627; 1.1695961 0.39951283 0.60768372; 0.3803890 0.70011547 0.39195739; ****. Name the file wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/basissets-1.html:6568,perform,performing,6568,psi4manual/1.2.1/basissets-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/basissets-1.html,4,['perform'],['performing']
Performance,"; X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms. Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(numatoms):; A = F[f + 1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0. while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < _autofragment_convert(u, symbol) + _autofragment_convert(i, symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1. new_geom = """"""\n""""""; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". moleculenew = psi4.Molecule.create_molecule_from_string(new_geom); moleculenew.set_name(molname); moleculenew.update_geometry(); moleculenew.print_cluster(); psi4.print_out("""""" Exiting auto_fragments\n""""""). return moleculenew. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; Psi4 [1.0.0 6a9a71b] » ; Module code ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html:3946,Queue,Queue,3946,psi4manual/1.0.0/_modules/wrapper_autofrag.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/wrapper_autofrag.html,3,['Queue'],['Queue']
Performance,"; Y; Y; UHF. SIMULTANEOUS, QC; Y; N; UHF. SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE = RHF is only available for; ALGORITHM = SIMULTANEOUS. To compute correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS = DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS = DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:13191,optimiz,optimize,13191,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['optimiz'],['optimize']
Performance,"; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, PSI4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that PSI4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to the intermolecular interaction,; and the 0 indicates zeroth-order with respect to intramolecular electron; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/tutorial-1.html:11910,perform,perform,11910,psi4manual/4.0b3/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/tutorial-1.html,21,['perform'],['perform']
Performance,"; [Hohenstein:2010:014101]. Since we’re using density fitting for the SAPT,; we might as well also use it for the Hartree–Fock computations that are; performed as part of the SAPT. We can specify that with; scf_type DF.; Density fitting procedures require the use of auxiliary basis sets that; pair with the primary basis set. Fortunately, Psi4 is usually smart; enough to figure out what auxiliary basis sets are needed for a given; computation. In this case, jun-cc-pVDZ is a standard enough basis set; (just a simple truncation of the very popular aug-cc-pVDZ basis set); that Psi4 correctly guesses that we want the jun-cc-pVDZ-JKFIT; auxiliary basis for the Hartree–Fock, and the jun-cc-pVDZ-RI basis set; for the SAPT procedure.; To speed up the computation a little, we also tell the SAPT procedure to; freeze the core electrons with freeze_core True. The SAPT; procedure is invoked with the simple call, energy('sapt0'). This; call knows to automatically run two monomer computations and a dimer; computation and then use these results to perform the SAPT analysis. The; various energy components are printed at the end of the output, in addition; to the total SAPT0 interaction energy. An explanation of the various; energy components can be found in the review by Jeziorski, Moszynski, and; Szalewicz [Jeziorski:1994:1887], and this is discussed in more detail; in the SAPT section later in this manual. For now, we’ll note that most of; the SAPT energy components are negative; this means those are attractive; contributions (the zero of energy in a SAPT computation is defined as; non-interacting monomers). The exchange contributions are positive; (repulsive). In this example, the most attractive contribution between; ethylene and acetylene is an electrostatic term of -2.12 kcal mol-1; (Elst10,r where the 1 indicates the first-order; perturbation theory result with respect to the intermolecular interaction,; and the 0 indicates zeroth-order with respect to intramolecular electron; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:12999,perform,perform,12999,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['perform'],['perform']
Performance,"; [Lehtola:2020:144105]. The main difference to the SAP guess; discussed above [Lehtola:2019:25945] is that the SAPGAU scheme is; analytic, and can be efficiently formed in terms of three-center; two-electron integrals [Lehtola:2020:144105]. The potential in; the SAPGAU scheme is passed with the SAPGAU_BASIS; keyword. The default potential is given by the large fit to the; HelFEM potential, sap_helfem_large, described in; [Lehtola:2020:144105]. Note that this guess is known in the DIRAC; program as .SCRPOT and in the ERKALE program as SAPFIT. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G or pcseg-0 basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). Restarting the SCF¶; Reading orbital data from a previous calculations is done via the restart_file option,; where the actual file is a serialized wfn object (see saving the wfn); By default, the orbital data file of the converged SCF(psi.PID.name.180.npy) is deleted; after PSI4 exits or the clean() function is called. The orbital guess is automatically; set to READ when restart_file is given a wfn file.; To write the orbitals after every iteration and keep the orbitals from the last iteration, the write_orbitals options is available:; energy('scf', write_orbitals='my_mos'),. which writes a Wavefunction object converted (serialized) to a numpy file called my_mos.npy.; The restart can then be done as follows:; energy('scf', restart_file='my_mos'). Specifying the .npy suffix when writing and reading restart files is ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/scf.html:20396,perform,performing,20396,psi4manual/master/scf.html,https://psicode.org,https://psicode.org/psi4manual/master/scf.html,3,['perform'],['performing']
Performance,"; are set to complain if contradicted (‘clobber’ set to True), other; ‘recommended’ settings, like CFOUR_CC_PROGRAM, can be; countermanded by keywords in input file (‘clobber’ set to False).; Occasionally, want these pieces to actually overcome keywords in; input file (‘superclobber’ set to True). prepare_options_for_molpro(options, proc)[source]¶; Function to take the full snapshot of the liboptions object; encoded in dictionary options, find the options directable toward; Cfour (options[‘CFOUR’][‘CFOUR_**’]) that aren’t default, then write; a CFOUR deck with those options.; Note that unlike the cfour version, this uses complete options deck. psi4_list()[source]¶; Return an array of Psi4 methods with energies. class Gaussian94BasisSetParser(forced_puream=None)[source]¶; Class for parsing basis sets from a text file in Gaussian 94; format. Translated directly from the Psi4 libmints class written; by Justin M. Turney and Andrew C. Simmonett. load_file(filename, basisname=None)[source]¶; Load and return the file to be used by parse. Return only; portion of filename pertaining to basisname if specified (for; multi-basisset files) otherwise entire file as list of strings. parse(symbol, dataset)[source]¶; Given a string, parse for the basis set needed for atom.; * @param symbol atom symbol to look for in dataset; * @param dataset data set to look through; dataset can be list of lines or a single string which will be converted to list of lines. getrec(reclabelarray, verbose=False)[source]¶; Reads binary files JOBARC and JAINDX and returns contents; of each record in reclabelarray. class Infile(mem, mol, mtd, der, opt)[source]¶. format_infile_string()[source]¶. harvest_output(outtext)[source]¶; Function to separate portions of a Psi4 output file outtext. muster_cdsgroup_options()[source]¶. muster_modelchem(name, dertype)[source]¶; Transform calculation method name and derivative level dertype; into options for cfour. While deliberately requested pieces,; generally CFOUR_DE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:105368,Load,Load,105368,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Load'],['Load']
Performance,"; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the pl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/plugins-1.html:6285,Load,Load,6285,psi4manual/4.0b4/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/plugins-1.html,2,['Load'],['Load']
Performance,"; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import PsiMod; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; PsiMod.plugin_load(sofile). inputalt.dat — Sample input file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:5939,Load,Load,5939,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,4,['Load'],['Load']
Performance,"; dft_spherical_points 590 # Often needed; dft_radial_points 99 # Often needed; dft_radial_scheme treutler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to those; listed above for Hartree-Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn-Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 and 0.5. Fractional ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dft-1.html:18817,perform,perform,18817,psi4manual/4.0b3/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dft-1.html,4,['perform'],['perform']
Performance,"; docstring. DSYR2(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYR2K(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYRK(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DSYSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, ...); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time[, nthread]); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:2582,Perform,Perform,2582,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,4,['Perform'],['Perform']
Performance,"; driver.response, and driver.frequency. diatomic¶. pcm_placeholder¶; This is a placeholder for the real pcmsolver.py script.; The location of the real pcmsolver.py is configured by CMake; to point to the proper install prefix.; In this way we avoid to transform inputparser.py into a file; that has to be configured by CMake; With conda, this starts to get complicated. Bottom option; works for build-in-place and build-psi-w-prebuilt-pcmsolver.; Upper option necessary when psi4metapackage is conda build; dependency. At least I think that’s what’s going on. dependency_check¶; Attempts to catch Python based import errors and provides possible solutions. gaussian_n¶. run_gaussian_2(name, **kwargs)[source]¶. frac¶. frac_nuke(molecule, **kwargs)[source]¶. frac_traverse(molecule, **kwargs)[source]¶. ip_fitting(molecule, omega_l, omega_r, **kwargs)[source]¶. molutil¶; Module with utility functions that act on molecule objects. BFS(self)[source]¶; Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. activate(mol)[source]¶; Function to set molecule object mol as the current active molecule.; Permitted for user use but deprecated in driver in favor of explicit; molecule-passing. dynamic_variable_bind(cls)[source]¶; Function to dynamically add extra members to; the psi4.Molecule class. extract_cluster_indexing(mol, cluster_size=0)[source]¶; Function to returns a LIST of all subclusters of the molecule mol of; real size cluster_size. If cluster_size = 0, returns all possible; combinations of cluster size. extract_clusters(mol, ghost=True, cluster_size=0)[source]¶; Function to return all subclusters of the molecule mol of; real size cluster_size and all other atoms ghosted if ghost; equals true, all other atoms discarded if ghost is false. If; cluster_size = 0, returns all possible comb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:1219,Perform,Perform,1219,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Perform'],['Perform']
Performance,"; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([-1.0, 1.0, -1.0])]):; self.bits = SymmOps['C2_y']; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([-1.0, -1.0, 1.0])]):; self.bits = SymmOps['C2_z']; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([1.0, 1.0, -1.0])]):; self.bits = SymmOps['Sigma_xy']; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([1.0, -1.0, 1.0])]):; self.bits = SymmOps['Sigma_xz']; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([-1.0, 1.0, 1.0])]):; self.bits = SymmOps['Sigma_yz']; elif all([abs(temp[idx] - val) < tol for idx, val in enumerate([-1.0, -1.0, -1.0])]):; self.bits = SymmOps['i']. [docs] def operate(self, r):; """"""This operates on this with r (i.e. return r * this)"""""". ret = SymmetryOperation(); for i in range(3):; for j in range(3):; t = 0.0; for k in range(3):; t += r.d[i][k] * self.d[k][j]; ret.d[i][j] = t; ret.analyze_d(); return ret. [docs] def transform(self, r):; """"""This performs the transform r * this * r~"""""". # foo = r * d; foo = SymmetryOperation(); for i in range(3):; for j in range(3):; t = 0.0; for k in range(3):; t += r.d[i][k] * self.d[k][j]; foo.d[i][j] = t. # ret = (r*d)*r~ = foo*r~; ret = SymmetryOperation(); for i in range(3):; for j in range(3):; t = 0.0; for k in range(3):; t += foo.d[i][k] * r.d[j][k]; ret.d[i][j] = t. ret.analyze_d(); return ret. # SymmetryOperation & operator = (SymmetryOperation const & a); // Assignment operator. [docs] def rotation(self, theta):; """"""Set equal to a clockwise rotation by 2pi/n or theta degrees"""""". if isinstance(theta, int):; theta = 2.0 * math.pi if theta == 0 else 2.0 * math.pi / theta; ctheta = math.cos(theta); stheta = math.sin(theta). self.zero(); self.d[0][0] = ctheta; self.d[0][1] = stheta; self.d[1][0] = -stheta; self.d[1][1] = ctheta; self.d[2][2] = 1.0; self.analyze_d(). [docs] def transpose(self):; """"""Transpose matrix operation"""""". for i in range(3):; for j in range(i):; tmp = self.d[i][j]; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html:8053,perform,performs,8053,psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintspointgrp.html,1,['perform'],['performs']
Performance,"; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gradient', name, 'MP_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def sele",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:11851,perform,performance,11851,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; core.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:9185,perform,performance,9185,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"; else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:26978,optimiz,optimize,26978,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['optimiz'],['optimize']
Performance,"; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:32833,perform,performance,32833,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Contributions: Intro to Programming in PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/plugins-1.html:8196,load,loaded,8196,psi4manual/1.2.1/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/plugins-1.html,6,['load'],"['loaded', 'loading']"
Performance,"; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, **kwargs); steps_since_last_hessian = 0; core.set_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup bi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:61588,optimiz,optimized,61588,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['optimiz'],['optimized']
Performance,"; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = psi4.get_gradient() # TODO; psi4.IOManager.shared_object().set_specific_retention(1, True); psi4.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, **kwargs); steps_since_last_hessian = 0; psi4.set_gradient(G); psi4.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and psi4.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; psi4.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; psi4.set_legacy_molecule(moleculeclone); optking_rval = psi4.optking(); moleculeclone = psi4.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == psi4.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if psi4.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); psi4.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if psi4.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if psi4.get_option('OPTKING', 'KEEP_INTCOS') == False:; psi4.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); psi4.clean(). # S/R: Clean up opt input file; if opt_mode == 'reap':; with open('OPT-master.in', 'wb') as fmaster:; fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'.encode('utf-8')); fmaster.write('# Optimization complete!\n\n'.encode('utf-8')). # Cleanup bi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:59746,optimiz,optimized,59746,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimized']
Performance,"; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CI_TYPE'); module = psi4.get_global_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:23696,perform,performance,23696,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_ccsd_at_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CI_TYPE'); module = core.get_global_option('QC_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:23485,perform,performance,23485,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['perform'],['performance']
Performance,"; method call) starts building a *CFOUR(...) directive for the; ZMAT file. Since the contents of the cfour {...} block are; blindly appended to any input interpreted from PSI4 format, mixing; of PSI4 and Cfour input formats likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route.; Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between PSI4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM (as opposed to CFOUR_SPHERICAL).; Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. PSI4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles.; Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; muster_modelchem for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:31418,optimiz,optimization,31418,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,9,['optimiz'],['optimization']
Performance,"; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/oeprop-1.html:2423,Optimiz,Optimization,2423,psi4manual/4.0b4/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/oeprop-1.html,2,['Optimiz'],['Optimization']
Performance,"; properties may be requested, as in the example above. Note that, due to Python; syntax restrictions, the title argument must appear after the list of; properties to compute. The available properties are shown in the table below. Current one-electron property capabilities of PSI4. Feature; Keyword; Notes. Electric dipole moment; DIPOLE;  . Electric quadrupole moment; QUADRUPOLE; Raw (traced) moments and traceless multipoles. All moments up order N; MULTIPOLE(N); Only raw (traced) moments. Sets global variables e.g. “DIPOLE X”, “32-POLE XYYZZ”. Transition dipole moment; TRANSITION_DIPOLE;  . Transition quadrupole moment; TRANSITION_QUADRUPOLE;  . Electrostatic potential, at nuclei; ESP_AT_NUCLEI; Sets global variables “ESP AT CENTER n”, n = 1 to natoms. Molecular orbital extents; MO_EXTENTS;  . Mulliken atomic charges; MULLIKEN_CHARGES;  . Löwdin atomic charges; LOWDIN_CHARGES;  . Wiberg bond indices; WIBERG_LOWDIN_INDICES; Uses (Löwdin) symmetrically orthogonalized orbitals. Mayer bond indices; MAYER_INDICES;  . Natural orbital occupations; NO_OCCUPATIONS;  . Basic Keywords¶; Multipole moments may be computed at any origin, which is controlled by the; global PROPERTIES_ORIGIN keyword. The keyword takes an array with; the following possible values:. Allowed origin specifications. Keyword; Interpretation. [x, y, z]; Origin is at the coordinates, in the same units as the geometry specification. [“COM”]; Origin is at the center of mass. [“NUCLEAR_CHARGE”]; Origin is at the center of nuclear charge. Table Of Contents. Evaluation of One-Electron Properties; Basic Keywords. Previous topic; Geometry Optimization; Next topic; Interfaces: Enhancing PSI4 Capabilities; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/oeprop-1.html:2423,Optimiz,Optimization,2423,psi4manual/4.0b5/oeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/oeprop-1.html,2,['Optimiz'],['Optimization']
Performance,"; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . The psi_ prefix is to prevent clashes with user-defined variables in; Psi4 input files. Memory Specification¶; By default, Psi4 assumes that 256 Mb of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 Gb of RAM is available; to Psi4:; # all equivalent. memory 2 Gb. memory 2000 Mb. memory 2000000 Kb. One convenient way to override the Psi4 default memory is to place a; memory command in the ~/.psi4rc file (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 Gb.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis. Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and Geometry Specification¶. Molecule and Geometry Specification; Coordinates; Molecule Keywords; Multiple Molecules; Ghost Atoms; Isot",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:4087,perform,perform,4087,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['perform'],['perform']
Performance,"; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 20. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/optking-1.html:2962,optimiz,optimization,2962,psi4manual/4.0b2/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html,2,['optimiz'],['optimization']
Performance,"; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:3494,optimiz,optimization,3494,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,2,['optimiz'],['optimization']
Performance,"; return namelower, None; else:; return namelower, None. [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: (*float*) Total electronic energy in Hartrees. .. note:: Analytic hessians are not available. Frequencies will proceed through; finite differences according to availability of gradients or energies. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Make frequency look analogous to gradient, especially in matching derivative levels. Make dertype actually a dertype type. .. _`table:freq_gen`:. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] <example description>; >>> <example python command>. >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> frequencies('scf', dertype=1, irrep=4). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:42966,perform,performed,42966,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['perform'],['performed']
Performance,"; return namelower, None; else:; return namelower, None. [docs]def frequency(name, **kwargs):; r""""""Function to compute harmonic vibrational frequencies. :aliases: frequencies(), freq(). :returns: (*float*) Total electronic energy in Hartrees. .. note:: Analytic hessians are not available. Frequencies will proceed through; finite differences according to availability of gradients or energies. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - Make frequency look analogous to gradient, especially in matching derivative levels. Make dertype actually a dertype type. .. _`table:freq_gen`:. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] <example description>; >>> <example python command>. >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> frequencies('scf', dertype=1, irrep=4). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 2. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Defaul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:58693,perform,performed,58693,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['perform'],['performed']
Performance,"; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2p5_gradient', name, 'MP_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:15301,perform,performance,15301,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"; scf_type df; dft_spherical_points 590 # Often needed; dft_radial_points 99 # Often needed; dft_radial_scheme treutler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to; those for Hartree–Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn–Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Lar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:22631,perform,perform,22631,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['perform'],['perform']
Performance,"; setting keywords. theory. OMP2.5. ; setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3. ; setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRONENERGY. one_electron_integrals() psi4.core.MintsHelper method, [1], [2]. OneBodyAOInt class in psi4.core, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). OrbitalSpace class in psi4.core, [1]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt attribute, [1]. psi4.core.OneBodyAOInt attribute, [1], [2]. psi4.core.OverlapInt attribute, [1]. psi4.core.PotentialInt attribute, [1]. psi4.core.PseudospectralInt attribute, [1]. psi4.core.QuadrupoleInt attribute, [1]. psi4.core.TracelessQuadrupoleInt attribute, [1]. original_coef() psi4.core.GaussianShell method, [1], [2]. ORTH_TYPE (DFOCC). (OCC). outfile_nam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:71756,optimiz,optimize,71756,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['optimiz'],['optimize']
Performance,"; setting keywords. theory. OMP3 CORRELATION ENERGY. OMP3 DOUBLES ENERGY. OMP3 OPPOSITE-SPIN CORRELATION ENERGY. OMP3 REFERENCE CORRECTION ENERGY. OMP3 SAME-SPIN CORRELATION ENERGY. OMP3 TOTAL ENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRON ENERGY. one_electron_integrals() (psi4.core.MintsHelper method). OneBodyAOInt (class in psi4.core). OneBodySOInt (class in psi4.core). onel_Hx() (psi4.core.HF method). ONEPDM (DFMP2). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DCT). (DETCI). opdm() (psi4.core.CIWavefunction method). OPDM_ONLY (CCDENSITY). OPDM_RELAX (CCDENSITY). (DFMP2). open() (psi4.core.IO method). open_check() (psi4.core.IO method). operate() (psi4.core.SymmetryOperation method). opt(). . see optimize(). opt() (in module psi4.driver). OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_RESTART (OPTKING). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() (in module psi4.driver). optimize_geometric() (in module psi4.driver). option_exists_in_module() (in module psi4.core). Options (class in psi4.core). options() (psi4.core.Wavefunction method). options_to_python() (in module psi4.core). OptionsState (class in psi4.driver.p4util). OptionsStateCM() (in module psi4.driver.p4util). OptionState (class in psi4.driver.p4util). ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() (psi4.core.PointFunctions method). ORBITALS_WRITE (SCF). OrbitalSpace (class in psi4.core). order() (psi4.core.CharacterTable method). (psi4.core.PointGroup method). ordered_params (psi4.driver.EmpiricalDispersion attribute). (psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute). OREMP. ; setting keywords. OREMP2 CORRELATION ENERGY. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:87597,optimiz,optimize,87597,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['optimiz'],['optimize']
Performance,"; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/psi-mp4; MP4 energy components. Checks that computed identically betwee",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html:1512,optimiz,optimization,1512,psi4manual/1.9.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-chg; B3LYP Hybrid-GG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:3005,optimiz,optimizations,3005,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['optimiz'],['optimizations']
Performance,"; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:3147,optimiz,optimizations,3147,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,4,['optimiz'],['optimizations']
Performance,"; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj;  . b1pw91; B1PW91 Hyb-GGA Ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:2734,optimiz,optimizations,2734,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,4,['optimiz'],['optimizations']
Performance,"; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d;  . b3lyp-d3;  . b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:2501,optimiz,optimizations,2501,psi4manual/1.1.0/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html,2,['optimiz'],['optimizations']
Performance,"; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to those; listed above for Hartree-Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn-Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional.; Note: gradients with LRC functionals and DF integrals technology are not; currently enabled. We hope to have a patch for this deficit soon. Please let us; know if you have a strong need for this capability, and we will move the; priority up. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 and 0.5. Fractional ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dft-1.html:19060,perform,perform,19060,psi4manual/4.0b4/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dft-1.html,4,['perform'],['perform']
Performance,"; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to those; listed above for Hartree-Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn-Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional.; Note: gradients with LRC functionals and DF integrals technology are not; currently enabled. We hope to have a patch for this deficit soon. Please let us; know if you have a strong need for this capability, and we will move the; priority up. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:19145,perform,perform,19145,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['perform'],['perform']
Performance,"; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set' : [{'type' : 'distance',; 'indices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in; place:; molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:23940,optimiz,optimize,23940,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,9,['optimiz'],['optimize']
Performance,"; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if not core.get_option('OPTKING', 'KEEP_INTCOS'):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). n += 1. if not core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT'):; if not core.get_option('OPTKING', 'KEEP_INTCOS'):; core.opt_clean(). optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; ## First half of this fn -- entry means user wants a 2nd derivative by any means. kwargs = p4util.kwargs_lower(kwargs); basisstash = p4util.OptionsState(['BASIS']",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:69373,Optimiz,OptimizationConvergenceError,69373,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimization']"
Performance,";  · . PSI4. PSI4 API: Linking C++ and Python; properties. properties¶. psi4.driver.properties(*args, **kwargs)[source]¶; Function to compute various properties. Aliases:; prop(). Returns:; none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.properties.html:1028,optimiz,optimized,1028,psi4manual/1.7.x/api/psi4.driver.properties.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.properties.html,4,['optimiz'],['optimized']
Performance,"; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. mp3; MP_TYPE; ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. remp2; CC_TYPE; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. lccd; CC_TYPE; ✓; ✓; ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ccd; CC_TYPE. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ccsd; CC_TYPE. ✓; ✓; ✓; ✓. ✓̲; ✓̲. ✓̲; ✓̲; ✓̲; ✓̲. ✓̲; ✓̲. ccsd(t); CC_TYPE. ✓; ✓; ✓; ✓. ✓̲; ✓̲. a-ccsd(t)[8]; CC_TYPE. ✓̲; ✓̲; ✓̲; ✓̲. [5]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [6]; Active orbital values to the right: all-electron A and frozen-core F. [7]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [8]; a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L. table of contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced OCC Keywords; OPT_METHOD; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Basic DFOCC Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; ORB_OPT. Advanced DFOCC Keywords; OPT_METHOD; HESS_TYPE; MO_DIIS_NUM_VECS; ORTH_TYPE; DO_DIIS; DO_LEVEL_SHIFT. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/occ.html:21481,Optimiz,Optimized,21481,psi4manual/1.7.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/occ.html,2,['Optimiz'],['Optimized']
Performance,"; ✓̳. ✓̲; ✓̲. omp3[4]; MP_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. oremp2[4]; CC_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. olccd[4]; CC_TYPE; ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. ✓̳. ✓̲; ✓̲; ✓̲; ✓̲; ✓̳. ✓̲; ✓̲. [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-core F. [3]; (1,2,3); Finite difference gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [4]; (1,2,3,4,5); Also available for DFT references RKS/UKS. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp2; A special version of SCS-OMP2 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp2; A special version of SOS-OMP2 for \(\pi\)-systems; RHF/UHF/ROHF/RKS/UKS; —. Basic OCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:12541,Optimiz,Optimized,12541,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,4,['Optimiz'],['Optimized']
Performance,"<sec:fnompn>` |; +-------------------------+---------------------------------------------------------------------------------------+; | mp\ *n* | *n*\ th-order Moller--Plesset (MP) perturbation theory :ref:`[manual] <sec:arbpt>` |; +-------------------------+---------------------------------------------------------------------------------------+; | zapt\ *n* | *n*\ th-order z-averaged perturbation theory (ZAPT) :ref:`[manual] <sec:arbpt>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp2 | orbital-optimized second-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | ocepa | orbital-optimized coupled electron pair approximation :ref:`[manual] <sec:occ>` |; +-------------------------+---------------------------------------------------------------------------------------+; | cepa0 | coupled electron pair approximation, equiv. linear. CCD :ref:`[manual] <sec:convocc>` |; +-------------------------+---------------------------------------------------------------------------------------+; | cepa(0) | coupled electron pair approximation variant 0 :ref:`[manual] <sec:fnocepa>` |; +-------------------------+---------------------------------------------------------------------------------------+; | cepa(1) | coupled electron pair approximation variant 1 :ref:`[manual] <sec:fnocepa>` |; +-------------------------+---------------------------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:10621,optimiz,optimized,10621,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['optimiz'],['optimized']
Performance,"= 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zapt2')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""); elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:5299,perform,performance,5299,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"= 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:75898,optimiz,optimized,75898,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimized']
Performance,"= None¶; internal name of database; >>> print asdf.dbse; 'NBC1'. get_pec_weightinfo()[source]¶. hrgt = None¶; dict of reagents/geometries; >>> print asdf.hrgt.keys(); ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']. hrxn = None¶; OrderedDict of reactions/members; >>> print asdf.hrxn.keys(); ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']. integer_reactions()[source]¶; Returns boolean of whether reaction names need to be cast to integer. static load_pickled(dbname, path=None)[source]¶. load_qcdata(modname, funcname, pythonpath=None, failoninc=True)[source]¶; Loads qcdb.ReactionDatums from module modname function; funcname. Module search path can be prepended with pythonpath. load_qcdata_byproject(project, pythonpath=None)[source]¶; Loads qcdb.ReactionDatums from standard location for project; :module dbse_project and function load_project. Module search path; can be prepended with pythonpath. load_qcdata_hdf5_trusted(project, path=None)[source]¶; Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. load_qcdata_hrxn_byproject(project, path=None)[source]¶. load_subsets(modname='subsetgenerator', pythonpath=None)[source]¶; Loads subsets from all functions in module modname. oss = None¶; object of defined reaction subsets. sset = None¶; dict of defined reaction subsets.; Note that self.sset[‘default’] contains all the nonredundant information.; >>> print asdf.sset.keys(); ['meme', 'mxddpp', '5min', ... 'small']. tagl = None¶; description line; >>> print asdf.tagl; 'interaction energies of dissociation curves for non-bonded systems'. average_errors(*args)[source]¶; Each item in args should be an error dictionary. Performs; average-like operation over all items, which should be error; dictionaries, in args. Defined for ME, MAE, STDE, and their; relative-error variants. None returned for undef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:48826,Load,Loads,48826,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['Load'],['Loads']
Performance,"= kwargs.pop('opt_datafile'); if(psi4.me() == 0):; shutil.copy(restartfile, p4util.get_psifile(1)). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = psi4.get_gradient(); psi4.IOManager.shared_object().set_specific_retention(1, True); psi4.IOManager.shared_object().set_specific_path(1, './'); frequencies(name, **kwargs); steps_since_last_hessian = 0; psi4.set_gradient(G); psi4.set_global_option('CART_HESS_READ', True); elif ((full_hess_every == -1) and (psi4.get_global_option('CART_HESS_READ')) and (n == 1)):; pass; # Do nothing; user said to read existing hessian once; else:; psi4.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # print 'cart_hess_read', psi4.get_global_option('CART_HESS_READ'); # Take step; if psi4.optking() == psi4.PsiReturnType.EndLoop:; print('Optimizer: Optimization complete!'); psi4.print_out('\n Final optimized geometry and variables:\n'); psi4.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (psi4.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False):; psi4.opt_clean(); psi4.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(). optstash.restore(); return thisenergy; psi4.print_out('\n Structure for next step:\n'); psi4.get_active_molecule().print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = p4util.get_psifile(1); kwargs['mode'] = 'sow'. n += 1. psi4.print_out('\tOptimizer: Did not converge!'). optstash.restore(); return 0.0. ## Aliases ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:53553,optimiz,optimized,53553,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['optimiz'],['optimized']
Performance,"= self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = np.array(task.extras['qcvars']['CURRENT DIPOLE']). if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = np.array(task.extras['qcvars']['CURRENT DIPOLE GRADIENT']). # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] ==",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html:56455,load,load,56455,psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_cbs.html,1,['load'],['load']
Performance,"= self.metameta['label']; instructions = ""\n"" + p4util.banner(f"" CBS Computations{':' + label if label else ''} "",; strNotOutfile=True) + ""\n""; logger.debug(instructions); core.print_out(instructions). with p4util.hold_options_state():; for t in reversed(self.task_list):; t.compute(client=client). def _prepare_results(self, client: Optional[""qcportal.FractalClient""] = None):; results_list = [x.get_results(client=client) for x in self.task_list]. modules = [getattr(v.provenance, ""module"", None) for v in results_list]; if self.driver != ""energy"" and len(set(modules)) == 2 and modules.count(""scf"") == len(modules) / 2:; # signature of ""MP2 GRAD"" - ""HF GRAD"" implementation detail; # * avoid having post-scf single-method gradients/Hessians show up as ""(mixed)"" module just because an outright HF call in the jobs list; modules = set(modules) - {""scf""}; modules = list(set(modules)); modules = modules[0] if len(modules) == 1 else ""(mixed)"". # load results_list numbers into compute_list (task_list is AtomicComputer-s); for itask, mc in enumerate(self.compute_list):; task = results_list[itask]; response = task.return_result. if self.metameta['ptype'] == 'energy':; mc['f_energy'] = response. elif self.metameta['ptype'] == 'gradient':; mc['f_gradient'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']. elif self.metameta['ptype'] == 'hessian':; mc['f_hessian'] = response; mc['f_energy'] = task.extras['qcvars']['CURRENT ENERGY']; if 'CURRENT GRADIENT' in task.extras['qcvars']:; mc['f_gradient'] = task.extras['qcvars']['CURRENT GRADIENT']. if 'CURRENT DIPOLE' in task.extras['qcvars']:; mc['f_dipole'] = task.extras['qcvars']['CURRENT DIPOLE']. if 'CURRENT DIPOLE GRADIENT' in task.extras['qcvars']:; mc['f_dipder'] = task.extras['qcvars']['CURRENT DIPOLE GRADIENT']. # Fill in energies for subsumed methods; if self.metameta['ptype'] == 'energy':; for wfn in VARH[mc['f_wfn']]:; for job in self.trove:; if ((wfn == job['f_wfn']) and (mc['f_basis'] == job['f_basis']); an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html:56636,load,load,56636,psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_cbs.html,3,['load'],['load']
Performance,"== run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'E_CONVERGENCE', 10); if not PsiMod.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 6); else:; PsiMod.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not PsiMod.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 8). returnvalue = procedures['property'][lowername](lowername, **kwargs). except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). optstash.restore(); return returnvalue. ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory :ref:`[manual] <sec:dcft>` |; +-------------------------+----------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:44988,optimiz,optimize,44988,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,3,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"========================================+; | scf | Hartree--Fock (HF) or LSDA density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[details] <dd_svwn>` |; +-------------------------+-----------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:86600,optimiz,optimize,86600,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimize']
Performance,"=============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce (someday) if name is function; if hasattr(name, '__call__'):; raise ValidationError(""Frequency: Cannot use custom function""). lowername = name.lower(). if ""/"" in lowername:; return driver_cbs._cbs_gufunc(frequency, name, ptype='frequency', **kwargs). if kwargs.get('bsse_type', None) is not None:; raise ValdiationError(""Frequency: Does not currently support 'bsse_type' arguements""). return_wfn = kwargs.pop('return_wfn', False). # are we in sow/reap mode?; freq_mode = kwargs.get('mode', 'continuous').lower(); if freq_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Frequency execution mode '%s' not valid."""""" % (freq_mode)). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(lowername,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:88206,optimiz,optimize,88206,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"=============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; if wfn.gradient(): # available for analytic and any findif including totally symmetric space; gradient_rms = wfn.gradient().rms(); else:; gradient_rms = 1 # choose to force non-projection of rotations; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(gradient_rms). project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:78580,optimiz,optimize,78580,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"=============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs). return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:72434,optimiz,optimize,72434,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"=============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. :examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). """"""; kwargs = p4util.kwargs_lower(kwargs); ; return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:85328,optimiz,optimize,85328,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['optimiz'],['optimize']
Performance,"=NONE is used, where four-virtual integrals are transformed into MO basis. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. sapt-compare; SAPT0 aug-cc-pVDZ computation of the water-water interaction energy, using the three SAPT codes. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:12079,optimiz,optimization,12079,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. scf-guess-read3; Test if the the guess read in the same basis converges. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. ao-dfcasscf-sp; CASSCF/6-31G** energy point. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. cc52; CCSD Response for H2O2. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mbis-3; MBIS calculation on OH radical. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cisd-sp; 6-31G** H2O Test CISD Energy Point. cbs-xtpl-alpha; Extrapolated water energies. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cc13b; Tests RHF CCSD(T)gradients. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:15267,optimiz,optimization,15267,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc51; EOM-CC3/cc-pVTZ on H2O. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). mints2-bse; Similar to mints2, but using the BSE to specify the basis sets. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. nbo; Generation of NBO file. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. dfccsd-t-grad2; DF-CCSD(T) cc-pVDZ gradient for the NH molecule. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. tu1-h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:28959,optimiz,optimization,28959,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"> # [4] This WILL work, note the transformation of Da (SO->MO); >>> E, wfn = properties('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> Da_mo = Matrix.triplet(wfn.Ca(), Da_so, wfn.Ca(), True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.2.1;  · . PSI4. Module code. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:99849,optimiz,optimize,99849,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode not in ['continuous', 'sow', 'reap']:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are feezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone().",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:57434,Optimiz,Optimize,57434,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['Optimiz'],['Optimize']
Performance,">1 -> everything); nonneg_only; Should eigenpairs with eigenvalue < 0 be ignored?. Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors: List[`vector`]; (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly.; """"""; nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""done"": True,; ""nvec"": 0,; ""collapse"": False,; ""product_count"": 0,; }. print_name = ""DavidsonSolver""; title_lines = [""Generalized Davidson Solver"", ""By Ruhee Dcunha""]. _diag_print_heading(title_lines, print_name, max_ss_size, nroot, r_convergence, maxiter, verbose). vecs = guess; stats = []; best_eigvecs = []; best_eigvals = []; while iter_info['count'] < maxiter:. # increment iteration/ save old vals; iter_info['count'] += 1; old_vals = iter_info['val'].copy(). # reset flags; iter_info['collapse'] = False; iter_info['done'] = True. # get subspace dimension; l = len(vecs); iter_info['nvec'] = l. # check if ss dimension has exceeded limits; if l >= m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:20805,perform,performed,20805,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,4,['perform'],['performed']
Performance,"? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MOM_OCC (SCF); SCF — The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START (SCF); SCF — The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR (SCF); SCF — The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. MP2_AMP_TYPE (DFOCC); DFOCC — The algorithm that used to handle mp2 amplitudes. The DIRECT option means compute amplitudes on the fly whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_AMPS_PRINT (CCENERGY); CCENERGY — Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. MP2_CCSD_METHOD (PSIMRCC); PSIMRCC — How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS (PSIMRCC); PSIMRCC — Do start from a MP2 guess?. Type: boolean; Default: true. MP2_OS_SCALE (CCENERGY); CCENERGY — MP2 opposite-spin scaling value. Type: double; Default: 1.20. MP2_OS_SCALE (DFMP2); DFMP2 — OS Scale. Type: double; Default: 6.0/5.0. MP2_OS_SCALE (DFOCC); DFOCC — MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_OS_SCALE (OCC); OCC — MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SCALE_OS (FNOCC); FNOCC — Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. MP2_SCALE_SS (FNOCC); FNOCC — Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0/3.0. MP2_SOS_SCALE (DFOCC); DFOCC — MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE (OCC); OCC — MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2 (DFOCC); DFOCC — Spin-opposite scaling (SOS) value for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:163269,perform,perform,163269,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['perform'],['perform']
Performance,"?. Type: boolean; Default: false. SEMICANONICAL¶. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. T2_COUPLED¶. Type: boolean; Default: false. T3_WS_INCORE¶. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Expert¶. AO_BASIS¶. The algorithm to use for the \(\left\langle VV||VV\right\rangle\) terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. FORCE_RESTART¶. Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: NONE. table of contents. CCENERGY; General; ABCD; ANALYZE; BCCD_MAXITER; BRUECKNER_ORBS_R_CONVERGENCE; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC_OS_SCALE; CC_SS_SCALE; DIIS; E_CONVERGENCE; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; MP2_AMPS_PRINT; MP2_OS_SCALE; MP2_SS_SCALE; NEW_TRIPLES; NUM_AMPS_PRINT; PAIR_ENERGIES_PRINT; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SCSN_MP2; SCS_CCSD; SCS_MP2; SEMICANONICAL; T2_COUPLED; T3_WS_INCORE. Expert; AO_BASIS; FORCE_RESTART; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__ccenergy.html:6685,CACHE,CACHELEVEL,6685,psi4manual/master/autodir_options_c/module__ccenergy.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__ccenergy.html,2,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"?. Type: boolean; Default: true. OPT_COORDINATES (OPTKING)¶OPTKING — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_METHOD (DFOCC)¶DFOCC — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC)¶OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. OPT_TYPE (OPTKING)¶OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC)¶DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC)¶OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (DFOCC)¶DFOCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORB_RESP_SOLVER (OCC)¶OCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:182838,perform,performed,182838,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['perform'],['performed']
Performance,"A (CCRESPONSE). (CCSORT). (RESPONSE). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (DETCI). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (DFMP2). opt(); . see optimize(); . OPT_METHOD (OCC). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in optproc. OptionState class in optproc. optproc module. ORB_OPT (OCC). ORB_RESP_SOLVER (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OCEPA. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OCC). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_multiline_array() in module input. PATH, [1], [2], [3], [4]. PB_LAMBDA (DFTSAPT). PCG_BETA_TYPE (OCC). PCG_CONVERGENCE (OCC). PCG_MAXITER (OCC). PEP1. perp_unit() in module qcdb.vecutil. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). PHI_POINTS (SCF). physconst module. physical constants. PITZER (TRANSQT). point_group() LibmintsMolecule method. POINTS (FINDIF). POLE_MAXITER (ADC). populateExtern() Diffuse method. QMMM method. PR (ADC). PRECONDITIONER (DETCI). prerequisites. PRESORT_FILE (TRANSQT). PRINT (CPHF). (DFTSAPT). (GLOBALS). (SAPT)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:31591,Optimiz,Optimized,31591,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['Optimiz'],['Optimized']
Performance,"A Exchange-Correlation Functional. x3lyp-d3bj2b. x3lyp-d3bjatm. x3lyp-d3zero2b. x3lyp-d3zeroatm. xb1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj2b. xlyp-d3bjatm. xlyp-d3zero2b. xlyp-d3zeroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/opt.html:17081,optimiz,optimization,17081,psi4manual/master/opt.html,https://psicode.org,https://psicode.org/psi4manual/master/opt.html,24,['optimiz'],"['optimization', 'optimize']"
Performance,"A and netlify now, not Conda.; Package psi4-rt used to be in “Psi4 stack”, but a maximum ecosystem package isn’t provided now, only a customizable env spec.; Package psi4-dev used to be in “Psi4 stack”, but now build environment and guidance is in-repo with psi4-path-advisor.py.; Other packages in the “ecosystem stack” (e.g., libint, gdma) should already be updated and; built on conda-forge. Survey them to check version tick PRs have been merged.; Conda-forge overwhelmingly handles the psi4 package itself, with a full architecture and Python; version matrix. What remains are specialty or development builds for the psi4 channel. High AM and multiarch psi4 builds for Linux. Especially at tagged releases, update and reconcile c-f psi4/feedstock recipe with psinet; psi4meta/conda-recipes/psi4-cf recipe. Differences include:. restricted to only even python versions; c-f libint vs. psi4 libint2 packages (latter with high AM); smoke vs. full tests; no git rev-parse lines; load Intel compilers and specify them in compilers and flags CMake arguments. Prepare recipe, make sure psi4-cf is the only target uncommented in kitandkapoodle.py, set; crontab, view in kpd-anom.log.; Files will upload to psi4/label/dev. For releases and postreleases, on the anaconda.org site; (logged in as psi4), add, not replace, main label, so accessible from psi4/label/main. Build Psi4conda set¶; Installers are build using the project constructor to build binary bash or exe scripts, one per; OS per Python version. For example, there’s 16 installers when OSes are linux-64, win-64, osx-64,; osx-arm64 and pythons are 38, 39, 310, 311. In analogy to Miniconda, they’re called Psi4Conda. They; are built through GHA on the https://github.com/psi4/psi4meta repository and get served from vergil; (the cdsgroup webserver). If the previous release hasn’t had a snapshot saved, copy construct.yaml into a version-labeled; file and check it in.; Edit recipe https://github.com/psi4/psi4meta/blob/master/installers/con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/manage_release.html:13841,load,load,13841,psi4manual/master/manage_release.html,https://psicode.org,https://psicode.org/psi4manual/master/manage_release.html,2,['load'],['load']
Performance,"A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 0.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the default basis, otherwise the specified basis is used. Type: string; Possible Values: basis string; Default: FALSE. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Will be removed in v1.7. Type: integer; Default: 2. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. DIIS_START¶. The minimum iteration to start storing DIIS vectors and performing ADIIS/EDIIS. Type: integer; Default: 1. DO_LINK¶. Perform the linear scaling exchange (LinK) algorithm, as described in [Ochsenfeld:1998:1663]. Only applies to Direct SCF. Type: boolean; Default: false. D_CONVERGENCE¶. Convergence criterion for SCF density, defined as the RMS or maximum absolute value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. INCFOCK¶. Do perform incremental Fock build?. Type: boolean; Default: false. INCFOCK_CONVERGENCE¶. The density threshold at which to stop building the Fock matrix ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html:5274,perform,performing,5274,psi4manual/1.6.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html,1,['perform'],['performing']
Performance,"A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 0.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the default basis, otherwise the specified basis is used. Type: string; Possible Values: basis string; Default: FALSE. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Will be removed in v1.7. Type: integer; Default: 2. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. DIIS_START¶. The minimum iteration to start storing DIIS vectors and performing ADIIS/EDIIS. Type: integer; Default: 1. D_CONVERGENCE¶. Convergence criterion for SCF density, defined as the RMS or maximum absolute value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. INCFOCK¶. Do perform incremental Fock build?. Type: boolean; Default: false. INCFOCK_CONVERGENCE¶. The density threshold at which to stop building the Fock matrix incrementally. Type: conv double; Default: 1.0e-5. INCFOCK_FULL_FOCK_EVERY¶. Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html:5274,perform,performing,5274,psi4manual/1.7.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html,4,['perform'],['performing']
Performance,"A'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'). # if the df_basis_mp2 basis is not set, pick a sensible one.; if PsiMod.get_global_option('DF_BASIS_MP2') == '':; ribasis = corresponding_rifit(PsiMod.get_global_option('BASIS')); if ribasis:; PsiMod.set_global_option('DF_BASIS_MP2', ribasis); PsiMod.print_out('No DF_BASIS_MP2 auxiliary basis selected, defaulting to %s\n' % (ribasis)); else:; raise ValidationError('Keyword DF_BASIS_MP2 is required.'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Dimer DFMP2'); PsiMod.print_out('\n'); e_dimer_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer A DFMP2'); PsiMod.print_out('\n'); e_monomerA_mp2 = PsiMod.dfmp2(). activate(monomerB); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.print_out('\n'); banner('Monomer B DFMP2'); PsiMod.print_out('\n'); e_monomerB_mp2 = PsiMod.dfmp2(); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:30917,LOAD,LOAD,30917,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['LOAD'],['LOAD']
Performance,"ACTION¶. Specifies the contraction scheme used by the integral and integral derivative program. SEGMENTED (=0) uses a segmented contraction scheme; GENERAL (=1) uses a general contraction scheme, and UNCONTRACTED (=2) uses the corresponding uncontracted sets. Note that even for truly segmented basis sets, the integral programs run significantly faster in the GENERAL mode. Type: string; Possible Values: SEGMENTED, GENERAL, UNCONTRACTED; Default: GENERAL. CFOUR_CONVERGENCE¶. Identical to CFOUR_GEO_CONV. Type: integer; Default: 4. CFOUR_COORDINATES¶. Specifies the type of coordinates used in the input file ZMAT. Value INTERNAL (=0) means that the geometry is supplied in the usual Z-matrix format, while CARTESIAN (=1) means that the geometry is given in Cartesian coordinates. A third option is XYZINT (=2) for which a Z-matrix connectivity is defined, but with values of the internal coordinates defined implicitly by supplying Cartesian coordinates. Note that geometry optimizations are currently only possible for INTERNAL and XYZ2INT. Psi4 Interface: Keyword set from active molecule, always CARTESIAN. Above restrictions on geometry optimizations no longer apply. Type: string; Possible Values: INTERNAL, CARTESIAN, XYZINT; Default: INTERNAL. CFOUR_CORE_ORBITALS¶. Specifies the core orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_ACTIVE_ORBI The core orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of core orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION. Type: array; Default: No Default. CFOUR_CPHF_CONVER¶. Specifies the convergence criterion for the iterative solution of the CPHF and Z-vector equations. The solutions are considered to be converged when the residual norm of the error vecto",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:12627,optimiz,optimizations,12627,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,17,['optimiz'],['optimizations']
Performance,"AGNETIZABILITY, ROA, ALL; Default: POLARIZABILITY. PROPERTY (CCRESPONSE); CCRESPONSE — The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ALL; Default: POLARIZABILITY. PROPERTY (CCSORT); CCSORT —. Type: string; Default: POLARIZABILITY. PROPERTY (RESPONSE); RESPONSE — Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ALL; Default: POLARIZABILITY. PSIMRCC (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. PT_ENERGY (PSIMRCC); PSIMRCC — The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. PUREAM (GLOBALS); GLOBALS — Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Type: boolean; Default: true. QRHF (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. R4S (DETCI); DETCI (Expert) — Do restrict strings with in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the res",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:76073,perform,perform,76073,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"AL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2). MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT ENERGY. SAPT ENERGY¶; The total electronic interaction energy [H] for the reques",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html:13530,optimiz,optimized,13530,psi4manual/4.0b4/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html,4,['optimiz'],['optimized']
Performance,"AL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2). MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Möller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). (3). OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction energy [H] fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html:13782,optimiz,optimized,13782,psi4manual/1.0.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/glossary_psivariables-1.html,2,['optimiz'],['optimized']
Performance,"ALENERGY. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRONENERGY. one_electron_integrals() psi4.core.MintsHelper method, [1], [2]. OneBodyAOInt class in psi4.core, [1]. onel_Hx() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. option_exists_in_module() in module psi4.core, [1]. Options class in psi4.core, [1]. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orbital_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. OrbitalSpace class in psi4.core, [1]. order() psi4.core.CharacterTable method, [1], [2]. psi4.core.PointGroup method, [1], [2]. ordered_params psi4.driver.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. orientation_fixed() psi4.core.Molecule method, [1], [2]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:102301,optimiz,optimize,102301,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['optimiz'],['optimize']
Performance,"ALS¶. Do print one-electron integrals?. Type: boolean; Default: false. PRINT_REORDER¶. Do print reordered MOs?. Type: boolean; Default: false. PRINT_SORTED_OE_INTS¶. Do print sorted one-electron integrals?. Type: boolean; Default: false. PRINT_SORTED_TE_INTS¶. Do print sorted two-electron integrals (TEIs)?. Type: boolean; Default: false. PRINT_TE_INTEGRALS¶. Do print two-electron integrals?. Type: boolean; Default: false. PSIMRCC¶. Do specific arrangements for PSIMRCC?. Type: boolean; Default: false. QRHF¶. Do form quasi RHF (QRHF) orbitals?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. REORDER¶. Do reorder MOs?. Type: boolean; Default: false. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SORTED_TEI_FILE¶. MO-basis sorted two-electron integrals file. Type: integer; Default: PSIF_MO_TEI. SO_S_FILE¶. SO basis overlap matrix file. Type: integer; Default: PSIF_OEI. SO_TEI_FILE¶. SO basis two-electron integrals file. Type: integer; Default: PSIF_SO_TEI. SO_T_FILE¶. SO basis kinetic energy matrix file. Type: integer; Default: PSIF_OEI. SO_V_FILE¶. SO basis potential energy matrix file. Type: integer; Default: PSIF_OEI. TPDM_ADD_REF¶. Do add reference contribution to TPDM?. Type: boolean; Default: false. TPDM_FILE¶. MO-basis two-particle density matrix file. Type: integer; Default: PSIF_MO_TPDM. Expert¶. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__transqt-1.html:4474,optimiz,optimized,4474,psi4manual/4.0b3/autodir_options_c/module__transqt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__transqt-1.html,6,['optimiz'],['optimized']
Performance,AL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; MP2_AMPS_PRINT; MP2_OS_SCALE; MP2_SS_SCALE; NEW_TRIPLES; NUM_AMPS_PRINT; PAIR_ENERGIES_PRINT; PROPERTY; R_CONVERGENCE; REFERENCE; RESTART; SCS_CCSD; SCS_MP2; SCSN_MP2; SEMICANONICAL; T2_COUPLED; T3_WS_INCORE; WFN; ABCD; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC3_FOLLOW_ROOT; COLLAPSE_WITH_LAST; COLLAPSE_WITH_LAST_CC3; COMPLEX_TOLERANCE; E_CONVERGENCE; EOM_GUESS; EOM_REFERENCE; EXCITATION_RANGE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; R_CONVERGENCE; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT; WFN; CACHELEVEL; EOM_REFERENCE; T_AMPS; WABEI_LOWDISK; WFN; ABCD; AO_BASIS; CACHELEVEL; DIIS; JOBTYPE; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; R_CONVERGENCE; RESTART; ROOTS_PER_IRREP; SEKINO; WFN; ZETA; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; R_CONVERGENCE; REFERENCE; RESTART; SEKINO; WFN; AO_BASIS; CACHELEVEL; DELETE_TEI; REFERENCE; RUN_CCTRANSORT; SEMICANONICAL; WFN; CC_NUM_THREADS; REFERENCE; SEMICANONICAL; WFN; CFOUR_ABCDTYPE; CFOUR_ACTIVE_ORBI; CFOUR_ANH_ALGORITHM; CFOUR_ANH_DERIVATIVES; CFOUR_ANH_STEPSIZE; CFOUR_ANH_SYMMETRY; CFOUR_ANHARMONIC; CFOUR_AO_LADDERS; CFOUR_AV_SCF; CFOUR_BASIS; CFOUR_BRUCK_CONV; CFOUR_BRUECKNER; CFOUR_CACHE_RECS; CFOUR_CALC_LEVEL; CFOUR_CC_CONV; CFOUR_CC_EXPORDER; CFOUR_CC_EXTRAPOLATION; CFOUR_CC_MAXCYC; CFOUR_CC_PROGRAM; CFOUR_CHARGE; CFOUR_CIS_CONV; CFOUR_CONTINU,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:766375,CACHE,CACHELEVEL,766375,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,7,['CACHE'],['CACHELEVEL']
Performance,AL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; MP2_AMPS_PRINT; MP2_OS_SCALE; MP2_SS_SCALE; NEW_TRIPLES; NUM_AMPS_PRINT; PAIR_ENERGIES_PRINT; PROPERTY; R_CONVERGENCE; REFERENCE; RESTART; SCS_CCSD; SCS_MP2; SCSN_MP2; SEMICANONICAL; SPINADAPT_ENERGIES; T2_COUPLED; T3_WS_INCORE; WFN; ABCD; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC3_FOLLOW_ROOT; COLLAPSE_WITH_LAST; COLLAPSE_WITH_LAST_CC3; COMPLEX_TOLERANCE; E_CONVERGENCE; EOM_GUESS; EOM_REFERENCE; EXCITATION_RANGE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_GHOST; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; R_CONVERGENCE; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT; WFN; CACHELEVEL; EOM_REFERENCE; T_AMPS; WABEI_LOWDISK; WFN; ABCD; AO_BASIS; CACHELEVEL; DIIS; JOBTYPE; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; R_CONVERGENCE; RESTART; ROOTS_PER_IRREP; SEKINO; WFN; ZETA; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; R_CONVERGENCE; REFERENCE; RESTART; SEKINO; WFN; AO_BASIS; CACHELEVEL; DELETE_TEI; REFERENCE; RUN_CCTRANSORT; SEMICANONICAL; WFN; CC_NUM_THREADS; REFERENCE; SEMICANONICAL; WFN; CFOUR_ABCDTYPE; CFOUR_ACTIVE_ORBI; CFOUR_ANH_ALGORITHM; CFOUR_ANH_DERIVATIVES; CFOUR_ANH_STEPSIZE; CFOUR_ANH_SYMMETRY; CFOUR_ANHARMONIC; CFOUR_AO_LADDERS; CFOUR_AV_SCF; CFOUR_BASIS; CFOUR_BRUCK_CONV; CFOUR_BRUECKNER; CFOUR_CACHE_RECS; CFOUR_CALC_LEVEL; CFOUR_CC_CONV; CFOUR_CC_EXPORDER; CFOUR_CC_EXTRAPOLATION; CFOUR_CC_MAXCYC; CFOUR_CC_PROGRAM; CFOUR_CHARGE; CFOUR_CIS_CONV; CFOUR_CONTINU,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:555284,CACHE,CACHELEVEL,555284,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,8,['CACHE'],['CACHELEVEL']
Performance,"AMBDA — Do restart the coupled-cluster iterations from old and amplitudes?. Type: boolean; Default: false. RESTART (CCRESPONSE); CCRESPONSE — Do restart from on-disk amplitudes?. Type: boolean; Default: true. RESTART (DETCI); DETCI — Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk; the number of vectors specified by RESTART_VECS (obsolete) is collapsed down to one vector per root. Type: boolean; Default: false. RESTART_EOM_CC3 (CCEOM); CCEOM — Do restart from on-disk?. Type: boolean; Default: false. RESTRICTED_DOCC (DETCI); DETCI — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_DOCC (PSIMRCC); PSIMRCC — The number of doubly occupied orbitals per irrep. Type: array; Default: No Default. RESTRICTED_DOCC (TRANSQT); TRANSQT — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (DETCI); DETCI — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (TRANSQT); TRANSQT — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RFO_FOLLOW_ROOT (OPTKING); OPTKING — Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_ROOT (OPTKING); OPTKING — Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RHF_TRIPLETS (CCEOM); CCEOM — Do form a triplet state from RHF reference?. Type: boolean; Default: false. RMS_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: rms ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:110863,optimiz,optimized,110863,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimized']
Performance,"ANSQT — Do transform all TEIs. Type: boolean; Default: false. DO_LEVEL_SHIFT (OMP2); OMP2 — Do apply level shifting?. Type: boolean; Default: false. DO_LEVEL_SHIFT (OMP3); OMP3 — Do apply level shifting to aid convergence. Type: boolean; Default: false. DO_SCS (OMP2); OMP2 — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OMP3); OMP3 — Do perform spin-component-scaled OMP3 (SCS-OMP3)? In all computation, SCS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP3, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (OMP2); OMP2 — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OMP3); OMP3 — Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SOS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CIS); CIS — ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:34160,perform,perform,34160,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. cc12; Single point energies of multiple excited states with EOM-CCSD. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. mp2-1; All-electron MP2 6-31G** geometry optimization of water. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. opt-freeze-coords; SCF/cc-pVDZ optimization exampl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:32136,optimiz,optimization,32136,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"APT(DFT), compute the non-approximated second-order exchange-dispersion term. Type: boolean; Default: false. DO_IND30_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT2+3, compute the non-approximated third-order exchange-induction term. Type: boolean; Default: false. DO_IND_EXCH_SINF (SAPT)¶SAPT (Expert) — For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-induction term. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC)¶DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_LINK (SCF)¶SCF — Perform the linear scaling exchange (LinK) algorithm, as described in [Ochsenfeld:1998:1663]. Only applies to Direct SCF. Type: boolean; Default: false. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:116766,perform,perform,116766,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['perform'],['perform']
Performance,"ART_HESS_READ', True); elif ((full_hess_every == -1) and (PsiMod.get_global_option('CART_HESS_READ')) and (n == 1)):; pass; # Do nothing; user said to read existing hessian once; else:; PsiMod.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # print 'cart_hess_read', PsiMod.get_global_option('CART_HESS_READ'); # Take step; if PsiMod.optking() == PsiMod.PsiReturnType.EndLoop:; print('Optimizer: Optimization complete!'); PsiMod.print_out('\n Final optimized geometry and variables:\n'); PsiMod.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (PsiMod.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False):; PsiMod.opt_clean(); PsiMod.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(). optstash.restore(); return thisenergy; PsiMod.print_out('\n Structure for next step:\n'); PsiMod.get_active_molecule().print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = get_psifile(1); kwargs['mode'] = 'sow'. n += 1. PsiMod.print_out('\tOptimizer: Did not converge!'). optstash.restore(); return 0.0. ## Aliases ##; opt = optimize. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """"""; namelower = name.lower(). # matches 'mrccsdt(q)'; if namelower.startswith('mrcc'):; # grabs 'sdt(q)'; ccfullname = namelower[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method' : 1, 'order' : 2, 'fullname' : 'CCSD' },; 'sdt' : { 'method' : 1, 'order' : 3, 'fullname' : 'CCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:53837,Optimiz,Optimization,53837,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Optimiz'],['Optimization']
Performance,"AS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {…} block and basis is set through; PSI4‘s BASIS keyword. In that case, a GENBAS is written from; LibMints and all is well. Otherwise, a GENBAS is looked for in; the usual places: PSIPATH, PATH, PSIDATADIR/basis. If path kwarg is; specified, also looks there preferentially for a GENBAS. Can; also specify GENBAS within an input file through a string and; setting the genbas kwarg. Note that due to the input parser’s; aggression, blank lines need to be replaced by the text blankline. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into PSI4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; cbs() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/cfour.html:25830,optimiz,optimize,25830,psi4manual/master/cfour.html,https://psicode.org,https://psicode.org/psi4manual/master/cfour.html,4,['optimiz'],['optimize']
Performance,"AS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {…} block and basis is set through; PSI4‘s BASIS keyword. In that case, a GENBAS is written from; LibMints and all is well. Otherwise, a GENBAS is looked for in; the usual places: PSIPATH, PATH, PSIDATADIR/basis. If path kwarg is; specified, also looks there preferentially for a GENBAS. Can; also specify GENBAS within an input file through a string and; setting the genbas kwarg. Note that due to the input parser’s; aggression, blank lines need to be replaced by the text blankline. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into PSI4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; cbs() for computation of compound methods involving; basis set extrapolations and/or delta corrections wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:25698,optimiz,optimize,25698,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,5,['optimiz'],['optimize']
Performance,"AU). Type: string; Possible Values: AU, AA; Default: AU. BORDER_TYPE (PE)¶PE — border type, either remove or redistribute moments/polarizabilities. Type: string; Possible Values: REMOVE, REDIST; Default: REMOVE. BRIANQC_ENABLE (GLOBALS)¶GLOBALS — Whether to enable using the BrianQC GPU module. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC)¶FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (CCDENSITY)¶CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY)¶CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM)¶CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR)¶CCHBAR — Caching level for libdpd governing the storage of amplitudes, inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:8142,cache,cache,8142,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,8,['cache'],['cache']
Performance,"AULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE¶. When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, PRINCIPAL_AXES; Default: FIXED. Misc.¶. OPT_RESTART¶. Restart the optimization from optking’s written history. Type: double; Default: 0. PRINT_TRAJECTORY_XYZ_FILE¶. Should an xyz trajectory file be kept (useful for visualization)?. Type: boolean; Default: false. SAVE_OPTIMIZATION¶. Save OptKing’s internal classes for possible restart upon error. Type: boolean; Default: false. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. WRITE_OPT_HISTORY¶. Write the full history to disk. Produces a non validated OptimizationResult. Type: boolean; Default: false. WRITE_OPT_RESULT¶. Write the optimization history / state to disc. Type: boolean; Default: false. WRITE_TRAJECTORY¶. Write Optimization Trajectory. Type: boolean; Default: false. table of contents. OPTKING; Optimization Algorithm; CARTESIAN_SYM_TOLERANCE; CONSECUTIVE_BACKSTEPS; CUSTOM_COORDS; DYNAMIC_LEVEL; ENSURE_BT_CONVERGENCE; EXT_FORCE_BEND; EXT_FORCE_CARTESIAN; EXT_FORCE_DIHEDRAL; EXT_FORCE_DISTANCE; EXT_FORCE_OOFP; FREEZE_ALL_DIHEDRALS; FROZEN_BEND; FROZEN_CARTESIAN; FROZEN_DIHEDRAL; FROZEN_DISTANCE; FROZEN_OOFP; GEOM_MAXITER; H_UPDATE_DEN_TOL; INTERFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT_MAX; INTRAFRAG_STEP_LIMIT_MIN; IRC_DIRECTION; IRC_POINTS; IRC_STEP_SIZE; OPT_COORDINATES; OPT_TYPE; PRINT_OPT_PARAMS; RANGED_BEND; RANGED_DIHEDRAL; RANGED_DISTANCE; RANGED_OOFP; RFO_FOLLOW_ROOT; RFO_NORMALIZATION_MAX; RFO_ROOT; RSRFO_ALPHA_MAX; STEP_TYPE; UNFREEZE_DIHEDRALS. Convergence Control; FLEXIBLE_G_CONVERGENCE; G_CONVERGENCE; MAX_DISP_G_CONVERGENCE; MAX_ENERGY_G_CONVERGENCE; MAX_FORCE_G_CONVERGENCE; RMS_DISP_G_CONVERGENCE; RMS_FORCE_G_CONVERGENCE. Hessian Update; CART_HESS_READ; FULL_HESS_EVERY; H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html:11203,Optimiz,Optimization,11203,psi4manual/master/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html,1,['Optimiz'],['Optimization']
Performance,"AULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE¶. When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, PRINCIPAL_AXES; Default: FIXED. Misc.¶. OPT_RESTART¶. Restart the optimization from optking’s written history. Type: double; Default: 0. PRINT_TRAJECTORY_XYZ_FILE¶. Should an xyz trajectory file be kept (useful for visualization)?. Type: boolean; Default: false. SAVE_OPTIMIZATION¶. Save OptKing’s internal classes for possible restart upon error. Type: boolean; Default: false. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. WRITE_OPT_HISTORY¶. Write the full history to disk. Produces a non validated OptimizationResult. Type: boolean; Default: false. WRITE_OPT_RESULT¶. Write the optimization history / state to disc. Type: boolean; Default: false. WRITE_TRAJECTORY¶. Write Optimization Trajectory. Type: boolean; Default: false. table of contents. OPTKING; Optimization Algorithm; CARTESIAN_SYM_TOLERANCE; CONSECUTIVE_BACKSTEPS; DYNAMIC_LEVEL; ENSURE_BT_CONVERGENCE; EXT_FORCE_BEND; EXT_FORCE_CARTESIAN; EXT_FORCE_DIHEDRAL; EXT_FORCE_DISTANCE; EXT_FORCE_OOFP; FROZEN_BEND; FROZEN_CARTESIAN; FROZEN_DIHEDRAL; FROZEN_DISTANCE; FROZEN_OOFP; GEOM_MAXITER; H_UPDATE_DEN_TOL; INTERFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT_MAX; INTRAFRAG_STEP_LIMIT_MIN; IRC_DIRECTION; IRC_POINTS; IRC_STEP_SIZE; OPT_COORDINATES; OPT_TYPE; PRINT_OPT_PARAMS; RANGED_BEND; RANGED_DIHEDRAL; RANGED_DISTANCE; RANGED_OOFP; RFO_FOLLOW_ROOT; RFO_NORMALIZATION_MAX; RFO_ROOT; RSRFO_ALPHA_MAX; STEP_TYPE. Convergence Control; FLEXIBLE_G_CONVERGENCE; G_CONVERGENCE; MAX_DISP_G_CONVERGENCE; MAX_ENERGY_G_CONVERGENCE; MAX_FORCE_G_CONVERGENCE; RMS_DISP_G_CONVERGENCE; RMS_FORCE_G_CONVERGENCE. Hessian Update; CART_HESS_READ; FULL_HESS_EVERY; HESS_UPDATE; HESS_UPDATE_LIMIT; HESS_UPDATE_LIMIT_MAX; HES",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__optking.html:10680,Optimiz,Optimization,10680,psi4manual/1.7.x/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__optking.html,3,['Optimiz'],['Optimization']
Performance,"AU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition St",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:4749,Optimiz,Optimize,4749,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,10,['Optimiz'],['Optimize']
Performance,"AXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html:6485,perform,perform,6485,psi4manual/1.1.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html,4,['perform'],['perform']
Performance,"Algorithms; section and usually exhibit the similar efficiency. The choice of the algorithm can; be made using the RESPONSE_ALGORITHM option. For the DC-12 method the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computations of small systems (less than 150 basis; functions and high symmetry) the use of the default parameters is recommended,; including the choice of the two-step algorithm.; For large systems (more than 150 basis functions) the simultaneous algorithm; is preferred and can be significantly faster than two-step, as the result of; smaller number of the expensive steps. In addition,; significant savings can be achieved if one sets AO_BASIS option to; DISK together with simulta",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:10639,perform,perform,10639,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,8,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,B; SOGGA11-X Hybrid Exchange-Correlation Functional; Y; —; —; 0.401500; —; —; —; Y. SOGGA11-X-D3ZEROATM; SOGGA11-X Hybrid Exchange-Correlation Functional; Y; —; —; 0.401500; —; —; —; Y. T-HCTHH; Hybrid Tau HCTH Meta-GGA XC Functional; Y; Y; —; 0.150000; —; —; —; —; —. TPSSH; TPSSh Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TPSSH-D3BJ2B; TPSSh-d3bj2b Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y. TPSSH-D3BJATM; TPSSh-d3bjatm Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y. TPSSH-D3OPATM; TPSSh-d3opatm Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y. TPSSH-D3ZERO2B; TPSSh-d3zero2b Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y. TPSSH-D3ZEROATM; TPSSh-d3zeroatm Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; Y. TPSSH-NL; TPSSh-nl Hyb-GGA Exchange-Correlation Functional; Y; Y; —; 0.100000; —; —; —; —; —. TUNED-CAM-B3LYP; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; 0.150000; 0.079900; —; —; —; —; —. WB97M-D3BJ; wB97M-V with D3(BJ) instead of VV10 dispersion; Y; Y; 0.300000; 0.150000; —; —; —; Y. WB97M-V; wB97M-V Hyb-GGA Exchange-Correlation Functional; Y; Y; 0.300000; 0.150000; —; —; —; —; —. WB97X; wB97X Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; —; —. WB97X-D; wB97X-D Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.222036; —; —; —; Y. WB97X-D3; wB97X-D3 Hyb-GGA Exchange-Correlation Functional; Y; —; 0.250000; 0.195728; —; —; —; Y. WB97X-D3BJ; wB97X-V with D3(BJ) instead of VV10 dispersion; Y; —; 0.300000; 0.167000; —; —; —; Y. WB97X-D3BJATM; wB97X-d3bjatm Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; Y. WB97X-D3ZERO2B; wB97X-d3zero2b Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; Y. WB97X-D3ZEROATM; wB97X-d3zeroatm Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; Y. WB97X-V; wB9,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_dft_hybrid.html:28765,TUNE,TUNED-CAM-,28765,psi4manual/1.8.x/autodoc_dft_hybrid.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_dft_hybrid.html,4,['TUNE'],['TUNED-CAM-']
Performance,"BCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BCCD_MAXITER¶. Maximum number of iterations for Brueckner CCD. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__ccenergy-1.html:1241,CACHE,CACHETYPE,1241,psi4manual/1.4.0/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__ccenergy-1.html,9,['CACHE'],['CACHETYPE']
Performance,"BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta3] » ; Module code ». © Copyright 2012, The Psi4 Project.; Last updated on Apr 05, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html:7206,Queue,Queue,7206,psi4manual/4.0b3/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/qcdb/molecule.html,8,"['Queue', 'queue']","['Queue', 'queue']"
Performance,"BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    ; PSI4 [beta4] » ; Module code ». © Copyright 2013, The Psi4 Project.; Last updated on Mar 20, 2014.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html:7206,Queue,Queue,7206,psi4manual/4.0b4/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/qcdb/molecule.html,8,"['Queue', 'queue']","['Queue', 'queue']"
Performance,"BI. SOLVER_PRECONDITION_MAXITER (CPHF); CPHF — Solver precondition max steps. Type: integer; Default: 1. SOLVER_PRECONDITION_STEPS (CPHF); CPHF — Solver precondition step type. Type: string; Possible Values: CONSTANT, TRIANGULAR; Default: TRIANGULAR. SOLVER_QUANTITY (CPHF); CPHF — Solver residue or eigenvector delta. Type: string; Possible Values: EIGENVECTOR, RESIDUAL; Default: RESIDUAL. SOLVER_TYPE (CPHF); CPHF — Solver type (for interchangeable solvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SOS_TYPE (DFOCC); DFOCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OCC); OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF); SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF); SCF — Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF); SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF); SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF); SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF); SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:211410,perform,perform,211410,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,BIS VALENCE WIDTHS. MBIS VOLUME RATIOS. MBIS_D_CONVERGENCE (GLOBALS). MBIS_MAXITER (GLOBALS). MBIS_PRUNING_SCHEME (GLOBALS). MBIS_RADIAL_POINTS (GLOBALS). MBIS_SPHERICAL_POINTS (GLOBALS). MCSCF. theory. MCSCF TOTAL ENERGY. mcscf() (in module psi4.core). MCSCF_ALGORITHM (DETCI). MCSCF_CI_CLEANUP (DETCI). MCSCF_DIIS_ERROR_TYPE (DETCI). MCSCF_DIIS_FREQ (DETCI). MCSCF_DIIS_MAX_VECS (DETCI). MCSCF_DIIS_START (DETCI). MCSCF_DPD_CLEANUP (DETCI). MCSCF_E_CONVERGENCE (DETCI). MCSCF_GUESS (DETCI). MCSCF_MAX_ROT (DETCI). MCSCF_MAXITER (DETCI). mcscf_object() (psi4.core.CIWavefunction method). MCSCF_R_CONVERGENCE (DETCI). MCSCF_ROTATE (DETCI). MCSCF_SO_START_E (DETCI). MCSCF_SO_START_GRAD (DETCI). MCSCF_TYPE (DETCI). mdi_run() (in module psi4.driver). MemDFJK (class in psi4.core). memory. memory_estimate() (psi4.core.JK method). message (psi4.driver.ConvergenceError attribute). (psi4.driver.ManagedMethodError attribute). (psi4.driver.MissingMethodError attribute). (psi4.driver.OptimizationConvergenceError attribute). (psi4.driver.SCFConvergenceError attribute). (psi4.driver.TDSCFConvergenceError attribute). (psi4.driver.TestComparisonError attribute). (psi4.driver.ValidationError attribute). message_box() (in module psi4.driver). (in module psi4.driver.p4util). meta_cutoff() (psi4.core.Functional method). metadata (psi4.driver.driver_cbs.CompositeComputer attribute). metameta (psi4.driver.driver_cbs.CompositeComputer attribute). (psi4.driver.driver_findif.FiniteDifferenceComputer attribute). method (psi4.driver.AtomicComputer attribute). (psi4.driver.driver_cbs.CompositeComputer attribute). (psi4.driver.driver_findif.FiniteDifferenceComputer attribute). (psi4.driver.driver_nbody.ManyBodyComputer attribute). method alias. ; adding new. metric() (psi4.core.FDDS_Dispersion method). metric_inv() (psi4.core.FDDS_Dispersion method). MIN_CCD_DIISVECS (SAPT). MINAO_BASIS (FISAPT). MintsHelper (class in psi4.core). mintshelper() (psi4.core.CUHF method). (psi4.core.RHF method). (psi4.cor,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:75609,Optimiz,OptimizationConvergenceError,75609,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['Optimiz'],['OptimizationConvergenceError']
Performance,"BRIANQC_INSTALL_PATH environment variable; must be set to the full path of your BrianQC installation.; There are two ways to enable BrianQC for a specific calculation:. setting the BRIANQC_ENABLE input option to True;; setting the BRIANQC_ENABLE environment variable to 1. If both the input option and the environment variable are specified,; then the environment variable takes precedence. When to enable BrianQC¶; The operation of BrianQC is transparent from a user’s point of view; every; internal computation is either performed by PSI4 (if unsupported by BrianQC),; or taken over by BrianQC, yielding the same result to within the required; precision. In particular, BrianQC will respect all of PSI4’s usual precision; parameters, like INTS_TOLERANCE and E_CONVERGENCE.; BrianQC can speed up a number of internal computations, including Fock and; gradient computation. Thus, BrianQC will speed up any calculation involving; those terms, such as. HF and DFT single point energies; HF and DFT geometry optimizations; HF and DFT frequency analysis. Note that not every term of every calculation can be handled by BrianQC, thus,; the actual speedup depends on the specifics of the calculation. Necessary and recommended option values¶; To ensure that a calculation works with BrianQC, the following options need to; be set when enabling BrianQC:. BrianQC currently only handles the C1 molecular symmetry point group. Thus, if; the molecule has any symmetries (which PSI4 would detect by default), the; input geometry must contain the line symmetry c1 to force PSI4 to; disregard the symmetry. To achieve peak performance, the following settings are recommended when enabling; BrianQC:. By default, PSI4 uses density-fitted preiterations for SCF, which BrianQC; doesn’t handle yet. To ensure that no non-BrianQC-accelerated iterations are; performed, disable the preiterations by setting DF_SCF_GUESS to False.; By default, PSI4 uses a disk-based Fock building, but BrianQC currently only; accelerate",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/brianqc.html:3128,optimiz,optimizations,3128,psi4manual/master/brianqc.html,https://psicode.org,https://psicode.org/psi4manual/master/brianqc.html,9,['optimiz'],['optimizations']
Performance,"BSSE Treatment: %s\n' % (bsse)); PsiMod.print_out(' Maximum N-Body Interactions: %d\n' % (max_n_body)); PsiMod.print_out(' Compute Total Energy: %s\n' % (do_total)); PsiMod.print_out(' External Field: %s\n' % (has_external)); if (external):; PsiMod.print_out(' External Field Monomers: '); for k in external_indices:; PsiMod.print_out('%-3d ' % (k)); PsiMod.print_out('\n'); PsiMod.print_out('\n'). # Run the total molecule, if required; energies_full = {}; energies_mon = {}; N = molecule.nfragments(); Etotal = 0.0; if do_total or max_n_body == molecule.nfragments():; PsiMod.print_out(' => Total Cluster Energy <=\n'); # Full cluster always gets the external field; if (external):; PsiMod.set_global_option_python(""EXTERN"", external); Etotal = call_function_in_1st_argument(func, **kwargs); if (external):; PsiMod.set_global_option_python(""EXTERN"", None); energies_full[N] = []; energies_full[N].append(Etotal); energies_mon[N] = []; energies_mon[N].append(Etotal); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'); PsiMod.clean(). max_effective = max_n_body; if (max_effective == N):; max_effective = N - 1. # Build the combos for indexing purposes; Ns = []; if (max_n_body == N or do_total):; Ns.append(N); for n in range(max_effective, 0, -1):; Ns.append(n). combos = {}; for n in Ns:. combos[n] = []. # Loop through combinations in lexical order #. # initialize the reals list; reals = []; #setup first combination [3,2,1] lexical ordering; #fragments indexing is 1's based, bloody hell; for index in range(n, 0, -1):; reals.append(index); #start loop through lexical promotion; counter = 0; while True:. counter = counter + 1. # Append the current combo; combos[n].append(copy.deepcopy(reals)). #reset rank; rank = 0. #look for lexical promotion opportunity; #i.e.: [4 2 1] has a promotion opportunity at; # index 1 to produce [4 3 1]; for k in range(n - 2, -1, -1):; if (reals[k] != reals[k + 1] + 1):; rank = k + 1; break. #do the promotion; reals[rank] = reals[rank] + 1. #demote the right p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:7193,LOAD,LOAD,7193,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,3,['LOAD'],['LOAD']
Performance,"BT_CONVERGENCE¶. Reduce step size as necessary to ensure back-transformation of internal coordinate step to cartesian coordinates. Type: boolean; Default: false. FIXED_BEND¶. Specify angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DIHEDRAL¶. Specify dihedral angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DISTANCE¶. Specify distances between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FROZEN_BEND¶. Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_CARTESIAN¶. Specify atom and X, XY, XYZ, ... to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL¶. Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE¶. Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. H_UPDATE_DEN_TOL¶. Denominator check for hessian update. Type: conv double; Default: 1e-7. INTERFRAG_STEP_LIMIT¶. Maximum step size in bohr or radian along an interfragment coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT¶. Initial maximum step size in bohr or radian along an internal coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT_MAX¶. Upper bound for dynamic trust radius [au]. Type: double; Default: 1.0. INTRAFRAG_STEP_LIMIT_MIN¶. Lower bound for dynamic trust radius [au]. Type: double; Default: 0.001. IRC_DIRECTION¶. IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE¶. IRC step size in bohr(amu). Type: double; Default: 0.2. IRC_STOP¶. Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. OPT_COORDINATES¶. Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html:1524,optimiz,optimization,1524,psi4manual/1.0.0/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html,2,['optimiz'],['optimization']
Performance,"BT_CONVERGENCE¶. Reduce step size as necessary to ensure back-transformation of internal coordinate step to cartesian coordinates. Type: boolean; Default: false. FIXED_BEND¶. Specify angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DIHEDRAL¶. Specify dihedral angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DISTANCE¶. Specify distances between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FROZEN_BEND¶. Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_CARTESIAN¶. Specify atom and X, XY, XYZ, ... to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL¶. Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE¶. Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. H_UPDATE_DEN_TOL¶. Denominator check for hessian update. Type: conv double; Default: 1e-7. INTERFRAG_STEP_LIMIT¶. Maximum step size in bohr or radian along an interfragment coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT¶. Initial maximum step size in bohr or radian along an internal coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT_MAX¶. Upper bound for dynamic trust radius [au]. Type: double; Default: 1.0. INTRAFRAG_STEP_LIMIT_MIN¶. Lower bound for dynamic trust radius [au]. Type: double; Default: 0.001. IRC_DIRECTION¶. IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE¶. IRC step size in bohr(amu)\(^{1/2}\). Type: double; Default: 0.2. IRC_STOP¶. Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. OPT_COORDINATES¶. Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__optking-1.html:1470,optimiz,optimization,1470,psi4manual/1.1.0/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__optking-1.html,2,['optimiz'],['optimization']
Performance,"B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. omp3-1; OMP3 cc-pVDZ energy for the H2O molecule. tdscf-1; td-uhf test on triplet states of methylene (rpa). scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:43740,optimiz,optimization,43740,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,4,['optimiz'],"['optimization', 'optimized']"
Performance,"B_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). OrbitalSpace class in psi4.core, [1]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt attribute, [1]. psi4.core.OneBodyAOInt attribute, [1], [2]. psi4.core.OverlapInt attribute, [1]. psi4.core.PotentialInt attribute, [1]. psi4.core.PseudospectralInt attribute, [1]. psi4.core.QuadrupoleInt attribute, [1]. psi4.core.TracelessQuadrupoleInt attribute, [1]. original_coef() psi4.core.GaussianShell method, [1], [2]. ORTH_TYPE (DFOCC). (OCC). outfile_name() in module psi4.core, [1]. output. ; SAPT. cbs(). database(). geometry optimization. vibrational analysis. overlap_3c() psi4.core.IntegralFactory method, [1], [2]. OVERLAP_CHECK (CCEOM). OverlapInt class in psi4.core, [1]. P. p psi4.core.AOShellCombinationsIterator attribute, [1], [2]. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. ParsingError. partial_cholesky_factorize() psi4.core.Matrix method, [1], [2]. pasture_required_modules psi4.driver.PastureRequiredError attribute. PastureRequiredError. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33], [34]. PBS queueing system. PCG_BETA_TYPE (DFOCC). (OCC). PCG_CONVERGENCE (DFOCC). (OCC). PCG_MAXITER (DFOCC). (OCC). PCM. Using PCM. PCM (GLOBALS). PCM_CC_TYPE (GLOBALS). pcm_helper() in module psi4.driver. PCM_SCF_TYPE (GLOBALS). PCMSolver. PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). PERTURB_H (SCF). ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:72843,optimiz,optimization,72843,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['optimiz'],['optimization']
Performance,"Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt). [docs] def inertia_tensor_partial(self, part, masswt=True):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); tensor[1][1] += self.mass(i) * (self.x(i) * self.x(i) + self.z(i) * self.z(i)); tensor[2][2] += self.mass(i) * (self.x(i) * self.x(i)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html:12555,Queue,Queue,12555,psi4manual/4.0b5/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qcdb/molecule.html,1,['Queue'],['Queue']
Performance,"Bondi JPC 68 441 (1964); 'I': 2.04 / 1.5, # Bondi JPC 68 441 (1964); 'XE': 2.05 / 1.5} # Bondi JPC 68 441 (1964). Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = distance(self.xyz(i), self.xyz(u)) * psi_bohr2angstroms; if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].append(int(u)) # add to group (0-indexed); Fragment[-1].sort() # preserve original atom ordering. if len(White) != 0: # can't move White -> Queue if no more exist; Queue.append(White[0]); White.remove(White[0]). return Fragment. [docs] def inertia_tensor(self, masswt=True, zero=ZERO):; """"""Compute inertia tensor. >>> print H2OH2O.inertia_tensor(); [[8.704574864178731, -8.828375721817082, 0.0], [-8.828375721817082, 280.82861714077666, 0.0], [0.0, 0.0, 281.249500988553]]. """"""; return self.inertia_tensor_partial(range(self.natom()), masswt, zero). [docs] def inertia_tensor_partial(self, part, masswt=True, zero=ZERO):; """"""Compute inertia tensor based on atoms in *part*. """"""; tensor = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]. for i in part:; if masswt:; # I(alpha, alpha); tensor[0][0] += self.mass(i) * (self.y(i) * self.y(i) + self.z(i) * self.z(i)); tensor[1][1] += self.mass(i) * (self.x(i) * self.x(i) + self.z(i) * self.z(i)); tensor[2][2] += self.mass",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html:29943,Queue,Queue,29943,psi4manual/1.0.0/_modules/qcdb/molecule.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/molecule.html,1,['Queue'],['Queue']
Performance,"Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:7529,cache,cache,7529,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['cache'],['cache']
Performance,"C for HOOH torsional rotation at the RHF/DZP level of theory. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. dfccsd-t-grad2; DF-CCSD(T) cc-pVDZ gradient for the NH molecule. cdremp-2; Cholesky decomposed REMP/cc-pVDZ energies for the CH3 radical. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. mbis-1; MBIS calculation on H2O. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. cc52; CCSD Response for H2O2. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:29336,perform,performed,29336,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/mrcc-1.html:2287,optimiz,optimize,2287,psi4manual/4.0b4/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html,4,['optimiz'],['optimize']
Performance,"C simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6, 7, 8) Pertubative methods not available with ROHF reference. Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Table Of Contents. Interface to MRCC by M. Kállay; Installation; Running MRCC. Previous topic; Interfaces: Enhancing PSI4 Capabilities; Next topic; Interface to DFTD3 by S. Grimme; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Interfaces: Enhancing PSI4 Capabilities ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/mrcc-1.html:2287,optimiz,optimize,2287,psi4manual/4.0b5/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/mrcc-1.html,4,['optimiz'],['optimize']
Performance,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html:37418,perform,perform,37418,psi4manual/1.8.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.energy.html,2,['perform'],['perform']
Performance,"C singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.energy.html:38748,perform,perform,38748,psi4manual/1.9.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.energy.html,2,['perform'],['perform']
Performance,"C-06 and ODC-12 REFERENCE = RHF is only available for; ALGORITHM = SIMULTANEOUS. To compute correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS = DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS = DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; by one or two orders of magnitude (e.g. or; ). This can be particularly useful for computions using the; OD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:13400,optimiz,optimization,13400,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,4,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"C-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG¶. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT¶. SS vectors stored per root. Type: integer; Default: 5. T3_WS_INCORE¶. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. VECS_CC3¶. Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT¶. Vectors stored per root. Type: integer; Default: 12. Expert¶. EXCITATION_RANGE¶. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. WFN¶. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. Table Of Contents. CCEOM; General; ABCD; CACHELEVEL; CACHETYPE; CC3_FOLLOW_ROOT; CC_NUM_THREADS; COLLAPSE_WITH_LAST; COMPLEX_TOLERANCE; EOM_GUESS; EOM_REFERENCE; E_CONVERGENCE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_GHOST; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; R_CONVERGENCE; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT. Expert; EXCITATION_RANGE; WFN. Previous topic; WFN; Next topic; ABCD. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices »; Keywords by Module ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cceom-1.html:6799,CACHE,CACHELEVEL,6799,psi4manual/1.0.0/autodir_options_c/module__cceom-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cceom-1.html,4,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"C-hybrid GKS functional has the; generic form,. \[E_{\mathrm{xc}} = (1-\alpha) \int_{\mathrm{R}^3}; f_{\mathrm{xc}}; \left(; \rho_{\alpha} (\vec r_1),; \rho_{\beta} (\vec r_1),; \gamma_{\alpha\alpha} (\vec r_1),; \gamma_{\alpha\beta} (\vec r_1),; \gamma_{\beta\beta} (\vec r_1),; \tau_{\alpha} (\vec r_1),; \tau_{\beta} (\vec r_1); ; \omega \right) \ \mathrm{d} ^3 r_1\]. \[-\frac{1}{2} \sum_{i,j}; \delta_{\sigma_{i} \sigma_{j}} \alpha \iint_{\mathrm{R}^6} \phi_{i}^1 \phi_{j}^1; \frac{1}{r_{12}} \phi_{i}^2 \phi_{j}^2 \ \mathrm{d}^3 r_1 \ \mathrm{d}^3 r_2\]. \[-\frac{1}{2} \sum_{i,j}; \delta_{\sigma_{i} \sigma_{j}} (1-\alpha)\iint_{\mathrm{R}^6} \phi_{i}^1 \phi_{j}^1; \frac{\mathrm{erf}(\omega r_{12})}{r_{12}} \phi_{i}^2 \phi_{j}^2 \ \mathrm{d}^3 r_1 \ \mathrm{d}^3 r_2\]; For LRC functionals, the choice of range-separation parameter \(\omega\) has; been the subject of considerable activity since the inception of LRC; functionals. Some authors advocate a static range-separation parameter; determined by optimization over a test set of chemical systems. However, a more; physically-motivated and often more accurate approach is the idea of “gap; fitting” or “optimal tuning” or simply “tuning.” The most popular tuned-LRC; approach is IP-fitting, in which the \(\omega\) is varied until the; Koopman’s IP (the opposite of the HOMO energy) matches the true IP (the; difference between \(N-1\)-electron and \(N\)-electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{tuned-LRC}} (r) = -; \frac{1}{r} + I_{\mathrm{IP}} +; \epsilon_{\mathrm{HOMO}}\]; Note that LRC functionals with default \(\omega\) only capture the; \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{LRC}} (r) = -; \frac{1}{r},\]; hybrid functionals only capture part of the \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Hybrid}} (r) = -; \frac{\alpha}{r}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dft.html:10928,optimiz,optimization,10928,psi4manual/master/dft.html,https://psicode.org,https://psicode.org/psi4manual/master/dft.html,15,['optimiz'],['optimization']
Performance,"C. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:1335,optimiz,optimized,1335,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['optimiz'],['optimized']
Performance,"C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 1e-12. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ORBITALS_WRITE¶. File name (case sensitive) to which to serialize Wavefunction orbital data. Type: string; Default: No Default. PRINT_BASIS¶. Do print the basis set?. Type: boolean; Default: false. PRINT_MOS¶. Do print the molecular orbitals?. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. S_CHOLESKY_TOLERANCE¶. Tolerance for partial Cholesky decomposition of overlap matrix. Type: conv double; Default: 1e-8. S_ORTHOGONALIZATION¶. SO orthogonalization: automatic, symmetric, or canonical?. Type: string; Possible Values: AUTO, SYMMETRIC, CANONICAL, PARTIALCHOLESKY; Default: AUTO. S_TOLERANCE¶. Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. Convergence Control/Stabiliza",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html:2461,perform,perform,2461,psi4manual/1.4.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"C2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CC2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] Both UHF and ROHF gradients run in ccenergy but ROHF is slightly off (1.e-5); # and UHF is more off (1.e-4). Moreover, manual only claims RHF are working, so restricting here.; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc3(name, **kwargs):; """"""Function selectin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:35078,perform,performance,35078,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"CALE (OCC). outfile_name() in module psi4.core. output. ; cbs(). database(). geometry optimization. SAPT. vibrational analysis. overlap() psi4.core.FISAPT method. overlap_3c() psi4.core.IntegralFactory method. OVERLAP_CHECK (CCEOM). overlap_grad() psi4.core.MintsHelper method. OverlapInt class in psi4.core. P. p psi4.core.AOShellCombinationsIterator attribute. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parent_atom() psi4.core.BlockOPoints method. PARENT_SYMMETRY (GLOBALS). parse_file() psi4.driver.AtomicComputer class method. parse_obj() psi4.driver.AtomicComputer class method. parse_raw() psi4.driver.AtomicComputer class method. ParsingError. partial_cholesky_factorize() psi4.core.Matrix method. partition() psi4.core.FISAPT method. PastureRequiredError. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32]. PBS queueing system. PCG_BETA_TYPE (DFOCC). (OCC). PCG_CONVERGENCE (DFOCC). (OCC). PCG_MAXITER (DFOCC). (OCC). PCM. Using PCM. PCM (GLOBALS). PCM POLARIZATION ENERGY. PCM_CC_TYPE (PCM). PCM_enabled() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. pcm_helper() in module psi4.driver. PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PE. Using PE. PE (GLOBALS). PE ENERGY. PE_ECP (PE). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() psi4.core.MintsHelper method. PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() psi4.core.MintsHelper method. psi4.core.SOBasisSet method. petite_list1() psi4.core.MintsHelper method. PetiteList class in psi4.core. PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:106896,queue,queueing,106896,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['queue'],['queueing']
Performance,"CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION¶. Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS (=1) uses the DIIS approach by Pulay, NOJACOBI (=2) uses RLE with continuous extrapolation, OFF (=3) uses no convergence acceleration. In general, DIIS provides the best results and is recommended, while OFF often results in poor convergence and thus cannot be recommended. Type: string; Possible Values: RLE, DIIS, NOJACOBI, OFF; Default: DIIS. CFOUR_CC_MAXCYC¶. Specifies the maximum number of iterations in solving the CC amplitude equations. Type: integer; Default: 50. CFOUR_CC_PROGRAM¶. Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, MRCC, EXTERNAL; Default: VCC. CFOUR_CHARGE¶. Specifies the molecular charge. Psi4 Interface: Keyword set from active molecule. Type: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:10093,perform,performance,10093,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,4,['perform'],['performance']
Performance,"CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION¶. Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS (=1) uses the DIIS approach by Pulay, NOJACOBI (=2) uses RLE with continuous extrapolation, OFF (=3) uses no convergence acceleration. In general, DIIS provides the best results and is recommended, while OFF often results in poor convergence and thus cannot be recommended. Type: string; Possible Values: RLE, DIIS, NOJACOBI, OFF; Default: DIIS. CFOUR_CC_MAXCYC¶. Specifies the maximum number of iterations in solving the CC amplitude equations. Type: integer; Default: 50. CFOUR_CC_PROGRAM¶. Specifies which CC program is used. The available options are VCC (=0), ECC (=1), MRCC (=2), and EXTERNAL (=3). The default for all calculations is currently VCC which requests usage of xvcc, but in many cases (e.g., for CCSD and CCSD(T)) ECC should be preferred due to the better performance of xecc (available currently for CCSD, CCSD+T, CCSD(T), and closed-shell CCSDT-n, CC3, and CCSDT). MRCC and External are intended for CC programs outside the CFOUR suite, e.g., the general CC module mrcc written by M. Kallay (Budapest, Hungary). Default: VCC Note: Using the option ECC is not recommended for ROHF gradients. That is, if you are doing a geometry optimization with ROHF as your reference wave function then it is safe to use the option VCC. Psi4 Interface: Keyword set according to best practice for the computational method CFOUR_CALC_LEVEL reference CFOUR_REFERENCE (NYI) and derivative level CFOUR_DERIV_LEVEL according to Table Best Practices when method specified by argument to computation command (e.g., when energy('c4-ccsd') requested but not when energy('cfour') requested). Value can always be set explicitly. Type: string; Possible Values: VCC, ECC, NCC, MRCC, EXTERNAL; Default: VCC. CFOUR_CHARGE¶. Specifies the molecular charge. Psi4 Interface: Keyword set from active molecule. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cfour-1.html:10207,perform,performance,10207,psi4manual/1.2.1/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cfour-1.html,13,['perform'],['performance']
Performance,"CC', 'WFN_TYPE', 'DF-OMP2.5'); type_val = set_cholesky_from('MP_TYPE'); elif name in ['mp3', 'omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); type_val = set_cholesky_from('MP_TYPE'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); type_val = set_cholesky_from('CC_TYPE'). elif name == 'ccd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCD'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'ccsd':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'ccsd(t)':; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(T)'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'ccsd(at)':; core.set_local_option('DFOCC', 'CC_LAMBDA', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-CCSD(AT)'); type_val = set_cholesky_from('CC_TYPE'); elif name == 'dfocc':; pass; else:; raise ValidationError('Unidentified method %s' % (name)). # conventional vs. optimized orbitals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'ccsd(at)']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:45976,optimiz,optimized,45976,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,2,['optimiz'],['optimized']
Performance,"CC). symmetrize() LibmintsMolecule method. symmetry. molecule. symmetry_frame() LibmintsMolecule method. symmetry_from_input() LibmintsMolecule method. SymmetryOperation class in qcdb.libmintspointgrp. SymmetryOperation() SymRep method. SymRep class in qcdb.libmintspointgrp. T. T (THERMO). T2_COUPLED (CCENERGY). T3_WS_INCORE (CCENERGY). (CCEOM). T_AMPS (CCHBAR). Table class in p4util.text. table_generic() in module qcdb.textables. table_merge_abbr() Database method. table_merge_suppmat() Database method. table_reactions() Database method. table_scrunch() Database method. table_wrapper() Database method. tagl WrappedDatabase attribute. TDHF_MEM_SAFETY_FACTOR (CPHF). TDM (DETCI). TDM_PRINT (DETCI). TDM_WRITE (DETCI). ternary() in module qcdb.mpl. TEST_B (OPTKING). test_basis_set() BasisSet static method. test_ccl_functional() in module procedures.functional. TEST_DERIVATIVE_B (OPTKING). TestComparisonError. theory; . ADC. CC. CI. DCFT. DF-MP2. DFT. OEProp. OLCCD. OMP2. OMP3. Orbital-Optimized Methods. SAPT. SCF. cbs(), [1]. THETA_POINTS (SCF). THICKNESS (SCF). threading, [1]. threads() in module qcdb.mpl. THREE_PARTICLE (DCFT). ThreeDatabases class in qcdb.dbwrap. TIKHONOW_MAX (PSIMRCC). TIKHONOW_OMEGA (DCFT). (PSIMRCC). TIKHONOW_TRIPLES (PSIMRCC). TILE_SZ (SCF). to_array() in module p4util.numpy_helper. TPDM (DETCI). TPDM_ABCD_TYPE (OCC). TPDM_PRINT (DETCI). trace() SymmetryOperation method. SymRep method. transform() SymmetryOperation method. SymRep method. transform_coordinates() OrientMols method. transform_coordinates2() OrientMols method. transform_elementlist() OrientMols method. transform_gradient() OrientMols method. transform_vector() OrientMols method. transition state; . geometry optimization. translate() LibmintsMolecule method. TRANSLATE_PSI4 (CFOUR). transpose() in module qcdb.vecutil. SymmetryOperation method. TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_IABC_TYPE (DFOCC). TRIPLES_LOW_MEMORY (FNOCC). TURN_ON_ACTV (MCSCF). TWO-ELECTRONENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:133354,Optimiz,Optimized,133354,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['Optimiz'],['Optimized']
Performance,"CC)¶OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY)¶CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM)¶CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CALC_S_SQUARED (DETCI)¶DETCI — Do calculate the value of \(\langle S^2\rangle\) for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CANONICALIZE_ACTIVE_FAVG (MCSCF)¶MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF)¶MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING)¶OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CARTESIAN_SYM_TOLERANCE (OPTKING)¶OPTKING — Tolerance for symmetrizing cartesian geometry between steps. Type: conv double; Default: 1e-7. CC (DETCI)¶DETCI — Do coupled-cluster computation?. Type: boolean; Default: false. CC3_FOLLOW_ROOT (CCEOM)¶CCEOM — Do turn on root foll",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:11439,CACHE,CACHETYPE,11439,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,8,"['CACHE', 'cache']","['CACHETYPE', 'cached']"
Performance,"CC)¶OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY)¶CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM)¶CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CALC_S_SQUARED (DETCI)¶DETCI — Do calculate the value of \(\langle S^2\rangle\) for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CANONICALIZE_ACTIVE_FAVG (MCSCF)¶MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF)¶MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING)¶OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CC (DETCI)¶DETCI — Do coupled-cluster computation?. Type: boolean; Default: false. CC3_FOLLOW_ROOT (CCEOM)¶CCEOM — Do turn on root following for CC3. Type: boolean; Default: false. CC_A_RAS3_MAX (DETCI)¶DETCI — maximum number of alpha electrons in RAS III, for CC. Type: int",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:11748,CACHE,CACHETYPE,11748,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,10,"['CACHE', 'cache']","['CACHETYPE', 'cached']"
Performance,"CC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC — Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for CC-EOM. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE (DCT)¶DCT — Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-10. E_CONVERGENCE (DETCI)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:116325,optimiz,optimization,116325,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimization']
Performance,"CC3). ccsd(t); CCSD with perturbative triples. bccd(t); BCCD with perturbative triples. ccenergy; expert full control over ccenergy module. mpn; nth-order Moller–Plesset perturbation theory. zaptn; nth-order z-averaged perturbation theory (ZAPT). cisd; configuration interaction (CI) singles and doubles (CISD). cisdt; CI singles, doubles, and triples (CISDT). cisdtq; CI singles, doubles, triples, and quadruples (CISDTQ). cin; nth-order CI. fci; full configuration interaction (FCI). detci; expert full control over detci module. adc; 2nd-order algebraic diagrammatic construction (ADC). eom-cc2; EOM-CC2. eom-ccsd; equation of motion (EOM) CCSD. eom-cc3; EOM-CC3. cepa(n); coupled electron pair approximation, variants 0, 1, and 3. acpf; averaged coupled-pair functional. aqcc; averaged quadratic coupled cluster. omp2; orbital-optimized second order Moller–Plesset perturbation theory. scs-omp2; spin-component scaled OMP2. sos-omp2; spin-opposite scaled OMP2. omp3; orbital-optimized third order Moller–Plesset perturbation theory. scs-omp3; spin-component scaled OMP3. sos-omp3; spin-opposite scaled OMP3. name; calls method (aliases to name = ‘scf’). hf; HF. rhf; HF with restricted reference. uhf; HF with unrestricted reference. rohf; HF with restricted open-shell reference. rscf; HF or DFT with restricted reference. uscf; HF or DFT with unrestricted reference. roscf; HF or DFT with restricted open-shell reference. df-scf; HF or DFT with density fitting. name; calls method. b2plyp; B2PLYP Double Hybrid Exchange-Correlation Functional. b2plyp-d; B2PLYP Double Hybrid Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b2plyp-d3; B2PLYP Double Hybrid Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b2plyp-d3bj; B2PLYP Double Hybrid Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/energy-1.html:2362,optimiz,optimized,2362,psi4manual/4.0b3/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/energy-1.html,2,['optimiz'],['optimized']
Performance,"CCSD gradient call; and directing to specified or best-performance default modules. select_ccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. select_ccsd_t__gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. select_cisd(name, **kwargs)[source]¶; Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. select_fnoccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. select_fnoccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. select_lccd(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. select_lccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. select_mp2(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. select_mp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. select_mp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. select_mp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. select_mp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 gra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:167747,perform,performance,167747,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; In general, choose the desired method, reference, and ERI type (e.g.,; set reference uhf, set mp2_type df, opt('mp2')) and the most; efficient module will be selected automatically, according to; Cross-module Redundancies.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/occ.html:3640,optimiz,optimization,3640,psi4manual/master/occ.html,https://psicode.org,https://psicode.org/psi4manual/master/occ.html,15,['optimiz'],['optimization']
Performance,"CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be followed.; Thus, there arise a few categories of method, each with corresponding input keywords:. Orbital-optimized MP and CC methods with conventional integrals (OMP Methods OCC keywords); Orbital-optimized MP and CC methods with DF and CD integrals (OMP Methods DFOCC keywords); Non-orbital-optimized MP and CC methods with conventional integrals (MP/CC Methods OCC keywords); Non-orbital-optimized MP and CC methods with DF and CD integrals (MP/CC Methods DFOCC keywords). Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in Psi4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:3621,optimiz,optimization,3621,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['optimiz'],['optimization']
Performance,"CCSD, and EOM-CC3. run_eom_cc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. run_libfock(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a calculation through libfock, namely RCPHF,; RCIS, RTDHF, RTDA, and RTDDFT. run_mcscf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. run_mp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 calculation. run_mp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 gradient calculation. run_mp2c(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a coupled MP2 calculation. run_mrcc(name, **kwargs)[source]¶; Function that prepares environment and input files; for a calculation calling Kallay’s MRCC code. run_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. run_property(name, **kwargs)[source]¶. run_psimrcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. run_psimrcc_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. run_sapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SAPT calculation of any level. run_sapt_ct(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. run_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. run_scf_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SCF gradient calculation. run_scf_property(name, **kwargs)[source]¶. scf_helper(name, **kwargs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:5984,optimiz,optimized,5984,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance,"CCSD. COUPLING¶. The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FROZEN_DOCC¶. The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC¶. The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__psimrcc-1.html:2092,perform,performed,2092,psi4manual/4.0b5/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__psimrcc-1.html,2,['perform'],['performed']
Performance,"CCSD. COUPLING¶. The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__psimrcc-1.html:2015,perform,performed,2015,psi4manual/1.0.0/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__psimrcc-1.html,17,['perform'],['performed']
Performance,"CCSD. COUPLING¶. The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FROZEN_DOCC¶. The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC¶. The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__psimrcc-1.html:2092,perform,performed,2092,psi4manual/4.0b4/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__psimrcc-1.html,2,['perform'],['performed']
Performance,"CCSD. COUPLING¶. The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS¶. Do include the terms that couple the reference determinants?. Type: boolean; Default: true. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the amplitude updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the amplitudes from the previous iteration being mixed into the current iteration) can help in cases where oscillatory convergence is observed. Type: double; Default: 0.0. DIAGONALIZE_HEFF¶. Do diagonalize the effective Hamiltonian?. Type: boolean; Default: false. DIAGONAL_CCSD_T¶. Do include the diagonal corrections in (T) computations?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-9. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. FROZEN_DOCC¶. The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC¶. The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html:2232,perform,performed,2232,psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html,4,['perform'],['performed']
Performance,CD CORRELATION ENERGY. LCCD DOUBLES ENERGY. LCCD OPPOSITE-SPIN CORRELATION ENERGY. LCCD SAME-SPIN CORRELATION ENERGY. LCCD SINGLES ENERGY. LCCD TOTAL ENERGY. LCCSD. (+LMP2). LCCSD CORRELATION ENERGY. LCCSD DOUBLES ENERGY. LCCSD OPPOSITE-SPIN CORRELATION ENERGY. LCCSD SAME-SPIN CORRELATION ENERGY. LCCSD SINGLES ENERGY. LCCSD TOTAL ENERGY. legacy_frequencies() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. legacy_wavefunction() in module psi4.core. LEVEL_SHIFT (DFOCC). (MCSCF). (OCC). (SCF). LEVEL_SHIFT_CUTOFF (SCF). levenshtein() in module psi4.driver. LIBEFP. Libint. Libxc. LibXCFunctional class in psi4.core. license. LINEAR (CCRESPONSE). LINEQ_SOLVER (DFOCC). (OCC). LINESEARCH_STATIC_MAX (OPTKING). LINESEARCH_STATIC_MIN (OPTKING). LINESEARCH_STATIC_N (OPTKING). LITERAL_CFOUR (GLOBALS). load() psi4.core.Matrix method. load_mpqc() psi4.core.Matrix method. LOCAL (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_CONVERGENCE (DLPNO). (FISAPT). (SCF). LOCAL_CPHF_CUTOFF (CCENERGY). (CCLAMBDA). (CCRESPONSE). LOCAL_CUTOFF (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_DO_SINGLES (CCEOM). LOCAL_FILTER_SINGLES (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_GHOST (CCEOM). LOCAL_IBO_CONDITION (FISAPT). LOCAL_IBO_POWER (FISAPT). LOCAL_IBO_STARS (FISAPT). LOCAL_IBO_STARS_COMPLETENESS (FISAPT). LOCAL_IBO_USE_STARS (FISAPT). LOCAL_MAXITER (DLPNO). (FISAPT). (SCF). LOCAL_METHOD (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_PAIRDEF (CCENERGY). (CCLAMBDA). (CCRESPONSE). LOCAL_PRECONDITIONER (CCEOM). LOCAL_USE_GHOSTS (FISAPT). LOCAL_WEAKP (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). localize() psi4.core.BoysLocalizer method. psi4.core.FISAPT method. psi4.core.Localizer method. psi4.core.PMLocalizer method. Localizer class in psi4.core. LOCK_SINGLET (PSIMRCC). LOWDIN CHARGES. LowerT,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:82721,load,load,82721,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['load'],['load']
Performance,CD CORRELATION ENERGY. LCCD DOUBLES ENERGY. LCCD OPPOSITE-SPIN CORRELATION ENERGY. LCCD SAME-SPIN CORRELATION ENERGY. LCCD SINGLES ENERGY. LCCD TOTAL ENERGY. LCCSD. (+LMP2). LCCSD CORRELATION ENERGY. LCCSD DOUBLES ENERGY. LCCSD OPPOSITE-SPIN CORRELATION ENERGY. LCCSD SAME-SPIN CORRELATION ENERGY. LCCSD SINGLES ENERGY. LCCSD TOTAL ENERGY. legacy_frequencies() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. legacy_wavefunction() in module psi4.core. LEVEL_SHIFT (DFOCC). (MCSCF). (OCC). (SCF). LEVEL_SHIFT_CUTOFF (SCF). levenshtein() in module psi4.driver. LIBEFP. Libint. Libxc. LibXCFunctional class in psi4.core. license. LINEAR (CCRESPONSE). LINEQ_SOLVER (DFOCC). (OCC). LINESEARCH_STATIC_MAX (OPTKING). LINESEARCH_STATIC_MIN (OPTKING). LINESEARCH_STATIC_N (OPTKING). LITERAL_CFOUR (GLOBALS). load() psi4.core.Matrix method. load_mpqc() psi4.core.Matrix method. LOCAL (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_CONVERGENCE (FISAPT). (SCF). LOCAL_CPHF_CUTOFF (CCENERGY). (CCLAMBDA). (CCRESPONSE). LOCAL_CUTOFF (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_DO_SINGLES (CCEOM). LOCAL_FILTER_SINGLES (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_GHOST (CCEOM). LOCAL_IBO_CONDITION (FISAPT). LOCAL_IBO_POWER (FISAPT). LOCAL_IBO_STARS (FISAPT). LOCAL_IBO_STARS_COMPLETENESS (FISAPT). LOCAL_IBO_USE_STARS (FISAPT). LOCAL_MAXITER (FISAPT). (SCF). LOCAL_METHOD (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_PAIRDEF (CCENERGY). (CCLAMBDA). (CCRESPONSE). LOCAL_PRECONDITIONER (CCEOM). LOCAL_USE_GHOSTS (FISAPT). LOCAL_WEAKP (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). localize() psi4.core.BoysLocalizer method. psi4.core.FISAPT method. psi4.core.Localizer method. psi4.core.PMLocalizer method. Localizer class in psi4.core. LOCK_SINGLET (PSIMRCC). LOWDIN CHARGES. LowerTriangle psi4.core.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:81758,load,load,81758,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['load'],['load']
Performance,"CE (SCF); SCF — Minimum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. INTS_TOLERANCE (TRANSQT); TRANSQT — Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. INTS_TOLERANCE (TRANSQT2); TRANSQT2 — Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. IRC_DIRECTION (OPTKING); OPTKING — IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE (OPTKING); OPTKING — IRC step size in bohr(amu). Type: double; Default: 0.2. IRC_STOP (OPTKING); OPTKING — Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. ISTOP (DETCI); DETCI — Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. IVO (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. J_FILE (TRANSQT); TRANSQT —. Type: integer; Default: 91. JOBTYPE (CCLAMBDA); CCLAMBDA (Expert) — Type of job being performed. Type: string; Default: No Default. JOBTYPE (MP2); MP2 (Expert) — Type of job being performed. Type: string; Default: SP. KEEP_INTCOS (OPTKING); OPTKING — Keep internal coordinate definition file. Type: boolean; Default: false. KEEP_J (TRANSQT); TRANSQT — Do keep half-transformed integrals?. Type: boolean; Default: false. KEEP_OEIFILE (CCSORT); CCSORT — Do retain the input one-electron integrals?. Type: boolean; Default: false. KEEP_PRESORT (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. KEEP_TEIFILE (CCSORT); CCSORT — Do retain the input two-electron integrals?. Type: boolean; Default: false. LAG_IN_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_MO_LAG. LAGRAN_DOUBLE (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. LAGRAN_HALVE (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. LAMBDA_MAXITER (DCFT); DCFT — Maximum number of density cumulant update micro-iterations per macro-iteration (for ALOGRITHM = TWOSTEP). Same ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:48786,perform,performed,48786,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"CF E.............................................................PASSED. How to run Psi4 as executable or Python module from conda installation¶; The configuration commands below are generic versions of the ones printed; to your screen as advice upon installing PSI4 into a Anaconda,; Miniconda, or Psi4conda distribution, condadist =; ana|mini|psi4conda. If which conda python psi4 points to your; condadist and echo $PSI_SCRATCH is set, skip ahead to the; “Run PSI4” commands below. Otherwise, issue the following; commands directly in your terminal or place them into your “rc” file and; open a new terminal.; If you installed the Psi4conda distribution or installed the PSI4; conda package into the main environment of an Anaconda or Miniconda; distribution and added that to your PATH, as prompted, then; which psi4 likely yields condadist/bin/psi4 and the PATH; setting lines below are redundant.; If you installed into a conda environment p4env and performed; source activate p4env, then which psi4 likely yields; condadist/envs/p4env/bin/psi4 and the PATH setting lines; below are redundant.; # csh, tcsh: add to shell or ~/.tcshrc file; unsetenv PSIDATADIR; setenv PATH {prefix}/bin:$PATH; setenv PSI_SCRATCH /path/to/existing/writable/local-not-network/directory/for/scratch/files. # sh, bash: add to shell or ~/.bashrc (Linux/Windows) or ~/.bash_profile (Mac) file; unset PSIDATADIR; export PATH={prefix}/bin:$PATH; export PSI_SCRATCH=/path/to/existing/writable/local-not-network/directory/for/scratch/files. Run PSI4 as executable.; 1; 2; 3; 4; 5; 6; 7; 8>>> cat sample.in; molecule {; He; }; energy('hf/cc-pvdz'); compare_values(-2.85518839, get_variable('current energy'), 5, 'SCF E'); >>> psi4 sample.in; SCF E.............................................................PASSED. or Run PSI4 as Python module.; 1; 2; 3; 4; 5; 6; 7; 8; 9>>> cat sample.py; import psi4; mol = psi4.geometry(""""""; He; """"""); psi4.energy('hf/cc-pvdz'); psi4.compare_values(-2.85518839, psi4.core.get_variable('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:21998,perform,performed,21998,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,4,['perform'],['performed']
Performance,"CF convergence? Use NONE for DIIS alone (if enabled) and EDIIS or ADIIS to have both the chosen accelerator and DIIS (if enabled). For restricted-open references, EDIIS and ADIIS have no effect. Type: string; Possible Values: NONE, EDIIS, ADIIS; Default: ADIIS. SCF_INITIAL_FINISH_DIIS_TRANSITION¶. SCF error at which to complete the linear interpolation between DIIS steps and steps of the initial SCF accelerator Value taken from Garza and Scuseria, DOI: 10.1063/1.4740249. Type: double; Default: 1.0e-4. SCF_INITIAL_START_DIIS_TRANSITION¶. SCF error at which to start the linear interpolation between DIIS steps and steps of the initial SCF accelerator. Value taken from Garza and Scuseria, DOI: 10.1063/1.4740249. Type: double; Default: 1.0e-1. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html:8377,perform,perform,8377,psi4manual/1.6.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html,1,['perform'],['perform']
Performance,"CF options set by other procedures (e.g., SAPT; output file types for SCF). dashparam¶; Module to hold and distribute the -D dispersion correction parameters. dash_server(func, dashlvl, mode='psi4')[source]¶; Function to serve up dispersion correction parameters in whatever form needed.; When mode is ‘dftd3’, returns a string suitable for writing to ./dftd3_parameters; to calculuate the correction at dashlvl with the default parameters for functional; func. When mode is ‘psi4’, returns a tuple of arguments suitable for building; a Dispersion object with dashlvl parameters for functional func.; There are four computational dashlvl choices. ‘d2p4’ calls the -D2 correction; within psi4 (hence, faked for mode=’dftd3’). The other three, ‘d2gr’, ‘d3zero’,; and ‘d3bj’ call the three dftd3 modes of operation (corresponding to -old, -zero, -bj).; Additionally, there are three aliased dashlvl choices since the aliases in dash_alias; above are imposed. driver¶. gradient(name, **kwargs)[source]¶; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. hessian(name, **kwargs)[source]¶; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. molden(filename)[source]¶; Function to write wavefunction information in molden; format to filename. parse_arbitrary_order(name)[source]¶; Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. parse_cotton_irreps(irrep)[source]¶; Function to return validated Cotton ordering index from string or integer; irreducible representation irrep. gaussian_n¶. run_gaussian_2(name, **kwargs)[source]¶. pcmgetkw¶. class Getkw(top)[source]¶; Unified interface to sections and keywords.; Implements a path stack. find_sect(path)[source]¶. get_active_section()[source]¶. get_keyword(path)[source]¶. get_topsect()[source]¶. getkw(path)[source]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:13803,optimiz,optimize,13803,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['optimiz'],['optimize']
Performance,"CF', 'SCF_TYPE') == 'DF':; castdf = True; else:; castdf = False. if psi4.has_option_changed('SCF', 'DF_BASIS_GUESS'):; castdf = psi4.get_option('SCF', 'DF_BASIS_GUESS'); if yes.match(str(castdf)):; castdf = True; elif no.match(str(castdf)):; castdf = False. # sort out broken_symmetry settings.; if 'brokensymmetry' in kwargs:; molecule = psi4.get_active_molecule(); multp = molecule.multiplicity(); if multp != 1:; raise ValidationError('Broken symmetry is only for singlets.'); if psi4.get_option('SCF','REFERENCE') != 'UHF' and psi4.get_option('SCF','REFERENCE') != 'UKS':; raise ValidationError('You must specify ""set reference uhf"" to use broken symmetry.'); do_broken = True; else:; do_broken = False. precallback = None; if 'precallback' in kwargs:; precallback = kwargs.pop('precallback'). postcallback = None; if 'postcallback' in kwargs:; postcallback = kwargs.pop('postcallback'). # Hack to ensure cartesian or pure are used throughout; # Note that can't query PUREAM option directly, as it only; # reflects user changes to value, so load basis and; # read effective PUREAM setting off of it; psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')); psi4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; molecule.set_multiplicity(3); psi4.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); psi4.print_out('\n'). # cast set-up; if (cast):. if yes.match(str(cast)):; guessbasis = '3-21G'; else:; guessbasis = cast. if (castdf):; if yes.match(str(castdf)):; guessbasisdf = p4util.corresponding_jkfit(guessbasis); else:; guessbasisdf = castdf. # Switch to the guess namespace; namespace = psi4.IO.get_default_namespace(); psi4.IO.set_default_namespace((namespace + '.guess')). # Setup initial SCF; psi4.set_global_option('BASIS', guessbasis); if (castdf):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'none'); psi4.set_global_option('DF_BASIS_SCF', guessbasisdf",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:18280,load,load,18280,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['load'],['load']
Performance,CF). frac_nuke() in module frac. FRAC_OCC (SCF). FRAC_RENORMALIZE (SCF). FRAC_START (SCF). frac_traverse() in module frac. FRAC_VAL (SCF). FRAG_MODE (OPTKING). FragmentCountError. FREEZE_CORE (GLOBALS). (SAPT). FREEZE_INTERFRAG (OPTKING). FREEZE_INTRAFRAG (OPTKING). freq(); . see frequency();; . frequencies(); . see frequency();; . frequency(); . setting keywords. frequency() in module driver. fromkeys() qcdb.oldpymodules.OrderedDict class method. Frozen natural orbital coupled cluster. Frozen Natural Orbitals. FROZEN_BEND (OPTKING). FROZEN_CARTESIAN (OPTKING). FROZEN_DIHEDRAL (OPTKING). FROZEN_DISTANCE (OPTKING). FROZEN_DOCC (GLOBALS). FROZEN_UOCC (GLOBALS). fsymbol() LibmintsMolecule method. full_geometry() LibmintsMolecule method. FULL_HESS_EVERY (OPTKING). FULL_MATRIX (CCEOM). full_name_to_bits() PointGroup static method. full_pg_n() LibmintsMolecule method. full_point_group_with_n() LibmintsMolecule method. FullPointGroupList LibmintsMolecule attribute. function call; . geometry optimization. gradient. hessian. vibrational analysis. function_index() ShellInfo method. function_to_center() BasisSet method. function_to_shell() BasisSet method. functional_list() in module procedures.functional. fx() LibmintsMolecule method. fxyz() LibmintsMolecule method. fy() LibmintsMolecule method. fZ() LibmintsMolecule method. fz() LibmintsMolecule method. G. G_CONVERGENCE (OPTKING). gamma() CharacterTable method. GAUGE (CCDENSITY). (CCRESPONSE). Gaussian Formatted Checkpoint. Gaussian94BasisSetParser class in qcdb.libmintsbasissetparser. gaussian_n module. GaussianShell class in qcdb.libmintsgshell. GDMA. gdma() in module driver. GDMA_LIMIT (GDMA). GDMA_MULTIPOLE_UNITS (GDMA). GDMA_ORIGIN (GDMA). GDMA_RADIUS (GDMA). GDMA_SWITCH (GDMA). general; . setting keywords. genset_allneutral() in module qcdb.subsetgenerator. genset_anyanion() in module qcdb.subsetgenerator. genset_anycation() in module qcdb.subsetgenerator. genset_DDn5min() in module qcdb.subsetgenerator. genset_HBn5min(,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:37753,optimiz,optimization,37753,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['optimiz'],['optimization']
Performance,"CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below Hartree/bohr, where is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR); CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:48289,optimiz,optimizations,48289,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['optimiz'],"['optimizations', 'optimizer']"
Performance,"CFOUR_SPHERICAL. Type: boolean; Default: true. QC_COUPLING (DCT)¶DCT — Controls whether to include the coupling terms in the DCT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS)¶GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, ADCC, CCT3, BUILTIN; Default: No Default. QC_TYPE (DCT)¶DCT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC)¶DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF)¶SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP)¶EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. R4S (DETCI)¶DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (ADC)¶ADC — Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:198597,perform,perform,198597,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['perform'],['perform']
Performance,"CFOUR_SPHERICAL. Type: boolean; Default: true. QC_COUPLING (DCT)¶DCT — Controls whether to include the coupling terms in the DCT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS)¶GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, CCT3, BUILTIN, MRCC; Default: No Default. QC_TYPE (DCT)¶DCT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC)¶DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF)¶SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP)¶EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. R4S (DETCI)¶DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (ADC)¶ADC — Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:202751,perform,perform,202751,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,4,['perform'],['perform']
Performance,"CF_CONV. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html:6102,perform,perform,6102,psi4manual/1.1.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html,4,['perform'],['perform']
Performance,"CF_CONV. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Secord order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_R_START¶. When to start second-order SCF iterations based on gradient RMS. Type: double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html:6152,perform,perform,6152,psi4manual/1.0.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"CF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; # print(""about to generate displacements""); displacements = core.fd_geoms_1_0(moleculeclone); # print(displacements); ndisp = len(displacements); # print(""generated displacments""). # This version is pretty dependent on the reference geometry being last (as it is now); print("""""" %d displacements needed ..."""""" % (ndisp), end=''); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if opt_mode == 'sow':; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:37901,Perform,Perform,37901,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['Perform'],['Perform']
Performance,"CF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; psi4.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; psi4.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(moleculeclone); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print("""""" %d displacements needed ..."""""" % (ndisp), end=''); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if opt_mode == 'sow':; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:36670,Perform,Perform,36670,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['Perform'],['Perform']
Performance,"CFunctional method, [1], [2]. set_units() psi4.core.Molecule method, [1], [2]. set_variable() in module psi4.core, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.Molecule method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. set_vv10_b() psi4.core.SuperFunctional method, [1], [2]. set_vv10_c() psi4.core.SuperFunctional method, [1], [2]. set_write_dpd_so_tpdm() psi4.core.IntegralTransform method, [1], [2]. set_x_alpha() psi4.core.SuperFunctional method, [1], [2]. set_x_beta() psi4.core.SuperFunctional method, [1], [2]. set_x_omega() psi4.core.SuperFunctional method, [1], [2]. setName() psi4.core.ExternalPotential method, [1], [2]. setting. ; keywords anharmonicity(). keywords cbs(). keywords cp. keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords properties(). keywords vmfc. SF_RESTRICT (DETCI). shallow_copy() psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. shape psi4.core.Matrix attribute, [1], [2]. psi4.core.Vector attribute, [1], [2]. shared_object() psi4.core.IO method, [1], [2]. psi4.core.IOManager method, [1], [2]. shell() psi4.core.BasisSet method, [1], [2]. shell_extents() psi4.core.BasisExtents method, [1], [2]. shell_to_ao_function() psi4.core.BasisSet method, [1], [2]. shell_to_basis_function() psi4.core.BasisSet method, [1], [2]. shell_to_center() psi4.core.BasisSet method, [1], [2]. ShellInfo class in psi4.core, [1]. shells_iterator() psi4.core.IntegralFactory method, [1], [2]. shells_local_to_global() psi4.core.BlockOPoints method, [1], [2]. sherrill_gold_standard() in module psi4.driver.al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:116215,optimiz,optimize,116215,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['optimiz'],['optimize']
Performance,"CHELEVEL (ADC)¶ADC — How to cache quantities within the DPD library. This option is only available for the built-in ADC backend. Type: integer; Default: 2. CACHELEVEL (CCDENSITY)¶CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY)¶CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM)¶CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR)¶CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA)¶CCLAMBDA — Caching level for libdpd governing the storage of amplitudes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:8994,cache,cache,8994,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,10,['cache'],['cache']
Performance,"CI). NUM_DETS_PRINT (DETCI). NUM_FROZEN_DOCC (GLOBALS). NUM_FROZEN_UOCC (GLOBALS). NUM_INIT_VECS (DETCI). NUM_ROOTS (DETCI). NUM_VECS_PRINT (STABILITY). NUM_VECS_WRITE (DETCI). O. OCC_TOLERANCE (SAPT). OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). (RESPONSE). OMEGA_BRACKET_ALPHA (PLUGIN_OMEGA), [1]. OMEGA_CONVERGE (PLUGIN_OMEGA), [1]. OMEGA_GUESS (PLUGIN_OMEGA), [1]. OMEGA_GUESS_A (PLUGIN_OMEGA), [1]. OMEGA_GUESS_B (PLUGIN_OMEGA), [1]. OMEGA_GUESS_INTERPOLATE (PLUGIN_OMEGA), [1]. OMEGA_MAXITER (PLUGIN_OMEGA), [1]. OMEGA_PROCEDURE (PLUGIN_OMEGA), [1]. OMEGA_ROOT_ALGORITHM (PLUGIN_OMEGA), [1]. OMP2_ORBS_PRINT (OMP2). OMP_N_THREAD (CPHF). (JK), [1]. OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). OPDM (DETCI). (MP2). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (MP2). opt(); . see optimize(); . OPT_METHOD (OMP2). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() (in module driver). ORTH_TYPE (OMP2). output; . SAPT. cbs(). database(). geometry optimization. P. PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() (in module driver). parse_cotton_irreps() (in module driver). PATH, [1]. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). physconst (module). physical constants. PITZER (TRANSQT). plugin; . plugin_aointegrals. plugin_backtrans. plugin_ccsd_serial. plugin_ccsort. plugin_cepa. plugin_dfadc. plugin_libfock. plugin_mointegrals. plugin_mp2. plugin_omega. plugin_rqchf. plugin_sointegrals. plugin_test_matrix. plugin_testparse. plugin_testparse.__init__ (module). plugins; . available. POINTS (FINDIF). POLE_MAX (PLUGIN_DFADC), [1]. POLE_MAXITER (ADC). populateExtern() (Diffuse method). (QMMM metho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/genindex.html:20116,optimiz,optimize,20116,psi4manual/4.0b2/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/genindex.html,1,['optimiz'],['optimize']
Performance,"CI). ternary() in module qcdb.mpl. TEST_B (OPTKING). test_basis_set() BasisSet static method. test_ccl_functional() in module procedures.functional. TEST_DERIVATIVE_B (OPTKING). TestComparisonError. theory; . ADC. CC. CI. DCFT. DF-MP2. DFT. OEProp. OLCCD. OMP2. OMP3. Orbital-Optimized Methods. SAPT. SCF. cbs(), [1]. THETA_POINTS (SCF). THICKNESS (SCF). threading, [1]. threads() in module qcdb.mpl. THREE_PARTICLE (DCFT). ThreeDatabases class in qcdb.dbwrap. TIKHONOW_MAX (PSIMRCC). TIKHONOW_OMEGA (DCFT). (PSIMRCC). TIKHONOW_TRIPLES (PSIMRCC). TILE_SZ (SCF). to_array() in module p4util.numpy_helper. TPDM (DETCI). TPDM_ABCD_TYPE (OCC). TPDM_PRINT (DETCI). trace() SymmetryOperation method. SymRep method. transform() SymmetryOperation method. SymRep method. transform_coordinates() OrientMols method. transform_coordinates2() OrientMols method. transform_elementlist() OrientMols method. transform_gradient() OrientMols method. transform_vector() OrientMols method. transition state; . geometry optimization. translate() LibmintsMolecule method. TRANSLATE_PSI4 (CFOUR). transpose() in module qcdb.vecutil. SymmetryOperation method. TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_IABC_TYPE (DFOCC). TRIPLES_LOW_MEMORY (FNOCC). TURN_ON_ACTV (MCSCF). TWO-ELECTRONENERGY. type() CartesianEntry method. NumberValue method. VariableValue method. ZMatrixEntry method. U. UHF_NOONS (SCF). UNCP-CORRECTED2-BODYINTERACTIONENERGY. unique() LibmintsMolecule method. unit() SymmetryOperation method. SymRep method. units; . molecule. UNITS (GLOBALS). units() LibmintsMolecule method. up InPsight attribute. UPDATE (DETCI). update() OrderedDict method. PreservingDict method. update_geometry() InPsight method. LibmintsMolecule method. USE_DF_INTS (FNOCC). USE_SPIN_SYM (PSIMRCC). USE_SPIN_SYMMETRY (PSIMRCC). useful() in module qcdb.dbproc. V. val() in module qcdb.textables. VAL_EX_LEVEL (DETCI). valerr() in module qcdb.mpl. valid_atom_map() LibmintsMolecule method. ValidationError, [1]. value",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:134077,optimiz,optimization,134077,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['optimiz'],['optimization']
Performance,"CI); DETCI (Expert) — Array specifying the absolute alpha string number and beta string number for the second determinant in the filter procedure. (See FILTER_GUESS). Type: array; Default: No Default. FILTER_GUESS_SIGN (DETCI); DETCI (Expert) — The required phase (1 or -1) between the two determinants specified by FILTER_GUESS_DET1 and FILTER_GUESS_DET2. Type: integer; Default: 1. FILTER_ZERO_DET (DETCI); DETCI (Expert) — If present, the code will try to filter out a particular determinant by setting its CI coefficient to zero. FILTER_ZERO_DET = [alphastr, betastr] specifies the absolute alpha and beta string numbers of the target determinant. This could be useful for trying to exclude states that have a nonzero CI coefficient for the given determinant. However, this option was experimental and may not be effective. Type: array; Default: No Default. FINAL_GEOM_WRITE (OPTKING); OPTKING — Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. FIRST_TMP_FILE (TRANSQT); TRANSQT — First temporary file. Type: integer; Default: 150. FITTING_ALGORITHM (CPHF); CPHF — Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. FITTING_CONDITION (CPHF); CPHF — The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. FIXED_BEND (OPTKING); OPTKING — Specify angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for nor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:44310,optimiz,optimization,44310,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"CI); DETCI (Expert) — Array specifying the absolute alpha string number and beta string number for the second determinant in the filter procedure. (See FILTER_GUESS). Type: array; Default: No Default. FILTER_GUESS_SIGN (DETCI); DETCI (Expert) — The required phase (1 or -1) between the two determinants specified by FILTER_GUESS_DET1 and FILTER_GUESS_DET2. Type: integer; Default: 1. FILTER_ZERO_DET (DETCI); DETCI (Expert) — If present, the code will try to filter out a particular determinant by setting its CI coefficient to zero. FILTER_ZERO_DET = [alphastr, betastr] specifies the absolute alpha and beta string numbers of the target determinant. This could be useful for trying to exclude states that have a nonzero CI coefficient for the given determinant. However, this option was experimental and may not be effective. Type: array; Default: No Default. FINAL_GEOM_WRITE (OPTKING); OPTKING — Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. FIRST_TMP_FILE (TRANSQT); TRANSQT — First temporary file. Type: integer; Default: 150. FITTING_ALGORITHM (CPHF); CPHF — Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. FITTING_CONDITION (CPHF); CPHF — The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOCK_TOLERANCE (LMP2); LMP2 — Minimum absolute value below which parts of the Fock matrix are skipped. Type: conv double; Default: 1e-2. FOLLOW (STABILITY); STABILITY — Do follow the most negative eigenvalue of the Hessian towards a lower energy HF solution? Follow a UHF UHF instability of same symmetry?. Type: boolean; Default: false. FOLLOW_R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:44185,optimiz,optimization,44185,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimization']
Performance,"CI); DETCI (Expert) — Array specifying the absolute alpha string number and beta string number for the second determinant in the filter procedure. (See FILTER_GUESS). Type: array; Default: No Default. FILTER_GUESS_SIGN (DETCI); DETCI (Expert) — The required phase (1 or -1) between the two determinants specified by FILTER_GUESS_DET1 and FILTER_GUESS_DET2. Type: integer; Default: 1. FILTER_ZERO_DET (DETCI); DETCI (Expert) — If present, the code will try to filter out a particular determinant by setting its CI coefficient to zero. FILTER_ZERO_DET = [alphastr, betastr] specifies the absolute alpha and beta string numbers of the target determinant. This could be useful for trying to exclude states that have a nonzero CI coefficient for the given determinant. However, this option was experimental and may not be effective. Type: array; Default: No Default. FINAL_GEOM_WRITE (OPTKING); OPTKING — Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. FIRST_TMP_FILE (TRANSQT); TRANSQT —. Type: integer; Default: 150. FITTING_ALGORITHM (CPHF); CPHF — Fitting algorithm (0 for old, 1 for new). Type: integer; Default: 0. FITTING_CONDITION (CPHF); CPHF — The maximum reciprocal condition allowed in the fitting metric. Type: double; Default: 1.0e-12. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOCK_TOLERANCE (LMP2); LMP2 — Minimum absolute value below which parts of the Fock matrix are skipped. Type: conv double; Default: 1e-2. FOLLOW (STABILITY); STABILITY — Do follow the most negative eigenvalue of the Hessian towards a lower energy HF solution? Follow a UHF UHF instability of same symmetry?. Type: boolean; Default: false. FOLLOW_ROOT (CLAG); CLAG — Ro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:32525,optimiz,optimization,32525,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"CI); DETCI (Expert) — Array specifying the absolute alpha string number and beta string number for the second determinant in the filter procedure. (See FILTER_GUESS). Type: array; Default: No Default. FILTER_GUESS_SIGN (DETCI); DETCI (Expert) — The required phase (1 or -1) between the two determinants specified by FILTER_GUESS_DET1 and FILTER_GUESS_DET2. Type: integer; Default: 1. FILTER_ZERO_DET (DETCI); DETCI (Expert) — If present, the code will try to filter out a particular determinant by setting its CI coefficient to zero. FILTER_ZERO_DET = [alphastr, betastr] specifies the absolute alpha and beta string numbers of the target determinant. This could be useful for trying to exclude states that have a nonzero CI coefficient for the given determinant. However, this option was experimental and may not be effective. Type: array; Default: No Default. FINAL_GEOM_WRITE (OPTKING); OPTKING — Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. FISAPT_CHARGE_COMPLETENESS (FISAPT); FISAPT — Amount of fragment charge completeness to distinguish link bonds. Type: double; Default: 0.8. FISAPT_DO_FSAPT (FISAPT); FISAPT — Do an F-SAPT analysis?. Type: boolean; Default: true. FISAPT_DO_PLOT (FISAPT); FISAPT — Plot a scalar-field analysis. Type: boolean; Default: false. FISAPT_FSAPT_EXCH_SCALE (FISAPT); FISAPT — Do F-SAPT exchange scaling? (ratio of S^infty to S^2). Type: boolean; Default: true. FISAPT_FSAPT_FILEPATH (FISAPT); FISAPT — Filepath to drop F-SAPT data within input file directory. Type: string; Default: fsapt/. FISAPT_FSAPT_IND_RESPONSE (FISAPT); FISAPT — Do F-SAPT coupled response? (not recommended). Type: boolean; Default: false. FISAPT_FSAPT_IND_SCALE (FISAPT); FISAPT — Do F-SAPT induction scaling? (ratio of HF induction to F-SAPT induction). Type: bo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:125019,optimiz,optimization,125019,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"CI); DETCI (Expert) — Array specifying the absolute alpha string number and beta string number for the second determinant in the filter procedure. (See FILTER_GUESS). Type: array; Default: No Default. FILTER_GUESS_SIGN (DETCI); DETCI (Expert) — The required phase (1 or -1) between the two determinants specified by FILTER_GUESS_DET1 and FILTER_GUESS_DET2. Type: integer; Default: 1. FILTER_ZERO_DET (DETCI); DETCI (Expert) — If present, the code will try to filter out a particular determinant by setting its CI coefficient to zero. FILTER_ZERO_DET = [alphastr, betastr] specifies the absolute alpha and beta string numbers of the target determinant. This could be useful for trying to exclude states that have a nonzero CI coefficient for the given determinant. However, this option was experimental and may not be effective. Type: array; Default: No Default. FINAL_GEOM_WRITE (OPTKING); OPTKING — Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. FISAPT_CHARGE_COMPLETENESS (FISAPT); FISAPT — Amount of fragment charge completeness to distinguish link bonds. Type: double; Default: 0.8. FISAPT_DO_FSAPT (FISAPT); FISAPT — Do an F-SAPT analysis?. Type: boolean; Default: true. FISAPT_DO_PLOT (FISAPT); FISAPT — Plot a scalar-field analysis. Type: boolean; Default: false. FISAPT_FSAPT_EXCH_SCALE (FISAPT); FISAPT — Do F-SAPT exchange scaling? (ratio of S^infty to S^2). Type: boolean; Default: true. FISAPT_FSAPT_FILEPATH (FISAPT); FISAPT — Filepath to drop F-SAPT data. Type: string; Default: fsapt/. FISAPT_FSAPT_IND_RESPONSE (FISAPT); FISAPT — Do F-SAPT coupled response? (not recommended). Type: boolean; Default: false. FISAPT_FSAPT_IND_SCALE (FISAPT); FISAPT — Do F-SAPT induction scaling? (ratio of HF induction to F-SAPT induction). Type: boolean; Default: true. FISAPT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:123589,optimiz,optimization,123589,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimization']
Performance,"CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DF-MP2 TOTAL ENERGY¶. DF-MP2 CORRELAT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html:9031,optimiz,optimizer,9031,psi4manual/4.0b3/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/glossary_psivariables-1.html,2,['optimiz'],['optimizer']
Performance,"CISD QUADRUPOLE YY¶. CISD QUADRUPOLE YZ¶. CISD QUADRUPOLE ZZ¶; The six components of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. DFT FUNCTIONAL TOTAL ENERGY¶; The tot",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html:9137,optimiz,optimizer,9137,psi4manual/4.0b4/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/glossary_psivariables-1.html,6,['optimiz'],['optimizer']
Performance,"CIWavefunction method. OPDM_ONLY (CCDENSITY). OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_RESTART (OPTKING). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.Wavefunction method. options_to_python() in module psi4.core. OptionsState class in psi4.driver.p4util. OptionsStateCM() in module psi4.driver.p4util. OptionState class in psi4.driver.p4util. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. OREMP. ; setting keywords. OREMP2 CORRELATION ENERGY. OREMP2 DOUBLES ENERGY. OREMP2 OPPOSITE-SPIN CORRELATION ENERGY. OREMP2 REFERENCE CORRECTION ENERGY. OREMP2 SAME-SPIN CORRELATION ENERGY. OREMP2 SINGLES ENERGY. OREMP2 TOTAL ENERGY. orientation() psi4.core.MolecularGrid method. orientation_fixed() psi4.core.Molecule method. origin psi4.core.OneBodyAOInt attribute. original_coef() psi4.core.GaussianShell method. ORTH_TYPE (DFOCC). (OCC). OS_SCALE (OCC). outfile_name() in module psi4.core. output. ; cbs(). database(). geometry optimization. SAPT. vibrational analysis. overlap() psi4.core.FISAPT method. overlap_3c() psi4.core.IntegralFactor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:84270,Optimiz,Optimized,84270,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,2,['Optimiz'],['Optimized']
Performance,"CIWavefunction method. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method. open_check() psi4.core.IO method. operate() psi4.core.SymmetryOperation method. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OPTIMIZATION ITERATIONS. OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4.driver. optimize_geometric() in module psi4.driver. option_exists_in_module() in module psi4.core. Options class in psi4.core. options() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. options_to_python() in module psi4.core. optking() in module psi4.core. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCT). orbital_values() psi4.core.PointFunctions method. psi4.core.RKSFunctions method. psi4.core.UKSFunctions method. ORBITALS_WRITE (SCF). OrbitalSpace class in psi4.core. order() psi4.core.CharacterTable method. psi4.core.PointGroup method. ordered_params psi4.driver.EmpiricalDispersion attribute. psi4.driver.procrouting.empirical_dispersion.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method. psi4.core.MolecularGrid method. orientation_fixed() psi4.core.Molecule method. origin psi4.core.AngularMomentumInt attribute. psi4.core.DipoleInt attribute. psi4.core.ElectricFieldInt attribute. psi4.core.ElectrostaticInt attribute. psi4.core.KineticInt attribute. psi4.core.MultipoleInt attribute. psi4.core.NablaInt attribute. psi4.core.OneBodyAOInt attribute. psi4.core.OverlapInt attribute. psi4.core.PotentialInt attribute. psi4.core.Pseu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/genindex-1.html:101675,Optimiz,Optimized,101675,psi4manual/1.5.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,CLAMBDA — PSI4 [beta2] documentation; CCRESPONSE — PSI4 [beta2] documentation; CCSORT — PSI4 [beta2] documentation; CCTRIPLES — PSI4 [beta2] documentation; CIS — PSI4 [beta2] documentation; CLAG — PSI4 [beta2] documentation; CPHF — PSI4 [beta2] documentation; DCFT — PSI4 [beta2] documentation; DETCI — PSI4 [beta2] documentation; DFMP2 — PSI4 [beta2] documentation; FINDIF — PSI4 [beta2] documentation; GLOBALS — PSI4 [beta2] documentation; LMP2 — PSI4 [beta2] documentation; MCSCF — PSI4 [beta2] documentation; MINTS — PSI4 [beta2] documentation; MP2 — PSI4 [beta2] documentation; MRCC — PSI4 [beta2] documentation; OMP2 — PSI4 [beta2] documentation; OPTKING — PSI4 [beta2] documentation; PSIMRCC — PSI4 [beta2] documentation; RESPONSE — PSI4 [beta2] documentation; SAPT — PSI4 [beta2] documentation; SCF — PSI4 [beta2] documentation; STABILITY — PSI4 [beta2] documentation; TRANSQT — PSI4 [beta2] documentation; TRANSQT2 — PSI4 [beta2] documentation; CACHELEVEL — PSI4 [beta2] documentation; CACHETYPE — PSI4 [beta2] documentation; JOBTYPE — PSI4 [beta2] documentation; MP2_OS_SCALE — PSI4 [beta2] documentation; MP2_SS_SCALE — PSI4 [beta2] documentation; OPDM — PSI4 [beta2] documentation; OPDM_RELAX — PSI4 [beta2] documentation; REFERENCE — PSI4 [beta2] documentation; SCS — PSI4 [beta2] documentation; SCS_N — PSI4 [beta2] documentation; WFN — PSI4 [beta2] documentation; E_CONVERGENCE — PSI4 [beta2] documentation; INTS_TOLERANCE — PSI4 [beta2] documentation; MRCC_LEVEL — PSI4 [beta2] documentation; MRCC_METHOD — PSI4 [beta2] documentation; MRCC_NUM_SINGLET_ROOTS — PSI4 [beta2] documentation; MRCC_NUM_TRIPLET_ROOTS — PSI4 [beta2] documentation; MRCC_OMP_NUM_THREADS — PSI4 [beta2] documentation; MRCC_RESTART — PSI4 [beta2] documentation; CACHELEVEL — PSI4 [beta2] documentation; CC_MAXITER — PSI4 [beta2] documentation; CUTOFF — PSI4 [beta2] documentation; DIIS_MAX_VECS — PSI4 [beta2] documentation; DO_SCS — PSI4 [beta2] documentation; DO_SOS — PSI4 [beta2] documentation; E_CONVERGENC,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:922417,CACHE,CACHETYPE,922417,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHETYPE']
Performance,"CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc4; Test FNO-DF-CCSD(T) energy. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. mbis-6; MBIS calculation on H2O. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. cbs-parser; mtd/basis syntax examples. scf-occ; force occupations in scf. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. cisd-opt-fd; H2O CISD/6-31G** O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:28358,optimiz,optimization,28358,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"CONVERGENCE. Type: conv double; Default: 1e-4. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 100. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MP2_AMP_TYPE¶. The algorithm that used to handle mp2 amplitudes. The DIRECT option means compute amplitudes on the fly * whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dfocc.html:3775,optimiz,optimized-,3775,psi4manual/1.7.x/autodir_options_c/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dfocc.html,4,['optimiz'],['optimized-']
Performance,CONVERGENCE; FORCE_RESTART; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; MP2_AMPS_PRINT; MP2_OS_SCALE; MP2_SS_SCALE; NEW_TRIPLES; NUM_AMPS_PRINT; PAIR_ENERGIES_PRINT; PROPERTY; R_CONVERGENCE; REFERENCE; RESTART; SCS_CCSD; SCS_MP2; SCSN_MP2; SEMICANONICAL; SPINADAPT_ENERGIES; T2_COUPLED; T3_WS_INCORE; WFN; ABCD; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC3_FOLLOW_ROOT; COLLAPSE_WITH_LAST; COLLAPSE_WITH_LAST_CC3; COMPLEX_TOLERANCE; E_CONVERGENCE; EOM_GUESS; EOM_REFERENCE; EXCITATION_RANGE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_GHOST; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; R_CONVERGENCE; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT; WFN; CACHELEVEL; EOM_REFERENCE; T_AMPS; WABEI_LOWDISK; WFN; ABCD; AO_BASIS; CACHELEVEL; DIIS; JOBTYPE; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; R_CONVERGENCE; RESTART; ROOTS_PER_IRREP; SEKINO; WFN; ZETA; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; R_CONVERGENCE; REFERENCE; RESTART; SEKINO; WFN; AO_BASIS; CACHELEVEL; DELETE_TEI; REFERENCE; RUN_CCTRANSORT; SEMICANONICAL; WFN; CC_NUM_THREADS; REFERENCE; SEMICANONICAL; WFN; CFOUR_ABCDTYPE; CFOUR_ACTIVE_ORBI; CFOUR_ANH_ALGORITHM; CFOUR_ANH_DERIVATIVES; CFOUR_ANH_STEPSIZE; CFOUR_ANH_SYMMETRY; CFOUR_ANHARMONIC; CFOUR_AO_LADDERS; CFOUR_AV_SCF; CFOUR_BASIS; CFOUR_BRUCK_CONV; CFOUR_BRUECKNER; CFOUR_CACHE_RECS; CFOUR_CALC_LEVEL; CFOUR_CC_CONV; CFOUR_CC_EXPORDER; CFOUR_CC_EXTRAPOLATION; CFOUR_C,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:555213,CACHE,CACHELEVEL,555213,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,8,['CACHE'],['CACHELEVEL']
Performance,"CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DF_BASIS_MP2¶. Auxiliary basis set for MP2 density fitting calculations. Type: string; Possible Values: basis string; Default: No Default. DF_LMP2¶. Do use density fitting? Turned on with specification of fitting basis. Type: boolean; Default: true. DIAG_METHOD¶. Diagonalization method for the CI matrix. Type: string; Possible Values: DAVIDSON, FULL; Default: DAVIDSON. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_START_ITER¶. Iteration at which to start DIIS extrapolation. Type: integer",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html:1451,cache,cache,1451,psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,2,['cache'],['cache']
Performance,"CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CPHF_CUTOFF¶. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_CUTOFF¶. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__ccenergy-1.html:1565,cache,cache,1565,psi4manual/1.0.0/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__ccenergy-1.html,2,['cache'],['cache']
Performance,"CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CPHF_CUTOFF¶. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_CUTOFF¶. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html:1476,cache,cache,1476,psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html,2,['cache'],['cache']
Performance,"CONVERGENCE¶. Convergence criterion for T2 amplitudes (RMS change). Type: conv double; Default: 1e-5. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cc-1.html:4978,cache,cache,4978,psi4manual/4.0b5/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cc-1.html,4,['cache'],['cache']
Performance,CORRELATION ENERGY. LCCD SAME-SPIN CORRELATION ENERGY. LCCD SINGLES ENERGY. LCCD TOTAL ENERGY. LCCSD. (+LMP2). LCCSD CORRELATION ENERGY. LCCSD DOUBLES ENERGY. LCCSD OPPOSITE-SPIN CORRELATION ENERGY. LCCSD SAME-SPIN CORRELATION ENERGY. LCCSD SINGLES ENERGY. LCCSD TOTAL ENERGY. LEFT-RIGHT CC2 EIGENVECTOR OVERLAP. LEFT-RIGHT CC3 EIGENVECTOR OVERLAP. LEFT-RIGHT CCSD EIGENVECTOR OVERLAP. LEFT-RIGHT CCSD(T) EIGENVECTOR OVERLAP. LEVEL_SHIFT (DFOCC). (MCSCF). (OCC). (SCF). LEVEL_SHIFT_CUTOFF (SCF). levenshtein() in module psi4.driver. in module psi4.driver.p4util. LibECPInt. LIBEFP. Libint. Libxc. LibXCFunctional class in psi4.core. license. light psi4.driver.p4util.InPsight attribute. light_color psi4.driver.p4util.InPsight attribute. LINEAR (CCRESPONSE). LINEQ_SOLVER (DFOCC). Lineshape class in psi4.driver.p4util. lineshape() psi4.driver.p4util.Gaussian method. psi4.driver.p4util.Lineshape method. psi4.driver.p4util.Lorentzian method. LINK_INTS_TOLERANCE (SCF). LITERAL_CFOUR (GLOBALS). load() psi4.core.Matrix method. psi4.core.Vector method. load_mpqc() psi4.core.Matrix method. LOCAL (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_CONVERGENCE (DLPNO). (FISAPT). (SCF). LOCAL_CPHF_CUTOFF (CCENERGY). (CCLAMBDA). (CCRESPONSE). LOCAL_CUTOFF (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_DO_SINGLES (CCEOM). LOCAL_FILTER_SINGLES (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_IBO_CONDITION (FISAPT). LOCAL_IBO_POWER (FISAPT). LOCAL_IBO_STARS (FISAPT). LOCAL_IBO_STARS_COMPLETENESS (FISAPT). LOCAL_IBO_USE_STARS (FISAPT). LOCAL_MAXITER (DLPNO). (FISAPT). (SCF). LOCAL_METHOD (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_PAIRDEF (CCENERGY). (CCLAMBDA). (CCRESPONSE). LOCAL_PRECONDITIONER (CCEOM). LOCAL_USE_GHOSTS (FISAPT). LOCAL_WEAKP (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). localize() psi4.core.FISAPT method. psi4.core.Localizer method. Localizer class in psi4.core. location psi4.driver.p4util.InPsight attribute. LOCK_SINGLET (PSIMRCC). look_at psi4.driver.p4util.InPsi,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:68239,load,load,68239,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,1,['load'],['load']
Performance,"CS-MP2)?. Type: boolean; Default: false. SEMICANONICAL¶. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. T2_COUPLED¶. Type: boolean; Default: false. T3_WS_INCORE¶. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Expert¶. AO_BASIS¶. The algorithm to use for the \(\left\langle VV||VV\right\rangle\) terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. FORCE_RESTART¶. Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: NONE. table of contents. CCENERGY; General; ABCD; ANALYZE; BCCD_MAXITER; BRUECKNER_ORBS_R_CONVERGENCE; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC_OS_SCALE; CC_SS_SCALE; DIIS; E_CONVERGENCE; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; MP2_AMPS_PRINT; MP2_OS_SCALE; MP2_SS_SCALE; NEW_TRIPLES; NUM_AMPS_PRINT; PAIR_ENERGIES_PRINT; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SCSN_MP2; SCS_CCSD; SCS_MP2; SEMICANONICAL; T2_COUPLED; T3_WS_INCORE. Expert; AO_BASIS; FORCE_RESTART; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__ccenergy.html:6678,CACHE,CACHELEVEL,6678,psi4manual/1.8.x/autodir_options_c/module__ccenergy.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__ccenergy.html,2,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"CS-MP2)?. Type: boolean; Default: false. SEMICANONICAL¶. Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. T2_COUPLED¶. Type: boolean; Default: false. T3_WS_INCORE¶. Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. Expert¶. AO_BASIS¶. The algorithm to use for the \(\left\langle VV||VV\right\rangle\) terms If AO_BASIS is NONE, the MO-basis integrals will be used; if AO_BASIS is DISK, the AO-basis integrals stored on disk will be used; if AO_BASIS is DIRECT, the AO-basis integrals will be computed on the fly as necessary. NB: The DIRECT option is not fully implemented and should only be used by experts. Default is NONE. Note: The developers recommend use of this keyword only as a last resort because it significantly slows the calculation. The current algorithms for handling the MO-basis four-virtual-index integrals have been significantly improved and are preferable to the AO-based approach. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. FORCE_RESTART¶. Do restart the coupled-cluster iterations even if MO phases are screwed up?. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: NONE. table of contents. CCENERGY; General; ABCD; ANALYZE; BCCD_MAXITER; BRUECKNER_ORBS_R_CONVERGENCE; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC_OS_SCALE; CC_SS_SCALE; DIIS; E_CONVERGENCE; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; MP2_AMPS_PRINT; MP2_OS_SCALE; MP2_SS_SCALE; NEW_TRIPLES; NUM_AMPS_PRINT; PAIR_ENERGIES_PRINT; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SCSN_MP2; SCS_CCSD; SCS_MP2; SEMICANONICAL; T2_COUPLED; T3_WS_INCORE. Expert; AO_BASIS; FORCE_RESTART; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CCENERGY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__ccenergy.html:6678,CACHE,CACHELEVEL,6678,psi4manual/1.9.x/autodir_options_c/module__ccenergy.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__ccenergy.html,2,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"CSD energy call; and directing to specified or best-performance default modules. select_ccsd_at_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. select_ccsd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. select_ccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. select_ccsd_t__gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. select_cisd(name, **kwargs)[source]¶; Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. select_fnoccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. select_fnoccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. select_lccd(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. select_lccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. select_mp2(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. select_mp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. select_mp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:167416,perform,performance,167416,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"CSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. freq-masses; check nonphysical masses possible. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. scf6; Tests RHF/ROHF/UHF SCF gradients. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). cc13c; Tests RHF CCSD(T)gradients. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:6027,perform,performing,6027,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performing']
Performance,"CSD(T) STO-3G frozen-core energy of C4NH4 Anion. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mrcc1; CCSDT cc-pVDZ energy for the H2O molecule using MRCC. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/testsuite-1.html:5971,Optimiz,Optimize,5971,psi4manual/4.0b3/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/testsuite-1.html,4,['Optimiz'],['Optimize']
Performance,"CSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc12; Single point energies of multiple excited states with EOM-CCSD. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cbs-xtpl-func; optimization with method defined via cbs. fcidump; test FCIDUMP functionality for rhf/uhf. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. scf-level-shift-rohf; SCF level shift on an ROHF computation. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. scf3; File retention, docc, socc, and bond distances specified explicitly. opt16; SCF 6-31G(d) optimization of TS for HCN to HNC Performs finite difference hessian calculation. Then optimizes using previous orbitals for scf guess, in subsequent calculations. The last two displacements of the hessian break the plane of symemtry, This test confirms that only the reference geometry, with the correct symmetry, writes orbitals to disk. SCF will fail (ValidationError) otherwise. nbo; Generation of NBO file. fno",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:34007,perform,performing,34007,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performing']
Performance,"CSD(T) energy call; and directing to specified or best-performance default modules. select_ccsd_t__gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. select_cisd(name, **kwargs)[source]¶; Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. select_fnoccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. select_fnoccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. select_lccd(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. select_lccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. select_mp2(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. select_mp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. select_mp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. select_mp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. select_mp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. select_mp3(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 energy c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:167917,perform,performance,167917,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"CSD. scf-guess-read2; Test if the the guess read in the same basis converges. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:34924,Optimiz,Optimize,34924,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['Optimiz'],['Optimize']
Performance,"CSD. scf-guess-read2; Test if the the guess read in the same basis converges. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:31328,Optimiz,Optimize,31328,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,4,['Optimiz'],['Optimize']
Performance,"CSDT/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-4; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_cfour-1.html:1491,optimiz,optimization,1491,psi4manual/1.1.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_cfour-1.html,6,['optimiz'],['optimization']
Performance,"CTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. cc51; EOM-CC3/cc-pVTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. omp2p5",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html:34092,perform,performed,34092,psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"CTest (thorough) or pytest (cursory) to test the build. How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation. 1>>> ctest -j`getconf _NPROCESSORS_ONLN`. >>> make pytest. 6. Install. If tests pass, install the code.; 1>>> make install. 7. Configure Runtime. To run PSI4 after installation, you need to configure a few variables:. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation. What are the tools and dependencies strictly required for building Psi4¶; The core PSI4 build requires the software below. Note that; practically everything (including Python, CMake, NumPy, BLAS/LAPACK,; Libint, and even C++ compilers on Linux and Mac) can be; satisfied through conda. The links below give examples of how to configure; that software for PSI4 and any notes and warnings pertaining to it. C++ and C Compilers (C++14 compliant); Optimized BLAS and LAPACK libraries (preferably NOT one supplied by a standard; Linux distribution); Python interpreter and headers (3.6 or 3.7) https://www.python.org/; CMake (3.8+) http://www.cmake.org/download/; NumPy (needed at runtime and buildtime) http://www.numpy.org/; System utilities: GNU make, GNU install, POSIX threads (Pthreads) library. The following are also required for PSI4, but if not detected, the; build system will automatically download and build. gau2grid <cmake:gau2grid — [what is this?] [min version]; Libint — [what is this?] [min version]; Libxc — [what is this?] [min version]; pybind11 — [what is this?] [min version]; QCElemental — [what is this?]. Additionally, there are runtime-only dependencies:. NumPy http://www.numpy.org/; networkx https://github.com/networkx/networkx; deepdiff https://github.com/seperman/deepdiff; pint https://pint.readthedocs.io/en/latest/; pydantic (depending on your QCElemental version) https://pydantic-docs.helpmanual.io/#. What are the add-on capabilities for Psi4 and what are th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:4340,Optimiz,Optimized,4340,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['Optimiz'],['Optimized']
Performance,"CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. option_exists_in_module() in module psi4.core, [1]. Options class in psi4.core, [1]. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orbital_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. OrbitalSpace class in psi4.core, [1]. order() psi4.core.CharacterTable method, [1], [2]. psi4.core.PointGroup method, [1], [2]. ordered_params psi4.driver.EmpiricalDispersion attribute. orientation() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. orientation_fixed() psi4.core.Molecule method, [1], [2]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt attribute, [1]. psi4.core.OneBodyAOInt attribute, [1], [2]. psi4.core.OverlapInt a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:102536,Optimiz,Optimized,102536,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,"CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. option_exists_in_module() in module psi4.core, [1]. Options class in psi4.core, [1]. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orbital_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. OrbitalSpace class in psi4.core, [1]. orientation() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. orientation_fixed() psi4.core.Molecule method, [1], [2]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt attribute, [1]. psi4.core.OneBodyAOInt attribute, [1], [2]. psi4.core.OverlapInt attribute, [1]. psi4.core.PotentialInt attribute, [1]. psi4.core.PseudospectralInt attribute, [1]. psi4.core.QuadrupoleInt attribute, [1]. psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:88116,Optimiz,Optimized,88116,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['Optimiz'],['Optimized']
Performance,CUTOFF — PSI4 [beta2] documentation; LOCAL_METHOD — PSI4 [beta2] documentation; LOCAL_PAIRDEF — PSI4 [beta2] documentation; LOCAL_WEAKP — PSI4 [beta2] documentation; MAXITER — PSI4 [beta2] documentation; MP2_AMPS_PRINT — PSI4 [beta2] documentation; MP2_OS_SCALE — PSI4 [beta2] documentation; MP2_SS_SCALE — PSI4 [beta2] documentation; NEW_TRIPLES — PSI4 [beta2] documentation; NUM_AMPS_PRINT — PSI4 [beta2] documentation; PAIR_ENERGIES_PRINT — PSI4 [beta2] documentation; PROPERTY — PSI4 [beta2] documentation; R_CONVERGENCE — PSI4 [beta2] documentation; REFERENCE — PSI4 [beta2] documentation; RESTART — PSI4 [beta2] documentation; SCS_CCSD — PSI4 [beta2] documentation; SCS_MP2 — PSI4 [beta2] documentation; SCSN_MP2 — PSI4 [beta2] documentation; SEMICANONICAL — PSI4 [beta2] documentation; SPINADAPT_ENERGIES — PSI4 [beta2] documentation; T2_COUPLED — PSI4 [beta2] documentation; T3_WS_INCORE — PSI4 [beta2] documentation; WFN — PSI4 [beta2] documentation; ABCD — PSI4 [beta2] documentation; CACHELEVEL — PSI4 [beta2] documentation; CACHETYPE — PSI4 [beta2] documentation; CC_NUM_THREADS — PSI4 [beta2] documentation; CC3_FOLLOW_ROOT — PSI4 [beta2] documentation; COLLAPSE_WITH_LAST — PSI4 [beta2] documentation; COMPLEX_TOLERANCE — PSI4 [beta2] documentation; E_CONVERGENCE — PSI4 [beta2] documentation; EOM_GUESS — PSI4 [beta2] documentation; EOM_REFERENCE — PSI4 [beta2] documentation; EXCITATION_RANGE — PSI4 [beta2] documentation; FULL_MATRIX — PSI4 [beta2] documentation; LOCAL — PSI4 [beta2] documentation; LOCAL_CUTOFF — PSI4 [beta2] documentation; LOCAL_DO_SINGLES — PSI4 [beta2] documentation; LOCAL_FILTER_SINGLES — PSI4 [beta2] documentation; LOCAL_GHOST — PSI4 [beta2] documentation; LOCAL_METHOD — PSI4 [beta2] documentation; LOCAL_PRECONDITIONER — PSI4 [beta2] documentation; LOCAL_WEAKP — PSI4 [beta2] documentation; MAXITER — PSI4 [beta2] documentation; NEW_TRIPLES — PSI4 [beta2] documentation; NUM_AMPS_PRINT — PSI4 [beta2] documentation; PROP_ROOT — PSI4 [beta2] documentation; ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:905696,CACHE,CACHELEVEL,905696,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,CUTOFF — PSI4 [beta3] documentation; LOCAL_METHOD — PSI4 [beta3] documentation; LOCAL_PAIRDEF — PSI4 [beta3] documentation; LOCAL_WEAKP — PSI4 [beta3] documentation; MAXITER — PSI4 [beta3] documentation; MP2_AMPS_PRINT — PSI4 [beta3] documentation; MP2_OS_SCALE — PSI4 [beta3] documentation; MP2_SS_SCALE — PSI4 [beta3] documentation; NEW_TRIPLES — PSI4 [beta3] documentation; NUM_AMPS_PRINT — PSI4 [beta3] documentation; PAIR_ENERGIES_PRINT — PSI4 [beta3] documentation; PROPERTY — PSI4 [beta3] documentation; R_CONVERGENCE — PSI4 [beta3] documentation; REFERENCE — PSI4 [beta3] documentation; RESTART — PSI4 [beta3] documentation; SCS_CCSD — PSI4 [beta3] documentation; SCS_MP2 — PSI4 [beta3] documentation; SCSN_MP2 — PSI4 [beta3] documentation; SEMICANONICAL — PSI4 [beta3] documentation; SPINADAPT_ENERGIES — PSI4 [beta3] documentation; T2_COUPLED — PSI4 [beta3] documentation; T3_WS_INCORE — PSI4 [beta3] documentation; WFN — PSI4 [beta3] documentation; ABCD — PSI4 [beta3] documentation; CACHELEVEL — PSI4 [beta3] documentation; CACHETYPE — PSI4 [beta3] documentation; CC_NUM_THREADS — PSI4 [beta3] documentation; CC3_FOLLOW_ROOT — PSI4 [beta3] documentation; COLLAPSE_WITH_LAST — PSI4 [beta3] documentation; COMPLEX_TOLERANCE — PSI4 [beta3] documentation; E_CONVERGENCE — PSI4 [beta3] documentation; EOM_GUESS — PSI4 [beta3] documentation; EOM_REFERENCE — PSI4 [beta3] documentation; EXCITATION_RANGE — PSI4 [beta3] documentation; FULL_MATRIX — PSI4 [beta3] documentation; LOCAL — PSI4 [beta3] documentation; LOCAL_CUTOFF — PSI4 [beta3] documentation; LOCAL_DO_SINGLES — PSI4 [beta3] documentation; LOCAL_FILTER_SINGLES — PSI4 [beta3] documentation; LOCAL_GHOST — PSI4 [beta3] documentation; LOCAL_METHOD — PSI4 [beta3] documentation; LOCAL_PRECONDITIONER — PSI4 [beta3] documentation; LOCAL_WEAKP — PSI4 [beta3] documentation; MAXITER — PSI4 [beta3] documentation; NEW_TRIPLES — PSI4 [beta3] documentation; NUM_AMPS_PRINT — PSI4 [beta3] documentation; PROP_ROOT — PSI4 [beta3] documentation; ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1115143,CACHE,CACHELEVEL,1115143,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,CUTOFF — PSI4 [beta4] documentation; LOCAL_METHOD — PSI4 [beta4] documentation; LOCAL_PAIRDEF — PSI4 [beta4] documentation; LOCAL_WEAKP — PSI4 [beta4] documentation; MAXITER — PSI4 [beta4] documentation; MP2_AMPS_PRINT — PSI4 [beta4] documentation; MP2_OS_SCALE — PSI4 [beta4] documentation; MP2_SS_SCALE — PSI4 [beta4] documentation; NEW_TRIPLES — PSI4 [beta4] documentation; NUM_AMPS_PRINT — PSI4 [beta4] documentation; PAIR_ENERGIES_PRINT — PSI4 [beta4] documentation; PROPERTY — PSI4 [beta4] documentation; R_CONVERGENCE — PSI4 [beta4] documentation; REFERENCE — PSI4 [beta4] documentation; RESTART — PSI4 [beta4] documentation; SCS_CCSD — PSI4 [beta4] documentation; SCS_MP2 — PSI4 [beta4] documentation; SCSN_MP2 — PSI4 [beta4] documentation; SEMICANONICAL — PSI4 [beta4] documentation; SPINADAPT_ENERGIES — PSI4 [beta4] documentation; T2_COUPLED — PSI4 [beta4] documentation; T3_WS_INCORE — PSI4 [beta4] documentation; WFN — PSI4 [beta4] documentation; ABCD — PSI4 [beta4] documentation; CACHELEVEL — PSI4 [beta4] documentation; CACHETYPE — PSI4 [beta4] documentation; CC_NUM_THREADS — PSI4 [beta4] documentation; CC3_FOLLOW_ROOT — PSI4 [beta4] documentation; COLLAPSE_WITH_LAST — PSI4 [beta4] documentation; COMPLEX_TOLERANCE — PSI4 [beta4] documentation; E_CONVERGENCE — PSI4 [beta4] documentation; EOM_GUESS — PSI4 [beta4] documentation; EOM_REFERENCE — PSI4 [beta4] documentation; EXCITATION_RANGE — PSI4 [beta4] documentation; FULL_MATRIX — PSI4 [beta4] documentation; LOCAL — PSI4 [beta4] documentation; LOCAL_CUTOFF — PSI4 [beta4] documentation; LOCAL_DO_SINGLES — PSI4 [beta4] documentation; LOCAL_FILTER_SINGLES — PSI4 [beta4] documentation; LOCAL_GHOST — PSI4 [beta4] documentation; LOCAL_METHOD — PSI4 [beta4] documentation; LOCAL_PRECONDITIONER — PSI4 [beta4] documentation; LOCAL_WEAKP — PSI4 [beta4] documentation; MAXITER — PSI4 [beta4] documentation; NEW_TRIPLES — PSI4 [beta4] documentation; NUM_AMPS_PRINT — PSI4 [beta4] documentation; PROP_ROOT — PSI4 [beta4] documentation; ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:1326246,CACHE,CACHELEVEL,1326246,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['CACHE'],['CACHELEVEL']
Performance,"C_DIIS (SCF). FRAC_LOAD (SCF). frac_nuke() in module frac. FRAC_OCC (SCF). FRAC_RENORMALIZE (SCF). FRAC_START (SCF). frac_traverse() in module frac. FRAC_VAL (SCF). FRAG_MODE (OPTKING). FREEZE_CORE (GLOBALS). (SAPT). FREEZE_INTERFRAG (OPTKING). FREEZE_INTRAFRAG (OPTKING). frequency() in module driver. FROZEN_DOCC (GLOBALS). (PSIMRCC). FROZEN_UOCC (GLOBALS). (PSIMRCC). fsymbol() LibmintsMolecule method. full_geometry() LibmintsMolecule method. FULL_HESS_EVERY (OPTKING). FULL_MATRIX (CCEOM). full_pg_n() LibmintsMolecule method. full_point_group_with_n() LibmintsMolecule method. FullPointGroupList LibmintsMolecule attribute. functional module. functional_list() in module functional. fx() LibmintsMolecule method. fxyz() LibmintsMolecule method. fy() LibmintsMolecule method. fZ() LibmintsMolecule method. fz() LibmintsMolecule method. FZC_A_FILE (TRANSQT). FZC_B_FILE (TRANSQT). FZC_FILE (TRANSQT). G. G_CONVERGENCE (OPTKING). GAUGE (CCDENSITY). (CCRESPONSE). GEOM_MAXITER (OPTKING). geometry optimization. IRC. constrained. convergence criteria. minima. output. transition state. geometry() in module molutil. LibmintsMolecule method. get_anchor_atom() LibmintsMolecule method. get_coord_value() LibmintsMolecule method. get_full_point_group() LibmintsMolecule method. get_memory() in module util. get_num_threads() in module util. get_psifile() in module procutil. get_variable() LibmintsMolecule method. getattr_ignorecase() in module procutil. getCartesian() PubChemObj method. getMoleculeString() PubChemObj method. getPubChemResults() in module pubchem. getSDF() PubChemObj method. getXYZFile() PubChemObj method. Ghost Atoms. gradient() in module driver. GUESS (SCF). GUESS_VECTOR (DETCI). H. H0_BLOCK_COUPLING (DETCI). H0_BLOCK_COUPLING_SIZE (DETCI). H0_BLOCKSIZE (DETCI). H0_GUESS_SIZE (DETCI). H_BOND_CONNECT (OPTKING). Hartree-Fock. has_inversion() LibmintsMolecule method. has_symmetry_element() LibmintsMolecule method. HBC6 module, [1]. HD_AVG (DETCI). HD_OTF (DETCI). HEFF4 (PSIMR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/genindex.html:21274,optimiz,optimization,21274,psi4manual/4.0b3/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/genindex.html,1,['optimiz'],['optimization']
Performance,C_OS_SCALE; CC_SS_SCALE; DIIS; E_CONVERGENCE; FORCE_RESTART; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; MP2_AMPS_PRINT; MP2_OS_SCALE; MP2_SS_SCALE; NEW_TRIPLES; NUM_AMPS_PRINT; PAIR_ENERGIES_PRINT; PROPERTY; R_CONVERGENCE; REFERENCE; RESTART; SCS_CCSD; SCS_MP2; SCSN_MP2; SEMICANONICAL; T2_COUPLED; T3_WS_INCORE; WFN; ABCD; CACHELEVEL; CACHETYPE; CC_NUM_THREADS; CC3_FOLLOW_ROOT; COLLAPSE_WITH_LAST; COLLAPSE_WITH_LAST_CC3; COMPLEX_TOLERANCE; E_CONVERGENCE; EOM_GUESS; EOM_REFERENCE; EXCITATION_RANGE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; R_CONVERGENCE; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT; WFN; CACHELEVEL; EOM_REFERENCE; T_AMPS; WABEI_LOWDISK; WFN; ABCD; AO_BASIS; CACHELEVEL; DIIS; JOBTYPE; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; R_CONVERGENCE; RESTART; ROOTS_PER_IRREP; SEKINO; WFN; ZETA; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; R_CONVERGENCE; REFERENCE; RESTART; SEKINO; WFN; AO_BASIS; CACHELEVEL; DELETE_TEI; REFERENCE; RUN_CCTRANSORT; SEMICANONICAL; WFN; CC_NUM_THREADS; REFERENCE; SEMICANONICAL; WFN; CFOUR_ABCDTYPE; CFOUR_ACTIVE_ORBI; CFOUR_ANH_ALGORITHM; CFOUR_ANH_DERIVATIVES; CFOUR_ANH_STEPSIZE; CFOUR_ANH_SYMMETRY; CFOUR_ANHARMONIC; CFOUR_AO_LADDERS; CFOUR_AV_SCF; CFOUR_BASIS; CFOUR_BRUCK_CONV; CFOUR_BRUECKNER; CFOUR_CACHE_RECS; CFOUR_CALC_LEVEL; CFOUR_CC_CONV; CFOUR_CC_EXPORDER; CFOUR_CC_EXTRAPOLATION; CFOUR_C,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:766304,CACHE,CACHELEVEL,766304,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,7,['CACHE'],['CACHELEVEL']
Performance,"Ca = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). [docs]; def tdscf(wfn, **kwargs):; return proc.run_tdscf_excitations(wfn,**kwargs). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.10a1.dev61;  · . PSI4. Module code; psi4.driver.driver. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:106300,optimiz,optimize,106300,psi4manual/master/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); dertype = 1. optstash = p4util.OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError('No analytic derivatives for SCF_TYPE CD.'). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:32365,optimiz,optimize,32365,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['optimiz'],['optimize']
Performance,"Cartesian input. cepa1; cc-pvdz H2O Test CEPA(1) Energy. psimrcc-pt2; Mk-MRPT2 single point. \(^1A_1\) F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. sapt-sf1; Tests the Psi4 SF-SAPT code. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. scf-guess-read2; Test if the the guess read in the same basis converges. cc13d; Tests analytic CC2 gradients. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. mp2-h; check tha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:4218,optimiz,optimization,4218,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,8,['optimiz'],"['optimization', 'optimized']"
Performance,Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through ‘type select’ values; see rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. omp2.5; Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2.5; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. olccd; Orbital-Optimized Linear CCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE CONV. Density-Fitted Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; CC_TYPE DF. Cholesky-Decomposed Orbital-Optimized LCCD; RHF/UHF/ROHF/RKS/UKS; —; CC_TYPE CD. Spin-Component-Scaled Orbital-Optimized MP capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —. scs(n)-omp3; A special version of SCS-OMP3 for nucleobase interactions; RHF/UHF/ROHF/RKS/UKS; —. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); RHF/UHF/ROHF/RKS/UKS; —. sos-pi-omp3; A special version of SOS-OMP3 for -systems; RHF/UHF/ROHF/RKS/UKS; —. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —. sos-omp2; Spin-Opposite Scaled Orbital-Opt,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:7487,Optimiz,Optimized,7487,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['Optimiz'],['Optimized']
Performance,"Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-optimized second-order perturbation theory (DF-OMP2). “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c).; “Analytic Energy Gradients and Spin Multiplicities for Orbital-Optimized; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/introduction.html:18365,optimiz,optimized,18365,psi4manual/master/introduction.html,https://psicode.org,https://psicode.org/psi4manual/master/introduction.html,17,['optimiz'],['optimized']
Performance,"Computer method). C. C() (psi4.core.OrbitalSpace method). c1_deep_copy() (psi4.core.CUHF method). (psi4.core.RHF method). (psi4.core.ROHF method). (psi4.core.UHF method). (psi4.core.Wavefunction method). c2_x() (psi4.core.SymmetryOperation method). c2_y() (psi4.core.SymmetryOperation method). c2_z() (psi4.core.SymmetryOperation method). C_add() (psi4.core.JK method). c_alpha() (psi4.core.SuperFunctional method). C_clear() (psi4.core.JK method). c_functional() (psi4.core.SuperFunctional method). c_functionals() (psi4.core.SuperFunctional method). C_left_add() (psi4.core.JK method). c_omega() (psi4.core.SuperFunctional method). c_os_alpha() (psi4.core.SuperFunctional method). C_right_add() (psi4.core.JK method). c_ss_alpha() (psi4.core.SuperFunctional method). Ca() (psi4.core.SADGuess method). (psi4.core.Wavefunction method). Ca_subset() (psi4.core.Wavefunction method). CACHELEVEL (CCDENSITY). (CCENERGY). (CCEOM). (CCHBAR). (CCLAMBDA). (CCRESPONSE). (CCTRANSORT). (DCT). (OCC). CACHETYPE (CCENERGY). (CCEOM). CALC_S_SQUARED (DETCI). CANONICALIZE_ACTIVE_FAVG (MCSCF). CANONICALIZE_INACTIVE_FAVG (MCSCF). CART_HESS_READ (OPTKING). Cartesian (psi4.core.GaussianType attribute). CARTESIAN_SYM_TOLERANCE (OPTKING). Cb() (psi4.core.SADGuess method). (psi4.core.Wavefunction method). Cb_subset() (psi4.core.Wavefunction method). CBS CORRELATION ENERGY. CBS NUMBER. CBS REFERENCE ENERGY. CBS TOTAL ENERGY. cbs(). ; extrapolation schemes. output. setting keywords. theory, [1], [2]. cbs() (in module psi4.driver). cbsrec (psi4.driver.driver_cbs.CompositeComputer attribute). CC. ; theory. CC (DETCI). CC ALPHA-ALPHA PAIR ENERGIES. CC ALPHA-BETA PAIR ENERGIES. CC CORRELATION ENERGY. CC CORRELATION KINETIC ENERGY. CC CORRELATION POTENTIAL ENERGY. CC CORRELATION VIRIAL RATIO. CC D1 DIAGNOSTIC. CC D2 DIAGNOSTIC. CC DIPOLE. CC NEW D1 DIAGNOSTIC. CC SINGLET PAIR ENERGIES. CC T1 DIAGNOSTIC. CC TOTAL ENERGY. CC TRIPLET PAIR ENERGIES. CC VIRIAL RATIO. CC(n-1)(n) CORRELATION ENERGY. CC(n-1)(n) TOTAL ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/genindex.html:13800,CACHE,CACHETYPE,13800,psi4manual/master/genindex.html,https://psicode.org,https://psicode.org/psi4manual/master/genindex.html,2,['CACHE'],['CACHETYPE']
Performance,Correlation Functional; Y; —; 0.750000; —; —; —; —; —; —. LCY-PBE; LCY-PBE GGA Exchange-Correlation Functional; Y; —; 0.750000; —; —; —; —; —; —. LRC-WPBE; LRC-WPBE GGA Exchange-Correlation Functional; Y; —; 0.300000; —; —; —; —; —; —. LRC-WPBEH; LRC-wPBEh Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.200000; —; —; —; —; —. M11; M11 Meta-GGA XC Functional; Y; Y; 0.250000; 0.428000; —; —; —; —; —. M11-D3BJ; M11 Meta-GGA XC Functional; Y; Y; 0.250000; 0.428000; —; —; —; Y;  . MN12-SX; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; —; —. MN12-SX-D3BJ; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; Y;  . N12-SX; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; —; —. N12-SX-D3BJ; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; Y;  . TUNED-CAM-B3LYP; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; 0.150000; 0.079900; —; —; —; —; —. WB97; wB97 GGA Exchange-Correlation Functional; Y; —; 0.400000; —; —; —; —; —; —. WB97M-V; wB97M-V Hyb-GGA Exchange-Correlation Functional; Y; Y; 0.300000; 0.150000; —; —; —; —; —. WB97X; wB97X Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; —; —. WB97X-D; wB97X-D Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.222036; —; —; —; Y;  . WB97X-V; wB97X-V Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.167000; —; —; —; —; —. WPBE; PBE SR-XC Functional (HJS Model); Y; —; 0.400000; —; —; —; —; —; —. WPBE-D3BJ; PBE SR-XC Functional (HJS Model); Y; —; 0.400000; —; —; —; —; Y;  . WPBE-D3MBJ; PBE SR-XC Functional (HJS Model); Y; —; 0.400000; —; —; —; —; Y;  . WPBE0; PBE0 SR-XC Functional (HJS Model); Y; —; 0.300000; 0.250000; —; —; —; —; —. Hybrid¶. Hybrid functionals available in PSI4¶. Name; Description; GGA?; Meta?; X_LRC?; X_Hybrid?; C_LRC?; C_Hybrid?; C_SCS? SS/OS; Disp,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft_byfunctional-1.html:37192,TUNE,TUNED-CAM-,37192,psi4manual/1.2.1/dft_byfunctional-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft_byfunctional-1.html,4,['TUNE'],['TUNED-CAM-']
Performance,Correlation Functional; Y; —; 0.750000; —; —; —; —; —; —. LCY-PBE; LCY-PBE GGA Exchange-Correlation Functional; Y; —; 0.750000; —; —; —; —; —; —. LRC-WPBE; LRC-WPBE GGA Exchange-Correlation Functional; Y; —; 0.300000; —; —; —; —; —; —. LRC-WPBEH; LRC-wPBEh Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.200000; —; —; —; —; —. M11; M11 Meta-GGA XC Functional; Y; Y; 0.250000; 0.428000; —; —; —; —; —. M11-D3BJ; M11 Meta-GGA XC Functional; Y; Y; 0.250000; 0.428000; —; —; —; Y;  . MN12-SX; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; —; —. MN12-SX-D3BJ; MN12-SX Meta-GGA Hybrid Screened Exchange-Correlation Functional; Y; Y; 0.110000; 0.250000; —; —; —; Y;  . N12-SX; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; —; —. N12-SX-D3BJ; N12-SX Hybrid nonseparable GGA Exchange-Correlation Functional; Y; —; 0.110000; 0.250000; —; —; —; Y;  . TUNED-CAM-B3LYP; TUNED-CAM-B3LYP Hyb-GGA Exchange-Correlation Functional; Y; —; 0.150000; 0.079900; —; —; —; —; —. WB97; wB97 GGA Exchange-Correlation Functional; Y; —; 0.400000; —; —; —; —; —; —. WB97M-V; wB97M-V Hyb-GGA Exchange-Correlation Functional; Y; Y; 0.300000; 0.150000; —; —; —; —; —. WB97X; wB97X Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.157706; —; —; —; —; —. WB97X-D; wB97X-D Hyb-GGA Exchange-Correlation Functional; Y; —; 0.200000; 0.222036; —; —; —; Y;  . WB97X-V; wB97X-V Hyb-GGA Exchange-Correlation Functional; Y; —; 0.300000; 0.167000; —; —; —; —; —. WPBE; PBE SR-XC Functional (HJS Model); Y; —; 0.400000; —; —; —; —; —; —. WPBE-D3BJ; PBE SR-XC Functional (HJS Model); Y; —; 0.400000; —; —; —; —; Y;  . WPBE-D3MBJ; PBE SR-XC Functional (HJS Model); Y; —; 0.400000; —; —; —; —; Y;  . WPBE0; PBE0 SR-XC Functional (HJS Model); Y; —; 0.300000; 0.250000; —; —; —; —; —. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; DFT Functionals. © C,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_dft_lrc-1.html:2598,TUNE,TUNED-CAM-,2598,psi4manual/1.2.1/autodoc_dft_lrc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_dft_lrc-1.html,4,['TUNE'],['TUNED-CAM-']
Performance,"D (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4], [5], [6], [7], [8]. ONE-ELECTRONENERGY. one_electron_integrals() psi4.core.MintsHelper method, [1], [2]. OneBodyAOInt class in psi4.core, [1]. onel_Hx() psi4.core.CUHF method, [1]. psi4.core.HF method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OO_SCALE (DFOCC). OPDM (DETCI). opdm() psi4.core.CIWavefunction method, [1], [2]. OPDM_RELAX (CCDENSITY). (DFMP2). open() psi4.core.IO method, [1], [2]. open_check() psi4.core.IO method, [1], [2]. operate() psi4.core.SymmetryOperation method, [1], [2]. opt(). . see optimize(). opt() in module psi4.driver. opt_clean() in module psi4.core, [1]. OPT_COORDINATES (OPTKING). OPT_METHOD (DFOCC). (OCC). OPT_TYPE (OPTKING). OptimizationConvergenceError. optimize(). ; setting keywords. optimize() in module psi4. in module psi4.driver. option_exists_in_module() in module psi4.core, [1]. Options class in psi4.core, [1]. optking() in module psi4.core, [1]. ORB_OPT (DFOCC). (OCC). ORB_RESP_SOLVER (DFOCC). (OCC). Orbital-Optimized Methods. ; theory. Orbital-Optimized Methods, OLCCD. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. ORBITAL_LEVEL_SHIFT (DCFT). orbital_values() psi4.core.PointFunctions method, [1], [2]. psi4.core.RKSFunctions method, [1]. psi4.core.UKSFunctions method, [1]. OrbitalSpace class in psi4.core, [1]. orientation() psi4.core.DFTGrid method, [1]. psi4.core.MolecularGrid method, [1], [2]. orientation_fixed() psi4.core.Molecule method, [1], [2]. origin psi4.core.AngularMomentumInt attribute, [1]. psi4.core.DipoleInt attribute, [1]. psi4.core.ElectricFieldInt attribute, [1]. psi4.core.ElectrostaticInt attribute, [1]. psi4.core.KineticInt attribute, [1]. psi4.core.MultipoleInt attribute, [1]. psi4.core.NablaInt att",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:87881,optimiz,optimize,87881,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['optimiz'],['optimize']
Performance,"D (PSIMRCC); PSIMRCC — How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS (PSIMRCC); PSIMRCC — Do start from a MP2 guess?. Type: boolean; Default: true. MP2_OS_SCALE (CCENERGY); CCENERGY — MP2 opposite-spin scaling value. Type: double; Default: 1.20. MP2_OS_SCALE (DFMP2); DFMP2 — OS Scale. Type: double; Default: 6.0/5.0. MP2_OS_SCALE (DFOCC); DFOCC — MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_OS_SCALE (OCC); OCC — MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SCALE_OS (FNOCC); FNOCC — Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. MP2_SCALE_SS (FNOCC); FNOCC — Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0/3.0. MP2_SOS_SCALE (DFOCC); DFOCC — MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE (OCC); OCC — MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2 (DFOCC); DFOCC — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SOS_SCALE2 (OCC); OCC — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE (CCENERGY); CCENERGY — MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (DFMP2); DFMP2 — SS Scale. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (DFOCC); DFOCC — MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (OCC); OCC — MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_TYPE (GLOBALS); GLOBALS — Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE (GLOBALS); GLOBALS — Algorithm to use for MPn ( ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. MPN (DETCI); DETCI — Do compute the MPn series out to kth order where k is determin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:164591,optimiz,optimized-,164591,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized-']
Performance,"D (PSIMRCC); PSIMRCC — How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS (PSIMRCC); PSIMRCC — Do start from a MP2 guess?. Type: boolean; Default: true. MP2_OS_SCALE (CCENERGY); CCENERGY — MP2 opposite-spin scaling value. Type: double; Default: 1.20. MP2_OS_SCALE (DFMP2); DFMP2 — OS Scale. Type: double; Default: 6.0/5.0. MP2_OS_SCALE (DFOCC); DFOCC — MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_OS_SCALE (OCC); OCC — MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SCALE_OS (FNOCC); FNOCC — Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. MP2_SCALE_SS (FNOCC); FNOCC — Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0/3.0. MP2_SOS_SCALE (DFOCC); DFOCC — MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE (OCC); OCC — MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2 (DFOCC); DFOCC — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SOS_SCALE2 (OCC); OCC — Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE (CCENERGY); CCENERGY — MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (DFMP2); DFMP2 — SS Scale. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (DFOCC); DFOCC — MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_SS_SCALE (OCC); OCC — MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_TYPE (GLOBALS); GLOBALS — Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE (GLOBALS); GLOBALS — Algorithm to use for MPn ( \(n>2\) ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: CONV. MPN (DETCI); DETCI — Do compute the MPn series out to kth order where k is ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:164263,optimiz,optimized-,164263,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimized-']
